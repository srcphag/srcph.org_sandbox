var CABLES;
/******/ (() => {
  // webpackBootstrap
  /******/ "use strict";
  /******/ // The require scope
  /******/ var __webpack_require__ = {};
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/define property getters */
  /******/ (() => {
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (
          __webpack_require__.o(definition, key) &&
          !__webpack_require__.o(exports, key)
        ) {
          /******/ Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key],
          });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ (() => {
    /******/ __webpack_require__.o = (obj, prop) =>
      Object.prototype.hasOwnProperty.call(obj, prop);
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/ (() => {
    /******/ // define __esModule on exports
    /******/ __webpack_require__.r = (exports) => {
      /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: "Module",
        });
        /******/
      }
      /******/ Object.defineProperty(exports, "__esModule", { value: true });
      /******/
    };
    /******/
  })();
  /******/
  /************************************************************************/
  var __webpack_exports__ = {};

  // EXPORTS
  __webpack_require__.d(__webpack_exports__, {
    default: () => /* binding */ core,
  });

  // NAMESPACE OBJECT: ./src/core/utils.js
  var utils_namespaceObject = {};
  __webpack_require__.r(utils_namespaceObject);
  __webpack_require__.d(utils_namespaceObject, {
    UTILS: () => UTILS,
    ajax: () => ajax,
    ajaxSync: () => ajaxSync,
    basename: () => basename,
    cacheBust: () => cacheBust,
    clamp: () => clamp,
    cleanJson: () => cleanJson,
    copyArray: () => copyArray,
    filename: () => filename,
    generateUUID: () => generateUUID,
    getShortOpName: () => getShortOpName,
    keyCodeToName: () => keyCodeToName,
    logErrorConsole: () => logErrorConsole,
    logStack: () => logStack,
    map: () => map,
    prefixedHash: () => prefixedHash,
    request: () => request,
    shortId: () => shortId,
    shuffleArray: () => shuffleArray,
    simpleId: () => simpleId,
    smoothStep: () => smoothStep,
    smootherStep: () => smootherStep,
    uuid: () => uuid,
  });

  // NAMESPACE OBJECT: ./src/core/anim.js
  var anim_namespaceObject = {};
  __webpack_require__.r(anim_namespaceObject);
  __webpack_require__.d(anim_namespaceObject, {
    ANIM: () => ANIM,
    Anim: () => Anim,
  }); // CONCATENATED MODULE: ./src/core/constants.js

  const CONSTANTS = {
    ANIM: {
      EASINGS: [
        "linear",
        "absolute",
        "smoothstep",
        "smootherstep",
        "Cubic In",
        "Cubic Out",
        "Cubic In Out",
        "Expo In",
        "Expo Out",
        "Expo In Out",
        "Sin In",
        "Sin Out",
        "Sin In Out",
        "Quart In",
        "Quart Out",
        "Quart In Out",
        "Quint In",
        "Quint Out",
        "Quint In Out",
        "Back In",
        "Back Out",
        "Back In Out",
        "Elastic In",
        "Elastic Out",
        "Bounce In",
        "Bounce Out",
      ],
      EASING_LINEAR: 0,
      EASING_ABSOLUTE: 1,
      EASING_SMOOTHSTEP: 2,
      EASING_SMOOTHERSTEP: 3,
      EASING_CUBICSPLINE: 4,

      EASING_CUBIC_IN: 5,
      EASING_CUBIC_OUT: 6,
      EASING_CUBIC_INOUT: 7,

      EASING_EXPO_IN: 8,
      EASING_EXPO_OUT: 9,
      EASING_EXPO_INOUT: 10,

      EASING_SIN_IN: 11,
      EASING_SIN_OUT: 12,
      EASING_SIN_INOUT: 13,

      EASING_BACK_IN: 14,
      EASING_BACK_OUT: 15,
      EASING_BACK_INOUT: 16,

      EASING_ELASTIC_IN: 17,
      EASING_ELASTIC_OUT: 18,

      EASING_BOUNCE_IN: 19,
      EASING_BOUNCE_OUT: 21,

      EASING_QUART_IN: 22,
      EASING_QUART_OUT: 23,
      EASING_QUART_INOUT: 24,

      EASING_QUINT_IN: 25,
      EASING_QUINT_OUT: 26,
      EASING_QUINT_INOUT: 27,
    },

    OP: {
      OP_PORT_TYPE_VALUE: 0,
      OP_PORT_TYPE_NUMBER: 0,
      OP_PORT_TYPE_FUNCTION: 1,
      OP_PORT_TYPE_TRIGGER: 1,
      OP_PORT_TYPE_OBJECT: 2,
      OP_PORT_TYPE_TEXTURE: 2,
      OP_PORT_TYPE_ARRAY: 3,
      OP_PORT_TYPE_DYNAMIC: 4,
      OP_PORT_TYPE_STRING: 5,

      OP_VERSION_PREFIX: "_v",
    },

    PORT: {
      PORT_DIR_IN: 0,
      PORT_DIR_OUT: 1,
    },

    PACO: {
      PACO_CLEAR: 0,
      PACO_VALUECHANGE: 1,
      PACO_OP_DELETE: 2,
      PACO_UNLINK: 3,
      PACO_LINK: 4,
      PACO_LOAD: 5,
      PACO_OP_CREATE: 6,
      PACO_OP_ENABLE: 7,
      PACO_OP_DISABLE: 8,
      PACO_UIATTRIBS: 9,
      PACO_VARIABLES: 10,
      PACO_TRIGGERS: 11,
      PACO_PORT_SETVARIABLE: 12,
      PACO_PORT_SETANIMATED: 13,
      PACO_PORT_ANIM_UPDATED: 14,
      PACO_DESERIALIZE: 15,
      PACO_OP_RELOAD: 16,
    },
  }; // CONCATENATED MODULE: ./src/core/utils.js

  /**
   * @namespace external:CABLES#Utils
   */

  const UTILS = {};
  /**
   * Merge two Float32Arrays.
   * @function float32Concat
   * @memberof Utils
   * @param {Float32Array} first Left-hand side array
   * @param {Float32Array} second Right-hand side array
   * @return {Float32Array}
   * @static
   */
  UTILS.float32Concat = function (first, second) {
    if (!(first instanceof Float32Array)) first = new Float32Array(first);
    if (!(second instanceof Float32Array)) second = new Float32Array(second);

    const result = new Float32Array(first.length + second.length);

    result.set(first);
    result.set(second, first.length);

    return result;
  };

  /**
   * get op shortname: only last part of fullname and without version
   * @function getShortOpName
   * @memberof CABLES
   * @param {string} fullname full op name
   * @static
   */
  const getShortOpName = function (fullname) {
    let name = fullname.split(".")[fullname.split(".").length - 1];

    if (name.contains(CONSTANTS.OP.OP_VERSION_PREFIX)) {
      const n = name.split(CONSTANTS.OP.OP_VERSION_PREFIX)[1];
      name = name.substring(
        0,
        name.length - (CONSTANTS.OP.OP_VERSION_PREFIX + n).length
      );
    }
    return name;
  };

  /**
   * randomize order of an array
   * @function shuffleArray
   * @memberof Utils
   * @param {Array|Float32Array} array {Array} original
   * @return {Array|Float32Array} shuffled array
   * @static
   */
  const shuffleArray = function (array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.seededRandom() * (i + 1));
      const temp = array[i];
      array[i] = array[j];
      array[j] = temp;
    }
    return array;
  };

  /**
   * generate a short "relativly unique" id
   * @function shortId
   * @memberof Utils
   * @return {String} generated ID
   * @static
   */

  const _shortIds = {};
  const _shortId = function () {
    let str = Math.random().toString(36).substr(2, 9);

    if (_shortIds.hasOwnProperty(str)) str = _shortId();
    _shortIds[str] = true;
    return str;
  };
  const shortId = _shortId;

  /**
   * generate a UUID
   * @function uuid
   * @memberof Utils
   * @return {String} generated UUID
   * @static
   */
  const _uuid = function () {
    let d = new Date().getTime();
    const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
      /[xy]/g,
      (c) => {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == "x" ? r : (r & 0x3) | 0x8).toString(16);
      }
    );
    return uuid;
  };
  const uuid = _uuid;
  const generateUUID = _uuid;

  function cleanJson(obj) {
    for (const i in obj) {
      if (
        obj[i] &&
        typeof objValue === "object" &&
        obj[i].constructor === Object
      )
        obj[i] = cleanJson(obj[i]);

      if (obj[i] === null || obj[i] === undefined) delete obj[i];
      else if (Array.isArray(obj[i]) && obj[i].length == 0) delete obj[i];
    }

    return obj;
  }

  /**
   * @see http://stackoverflow.com/q/7616461/940217
   * @memberof Utils
   * @param str
   * @param prefix
   * @return {string}
   */
  const _prefixedHash = function (str, prefix = "id") {
    let hash = 0;
    if (Array.prototype.reduce) {
      hash = str.split("").reduce((a, b) => {
        a = (a << 5) - a + b.charCodeAt(0);
        return a & a;
      }, 0);
    } else {
      if (str.length > 0) {
        for (let i = 0; i < str.length; i++) {
          let character = str.charCodeAt(i);
          hash = (hash << 5) - hash + character;
          hash &= hash; // Convert to 32bit integer
        }
      }
    }
    return prefix + "" + hash;
  };
  const prefixedHash = _prefixedHash;

  /**
   * generate a simple ID
   * @function simpleId
   * @memberof Utils
   * @return {Number} new id
   * @static
   */
  let simpleIdCounter = 0;
  const simpleId = function () {
    simpleIdCounter++;
    return simpleIdCounter;
  };

  /**
   * smoothStep a value
   * @function smoothStep
   * @memberof Utils
   * @function
   * @param {Number} perc value value to be smoothed [0-1]
   * @return {Number} smoothed value
   * @static
   */
  const smoothStep = function (perc) {
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * (3 - 2 * x); // smoothstep
    return perc;
  };

  /**
   * smootherstep a value
   * @function smootherStep
   * @memberof Utils
   * @param {Number} perc value to be smoothed [0-1]
   * @return {Number} smoothed value
   * @static
   */
  const smootherStep = function (perc) {
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * x * (x * (x * 6 - 15) + 10); // smootherstep
    return perc;
  };

  /**
   * clamp number / make sure its between min/max
   * @function clamp
   * @memberof Utils
   * @param {Number} value value to be mapped
   * @param {Number} min minimum value
   * @param {Number} max maximum value
   * @static
   */
  const clamp = function (value, min, max) {
    return Math.min(Math.max(value, min), max);
  };

  /**
   * map a value in a range to a value in another range
   * @function map
   * @memberof Utils
   * @param {Number} x value to be mapped
   * @param {Number} _oldMin old range minimum value
   * @param {Number} _oldMax old range maximum value
   * @param {Number} _newMin new range minimum value
   * @param {Number} _newMax new range maximum value
   * @param {Number} _easing
   * @return {Number} mapped value
   * @static
   */
  const map = function (x, _oldMin, _oldMax, _newMin, _newMax, _easing) {
    if (x >= _oldMax) return _newMax;
    if (x <= _oldMin) return _newMin;

    let reverseInput = false;
    const oldMin = Math.min(_oldMin, _oldMax);
    const oldMax = Math.max(_oldMin, _oldMax);
    if (oldMin != _oldMin) reverseInput = true;

    let reverseOutput = false;
    const newMin = Math.min(_newMin, _newMax);
    const newMax = Math.max(_newMin, _newMax);
    if (newMin != _newMin) reverseOutput = true;

    let portion = 0;
    let r = 0;

    if (reverseInput)
      portion = ((oldMax - x) * (newMax - newMin)) / (oldMax - oldMin);
    else portion = ((x - oldMin) * (newMax - newMin)) / (oldMax - oldMin);

    if (reverseOutput) r = newMax - portion;
    else r = portion + newMin;

    if (!_easing) return r;
    if (_easing == 1) {
      // smoothstep
      x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));
      return _newMin + x * x * (3 - 2 * x) * (_newMax - _newMin);
    }
    if (_easing == 2) {
      // smootherstep
      x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));
      return (
        _newMin + x * x * x * (x * (x * 6 - 15) + 10) * (_newMax - _newMin)
      );
    }

    return r;
  };

  /**
   * @namespace Math
   */
  /**
   * set random seed for seededRandom()
   * @memberof Math
   * @type Number
   * @static
   */
  Math.randomSeed = 1;

  Math.setRandomSeed = function (seed) {
    // https://github.com/cables-gl/cables_docs/issues/622
    Math.randomSeed = seed * 50728129;
    if (seed != 0) {
      Math.randomSeed = Math.seededRandom() * 17624813;
      Math.randomSeed = Math.seededRandom() * 9737333;
    }
  };

  /**
   * generate a seeded random number
   * @function seededRandom
   * @memberof Math
   * @param {Number} max minimum possible random number
   * @param {Number} min maximum possible random number
   * @return {Number} random value
   * @static
   */
  Math.seededRandom = function (max, min) {
    if (Math.randomSeed === 0) Math.randomSeed = Math.random() * 999;
    max = max || 1;
    min = min || 0;

    Math.randomSeed = (Math.randomSeed * 9301 + 49297) % 233280;
    const rnd = Math.randomSeed / 233280.0;

    return min + rnd * (max - min);
  };

  // ----------------------------------------------------------------

  /**
   * returns true if parameter is a number
   * @function isNumeric
   * @memberof Utils
   * @param {Any} n value The value to check.
   * @return {Boolean}
   * @static
   */
  UTILS.isNumeric = function (n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };

  /**
   * returns true if parameter is array
   * @function isArray
   * @param {Any} v value Value to check
   * @memberof Utils
   * @return {Boolean}
   * @static
   */
  UTILS.isArray = function (v) {
    return Object.prototype.toString.call(v) === "[object Array]";
  };

  /**
   * @namespace String
   */

  /**
   * append a linebreak to a string
   * @function endl
   * @memberof String
   * @return {String} string with newline break appended ('\n')
   */
  String.prototype.endl = function () {
    return this + "\n";
  };

  /**
   * return true if string starts with prefix
   * @function startsWith
   * @memberof String
   * @param {String} prefix The prefix to check.
   * @return {Boolean}
   */
  String.prototype.startsWith = function (prefix) {
    if (!this || !prefix) return false;
    if (this.length >= prefix.length) {
      if (this.substring(0, prefix.length) == prefix) return true;
    }
    return false;
    // return this.indexOf(prefix) === 0;
  };

  /**
   * return true if string ends with suffix
   * @function endsWith
   * @memberof String
   * @param {String} suffix
   * @return {Boolean}
   */
  String.prototype.endsWith =
    String.prototype.endsWith ||
    function (suffix) {
      return this.match(suffix + "$") == suffix;
    };

  /**
   * return true if string contains string
   * @function contains
   * @memberof String
   * @param {String} searchStr
   * @return {Boolean}
   */
  String.prototype.contains =
    String.prototype.contains ||
    function (searchStr) {
      return this.indexOf(searchStr) > -1;
    };

  // ----------------------------------------------------------------

  /**
   * append a unique/random parameter to a url, so the browser is forced to reload the file, even if its cached
   * @function cacheBust
   * @static
   * @memberof Utils
   * @param {String} url The url to append the cachebuster parameter to.
   * @return {String} url with cachebuster parameter
   */
  const cacheBust = function (url = "") {
    if (!url) return "";
    if (url.startsWith("data:")) return;
    if (url.contains("?")) url += "&";
    else url += "?";
    return url + "cache=" + CABLES.uuid();
  };

  /**
   * copy the content of an array
   * @function copyArray
   * @static
   * @memberof Utils
   * @param {Array} src sourceArray
   * @param {Array} dst optional
   * @return {Array} dst
   */
  const copyArray = function (src, dst) {
    if (!src) return null;
    dst = dst || [];
    dst.length = src.length;
    for (let i = 0; i < src.length; i++) {
      dst[i] = src[i];
    }

    return dst;
  };

  /**
   * return the filename part of a url without extension
   * @function basename
   * @static
   * @memberof Utils
   * @param {String} url
   * @return {String} just the filename
   */
  const basename = function (url) {
    let name = CABLES.filename(url);

    const parts2 = name.split(".");
    name = parts2[0];

    return name;
  };

  /**
   * output a stacktrace to the console
   * @function logStack
   * @static
   * @memberof Utils
   */
  const logStack = function () {
    console.log("logstack", new Error().stack);
  };

  /**
   * return the filename part of a url
   * @function filename
   * @static
   * @memberof Utils
   * @param {String} url
   * @return {String} just the filename
   */
  const filename = function (url) {
    let name = "";
    if (!url) return "";

    if (url.startsWith("data:") && url.contains(":")) {
      const parts = url.split(",");
      return parts[0];
    }

    let parts = (url + "").split("/");
    if (parts.length > 0) {
      const str = parts[parts.length - 1];
      let parts2 = str.split("?");
      name = parts2[0];
    }

    return name || "";
  };

  const ajaxSync = function (url, cb, method, post, contenttype) {
    request({
      url: url,
      cb: cb,
      method: method,
      data: post,
      contenttype: contenttype,
      sync: true,
    });
  };

  /**
   * make an ajax request
   * @static
   * @function ajax
   * @param url
   * @param cb
   * @param method
   * @param post
   * @param contenttype
   * @param jsonP
   * @param headers
   * @param options
   */
  const ajax = function (
    url,
    cb,
    method,
    post,
    contenttype,
    jsonP,
    headers = {},
    options = {}
  ) {
    const requestOptions = {
      url: url,
      cb: cb,
      method: method,
      data: post,
      contenttype: contenttype,
      sync: false,
      jsonP: jsonP,
      headers: headers,
    };
    if (options && options.credentials)
      requestOptions.credentials = options.credentials;
    request(requestOptions);
  };

  const request = function (options) {
    if (!options.hasOwnProperty("asynch")) options.asynch = true;

    let xhr;
    try {
      xhr = new XMLHttpRequest();
    } catch (e) {}

    xhr.onreadystatechange = function () {
      if (xhr.readyState != 4) return;

      if (options.cb) {
        if (xhr.status == 200 || xhr.status == 0)
          options.cb(false, xhr.responseText, xhr);
        else options.cb(true, xhr.responseText, xhr);
      }
    };

    try {
      xhr.open(
        options.method ? options.method.toUpperCase() : "GET",
        options.url,
        !options.sync
      );
    } catch (e) {
      if (options.cb && e) options.cb(true, e.msg, xhr);
    }

    if (typeof options.headers === "object") {
      if (options.headers) {
        const keys = Object.keys(options.headers);
        for (let i = 0; i < keys.length; i++) {
          const name = keys[i];
          const value = options.headers[name];
          xhr.setRequestHeader(name, value);
        }
      }
    }

    if (options.credentials && options.credentials !== "omit") {
      xhr.withCredentials = true;
    }

    try {
      if (!options.post && !options.data) {
        xhr.send();
      } else {
        xhr.setRequestHeader(
          "Content-type",
          options.contenttype
            ? options.contenttype
            : "application/x-www-form-urlencoded"
        );
        xhr.send(options.data || options.post);
      }
    } catch (e) {
      if (options.cb) options.cb(true, e.msg, xhr);
    }
  };

  const keyCodeToName = function (keyCode) {
    if (!keyCode && keyCode !== 0) return "Unidentified";
    const keys = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: "Space",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta",
    };
    if (keys[keyCode]) {
      return keys[keyCode];
    } else {
      return String.fromCharCode(keyCode);
    }
  };
  // ----------------------------------------------------------------

  window.performance = window.performance || {
    offset: Date.now(),
    now: function now() {
      return Date.now() - this.offset;
    },
  };

  const logErrorConsole = function (initiator) {
    CABLES.errorConsole = CABLES.errorConsole || { log: [] };
    CABLES.errorConsole.log.push({
      initiator: initiator,
      arguments: arguments,
    });

    if (!CABLES.errorConsole.ele) {
      const ele = document.createElement("div");
      ele.id = "cablesErrorConsole";
      ele.style.width = "90%";
      ele.style.height = "300px";
      ele.style.zIndex = "9999999";
      ele.style.display = "inline-block";
      ele.style.position = "absolute";
      ele.style.padding = "10px";
      ele.style.fontFamily = "monospace";
      ele.style.color = "red";
      ele.style.backgroundColor = "#200";

      CABLES.errorConsole.ele = ele;
      document.body.appendChild(ele);
    }

    let logHtml =
      "ERROR<br/>for more info, open your browsers dev tools console (Ctrl+Shift+I or Command+Alt+I)<br/>";

    for (let l = 0; l < CABLES.errorConsole.log.length; l++) {
      logHtml += CABLES.errorConsole.log[l].initiator + " ";
      for (let i = 1; i < CABLES.errorConsole.log[l].arguments.length; i++) {
        if (i > 2) logHtml += ", ";
        let arg = CABLES.errorConsole.log[l].arguments[i];
        if (
          arg.constructor.name.indexOf("Error") > -1 ||
          arg.constructor.name.indexOf("error") > -1
        ) {
          let txt = "Uncaught ErrorEvent ";
          if (arg.message) txt += " message: " + arg.message;
          logHtml += txt;
        } else if (typeof arg == "string") logHtml += arg;
        else if (typeof arg == "number") logHtml += String(arg) + " ";
      }
      logHtml += "<br/>";
    }

    CABLES.errorConsole.ele.innerHTML = logHtml;
  }; // CONCATENATED MODULE: ../shared/client/src/logger.js

  /* eslint-disable no-console */

  class Logger {
    constructor(initiator, options) {
      this.initiator = initiator;
      this._options = options;
    }

    stack(t) {
      console.info("[" + this.initiator + "] ", t);
      console.log(new Error().stack);
    }

    groupCollapsed(t) {
      if (
        (CABLES.UI &&
          CABLES.UI.logFilter.filterLog(
            { initiator: this.initiator, level: 0 },
            ...arguments
          )) ||
        !CABLES.logSilent
      )
        console.log("[" + this.initiator + "]", ...arguments);

      console.groupCollapsed("[" + this.initiator + "] " + t);
    }

    table(t) {
      console.table(t);
    }

    groupEnd() {
      console.groupEnd();
    }

    error() {
      if (
        (CABLES.UI &&
          CABLES.UI.logFilter.filterLog(
            { initiator: this.initiator, level: 2 },
            ...arguments
          )) ||
        !CABLES.UI
      ) {
        console.error("[" + this.initiator + "]", ...arguments);
      }

      if (this._options && this._options.onError) {
        this._options.onError(this.initiator, ...arguments);
        // console.log("emitevent onerror...");
        // CABLES.patch.emitEvent("onError", this.initiator, ...arguments);
        // CABLES.logErrorConsole("[" + this.initiator + "]", ...arguments);
      }
    }

    errorGui() {
      if (CABLES.UI)
        CABLES.UI.logFilter.filterLog(
          { initiator: this.initiator, level: 2 },
          ...arguments
        );
    }

    warn() {
      if (
        (CABLES.UI &&
          CABLES.UI.logFilter.filterLog(
            { initiator: this.initiator, level: 1 },
            ...arguments
          )) ||
        !CABLES.logSilent
      )
        console.warn("[" + this.initiator + "]", ...arguments);
    }

    verbose() {
      if (
        (CABLES.UI &&
          CABLES.UI.logFilter.filterLog(
            { initiator: this.initiator, level: 0 },
            ...arguments
          )) ||
        !CABLES.logSilent
      )
        console.log("[" + this.initiator + "]", ...arguments);
    }

    info() {
      if (
        (CABLES.UI &&
          CABLES.UI.logFilter.filterLog(
            { initiator: this.initiator, level: 0 },
            ...arguments
          )) ||
        !CABLES.logSilent
      )
        console.info("[" + this.initiator + "]", ...arguments);
    }

    log() {
      if (
        (CABLES.UI &&
          CABLES.UI.logFilter.filterLog(
            { initiator: this.initiator, level: 0 },
            ...arguments
          )) ||
        !CABLES.logSilent
      )
        console.log("[" + this.initiator + "]", ...arguments);
    }

    logGui() {
      if (CABLES.UI)
        CABLES.UI.logFilter.filterLog(
          { initiator: this.initiator, level: 0 },
          ...arguments
        );
    }

    userInteraction(text) {
      // this.log({ "initiator": "userinteraction", "text": text });
    }
  } // CONCATENATED MODULE: ./src/core/anim_key.js

  const Key = function (obj) {
    this.time = 0.0;
    this.value = 0.0;
    // this.ui = null;
    this.onChange = null;
    this._easing = 0;
    // this.bezTangIn = 0;
    // this.bezTangOut = 0;
    // this.bezTime = 0.5;
    // this.bezValue = 0;
    // this.bezTimeIn = -0.5;
    // this.bezValueIn = 0;

    this.cb = null;
    this.cbTriggered = false;

    // const bezierAnim = null;
    // this._updateBezier = false;

    this.setEasing(CONSTANTS.ANIM.EASING_LINEAR);
    this.set(obj);
  };

  Key.cubicSpline = function (perc, key1, key2) {
    let previousPoint = key1.value,
      previousTangent = key1.bezTangOut,
      nextPoint = key2.value,
      nextTangent = key2.bezTangIn;
    let t = perc;
    let t2 = t * t;
    let t3 = t2 * t;

    return (
      (2 * t3 - 3 * t2 + 1) * previousPoint +
      (t3 - 2 * t2 + t) * previousTangent +
      (-2 * t3 + 3 * t2) * nextPoint +
      (t3 - t2) * nextTangent
    );
  };

  Key.easeCubicSpline = function (perc, key2) {
    return Key.cubicSpline(perc, this, key2);
  };

  Key.linear = function (perc, key1, key2) {
    return parseFloat(key1.value) + parseFloat(key2.value - key1.value) * perc;
  };

  Key.easeLinear = function (perc, key2) {
    return Key.linear(perc, this, key2);
  };

  Key.easeAbsolute = function (perc, key2) {
    return this.value;
  };

  const easeExpoIn = function (t) {
    return (t = 2 ** (10 * (t - 1)));
  };

  Key.easeExpoIn = function (t, key2) {
    t = easeExpoIn(t);
    return Key.linear(t, this, key2);
  };

  const easeExpoOut = function (t) {
    t = -(2 ** (-10 * t)) + 1;
    return t;
  };

  Key.easeExpoOut = function (t, key2) {
    t = easeExpoOut(t);
    return Key.linear(t, this, key2);
  };

  const easeExpoInOut = function (t) {
    t *= 2;
    if (t < 1) {
      t = 0.5 * 2 ** (10 * (t - 1));
    } else {
      t--;
      t = 0.5 * (-(2 ** (-10 * t)) + 2);
    }
    return t;
  };

  Key.easeExpoInOut = function (t, key2) {
    t = easeExpoInOut(t);
    return Key.linear(t, this, key2);
  };

  Key.easeSinIn = function (t, key2) {
    t = -1 * Math.cos((t * Math.PI) / 2) + 1;
    return Key.linear(t, this, key2);
  };

  Key.easeSinOut = function (t, key2) {
    t = Math.sin((t * Math.PI) / 2);
    return Key.linear(t, this, key2);
  };

  Key.easeSinInOut = function (t, key2) {
    t = -0.5 * (Math.cos(Math.PI * t) - 1.0);
    return Key.linear(t, this, key2);
  };

  const easeCubicIn = function (t) {
    t = t * t * t;
    return t;
  };

  Key.easeCubicIn = function (t, key2) {
    t = easeCubicIn(t);
    return Key.linear(t, this, key2);
  };

  // b 0
  // c 1/2 or 1
  // d always 1
  // easeOutCubic: function (x, t, b, c, d) {
  //     return c*((t=t/d-1)*t*t + 1) + b;

  Key.easeInQuint = function (t, key2) {
    t = t * t * t * t * t;
    return Key.linear(t, this, key2);
  };
  Key.easeOutQuint = function (t, key2) {
    t = (t -= 1) * t * t * t * t + 1;
    return Key.linear(t, this, key2);
  };
  Key.easeInOutQuint = function (t, key2) {
    if ((t /= 0.5) < 1) t = 0.5 * t * t * t * t * t;
    else t = 0.5 * ((t -= 2) * t * t * t * t + 2);
    return Key.linear(t, this, key2);
  };

  Key.easeInQuart = function (t, key2) {
    t = t * t * t * t;
    return Key.linear(t, this, key2);
  };

  Key.easeOutQuart = function (t, key2) {
    // return -c * ((t=t/d-1)*t*t*t - 1) + b;
    t = -1 * ((t -= 1) * t * t * t - 1);
    return Key.linear(t, this, key2);
  };

  Key.easeInOutQuart = function (t, key2) {
    if ((t /= 0.5) < 1) t = 0.5 * t * t * t * t;
    else t = -0.5 * ((t -= 2) * t * t * t - 2);
    return Key.linear(t, this, key2);
  };

  Key.bounce = function (t) {
    if ((t /= 1) < 1 / 2.75) t = 7.5625 * t * t;
    else if (t < 2 / 2.75) t = 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
    else if (t < 2.5 / 2.75) t = 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
    else t = 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    return t;
  };

  Key.easeInBounce = function (t, key2) {
    return Key.linear(Key.bounce(t), this, key2);
    // return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d);
  };

  Key.easeOutBounce = function (t, key2) {
    return Key.linear(Key.bounce(t), this, key2);
  };

  Key.easeInElastic = function (t, key2) {
    let s = 1.70158;
    let p = 0;
    let a = 1;

    const b = 0;
    const d = 1;
    const c = 1;

    if (t === 0) t = b;
    else if ((t /= d) == 1) t = b + c;
    else {
      if (!p) p = d * 0.3;
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else s = (p / (2 * Math.PI)) * Math.asin(c / a);
      t =
        -(
          a *
          2 ** (10 * (t -= 1)) *
          Math.sin(((t * d - s) * (2 * Math.PI)) / p)
        ) + b;
    }

    return Key.linear(t, this, key2);
  };

  Key.easeOutElastic = function (t, key2) {
    let s = 1.70158;
    let p = 0;
    let a = 1;

    const b = 0;
    const d = 1;
    const c = 1;

    if (t === 0) t = b;
    else if ((t /= d) == 1) t = b + c;
    else {
      if (!p) p = d * 0.3;
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else s = (p / (2 * Math.PI)) * Math.asin(c / a);
      t =
        a * 2 ** (-10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) +
        c +
        b;
    }

    return Key.linear(t, this, key2);
  };

  Key.easeInBack = function (t, key2) {
    const s = 1.70158;
    t = t * t * ((s + 1) * t - s);

    return Key.linear(t, this, key2);
  };

  Key.easeOutBack = function (t, key2) {
    const s = 1.70158;
    t = (t = t / 1 - 1) * t * ((s + 1) * t + s) + 1;

    return Key.linear(t, this, key2);
  };

  Key.easeInOutBack = function (t, key2) {
    let s = 1.70158;
    const c = 1 / 2;
    if ((t /= 1 / 2) < 1) t = c * (t * t * (((s *= 1.525) + 1) * t - s));
    else t = c * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);

    return Key.linear(t, this, key2);
  };

  const easeCubicOut = function (t) {
    t--;
    t = t * t * t + 1;
    return t;
  };

  Key.easeCubicOut = function (t, key2) {
    t = easeCubicOut(t);
    return Key.linear(t, this, key2);
  };

  const easeCubicInOut = function (t) {
    t *= 2;
    if (t < 1) t = 0.5 * t * t * t;
    else {
      t -= 2;
      t = 0.5 * (t * t * t + 2);
    }
    return t;
  };

  Key.easeCubicInOut = function (t, key2) {
    t = easeCubicInOut(t);
    return Key.linear(t, this, key2);
  };

  Key.easeSmoothStep = function (perc, key2) {
    // var x = Math.max(0, Math.min(1, (perc-0)/(1-0)));
    const x = Math.max(0, Math.min(1, perc));
    perc = x * x * (3 - 2 * x); // smoothstep
    return Key.linear(perc, this, key2);
  };

  Key.easeSmootherStep = function (perc, key2) {
    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));
    perc = x * x * x * (x * (x * 6 - 15) + 10); // smootherstep
    return Key.linear(perc, this, key2);
  };

  Key.prototype.setEasing = function (e) {
    this._easing = e;

    if (this._easing == CONSTANTS.ANIM.EASING_LINEAR)
      this.ease = Key.easeLinear;
    else if (this._easing == CONSTANTS.ANIM.EASING_ABSOLUTE)
      this.ease = Key.easeAbsolute;
    else if (this._easing == CONSTANTS.ANIM.EASING_SMOOTHSTEP)
      this.ease = Key.easeSmoothStep;
    else if (this._easing == CONSTANTS.ANIM.EASING_SMOOTHERSTEP)
      this.ease = Key.easeSmootherStep;
    else if (this._easing == CONSTANTS.ANIM.EASING_CUBIC_IN)
      this.ease = Key.easeCubicIn;
    else if (this._easing == CONSTANTS.ANIM.EASING_CUBIC_OUT)
      this.ease = Key.easeCubicOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_CUBIC_INOUT)
      this.ease = Key.easeCubicInOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_EXPO_IN)
      this.ease = Key.easeExpoIn;
    else if (this._easing == CONSTANTS.ANIM.EASING_EXPO_OUT)
      this.ease = Key.easeExpoOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_EXPO_INOUT)
      this.ease = Key.easeExpoInOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_SIN_IN)
      this.ease = Key.easeSinIn;
    else if (this._easing == CONSTANTS.ANIM.EASING_SIN_OUT)
      this.ease = Key.easeSinOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_SIN_INOUT)
      this.ease = Key.easeSinInOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_BACK_OUT)
      this.ease = Key.easeOutBack;
    else if (this._easing == CONSTANTS.ANIM.EASING_BACK_IN)
      this.ease = Key.easeInBack;
    else if (this._easing == CONSTANTS.ANIM.EASING_BACK_INOUT)
      this.ease = Key.easeInOutBack;
    else if (this._easing == CONSTANTS.ANIM.EASING_ELASTIC_IN)
      this.ease = Key.easeInElastic;
    else if (this._easing == CONSTANTS.ANIM.EASING_ELASTIC_OUT)
      this.ease = Key.easeOutElastic;
    else if (this._easing == CONSTANTS.ANIM.EASING_ELASTIC_INOUT)
      this.ease = Key.easeElasticInOut;
    else if (this._easing == CONSTANTS.ANIM.EASING_BOUNCE_IN)
      this.ease = Key.easeInBounce;
    else if (this._easing == CONSTANTS.ANIM.EASING_BOUNCE_OUT)
      this.ease = Key.easeOutBounce;
    else if (this._easing == CONSTANTS.ANIM.EASING_QUART_OUT)
      this.ease = Key.easeOutQuart;
    else if (this._easing == CONSTANTS.ANIM.EASING_QUART_IN)
      this.ease = Key.easeInQuart;
    else if (this._easing == CONSTANTS.ANIM.EASING_QUART_INOUT)
      this.ease = Key.easeInOutQuart;
    else if (this._easing == CONSTANTS.ANIM.EASING_QUINT_OUT)
      this.ease = Key.easeOutQuint;
    else if (this._easing == CONSTANTS.ANIM.EASING_QUINT_IN)
      this.ease = Key.easeInQuint;
    else if (this._easing == CONSTANTS.ANIM.EASING_QUINT_INOUT)
      this.ease = Key.easeInOutQuint;
    else if (this._easing == CONSTANTS.ANIM.EASING_CUBICSPLINE) {
      // this._updateBezier = true;
      this.ease = Key.easeCubicSpline;
    } else {
      this._easing = CONSTANTS.ANIM.EASING_LINEAR;
      this.ease = Key.easeLinear;
    }
  };

  Key.prototype.trigger = function () {
    this.cb();
    this.cbTriggered = true;
  };

  Key.prototype.setValue = function (v) {
    this.value = v;
    // this._updateBezier = true;
    if (this.onChange !== null) this.onChange();
  };

  Key.prototype.set = function (obj) {
    if (obj) {
      if (obj.e) this.setEasing(obj.e);
      if (obj.cb) {
        this.cb = obj.cb;
        this.cbTriggered = false;
      }

      if (obj.b) {
        // this.bezTime = obj.b[0];
        // this.bezValue = obj.b[1];
        // this.bezTimeIn = obj.b[2];
        // this.bezValueIn = obj.b[3];
        // this._updateBezier = true;
      }

      if (obj.hasOwnProperty("t")) this.time = obj.t;
      if (obj.hasOwnProperty("time")) this.time = obj.time;
      if (obj.hasOwnProperty("v")) this.value = obj.v;
      else if (obj.hasOwnProperty("value")) this.value = obj.value;
    }
    if (this.onChange !== null) this.onChange();
  };

  Key.prototype.getSerialized = function () {
    const obj = {};
    obj.t = this.time;
    obj.v = this.value;
    obj.e = this._easing;
    // if (this._easing == CONSTANTS.ANIM.EASING_CUBICSPLINE) obj.b = [this.bezTime, this.bezValue, this.bezTimeIn, this.bezValueIn];

    return obj;
  };

  Key.prototype.getEasing = function () {
    return this._easing;
  }; // CONCATENATED MODULE: ./src/core/eventtarget.js

  const EventTarget = function () {
    this._log = new Logger("eventtarget");
    this._eventCallbacks = {};
    this._logName = "";
    this._logEvents = false;
    this._listeners = {};

    this.addEventListener = this.on = function (which, cb, idPrefix) {
      const event = {
        id: (idPrefix || "") + CABLES.simpleId(),
        name: which,
        cb: cb,
      };
      if (!this._eventCallbacks[which]) this._eventCallbacks[which] = [event];
      else this._eventCallbacks[which].push(event);

      this._listeners[event.id] = event;

      return event.id;
    };

    this.hasEventListener = function (which, cb) {
      if (which && !cb) {
        // check by id
        if (this._listeners[which]) return true;
        else return false;
      } else {
        this._log.warn("old eventtarget function haseventlistener!");
        if (which && cb) {
          if (this._eventCallbacks[which]) {
            const idx = this._eventCallbacks[which].indexOf(cb);
            if (idx == -1) return false;
            return true;
          }
        }
      }
    };

    this.hasListenerForEventName = function (eventName) {
      return (
        this._eventCallbacks[eventName] &&
        this._eventCallbacks[eventName].length > 0
      );
    };

    this.removeEventListener = this.off = function (which, cb) {
      if (which === null || which === undefined) return;

      if (!cb) {
        // new style, remove by id, not by name/callback
        const event = this._listeners[which];
        if (!event) {
          this._log.log("removeEvent: could not find event...", which, this);
          return;
        }

        let found = true;
        while (found) {
          found = false;
          let index = -1;
          for (let i = 0; i < this._eventCallbacks[event.name].length; i++) {
            if (this._eventCallbacks[event.name][i].id.startsWith(which)) {
              // this._eventCallbacks[event.name][i].id == which ||
              found = true;
              index = i;
            }
          }

          if (index !== -1) {
            this._eventCallbacks[event.name].splice(index, 1);
            delete this._listeners[which];
          }
        }

        return;
      }

      this._log.info(
        "[eventtaget] ",
        "old function signature: removeEventListener! use listener id"
      );
      this._log.log(new Error().stack);

      let index = null;
      for (let i = 0; i < this._eventCallbacks[which].length; i++)
        if (this._eventCallbacks[which][i].cb == cb) index = i;

      if (index !== null) {
        delete this._eventCallbacks[index];
      } else this._log.warn("removeEventListener not found " + which);
    };

    this.logEvents = function (enabled, name) {
      this._logEvents = enabled;
      this._logName = name;
    };

    this.emitEvent = function (
      which,
      param1,
      param2,
      param3,
      param4,
      param5,
      param6
    ) {
      if (this._logEvents)
        this._log.log("[event] ", this._logName, which, this._eventCallbacks);

      if (this._eventCallbacks[which]) {
        for (let i = 0; i < this._eventCallbacks[which].length; i++) {
          if (this._eventCallbacks[which][i]) {
            this._eventCallbacks[which][i].cb(
              param1,
              param2,
              param3,
              param4,
              param5,
              param6
            );
          }
        }
      } else {
        if (this._logEvents)
          this._log.log(
            "[event] has no event callback",
            which,
            this._eventCallbacks
          );
      }
    };
  }; // CONCATENATED MODULE: ./src/core/anim.js

  /**
 * Keyframed interpolated animation.
 *
 * Available Easings:
 * <code>
 * CONSTANTS.ANIM.EASING_LINEAR
 * CONSTANTS.ANIM.EASING_ABSOLUTE
 * CONSTANTS.ANIM.EASING_SMOOTHSTEP
 * CONSTANTS.ANIM.EASING_SMOOTHERSTEP
 * CONSTANTS.ANIM.EASING_CUBICSPLINE

 * CONSTANTS.ANIM.EASING_CUBIC_IN
 * CONSTANTS.ANIM.EASING_CUBIC_OUT
 * CONSTANTS.ANIM.EASING_CUBIC_INOUT

 * CONSTANTS.ANIM.EASING_EXPO_IN
 * CONSTANTS.ANIM.EASING_EXPO_OUT
 * CONSTANTS.ANIM.EASING_EXPO_INOUT

 * CONSTANTS.ANIM.EASING_SIN_IN
 * CONSTANTS.ANIM.EASING_SIN_OUT
 * CONSTANTS.ANIM.EASING_SIN_INOUT

 * CONSTANTS.ANIM.EASING_BACK_IN
 * CONSTANTS.ANIM.EASING_BACK_OUT
 * CONSTANTS.ANIM.EASING_BACK_INOUT

 * CONSTANTS.ANIM.EASING_ELASTIC_IN
 * CONSTANTS.ANIM.EASING_ELASTIC_OUT

 * CONSTANTS.ANIM.EASING_BOUNCE_IN
 * CONSTANTS.ANIM.EASING_BOUNCE_OUT

 * CONSTANTS.ANIM.EASING_QUART_IN
 * CONSTANTS.ANIM.EASING_QUART_OUT
 * CONSTANTS.ANIM.EASING_QUART_INOUT

 * CONSTANTS.ANIM.EASING_QUINT_IN
 * CONSTANTS.ANIM.EASING_QUINT_OUT
 * CONSTANTS.ANIM.EASING_QUINT_INOUT
 * </code>
 * @class
 * @param cfg
 * @example
 * var anim=new CABLES.Anim();
 * anim.setValue(0,0);  // set value 0 at 0 seconds
 * anim.setValue(10,1); // set value 1 at 10 seconds
 * anim.getValue(5);    // get value at 5 seconds - this returns 0.5
 */

  const Anim = function (cfg) {
    EventTarget.apply(this);

    cfg = cfg || {};
    this.keys = [];
    this.onChange = null;
    this.stayInTimeline = false;
    this.loop = false;
    this._log = new Logger("Anim");
    this._lastKeyIndex = 0;
    this._cachedIndex = 0;
    this.name = cfg.name || null;

    /**
     * @member defaultEasing
     * @memberof Anim
     * @instance
     * @type {Number}
     */
    this.defaultEasing = cfg.defaultEasing || CONSTANTS.ANIM.EASING_LINEAR;
    this.onLooped = null;

    this._timesLooped = 0;
    this._needsSort = false;
  };

  Anim.prototype.forceChangeCallback = function () {
    if (this.onChange !== null) this.onChange();
    this.emitEvent("onChange", this);
  };

  Anim.prototype.getLoop = function () {
    return this.loop;
  };

  Anim.prototype.setLoop = function (target) {
    this.loop = target;
    this.emitEvent("onChange", this);
  };

  /**
   * returns true if animation has ended at @time
   * checks if last key time is < time
   * @param {Number} time
   * @returns {Boolean}
   * @memberof Anim
   * @instance
   * @function
   */
  Anim.prototype.hasEnded = function (time) {
    if (this.keys.length === 0) return true;
    if (this.keys[this._lastKeyIndex].time <= time) return true;
    return false;
  };

  Anim.prototype.isRising = function (time) {
    if (this.hasEnded(time)) return false;
    const ki = this.getKeyIndex(time);
    if (this.keys[ki].value < this.keys[ki + 1].value) return true;
    return false;
  };

  /**
   * remove all keys from animation before time
   * @param {Number} time
   * @memberof Anim
   * @instance
   * @function
   */
  Anim.prototype.clearBefore = function (time) {
    const v = this.getValue(time);
    const ki = this.getKeyIndex(time);

    this.setValue(time, v);

    if (ki > 1) this.keys.splice(0, ki);
    this._updateLastIndex();
  };
  /**
   * remove all keys from animation
   * @param {Number} [time=0] set a new key at time with the old value at time
   * @memberof Anim
   * @instance
   * @function
   */
  Anim.prototype.clear = function (time) {
    let v = 0;
    if (time) v = this.getValue(time);
    this.keys.length = 0;
    this._updateLastIndex();
    if (time) this.setValue(time, v);
    if (this.onChange !== null) this.onChange();
    this.emitEvent("onChange", this);
  };

  Anim.prototype.sortKeys = function () {
    this.keys.sort((a, b) => {
      return parseFloat(a.time) - parseFloat(b.time);
    });
    this._updateLastIndex();
    this._needsSort = false;
    if (this.keys.length % 1000 == 0) console.log(this.name, this.keys.length);
  };

  Anim.prototype.getLength = function () {
    if (this.keys.length === 0) return 0;
    return this.keys[this.keys.length - 1].time;
  };

  Anim.prototype.getKeyIndex = function (time) {
    let index = 0;
    let start = 0;
    if (
      this._cachedIndex &&
      this.keys.length > this._cachedIndex &&
      time >= this.keys[this._cachedIndex].time
    )
      start = this._cachedIndex;
    for (let i = start; i < this.keys.length; i++) {
      if (time >= this.keys[i].time) index = i;
      if (this.keys[i].time > time) {
        if (time != 0) this._cachedIndex = index;
        return index;
      }
    }

    return index;
  };

  /**
   * set value at time
   * @function setValue
   * @memberof Anim
   * @instance
   * @param {Number} time
   * @param {Number} value
   * @param {Function} cb callback
   */
  Anim.prototype.setValue = function (time, value, cb) {
    let found = null;

    if (this.keys.length == 0 || time <= this.keys[this.keys.length - 1].time)
      for (let i = 0; i < this.keys.length; i++)
        if (this.keys[i].time == time) {
          found = this.keys[i];
          this.keys[i].setValue(value);
          this.keys[i].cb = cb;
          break;
        }

    if (!found) {
      found = new Key({
        time: time,
        value: value,
        e: this.defaultEasing,
        cb: cb,
      });
      this.keys.push(found);

      // if (this.keys.length % 1000 == 0)console.log(this.name, this.keys.length);
      this._updateLastIndex();
    }

    if (this.onChange) this.onChange();
    this.emitEvent("onChange", this);
    this._needsSort = true;
    return found;
  };

  Anim.prototype.setKeyEasing = function (index, e) {
    if (this.keys[index]) {
      this.keys[index].setEasing(e);
      this.emitEvent("onChange", this);
    }
  };

  Anim.prototype.getSerialized = function () {
    const obj = {};
    obj.keys = [];
    obj.loop = this.loop;

    for (let i = 0; i < this.keys.length; i++)
      obj.keys.push(this.keys[i].getSerialized());

    return obj;
  };

  Anim.prototype.getKey = function (time) {
    const index = this.getKeyIndex(time);
    return this.keys[index];
  };

  Anim.prototype.getNextKey = function (time) {
    let index = this.getKeyIndex(time) + 1;
    if (index >= this.keys.length) index = this.keys.length - 1;

    return this.keys[index];
  };

  Anim.prototype.isFinished = function (time) {
    if (this.keys.length <= 0) return true;
    return time > this.keys[this.keys.length - 1].time;
  };

  Anim.prototype.isStarted = function (time) {
    if (this.keys.length <= 0) return false;
    return time >= this.keys[0].time;
  };

  /**
   * get value at time
   * @function getValue
   * @memberof Anim
   * @instance
   * @param {Number} [time] time
   * @returns {Number} interpolated value at time
   */
  Anim.prototype.getValue = function (time) {
    if (this.keys.length === 0) {
      return 0;
    }
    if (this._needsSort) this.sortKeys();

    if (!this.loop && time > this.keys[this._lastKeyIndex].time) {
      if (
        this.keys[this._lastKeyIndex].cb &&
        !this.keys[this._lastKeyIndex].cbTriggered
      )
        this.keys[this._lastKeyIndex].trigger();

      return this.keys[this._lastKeyIndex].value;
    }

    if (time < this.keys[0].time) {
      // if (this.name)console.log("A");

      return this.keys[0].value;
    }

    if (this.loop && time > this.keys[this._lastKeyIndex].time) {
      const currentLoop = time / this.keys[this._lastKeyIndex].time;
      if (currentLoop > this._timesLooped) {
        this._timesLooped++;
        if (this.onLooped) this.onLooped();
      }
      time =
        (time - this.keys[0].time) %
        (this.keys[this._lastKeyIndex].time - this.keys[0].time);
      time += this.keys[0].time;
    }

    const index = this.getKeyIndex(time);
    if (index >= this._lastKeyIndex) {
      if (
        this.keys[this._lastKeyIndex].cb &&
        !this.keys[this._lastKeyIndex].cbTriggered
      )
        this.keys[this._lastKeyIndex].trigger();

      return this.keys[this._lastKeyIndex].value;
    }

    const index2 = index + 1;
    const key1 = this.keys[index];
    const key2 = this.keys[index2];

    if (key1.cb && !key1.cbTriggered) key1.trigger();

    if (!key2) return -1;

    const perc = (time - key1.time) / (key2.time - key1.time);

    if (!key1.ease) this.log._warn("has no ease", key1, key2);

    return key1.ease(perc, key2);
  };

  Anim.prototype._updateLastIndex = function () {
    this._lastKeyIndex = this.keys.length - 1;
  };

  Anim.prototype.addKey = function (k) {
    if (k.time === undefined) {
      this.log.warn("key time undefined, ignoring!");
    } else {
      this.keys.push(k);
      if (this.onChange !== null) this.onChange();
      this.emitEvent("onChange", this);
    }
    this._updateLastIndex();
  };

  Anim.prototype.easingFromString = function (str) {
    if (str == "linear") return CONSTANTS.ANIM.EASING_LINEAR;
    if (str == "absolute") return CONSTANTS.ANIM.EASING_ABSOLUTE;
    if (str == "smoothstep") return CONSTANTS.ANIM.EASING_SMOOTHSTEP;
    if (str == "smootherstep") return CONSTANTS.ANIM.EASING_SMOOTHERSTEP;

    if (str == "Cubic In") return CONSTANTS.ANIM.EASING_CUBIC_IN;
    if (str == "Cubic Out") return CONSTANTS.ANIM.EASING_CUBIC_OUT;
    if (str == "Cubic In Out") return CONSTANTS.ANIM.EASING_CUBIC_INOUT;

    if (str == "Expo In") return CONSTANTS.ANIM.EASING_EXPO_IN;
    if (str == "Expo Out") return CONSTANTS.ANIM.EASING_EXPO_OUT;
    if (str == "Expo In Out") return CONSTANTS.ANIM.EASING_EXPO_INOUT;

    if (str == "Sin In") return CONSTANTS.ANIM.EASING_SIN_IN;
    if (str == "Sin Out") return CONSTANTS.ANIM.EASING_SIN_OUT;
    if (str == "Sin In Out") return CONSTANTS.ANIM.EASING_SIN_INOUT;

    if (str == "Back In") return CONSTANTS.ANIM.EASING_BACK_IN;
    if (str == "Back Out") return CONSTANTS.ANIM.EASING_BACK_OUT;
    if (str == "Back In Out") return CONSTANTS.ANIM.EASING_BACK_INOUT;

    if (str == "Elastic In") return CONSTANTS.ANIM.EASING_ELASTIC_IN;
    if (str == "Elastic Out") return CONSTANTS.ANIM.EASING_ELASTIC_OUT;

    if (str == "Bounce In") return CONSTANTS.ANIM.EASING_BOUNCE_IN;
    if (str == "Bounce Out") return CONSTANTS.ANIM.EASING_BOUNCE_OUT;

    if (str == "Quart Out") return CONSTANTS.ANIM.EASING_QUART_OUT;
    if (str == "Quart In") return CONSTANTS.ANIM.EASING_QUART_IN;
    if (str == "Quart In Out") return CONSTANTS.ANIM.EASING_QUART_INOUT;

    if (str == "Quint Out") return CONSTANTS.ANIM.EASING_QUINT_OUT;
    if (str == "Quint In") return CONSTANTS.ANIM.EASING_QUINT_IN;
    if (str == "Quint In Out") return CONSTANTS.ANIM.EASING_QUINT_INOUT;
  };

  Anim.prototype.createPort = function (op, title, cb) {
    const port = op.inDropDown(title, CONSTANTS.ANIM.EASINGS, "Cubic Out");

    // const port = op.addInPort(
    //     new Port(op, title, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
    //         "display": "dropdown",
    //         "values": CONSTANTS.ANIM.EASINGS,
    //     }),
    // );

    port.set("linear");
    port.defaultValue = "linear";

    port.onChange = function () {
      this.defaultEasing = this.easingFromString(port.get());
      this.emitEvent("onChangeDefaultEasing", this);

      if (cb) cb();
    }.bind(this);

    return port;
  };

  // ------------------------------

  Anim.slerpQuaternion = function (time, q, animx, animy, animz, animw) {
    if (!Anim.slerpQuaternion.q1) {
      Anim.slerpQuaternion.q1 = quat.create();
      Anim.slerpQuaternion.q2 = quat.create();
    }

    const i1 = animx.getKeyIndex(time);
    let i2 = i1 + 1;
    if (i2 >= animx.keys.length) i2 = animx.keys.length - 1;

    if (i1 == i2) {
      quat.set(
        q,
        animx.keys[i1].value,
        animy.keys[i1].value,
        animz.keys[i1].value,
        animw.keys[i1].value
      );
    } else {
      const key1Time = animx.keys[i1].time;
      const key2Time = animx.keys[i2].time;
      const perc = (time - key1Time) / (key2Time - key1Time);

      quat.set(
        Anim.slerpQuaternion.q1,
        animx.keys[i1].value,
        animy.keys[i1].value,
        animz.keys[i1].value,
        animw.keys[i1].value
      );

      quat.set(
        Anim.slerpQuaternion.q2,
        animx.keys[i2].value,
        animy.keys[i2].value,
        animz.keys[i2].value,
        animw.keys[i2].value
      );

      quat.slerp(q, Anim.slerpQuaternion.q1, Anim.slerpQuaternion.q2, perc);
    }
    return q;
  };

  const ANIM = { Key: Key }; // CONCATENATED MODULE: ./src/core/core_link.js

  /**
   * @namespace external:CABLES#Link
   * @param {Object} scene The patch object
   * @description a link is a connection between two ops/ports -> one input and one output port
   * @hideconstructor
   * @class
   */
  const Link = function (scene) {
    EventTarget.apply(this);

    this.id = CABLES.simpleId();
    this.portIn = null;
    this.portOut = null;
    this.scene = scene; // todo: make private and rename to patch
    this.activityCounter = 0;
    this.ignoreInSerialize = false;
  };

  Link.prototype.setValue = function (v) {
    if (v === undefined) this._setValue();
    else this.portIn.set(v);
  };

  Link.prototype.activity = function () {
    this.activityCounter++;
    // if(Date.now()-this.lastTime>100)
    // {
    //     // this.lastTime=Date.now();
    //     // this.changesPerSecond=this.changesCounter*10;
    //     this.changesCounter=0;
    // }
  };

  Link.prototype._setValue = function () {
    if (!this.portOut) {
      this.remove();
      return;
    }
    const v = this.portOut.get();

    if (v == v) {
      // NaN is the only JavaScript value that is treated as unequal to itself
      if (this.portIn.type != CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)
        this.activity();

      if (this.portIn.get() !== v) {
        this.portIn.set(v);
      } else {
        if (this.portIn.changeAlways) this.portIn.set(v);
        if (this.portOut.forceRefChange) this.portIn.forceChange();
      }
    }
  };

  /**
   * @function getOtherPort
   * @memberof Link
   * @instance
   * @param {Port} p port
   * @description returns the port of the link, which is not port
   */
  Link.prototype.getOtherPort = function (p) {
    if (p == this.portIn) return this.portOut;
    return this.portIn;
  };

  /**
   * @function remove
   * @memberof Link
   * @instance
   * @description unlink/remove this link from all ports
   */
  Link.prototype.remove = function () {
    if (this.portIn) this.portIn.removeLink(this);
    if (this.portOut) this.portOut.removeLink(this);
    if (this.scene) {
      this.scene.emitEvent("onUnLink", this.portIn, this.portOut, this);
    }

    if (
      this.portIn &&
      (this.portIn.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT ||
        this.portIn.type == CONSTANTS.OP.OP_PORT_TYPE_ARRAY)
    ) {
      this.portIn.set(null);
      if (this.portIn.links.length > 0)
        this.portIn.set(this.portIn.links[0].getOtherPort(this.portIn).get());
    }

    if (this.portIn) this.portIn.op._checkLinksNeededToWork();
    if (this.portOut) this.portOut.op._checkLinksNeededToWork();

    this.portIn = null;
    this.portOut = null;
    this.scene = null;
  };

  /**
   * @function link
   * @memberof Link
   * @instance
   * @description link those two ports
   * @param {Port} p1 port1
   * @param {Port} p2 port2
   */
  Link.prototype.link = function (p1, p2) {
    if (!Link.canLink(p1, p2)) {
      console.warn("[core_link] cannot link ports!", p1, p2);
      return false;
    }

    if (p1.direction == CONSTANTS.PORT.PORT_DIR_IN) {
      this.portIn = p1;
      this.portOut = p2;
    } else {
      this.portIn = p2;
      this.portOut = p1;
    }

    p1.addLink(this);
    p2.addLink(this);

    this.setValue();

    if (p1.onLink) p1.onLink(this);
    if (p2.onLink) p2.onLink(this);

    p1.op._checkLinksNeededToWork();
    p2.op._checkLinksNeededToWork();
  };

  Link.prototype.getSerialized = function () {
    const obj = {};

    obj.portIn = this.portIn.getName();
    obj.portOut = this.portOut.getName();
    obj.objIn = this.portIn.op.id;
    obj.objOut = this.portOut.op.id;

    return obj;
  };

  // --------------------------------------------

  /**
   * @function canLinkText
   * @memberof Link
   * @instance
   * @description return a text message with human readable reason if ports can not be linked, or can be
   * @param {Port} p1 port1
   * @param {Port} p2 port2
   */
  Link.canLinkText = function (p1, p2) {
    if (p1.direction == p2.direction) {
      let txt = "(out)";
      if (p2.direction == CONSTANTS.PORT.PORT_DIR_IN) txt = "(in)";
      return "can not link: same direction " + txt;
    }
    if (p1.op == p2.op) return "can not link: same op";
    if (
      p1.type != CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC &&
      p2.type != CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC
    ) {
      if (p1.type != p2.type) return "can not link: different type";
    }

    if (
      CABLES.UI &&
      p1.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT &&
      p2.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT
    ) {
      if (p1.uiAttribs.objType && p2.uiAttribs.objType)
        if (p1.uiAttribs.objType != p2.uiAttribs.objType)
          return "incompatible objects";
    }

    if (!p1) return "can not link: port 1 invalid";
    if (!p2) return "can not link: port 2 invalid";

    if (p1.direction == CONSTANTS.PORT.PORT_DIR_IN && p1.isAnimated())
      return "can not link: is animated";
    if (p2.direction == CONSTANTS.PORT.PORT_DIR_IN && p2.isAnimated())
      return "can not link: is animated";

    // if(p1.direction==CABLES.CONSTANTS.PORT.PORT_DIR_IN && p1.links.length>0)return 'input port already busy';
    // if(p2.direction==CABLES.CONSTANTS.PORT.PORT_DIR_IN && p2.links.length>0)return 'input port already busy';
    if (p1.isLinkedTo(p2)) return "ports already linked";

    if ((p1.canLink && !p1.canLink(p2)) || (p2.canLink && !p2.canLink(p1)))
      return "Incompatible";

    return "can link";
  };

  /**
   * @function canLink
   * @memberof Link
   * @instance
   * @description return true if ports can be linked
   * @param {Port} p1 port1
   * @param {Port} p2 port2
   * @returns {Boolean}
   */
  Link.canLink = function (p1, p2) {
    if (!p1) return false;
    if (!p2) return false;
    if (p1.direction == CONSTANTS.PORT.PORT_DIR_IN && p1.isAnimated())
      return false;
    if (p2.direction == CONSTANTS.PORT.PORT_DIR_IN && p2.isAnimated())
      return false;

    if (p1.isHidden() || p2.isHidden()) return false;

    if (p1.isLinkedTo(p2)) return false;

    if (p1.direction == p2.direction) return false;

    if (
      CABLES.UI &&
      p1.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT &&
      p2.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT
    ) {
      if (p1.uiAttribs.objType && p2.uiAttribs.objType) {
        if (
          p1.uiAttribs.objType.indexOf("sg_") == 0 &&
          p2.uiAttribs.objType.indexOf("sg_") == 0
        )
          return true;
        if (p1.uiAttribs.objType != p2.uiAttribs.objType) return false;
      }
    }

    if (
      p1.type != p2.type &&
      p1.type != CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC &&
      p2.type != CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC
    )
      return false;
    if (
      p1.type == CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC ||
      p2.type == CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC
    )
      return true;

    if (p1.op == p2.op) return false;

    if (p1.canLink && !p1.canLink(p2)) return false;
    if (p2.canLink && !p2.canLink(p1)) return false;

    return true;
  }; // CONCATENATED MODULE: ./src/core/core_port.js

  /**
   * data is coming into and out of ops through input and output ports
   * @namespace external:CABLES#Port
   * @class
   * @hideconstructor
   * @param ___op
   * @param name
   * @param type
   * @param uiAttribs
   * @example
   * const myPort=op.inString("String Port");
   */
  const Port = function (___op, name, type, uiAttribs) {
    EventTarget.apply(this);

    this.data = {}; // UNUSED, DEPRECATED, only left in for backwards compatibility with userops
    this._log = new Logger("core_port");
    /**
     * @type {Number}
     * @name direction
     * @instance
     * @memberof Port
     * @description direction of port (input(0) or output(1))
     */
    this.direction = CONSTANTS.PORT.PORT_DIR_IN;
    this.id = String(CABLES.simpleId());
    this._op = ___op;

    /**
     * @type {Array<Link>}
     * @name links
     * @instance
     * @memberof Port
     * @description links of port
     */
    this.links = [];
    this.value = 0.0;
    this.name = name;
    this.type = type || CONSTANTS.OP.OP_PORT_TYPE_VALUE;
    this.uiAttribs = uiAttribs || {};
    this.anim = null;
    this._oldAnimVal = -5711;
    this.defaultValue = null;

    this._uiActiveState = true;
    this.ignoreValueSerialize = false;
    this.onLinkChanged = null;
    this.crashed = false;

    this._valueBeforeLink = null;
    this._lastAnimFrame = -1;
    this._animated = false;

    this.onValueChanged = null;
    this.onTriggered = null;
    this.onUiActiveStateChange = null;
    this.changeAlways = false;
    this.forceRefChange = false;

    this._useVariableName = null;

    this.activityCounter = 0;
    this.apf = 0;
    this.activityCounterStartFrame = 0;

    this._tempLastUiValue = null;

    Object.defineProperty(this, "title", {
      get() {
        return this.uiAttribs.title || this.name;
      },
    });

    Object.defineProperty(this, "parent", {
      get() {
        this._log.stack("use port.op, not .parent");
        return this._op;
      },
    });

    Object.defineProperty(this, "op", {
      get() {
        return this._op;
      },
    });

    Object.defineProperty(this, "val", {
      get() {
        // this._log.warn("val getter deprecated!", this);
        // this._log.stack("val getter deprecated");
        return this.get();
      },
      set(v) {
        // this._log.warn("val setter deprecated!", this);
        // this._log.stack("val setter deprecated");
        this.setValue(v);
      },
    });
  };

  /**
 * copy over a uiattrib from an external connected port to another port
 * @function copyLinkedUiAttrib
 * @memberof Port
 * @param {string} which attrib name
 * @param {Port} port source port
 * @instance
 * @example

inArray.onLinkChanged=()=>
{
    if(inArray) inArray.copyLinkedUiAttrib("stride", outArray);
};

 */
  Port.prototype.copyLinkedUiAttrib = function (which, port) {
    if (!CABLES.UI) return;
    if (!this.isLinked()) return;

    const attr = {};
    attr[which] = this.links[0].getOtherPort(this).getUiAttrib(which);
    port.setUiAttribs(attr);
  };

  // TODO make extend class for ports, like for ops only for ui
  Port.prototype.getValueForDisplay = function () {
    let str = this.value;

    if (typeof this.value === "string" || this.value instanceof String) {
      if (str.length > 1000) {
        str = str.substring(0, 999);
        str += "...";
      }
      if (this.uiAttribs && this.uiAttribs.display == "boolnum") {
        str += " - ";

        if (!this.value) str += "false";
        else str += "true";
      }

      str = str.replace(/[\u00A0-\u9999<>\&]/g, function (i) {
        return "&#" + i.charCodeAt(0) + ";";
      });

      if (str.length > 100) str = str.substring(0, 100);
    } else {
      str = this.value;
    }
    return str;
  };

  /**
   * change listener for input value ports, overwrite to react to changes
   * @function onChange
   * @memberof Port
   * @instance
   * @example
   * const myPort=op.inString("MyPort");
   * myPort.onChange=function()
   * {
   *   console.log("was changed to: ",myPort.get());
   * }
   *
   */
  Port.prototype.onAnimToggle = function () {};
  Port.prototype._onAnimToggle = function () {
    this.onAnimToggle();
  };

  /**
   * @function remove
   * @memberof Port
   * @instance
   * @description remove port
   */
  Port.prototype.remove = function () {
    // this.setUiAttribs({ "hidePort": true });
    this.removeLinks();
    this._op.removePort(this);
  };

  /**
   * set ui attributes
   * @function setUiAttribs
   * @memberof Port
   * @instance
   * @param {Object} newAttribs
   * <pre>
   * title - overwrite title of port (by default this is portname)
   * greyout - port paramater will appear greyed out, can not be
   * hidePort - port will be hidden from op
   * hideParam - port params will be hidden from parameter panel
   * showIndex - only for dropdowns - show value index (e.g. `0 - normal` )
   * editorSyntax - set syntax highlighting theme for editor port
   * ignoreObjTypeErrors - do not auto check object types
   * </pre>
   * @example
   * myPort.setUiAttribs({greyout:true});
   */
  Port.prototype.setUiAttribs = function (newAttribs) {
    let changed = false;
    if (!this.uiAttribs) this.uiAttribs = {};

    for (const p in newAttribs) {
      if (newAttribs[p] === undefined) {
        // delete newAttribs[p];
        delete this.uiAttribs[p];
        continue;
      }
      if (this.uiAttribs[p] != newAttribs[p]) changed = true;
      this.uiAttribs[p] = newAttribs[p];

      if (p == "group" && this.indexPort)
        this.indexPort.setUiAttribs({ group: newAttribs[p] });
    }

    if (newAttribs.hasOwnProperty("expose"))
      this._op.patch.emitEvent("subpatchExpose", this._op.uiAttribs.subPatch);

    if (changed) this.emitEvent("onUiAttrChange", newAttribs, this);
  };

  /**
   * get ui attributes
   * @function getUiAttribs
   * @memberof Port
   * @example
   * myPort.getUiAttribs();
   */
  Port.prototype.getUiAttribs = function () {
    return this.uiAttribs;
  };

  /**
   * get ui attribute
   * @function getUiAttrib
   * @memberof Port
   * @instance
   * @param {String} attribName
   * <pre>
   * attribName - return value of the ui-attribute, or null on unknown attribute
   * </pre>
   * @example
   * myPort.setUiAttribs("values");
   */
  Port.prototype.getUiAttrib = function (attribName) {
    if (!this.uiAttribs || !this.uiAttribs.hasOwnProperty(attribName)) {
      return null;
    }
    return this.uiAttribs[attribName];
  };

  /**
   * @function get
   * @memberof Port
   * @instance
   * @description get value of port
   */
  Port.prototype.get = function () {
    if (this._animated && this._lastAnimFrame != this._op.patch.getFrameNum()) {
      this._lastAnimFrame = this._op.patch.getFrameNum();

      let animval = this.anim.getValue(this._op.patch.timer.getTime());

      if (this.value != animval) {
        this.value = animval;
        this._oldAnimVal = this.value;
        this.forceChange();
      }
    }

    return this.value;
  };

  Port.prototype.setRef = function (v) {
    this.forceRefChange = true;
    this.set(v);
  };

  /**
   * @function setValue
   * @memberof Port
   * @instance
   * @description set value of port / will send value to all linked ports (only for output ports)
   */
  Port.prototype.set = Port.prototype.setValue = function (v) {
    if (v === undefined) v = null;

    if (CABLES.UI && CABLES.UI.showDevInfos)
      if (
        this.direction == CONSTANTS.PORT.PORT_DIR_OUT &&
        this.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT &&
        v &&
        !this.forceRefChange
      )
        this._log.warn("object port uses .set", this.name, this.op.objName);

    if (this._op.enabled && !this.crashed) {
      if (
        v !== this.value ||
        this.changeAlways ||
        this.type == CONSTANTS.OP.OP_PORT_TYPE_TEXTURE ||
        this.type == CONSTANTS.OP.OP_PORT_TYPE_ARRAY
      ) {
        if (this._animated) {
          this.anim.setValue(this._op.patch.timer.getTime(), v);
        } else {
          try {
            this.value = v;
            this.forceChange();
          } catch (ex) {
            this.crashed = true;

            this.setValue = function (_v) {};
            this.onTriggered = function () {};

            this._log.error("exception in ", this._op);
            this._log.error(ex);

            this._op.patch.emitEvent("exception", ex, this._op);
          }

          if (
            this._op &&
            this._op.patch &&
            this._op.patch.isEditorMode() &&
            this.type == CONSTANTS.OP.OP_PORT_TYPE_TEXTURE
          )
            gui.texturePreview().updateTexturePort(this);
        }

        if (this.direction == CONSTANTS.PORT.PORT_DIR_OUT)
          for (let i = 0; i < this.links.length; ++i) this.links[i].setValue();
      }
    }
  };

  Port.prototype.updateAnim = function () {
    if (this._animated) {
      this.value = this.get();

      if (this._oldAnimVal != this.value || this.changeAlways) {
        this._oldAnimVal = this.value;
        this.forceChange();
      }
      this._oldAnimVal = this.value;
    }
  };

  Port.prototype.forceChange = function () {
    if (this.onValueChanged || this.onChange) {
      // very temporary: deprecated warning!!!!!!!!!
      // if(params.length>0) this._log.warn('TOM: port has onchange params!',this._op.objName,this.name);
    }
    this._activity();
    this.emitEvent("change", this.value, this);

    // try
    // {
    if (this.onChange) this.onChange(this, this.value);
    else if (this.onValueChanged) this.onValueChanged(this, this.value); // deprecated
    // }
    // catch (e)
    // {
    //     console.log(e);
    // }
  };

  /**
   * @function getTypeString
   * @memberof Port
   * @instance
   * @description get port type as string, e.g. "Function","Value"...
   * @return {String} type
   */
  Port.prototype.getTypeString = function () {
    if (this.type == CONSTANTS.OP.OP_PORT_TYPE_VALUE) return "Number";
    if (this.type == CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) return "Trigger";
    if (this.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT) return "Object";
    if (this.type == CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return "Dynamic";
    if (this.type == CONSTANTS.OP.OP_PORT_TYPE_ARRAY) return "Array";
    if (this.type == CONSTANTS.OP.OP_PORT_TYPE_STRING) return "String";
    return "Unknown";
  };

  Port.prototype.deSerializeSettings = function (objPort) {
    if (!objPort) return;
    if (objPort.animated) this.setAnimated(objPort.animated);
    if (objPort.useVariable) this.setVariableName(objPort.useVariable);
    if (objPort.title) this.setUiAttribs({ title: objPort.title });
    if (objPort.expose) this.setUiAttribs({ expose: true });
    if (objPort.order) this.setUiAttribs({ order: objPort.order });

    if (objPort.multiPortManual)
      this.setUiAttribs({ multiPortManual: objPort.multiPortManual });
    if (objPort.multiPortNum)
      this.setUiAttribs({ multiPortNum: objPort.multiPortNum });

    if (objPort.anim) {
      if (!this.anim) this.anim = new Anim({ name: "port " + this.name });
      this._op._hasAnimPort = true;
      this.anim.addEventListener("onChange", () => {
        this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
      });
      if (objPort.anim.loop) this.anim.loop = objPort.anim.loop;
      for (const ani in objPort.anim.keys) {
        this.anim.keys.push(new ANIM.Key(objPort.anim.keys[ani]));
      }
      this.anim.sortKeys();
    }
  };

  Port.prototype.setInitialValue = function (v) {
    if (this.op.preservedPortLinks[this.name]) {
      for (let i = 0; i < this.op.preservedPortLinks[this.name].length; i++) {
        const lobj = this.op.preservedPortLinks[this.name][i];
        this.op.patch._addLink(
          lobj.objIn,
          lobj.objOut,
          lobj.portIn,
          lobj.portOut
        );
      }
    }

    if (
      this.op.preservedPortValues &&
      this.op.preservedPortValues.hasOwnProperty(this.name) &&
      this.op.preservedPortValues[this.name] !== undefined
    ) {
      this.set(this.op.preservedPortValues[this.name]);
    } else if (v !== undefined) this.set(v);
    if (v !== undefined) this.defaultValue = v;
  };

  Port.prototype.getSerialized = function () {
    let obj = { name: this.getName() };

    if (!this.ignoreValueSerialize && this.links.length === 0) {
      if (
        this.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT &&
        this.value &&
        this.value.tex
      ) {
      } else obj.value = this.value;
    }
    if (this._useVariableName) obj.useVariable = this._useVariableName;
    if (this._animated) obj.animated = true;
    if (this.anim) obj.anim = this.anim.getSerialized();
    if (this.uiAttribs.multiPortNum)
      obj.multiPortNum = this.uiAttribs.multiPortNum;
    if (this.uiAttribs.multiPortManual)
      obj.multiPortManual = this.uiAttribs.multiPortManual;

    if (this.uiAttribs.display == "file") obj.display = this.uiAttribs.display;
    if (this.uiAttribs.expose) {
      obj.expose = true;
      if (this.uiAttribs.hasOwnProperty("order"))
        obj.order = this.uiAttribs.order;
    }
    if (this.uiAttribs.title) obj.title = this.uiAttribs.title;
    if (
      (this.preserveLinks || this.direction == CONSTANTS.PORT.PORT_DIR_OUT) &&
      this.links.length > 0
    ) {
      obj.links = [];
      for (const i in this.links) {
        if (
          !this.links[i].ignoreInSerialize &&
          this.links[i].portIn &&
          this.links[i].portOut
        )
          obj.links.push(this.links[i].getSerialized());
      }
    }

    if (this.direction == CONSTANTS.PORT.PORT_DIR_IN && this.links.length > 0) {
      for (const i in this.links) {
        if (!this.links[i].portIn || !this.links[i].portOut) continue;

        const otherp = this.links[i].getOtherPort(this);
        // check if functions exist, are defined in core_extend_ops code in ui
        if (otherp.op.isInBlueprint2 && this.op.isInBlueprint2) {
          if (otherp.op.isInBlueprint2() && !this.op.isInBlueprint2()) {
            obj.links = obj.links || [];
            obj.links.push(this.links[i].getSerialized());
          }
        }
      }
    }

    if (obj.links && obj.links.length == 0) delete obj.links;
    if (this.type === CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) delete obj.value;
    if (
      this.type === CONSTANTS.OP.OP_PORT_TYPE_FUNCTION &&
      this.links.length == 0
    )
      obj = null;
    if (obj && Object.keys(obj).length == 1 && obj.name) obj = null; // obj is null if there is no real information other than name

    // console.log(obj);
    cleanJson(obj);

    return obj;
  };

  Port.prototype.shouldLink = function () {
    return true;
  };

  /**
   * @function removeLinks
   * @memberof Port
   * @instance
   * @description remove all links from port
   */
  Port.prototype.removeLinks = function () {
    let count = 0;
    while (this.links.length > 0) {
      count++;
      if (count > 5000) {
        this._log.warn("could not delete links... / infinite loop");
        this.links.length = 0;
        break;
      }
      this.links[0].remove();
    }
  };

  /**
   * @function removeLink
   * @memberof Port
   * @instance
   * @description remove all link from port
   * @param {CABLES.Link} link
   */
  Port.prototype.removeLink = function (link) {
    for (const i in this.links)
      if (this.links[i] == link) this.links.splice(i, 1);

    if (this.direction == CONSTANTS.PORT.PORT_DIR_IN) {
      if (this.type == CONSTANTS.OP.OP_PORT_TYPE_VALUE)
        this.setValue(this._valueBeforeLink || 0);
      else this.setValue(this._valueBeforeLink || null);
    }

    if (CABLES.UI && this._op.checkLinkTimeWarnings)
      this._op.checkLinkTimeWarnings();

    try {
      if (this.onLinkChanged) this.onLinkChanged();
      this.emitEvent("onLinkChanged");
      this.emitEvent("onLinkRemoved");
      this._op.emitEvent("onLinkChanged");
    } catch (e) {
      this._log.error(e);
    }
  };

  /**
   * @function getName
   * @memberof Port
   * @instance
   * @description return port name
   */
  Port.prototype.getName = function () {
    return this.name;
  };

  /**
   * @function getTitle
   * @memberof Port
   * @instance
   * @description return port name or title
   */
  Port.prototype.getTitle = function () {
    if (this.uiAttribs.title) return this.uiAttribs.title;
    return this.name;
  };

  Port.prototype.addLink = function (l) {
    this._valueBeforeLink = this.value;
    this.links.push(l);
    if (CABLES.UI && this._op.checkLinkTimeWarnings)
      this._op.checkLinkTimeWarnings();

    try {
      if (this.onLinkChanged) this.onLinkChanged();
      this.emitEvent("onLinkChanged");
      this._op.emitEvent("onLinkChanged");
    } catch (e) {
      this._log.error(e);
    }
  };

  /**
   * @function getLinkTo
   * @memberof Port
   * @instance
   * @param {Port} p2 otherPort
   * @description return link, which is linked to otherPort
   */
  Port.prototype.getLinkTo = function (p2) {
    for (const i in this.links)
      if (this.links[i].portIn == p2 || this.links[i].portOut == p2)
        return this.links[i];
  };

  /**
   * @function removeLinkTo
   * @memberof Port
   * @instance
   * @param {Port} p2 otherPort
   * @description removes link, which is linked to otherPort
   */
  Port.prototype.removeLinkTo = function (p2) {
    for (const i in this.links) {
      if (this.links[i].portIn == p2 || this.links[i].portOut == p2) {
        this.links[i].remove();
        if (CABLES.UI && this._op.checkLinkTimeWarnings)
          this._op.checkLinkTimeWarnings();

        if (this.onLinkChanged) this.onLinkChanged();
        this.emitEvent("onLinkChanged");
        this.emitEvent("onLinkRemoved");
        return;
      }
    }
  };

  /**
   * @function isLinkedTo
   * @memberof Port
   * @instance
   * @param {Port} p2 otherPort
   * @description returns true if port is linked to otherPort
   */
  Port.prototype.isLinkedTo = function (p2) {
    for (const i in this.links)
      if (this.links[i].portIn == p2 || this.links[i].portOut == p2)
        return true;

    return false;
  };

  Port.prototype._activity = function () {
    this.activityCounter++;
  };

  /**
   * @function trigger
   * @memberof Port
   * @instance
   * @description trigger the linked port (usually invoked on an output function port)
   */
  Port.prototype.trigger = function () {
    const linksLength = this.links.length;

    this._activity();
    if (linksLength === 0) return;
    if (!this._op.enabled) return;

    let portTriggered = null;
    try {
      for (let i = 0; i < linksLength; ++i) {
        if (this.links[i].portIn) {
          portTriggered = this.links[i].portIn;

          portTriggered.op.patch.pushTriggerStack(portTriggered);
          portTriggered._onTriggered();

          portTriggered.op.patch.popTriggerStack();
        }
        if (this.links[i]) this.links[i].activity();
      }
    } catch (ex) {
      portTriggered.op.enabled = false;

      if (this._op.patch.isEditorMode()) {
        // this._op.patch.emitEvent("exception", ex, portTriggered.op);
        // this._op.patch.emitEvent("opcrash", portTriggered);
        // console.log("crash", portTriggered.op.objName);

        if (portTriggered.op.onError) portTriggered.op.onError(ex);
      }
      this._log.error(
        "exception in port: ",
        portTriggered.name,
        portTriggered.op.name,
        portTriggered.op
      );
      this._log.error(ex);
    }
  };

  Port.prototype.call = function () {
    this._log.warn("call deprecated - use trigger() ");
    this.trigger();
  };

  Port.prototype.execute = function () {
    this._log.warn("### execute port: " + this.getName(), this.goals.length);
  };

  Port.prototype.setVariableName = function (n) {
    this._useVariableName = n;

    this._op.patch.on("variableRename", (oldname, newname) => {
      if (oldname != this._useVariableName) return;
      this._useVariableName = newname;
    });
  };

  Port.prototype.getVariableName = function () {
    return this._useVariableName;
  };

  Port.prototype.setVariable = function (v) {
    this.setAnimated(false);
    const attr = { useVariable: false };

    if (this._variableIn && this._varChangeListenerId) {
      this._variableIn.off(this._varChangeListenerId);
      this._variableIn = null;
    }

    if (v) {
      this._variableIn = this._op.patch.getVar(v);

      if (!this._variableIn) {
        this._log.warn("PORT VAR NOT FOUND!!!", v);
      } else {
        if (this.type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT) {
          this._varChangeListenerId = this._variableIn.on("change", () => {
            this.set(null);
            this.set(this._variableIn.getValue());
          });
        } else {
          this._varChangeListenerId = this._variableIn.on(
            "change",
            this.set.bind(this)
          );
        }
        this.set(this._variableIn.getValue());
      }
      this._useVariableName = v;
      attr.useVariable = true;
      attr.variableName = this._useVariableName;
    } else {
      attr.variableName = this._useVariableName = null;
      attr.useVariable = false;
    }

    this.setUiAttribs(attr);
    this._op.patch.emitEvent("portSetVariable", this._op, this, v);
  };

  Port.prototype._handleNoTriggerOpAnimUpdates = function (a) {
    let hasTriggerPort = false;
    for (let i = 0; i < this._op.portsIn.length; i++) {
      if (this._op.portsIn.type == CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) {
        hasTriggerPort = true;
        break;
      }
    }

    if (!hasTriggerPort) {
      if (a)
        this._notriggerAnimUpdate = this._op.patch.on("onRenderFrame", () => {
          this.updateAnim();
        });
      else this._op.patch.removeEventListener(this._notriggerAnimUpdate);
    }
  };

  Port.prototype.setAnimated = function (a) {
    if (this._animated != a) {
      this._animated = a;
      this._op._hasAnimPort = true;

      if (this._animated && !this.anim) {
        this.anim = new Anim({ name: "port " + this.name });
        this.anim.addEventListener("onChange", () => {
          this._op.patch.emitEvent(
            "portAnimUpdated",
            this._op,
            this,
            this.anim
          );
        });
      }
      this._onAnimToggle();
    }

    this._handleNoTriggerOpAnimUpdates(a);
    if (!a) {
      this.anim = null;
    }

    this.setUiAttribs({ isAnimated: this._animated });
  };

  Port.prototype.toggleAnim = function () {
    this._animated = !this._animated;
    if (this._animated && !this.anim) {
      this.anim = new Anim({ name: "port " + this.name });
      this.anim.addEventListener("onChange", () => {
        this._op.patch.emitEvent("portAnimUpdated", this._op, this, this.anim);
      });
    }
    this.setAnimated(this._animated);
    this._onAnimToggle();
    this.setUiAttribs({ isAnimated: this._animated });
  };

  /**
   * <pre>
   * CABLES.CONSTANTS.OP.OP_PORT_TYPE_VALUE = 0;
   * CABLES.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION = 1;
   * CABLES.CONSTANTS.OP.OP_PORT_TYPE_OBJECT = 2;
   * CABLES.CONSTANTS.OP.OP_PORT_TYPE_TEXTURE = 2;
   * CABLES.CONSTANTS.OP.OP_PORT_TYPE_ARRAY = 3;
   * CABLES.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC = 4;
   * CABLES.CONSTANTS.OP.OP_PORT_TYPE_STRING = 5;
   * </pre>
   * @function getType
   * @memberof Port
   * @instance
   * @return {Number} type of port
   */
  Port.prototype.getType = function () {
    return this.type;
  };

  /**
   * @function isLinked
   * @memberof Port
   * @instance
   * @return {Boolean} true if port is linked
   */
  Port.prototype.isLinked = function () {
    return (
      this.links.length > 0 || this._animated || this._useVariableName != null
    );
  };

  Port.prototype.isBoundToVar = function () {
    const b = this._useVariableName != null;
    this.uiAttribs.boundToVar = b;
    return b;
  };
  /**
   * @function isAnimated
   * @memberof Port
   * @instance
   * @return {Boolean} true if port is animated
   */
  Port.prototype.isAnimated = function () {
    return this._animated;
  };

  /**
   * @function isHidden
   * @memberof Port
   * @instance
   * @return {Boolean} true if port is hidden
   */
  Port.prototype.isHidden = function () {
    return this.uiAttribs.hidePort;
  };

  /**
   * @function onTriggered
   * @memberof Port
   * @instance
   * @param {function} a onTriggeredCallback
   * @description set callback, which will be executed when port was triggered (usually output port)
   */
  Port.prototype._onTriggered = function (a) {
    this._activity();
    this._op.updateAnims();
    if (this._op.enabled && this.onTriggered) this.onTriggered(a);

    if (this._op.enabled) this.emitEvent("trigger");
  };

  Port.prototype._onSetProfiling = function (v) {
    this._op.patch.profiler.add("port", this);
    this.setValue(v);
    this._op.patch.profiler.add("port", null);
  };

  Port.prototype._onTriggeredProfiling = function () {
    if (this._op.enabled && this.onTriggered) {
      this._op.patch.profiler.add("port", this);
      this.onTriggered();
      this._op.patch.profiler.add("port", null);
    }
  };

  Port.prototype.getUiActiveState = function () {
    return this._uiActiveState;
  };

  Port.prototype.setUiActiveState = function (onoff) {
    this._uiActiveState = onoff;
    if (this.onUiActiveStateChange) this.onUiActiveStateChange();
  };

  /**
   * @deprecated
   * @param {function} cb
   */
  Port.prototype.onValueChange = function (cb) {
    this.onChange = cb;
  };

  /**
   * @deprecated
   */
  Port.prototype.hidePort = function () {};

  /**
   * Returns the port type string, e.g. "value" based on the port type number
   * @function portTypeNumberToString
   * @instance
   * @memberof Port
   * @param {Number} type - The port type number
   * @returns {String} - The port type as string
   */
  Port.portTypeNumberToString = function (type) {
    if (type == CONSTANTS.OP.OP_PORT_TYPE_VALUE) return "value";
    if (type == CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) return "function";
    if (type == CONSTANTS.OP.OP_PORT_TYPE_OBJECT) return "object";
    if (type == CONSTANTS.OP.OP_PORT_TYPE_ARRAY) return "array";
    if (type == CONSTANTS.OP.OP_PORT_TYPE_STRING) return "string";
    if (type == CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return "dynamic";
    return "unknown";
  }; // CONCATENATED MODULE: ./src/core/core_port_switch.js

  class SwitchPort extends Port {
    constructor(__parent, name, type, uiAttribs, indexPort) {
      super(__parent, name, type, uiAttribs);

      this.get = () => {
        let s = super.get();

        if (CABLES.UI) {
          if (
            s === "" ||
            s === null ||
            s === undefined ||
            (uiAttribs.values && uiAttribs.values.indexOf(String(s)) === -1)
          ) {
            this.op.setUiError(
              "invalidswitch",
              "Invalid Value [" + this.name + ']: "' + s + '"',
              1
            );
          } else this.op.setUiError("invalidswitch", null);
        }

        if (s === null || s === undefined) s = "";

        return s;
      };

      this.indexPort = indexPort;
      this.indexPort.set = (value) => {
        const values = uiAttribs.values;

        if (!values) {
          // console.log("switch port has no values", this);
          return;
        }

        let intValue = Math.floor(value);

        intValue = Math.min(intValue, values.length - 1);
        intValue = Math.max(intValue, 0);

        this.indexPort.setValue(intValue);
        this.set(values[intValue]);

        if (
          this.op.patch.isEditorMode() &&
          performance.now() - (this.lastTime || 0) > 100 &&
          window.gui &&
          gui.patchView.isCurrentOp(this.op)
        ) {
          gui.opParams.show(this.op);
          this.lastTime = performance.now();
        }
      };
    }

    setUiAttribs(attribs) {
      const hidePort = attribs.hidePort;
      attribs.hidePort = true;
      super.setUiAttribs(attribs);
      if (typeof hidePort !== "undefined") {
        this.indexPort.setUiAttribs({ hidePort });
      }
    }
  } // CONCATENATED MODULE: ./src/core/core_port_select.js

  class ValueSelectPort extends SwitchPort {
    setUiAttribs(newAttribs) {
      // never unhide valuePort when indexPort is linked
      if (this.indexPort.isLinked()) {
        for (const p in newAttribs) {
          if (p == "greyout" && !newAttribs[p]) newAttribs[p] = "true";
        }
      }
      super.setUiAttribs(newAttribs);
    }
  } // CONCATENATED MODULE: ./src/core/core_port_multi.js

  const MIN_NUM_PORTS = 2;

  class MultiPort extends Port {
    constructor(__parent, name, type, dir, uiAttribs, uiAttribsPorts) {
      super(__parent, name, CONSTANTS.OP.OP_PORT_TYPE_ARRAY, uiAttribs);

      this.setUiAttribs({ multiPort: true, group: this.name, order: -1 });
      this.ports = [];
      this.direction = dir;
      this._uiAttribsPorts = uiAttribsPorts;

      // console.log("uiattribs", uiAttribs);

      const updateArray = () => {
        const arr = [];

        let ll = 1;
        if (this.uiAttribs.multiPortManual) ll = 0;

        for (let i = 0; i < this.ports.length - ll; i++) arr[i] = this.ports[i];

        this.setRef(arr);
      };

      const updateUi = () => {
        let grey = !this.uiAttribs.multiPortManual || undefined;

        if (this.direction == CONSTANTS.PORT.PORT_DIR_OUT) grey = false;

        for (let i = 0; i < this.ports.length; i++) {
          let lp; // undefined to remove/not set it
          // let opacity;// undefined to remove/not set it
          // let grey;// undefined to remove/not set it
          let addPort = false;
          let title;
          let o = {};

          // console.log("this.op.preservedPortTitles", this.op.preservedPortTitles, this.op.preservedPortTitles[po.name], po.name);
          if (
            this.op.preservedPortTitles &&
            this.op.preservedPortTitles[this.ports[i].name]
          )
            title = this.op.preservedPortTitles[this.ports[i].name];

          // if (!this.uiAttribs.multiPortManual)grey = true;
          if (i == 0) lp = this.ports.length;

          if (!this.uiAttribs.multiPortManual)
            if (i == this.ports.length - 1) {
              title = "add port";
              addPort = true;
              grey = true;
            }

          for (const attin in this._uiAttribsPorts) {
            o[attin] = this._uiAttribsPorts[attin];
          }

          o.addPort = addPort;
          o.longPort = lp;
          o.title = title;
          o.greyout = grey;
          o.group = this.name;

          this.ports[i].setUiAttribs(o);
        }
      };

      this.removeInvalidPorts = () => {
        for (let i = 0; i < this.ports.length; i++) {
          if (!this.ports[i]) this.ports.splice(i, 1);
        }

        if (!this.uiAttribs.multiPortManual) {
          if (this.ports.length > MIN_NUM_PORTS)
            for (let i = this.ports.length - 1; i > 1; i--) {
              if (!this.ports[i].isLinked()) this.uiAttribs.multiPortNum = i;
              else break;
            }
        }

        updateArray();
      };

      this.countPorts = () => {
        if (
          CABLES.UI &&
          !gui.isRemoteClient &&
          gui.patchView &&
          gui.patchView.patchRenderer &&
          gui.patchView.patchRenderer.isDraggingPort()
        ) {
          clearTimeout(this.retryTo);
          this.retryTo = setTimeout(this.countPorts.bind(this));
          return;
        }
        this.retryTo = null;

        let redo = false;
        this.removeListeners();
        this.removeInvalidPorts();

        for (let i = 0; i < this.ports.length; i++) {
          if (this.ports[i] && this.ports[i].links.length > 1) {
            const po = this.ports[i + 1];
            const otherPort = this.ports[i].links[0].getOtherPort(
              this.ports[i]
            );

            if (!po || !otherPort) {
              this._log.warn("no port found?");
            } else {
              this.ports[i].links[0].remove();
              this.op.patch.link(
                this.op,
                po.name,
                otherPort.op,
                otherPort.name
              );
              redo = true;
            }
            break;
          }
        }

        if (!this.uiAttribs.multiPortManual) {
          let foundHole = true;
          while (foundHole) {
            // console.log("search holes...");
            foundHole = false;

            for (let i = this.ports.length - 1; i > 1; i--) {
              if (
                this.ports[i] &&
                this.ports[i].links.length > 0 &&
                this.ports[i - 1].links.length == 0
              ) {
                // console.log("found hole!");

                // found hole
                const otherPort = this.ports[i].links[0].getOtherPort(
                  this.ports[i]
                );
                this.ports[i].links[0].remove();

                const po = this.ports[i - 1];

                if (po && this.ports[i]) {
                  // console.log("move ", this.ports[i].name, "to", po.name);
                  this.op.patch.link(
                    this.op,
                    po.name,
                    otherPort.op,
                    otherPort.name
                  );
                  foundHole = true;
                  redo = true;
                  break;
                }
              }
            }

            // this.checkNum();
          }

          // this.removeInvalidPorts();
        }

        if (!this.uiAttribs.multiPortManual) {
          // if auto
          while (
            this.ports.length > MIN_NUM_PORTS &&
            !this.ports[this.ports.length - 1].isLinked() &&
            !this.ports[this.ports.length - 2].isLinked()
          ) {
            let i = this.ports.length - 1;
            if (
              !this.ports[i].isLinked() &&
              this.ports[i - 1] &&
              !this.ports[i - 1].isLinked()
            ) {
              this.ports[i].setUiAttribs({ removed: true });
              this.ports[i].remove();
              // this.ports[i] = null;
              this.ports.splice(i, 1);
            }
          }
        }

        this.removeInvalidPorts();

        if (
          !this.uiAttribs.multiPortManual &&
          this.ports.length > 0 &&
          this.ports[this.ports.length - 1].isLinked()
        )
          this.newPort();

        updateArray();
        updateUi();

        if (redo) this.countPorts();
        else this.addListeners();
      };

      this.removeListeners = () => {
        for (let i = 0; i < this.ports.length; i++) {
          const po = this.ports[i];
          po.multiPortChangeListener = po.off(po.multiPortChangeListener);
          po.multiLinkChangeListener = po.off(po.multiLinkChangeListener);
        }
      };

      this.addListeners = () => {
        for (let i = 0; i < this.ports.length; i++) {
          const po = this.ports[i];
          const idx = i;

          if (po.multiPortChangeListener)
            po.multiPortChangeListener = po.off(po.multiPortChangeListener);
          po.multiPortChangeListener = po.on("change", updateArray.bind(this));

          if (po.multiPortTriggerListener)
            po.multiPortTriggerListener = po.off(po.multiPortTriggerListener);
          po.multiPortTriggerListener = po.on("trigger", () => {
            this._onTriggered(idx);
          });

          // if (po.multiPortTriggerListener)po.multiPortTriggerListener = po.off(po.multiPortTriggerListener);
          // po.multiPortTriggerListener = po.on("trigger", this.trigger());

          if (po.multiLinkChangeListener)
            po.multiLinkChangeListener = po.off(po.multiLinkChangeListener);
          po.multiLinkChangeListener = po.on("onLinkChanged", () => {
            this.countPorts();
            this.emitEvent("onLinkChanged");
          });

          if (po.multiLinkRemoveListener)
            po.multiLinkRemoveListener = po.off(po.multiLinkRemoveListener);
          po.multiLinkRemoveListener = po.on("onLinkRemoved", () => {
            // this.removeInvalidPorts();
            // this.checkNum();
            // this.countPorts();
            updateUi();
            this.emitEvent("onLinkChanged");
            // this.countPorts.bind(this);
          });
        }
      };

      this.newPort = () => {
        const attrs = {};
        // if (type == CABLES.OP_PORT_TYPE_STRING) attrs.type = "string";
        attrs.type = type;
        const po = new Port(
          this.op,
          name + "_" + this.ports.length,
          type,
          attrs
        );

        po.direction = dir;
        this.ports.push(po);
        // console.log("CONSTANTS.PORT_DIR_OUT", CONSTANTS.PORT.PORT_DIR_OUT, this.direction);
        if (this.direction == CONSTANTS.PORT.PORT_DIR_OUT)
          this.op.addOutPort(po);
        else this.op.addInPort(po);

        if (type == CONSTANTS.OP.OP_PORT_TYPE_NUMBER) po.setInitialValue(0);
        else if (type == CONSTANTS.OP.OP_PORT_TYPE_STRING)
          po.setInitialValue("");

        this.addListeners();

        updateUi();
        updateArray();
        this.emitEvent("onLinkChanged");
        // console.log("this.op.preservedPortTitles", this.op.preservedPortTitles, this.op.preservedPortTitles[po.name], po.name);
        if (this.op.preservedPortTitles && this.op.preservedPortTitles[po.name])
          po.setUiAttribs({ title: this.op.preservedPortTitles[po.name] });

        return po;
      };

      this.initPorts = () => {
        for (let i = 0; i < MIN_NUM_PORTS; i++) this.newPort();
        updateArray();
        updateUi();
      };

      this.checkNum = () => {
        this.uiAttribs.multiPortNum = Math.max(
          MIN_NUM_PORTS,
          this.uiAttribs.multiPortNum
        );

        while (this.ports.length < this.uiAttribs.multiPortNum) this.newPort();
        while (this.ports.length > this.uiAttribs.multiPortNum)
          if (this.ports[this.ports.length - 1]) this.ports.pop().remove();

        this.removeInvalidPorts();
      };

      this.incDec = (incDir) => {
        this.uiAttribs.multiPortNum =
          this.uiAttribs.multiPortNum || MIN_NUM_PORTS;
        // console.log("this.uiAttribs.multiPortNum", this.uiAttribs.multiPortNum, this.uiAttribs.multiPortNum + incDir);
        this.setUiAttribs({
          multiPortNum: this.uiAttribs.multiPortNum + incDir,
        });
        this.checkNum();

        updateUi();
      };

      this.toggleManual = () => {
        this.setUiAttribs({ multiPortManual: !this.uiAttribs.multiPortManual });
        this.op.refreshParams();
      };

      this.on("onUiAttrChange", (attribs) => {
        if (attribs.hasOwnProperty("multiPortManual")) {
          updateUi();
          this.removeInvalidPorts();
          this.checkNum();
          this.countPorts();
          updateUi();
        }
      });

      this.on("onUiAttrChange", this.checkNum.bind(this));
      this.checkNum();
      this.countPorts();
      this.removeInvalidPorts();
      updateUi();
    }
  } // CONCATENATED MODULE: ./src/core/core_op.js

  /**
   * op the class of all operators
   * @namespace external:CABLES#Op
   * @hideconstructor
   */

  /**
   * @type {Object}
   * @name attachments
   * @instance
   * @memberof Op
   * @description access file attachments as String values
   * @example
   * // set shader source to attached files (files are called shader.vert / shader.frag)
   * shader.setSource(attachments.shader_vert,attachments.shader_frag);
   */

  const Ops = {};

  const Op = function () {
    EventTarget.apply(this);

    this._log = new Logger("core_op");
    this.data = {}; // UNUSED, DEPRECATED, only left in for backwards compatibility with userops
    this.storage = {}; // op-specific data to be included in export
    this.__objName = "";
    this.portsOut = [];
    this.portsIn = [];
    this.portsInData = []; // original loaded patch data
    this.opId = ""; // unique op id
    this.uiAttribs = {};
    this.enabled = true;
    this.patch = arguments[0];
    this._name = arguments[1];
    this.preservedPortTitles = {};
    this.preservedPortValues = {};
    this.preservedPortLinks = {};

    this._linkTimeRules = {
      needsLinkedToWork: [],
      needsParentOp: null,
    };

    this.shouldWork = {};
    this.hasUiErrors = false;
    this._uiErrors = {};
    this._hasAnimPort = false;

    if (arguments[1]) {
      this._shortOpName = CABLES.getShortOpName(arguments[1]);
      this.getTitle();
    }

    this.id = arguments[2] || shortId(); // instance id
    this.onAddPort = null;
    this.onCreate = null;
    this.onResize = null;
    this.onLoaded = null;
    this.onDelete = null;
    this.onError = null;

    this._instances = null;

    /**
     * overwrite this to prerender shader and meshes / will be called by op `loadingStatus`
     * @function preRender
     * @memberof Op
     * @instance
     */
    this.preRender = null;

    /**
     * overwrite this to initialize your op
     * @function init
     * @memberof Op
     * @instance
     */
    this.init = null;

    Object.defineProperty(this, "name", {
      get() {
        return this.getTitle();
      },
      set(v) {
        this.setTitle(v);
      },
    });

    Object.defineProperty(this, "_objName", {
      set(on) {
        this.__objName = on;
        this._log = new Logger("op " + on);
      },
    });

    Object.defineProperty(this, "objName", {
      get() {
        return this.__objName;
      },
    });
    Object.defineProperty(this, "shortName", {
      get() {
        return this._shortOpName;
      },
    });

    if (this.initUi) this.initUi();
  };

  {
    Op.prototype.clearUiAttrib = function (name) {
      const obj = {};
      // obj.name = null;
      this.uiAttrib(obj);
    };

    Op.prototype.require = function (name) {
      if (
        CABLES.platform &&
        CABLES.StandaloneElectron &&
        !CABLES.platform.frontendOptions.isStandalone
      )
        this.setUiError(
          "notstandalone",
          "This op will only work in cables standalone version",
          3
        );

      return null;
    };

    Op.prototype.checkMainloopExists = function () {
      if (!CABLES.UI) return;
      if (!this.patch.tempData.mainloopOp)
        this.setUiError(
          "nomainloop",
          "patch should have a mainloop to use this op"
        );
      else this.setUiError("nomainloop", null);
    };

    Op.prototype.getTitle = function () {
      if (!this.uiAttribs) return "nouiattribs" + this._name;

      // if ((this.uiAttribs.title === undefined || this.uiAttribs.title === "") && this.objName.indexOf("Ops.Ui.") == -1)
      //     this.uiAttribs.title = this._shortOpName;

      return this.uiAttribs.title || this._shortOpName;
    };

    Op.prototype.setTitle = function (title) {
      // this._log.log("settitle", title);
      // this._log.log(
      //     (new Error()).stack
      // );

      if (title != this.getTitle()) this.uiAttr({ title: title });
    };

    Op.prototype.setStorage = function (newAttribs) {
      if (!newAttribs) return;
      this.storage = this.storage || {};

      let changed = false;
      for (const p in newAttribs) {
        if (this.storage[p] != newAttribs[p]) changed = true;
        this.storage[p] = newAttribs[p];
      }

      if (changed) this.emitEvent("onStorageChange", newAttribs);
    };

    Op.prototype.isSubPatchOp = function () {
      if (this.patchId && this.storage)
        return this.storage.subPatchVer || this.storage.blueprintVer || 0;
      return false;
    };

    const _setUiAttrib = function (newAttribs) {
      if (!newAttribs) return;

      if (newAttribs.error || newAttribs.warning || newAttribs.hint) {
        this._log.warn(
          "old ui error/warning attribute in " +
            this._name +
            ", use op.setUiError !",
          newAttribs
        );
      }

      if (typeof newAttribs != "object")
        this._log.error("op.uiAttrib attribs are not of type object");
      if (!this.uiAttribs) this.uiAttribs = {};

      let changed = false;
      let emitMove = false;
      if (
        CABLES.UI &&
        newAttribs.hasOwnProperty("translate") &&
        (!this.uiAttribs.translate ||
          this.uiAttribs.translate.x != newAttribs.translate.x ||
          this.uiAttribs.translate.y != newAttribs.translate.y)
      )
        emitMove = true;

      if (
        newAttribs.hasOwnProperty("title") &&
        newAttribs.title != this.uiAttribs.title
      ) {
        // const doEmitEvent = newAttribs.title != this.getTitle();
        this.uiAttribs.title = newAttribs.title;
        // if (doEmitEvent) this.emitEvent("onTitleChange", newAttribs.title);
        changed = true;
        // this.setTitle(newAttribs.title);
      }

      if (newAttribs.hasOwnProperty("disabled"))
        this.setEnabled(!newAttribs.disabled);

      for (const p in newAttribs) {
        if (this.uiAttribs[p] != newAttribs[p]) changed = true;
        this.uiAttribs[p] = newAttribs[p];
      }

      if (
        this.uiAttribs.hasOwnProperty("selected") &&
        this.uiAttribs.selected == false
      )
        delete this.uiAttribs.selected;

      if (changed) {
        this.emitEvent("onUiAttribsChange", newAttribs);
        this.patch.emitEvent("onUiAttribsChange", this, newAttribs);
      }

      if (emitMove) this.emitEvent("move");
    };
    /**
     * setUiAttrib
     * possible values:
     * <pre>
     * warning - warning message - showing up in op parameter panel
     * error - error message - showing up in op parameter panel
     * extendTitle - op title extension, e.g. [ + ]
     * </pre>
     * @function setUiAttrib
     * @param {Object} newAttribs, e.g. {"attrib":value}
     * @memberof Op
     * @instance
     * @example
     * op.setUiAttrib({"extendTitle":str});
     */
    Op.prototype.setUiAttribs =
      Op.prototype.setUiAttrib =
      Op.prototype.uiAttr =
        _setUiAttrib;

    Op.prototype.getName = function () {
      if (this.uiAttribs.name) return this.uiAttribs.name;
      return this._name;
    };

    Op.prototype.addOutPort = function (p) {
      p.direction = CONSTANTS.PORT.PORT_DIR_OUT;
      p._op = this;
      this.portsOut.push(p);
      this.emitEvent("onPortAdd", p);
      return p;
    };

    Op.prototype.hasDynamicPort = function () {
      let i = 0;
      for (i = 0; i < this.portsIn.length; i++) {
        if (this.portsIn[i].type == CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC)
          return true;
        if (this.portsIn[i].getName() == "dyn") return true;
      }
      for (i = 0; i < this.portsOut.length; i++) {
        if (this.portsOut[i].type == CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC)
          return true;
        if (this.portsOut[i].getName() == "dyn") return true;
      }

      return false;
    };

    Op.prototype.addInPort = function (p) {
      if (!(p instanceof Port)) throw new Error("parameter is not a port!");

      p.direction = CONSTANTS.PORT.PORT_DIR_IN;
      p._op = this;

      this.portsIn.push(p);
      this.emitEvent("onPortAdd", p);

      return p;
    };

    /**
     * create a trigger input port
     * @function inTrigger
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     *
     */
    Op.prototype.inFunction = Op.prototype.inTrigger = function (name, v) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)
      );
      if (v !== undefined) p.set(v);
      return p;
    };

    /**
     * create multiple UI trigger buttons
     * @function inTriggerButton
     * @memberof Op
     * @instance
     * @param {String} name
     * @param {Array} names
     * @return {Port} created port
     */
    Op.prototype.inFunctionButton = Op.prototype.inTriggerButton = function (
      name,
      v
    ) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_FUNCTION, {
          display: "button",
        })
      );
      if (v !== undefined) p.set(v);
      return p;
    };

    Op.prototype.inFunctionButton = Op.prototype.inUiTriggerButtons = function (
      name,
      v
    ) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_FUNCTION, {
          display: "buttons",
        })
      );
      if (v !== undefined) p.set(v);
      return p;
    };

    /**
     * create a number value input port
     * @function inFloat
     * @memberof Op
     * @instance
     * @param {String} name
     * @param {Number} value
     * @return {Port} created port
     */
    Op.prototype.inValueFloat =
      Op.prototype.inValue =
      Op.prototype.inFloat =
        function (name, v) {
          const p = this.addInPort(
            new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE)
          );

          p.setInitialValue(v);

          return p;
        };

    /**
     * create a boolean input port, displayed as a checkbox
     * @function inBool
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {Boolean} value
     * @return {Port} created port
     */
    Op.prototype.inValueBool = Op.prototype.inBool = function (name, v) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_NUMBER, {
          display: "bool",
        })
      );

      if (v === true) v = 1;
      if (v === false) v = 0;
      p.setInitialValue(v);

      return p;
    };

    Op.prototype.inMultiPort = function (name, type) {
      const p = new MultiPort(this, name, type, CONSTANTS.PORT.PORT_DIR_IN, {
        addPort: true,
        hidePort: true,
      });
      p.ignoreValueSerialize = true;

      this.addInPort(p);
      p.initPorts();

      return p;
    };

    Op.prototype.outMultiPort = function (name, type, uiAttribsPort = {}) {
      const p = new MultiPort(
        this,
        name,
        type,
        CONSTANTS.PORT.PORT_DIR_OUT,
        {
          display: "multiport",
          hidePort: true,
        },
        uiAttribsPort
      );
      p.ignoreValueSerialize = true;

      this.addOutPort(p);
      p.initPorts();

      return p;
    };

    Op.prototype.inValueString = function (name, v) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
          type: "string",
        })
      );
      p.value = "";

      p.setInitialValue(v);
      return p;
    };

    /**
     * create a String value input port
     * @function inString
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {String} value default value
     * @return {Port} created port
     */
    Op.prototype.inString = function (name, v) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_STRING, {
          type: "string",
        })
      );
      v = v || "";
      // p.value = v;

      p.setInitialValue(v);
      return p;
    };

    /**
     * create a String value input port displayed as TextArea
     * @function inValueText
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {String} value default value
     * @return {Port} created port
     */
    Op.prototype.inValueText = function (name, v) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
          type: "string",
          display: "text",
        })
      );
      p.value = "";

      p.setInitialValue(v);
      // if (v !== undefined)
      // {
      //     p.set(v);
      //     p.defaultValue = v;
      // }
      return p;
    };

    Op.prototype.inTextarea = function (name, v) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_STRING, {
          type: "string",
          display: "text",
        })
      );
      p.value = "";
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };

    /**
     * create a String value input port displayed as editor
     * @function inStringEditor
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {String} value default value
     * @return {Port} created port
     */
    // new string
    Op.prototype.inStringEditor = function (
      name,
      v,
      syntax,
      hideFormatButton = true
    ) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_STRING, {
          type: "string",
          display: "editor",
          editShortcut: true,
          editorSyntax: syntax,
          hideFormatButton: hideFormatButton,
        })
      );

      p.value = "";
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };

    // old
    Op.prototype.inValueEditor = function (
      name,
      v,
      syntax,
      hideFormatButton = true
    ) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_NUMBER, {
          type: "string",
          display: "editor",
          editorSyntax: syntax,
          hideFormatButton: hideFormatButton,
        })
      );
      p.value = "";
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };

    /**
     * create a string select box
     * @function inDropDown
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {Array} values
     * @param {String} value default value
     * @return {Port} created port
     */
    Op.prototype.inValueSelect = Op.prototype.inDropDown = function (
      name,
      values,
      v,
      noindex
    ) {
      let p = null;
      if (!noindex) {
        const indexPort = new Port(
          this,
          name + " index",
          CONSTANTS.OP.OP_PORT_TYPE_NUMBER,
          {
            increment: "integer",
            hideParam: true,
          }
        );
        const n = this.addInPort(indexPort);

        if (values)
          for (let i = 0; i < values.length; i++) values[i] = String(values[i]);

        const valuePort = new ValueSelectPort(
          this,
          name,
          CONSTANTS.OP.OP_PORT_TYPE_NUMBER,
          {
            display: "dropdown",
            hidePort: true,
            type: "string",
            values: values,
          },
          n
        );

        valuePort.indexPort = indexPort;

        valuePort.on("change", (val, thePort) => {
          if (!thePort.indexPort.isLinked() && thePort.uiAttribs.values) {
            const idx = thePort.uiAttribs.values.indexOf(val);
            if (idx > -1) thePort.indexPort.set(idx);
          }
        });

        indexPort.onLinkChanged = function () {
          valuePort.setUiAttribs({ greyout: indexPort.isLinked() });
        };

        p = this.addInPort(valuePort);

        if (v !== undefined) {
          p.set(v);
          const index = values.findIndex((item) => {
            return item == v;
          });
          n.setValue(index);
          p.defaultValue = v;
          n.defaultValue = index;
        }
      } else {
        const valuePort = new Port(
          this,
          name,
          CONSTANTS.OP.OP_PORT_TYPE_VALUE,
          {
            display: "dropdown",
            hidePort: true,
            type: "string",
            values,
          }
        );

        p = this.addInPort(valuePort);
      }

      return p;
    };

    /**
     * create a string switch box
     * @function inSwitch
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {Array} values
     * @param {String} value default value
     * @return {Port} created port
     */
    Op.prototype.inSwitch = function (name, values, v, noindex) {
      let p = null;
      if (!noindex) {
        if (!v) v = values[0];
        const indexPort = new Port(
          this,
          name + " index",
          CONSTANTS.OP.OP_PORT_TYPE_VALUE,
          {
            increment: "integer",
            values: values,
            hideParam: true,
          }
        );
        const n = this.addInPort(indexPort);

        if (values)
          for (let i = 0; i < values.length; i++) values[i] = String(values[i]);

        const switchPort = new SwitchPort(
          this,
          name,
          CONSTANTS.OP.OP_PORT_TYPE_STRING,
          {
            display: "switch",
            hidePort: true,
            type: "string",
            values: values,
          },
          n
        );

        switchPort.indexPort = indexPort;

        switchPort.on("change", (val, thePort) => {
          if (!thePort.indexPort.isLinked() && thePort.uiAttribs.values) {
            const idx = thePort.uiAttribs.values.indexOf(val);
            if (idx > -1) thePort.indexPort.set(idx);
          }
        });

        indexPort.onLinkChanged = function () {
          switchPort.setUiAttribs({ greyout: indexPort.isLinked() });
        };
        p = this.addInPort(switchPort);

        if (v !== undefined) {
          p.set(v);
          const index = values.findIndex((item) => {
            return item == v;
          });
          n.setValue(index);
          p.defaultValue = v;
          n.defaultValue = index;
        }
      } else {
        const switchPort = new Port(
          this,
          name,
          CONSTANTS.OP.OP_PORT_TYPE_STRING,
          {
            display: "switch",
            hidePort: true,
            type: "string",
            values: values,
          }
        );
        p = this.addInPort(switchPort);
      }

      return p;
    };

    /**
     * create a integer input port
     * @function inInt
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {number} value default value
     * @return {Port} created port
     */
    Op.prototype.inValueInt = Op.prototype.inInt = function (name, v) {
      // old
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
          increment: "integer",
        })
      );
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };

    /**
     * create a file/URL input port
     * @function inURL
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.inFile = function (name, filter, v) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
          display: "file",
          type: "string",
          filter: filter,
        })
      );
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };

    Op.prototype.inUrl = function (name, filter, v) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_STRING, {
          display: "file",
          type: "string",
          filter: filter,
        })
      );
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };

    /**
     * create a texture input port
     * @function inTexture
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.inTexture = function (name, v) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_OBJECT, {
          display: "texture",
          objType: "texture",
          preview: true,
        })
      );
      p.ignoreValueSerialize = true;
      if (v !== undefined) p.set(v);
      return p;
    };

    /**
     * create a object input port
     * @function inObject
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.inObject = function (name, v, objType) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_OBJECT, {
          objType: objType,
        })
      );
      p.ignoreValueSerialize = true;

      if (v !== undefined) p.set(v);
      return p;
    };

    Op.prototype.inGradient = function (name, v) {
      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
          display: "gradient",
          // "hidePort": true
        })
      );
      if (v !== undefined) p.set(v);
      return p;
    };

    Op.prototype.getPortVisibleIndex = function (p) {
      let ports = this.portsIn;
      if (p.direction == CONSTANTS.PORT_DIR_OUT) ports = this.portsOut;

      let index = 0;
      for (let i = 0; i < ports.length; i++) {
        if (ports[i].uiAttribs.hidePort) continue;
        index++;
        if (ports[i] == p) return index;
      }
    };

    /**
     * create a array input port
     * @function inArray
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.inArray = function (name, v, stride) {
      if (!stride && CABLES.UTILS.isNumeric(v)) stride = v;

      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_ARRAY, {
          stride: stride,
        })
      );

      if (v !== undefined && (Array.isArray(v) || v == null)) p.set(v);

      // if (v !== undefined) p.set(v);
      return p;
    };

    /**
     * create a value slider input port
     * @function inFloatSlider
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {number} defaultvalue
     * @param {number} min
     * @param {number} max
     * @return {Port} created port
     */
    Op.prototype.inValueSlider = Op.prototype.inFloatSlider = function (
      name,
      v,
      min,
      max
    ) {
      const uiattribs = { display: "range" };

      if (min != undefined && max != undefined) {
        uiattribs.min = min;
        uiattribs.max = max;
      }

      const p = this.addInPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, uiattribs)
      );
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };

    /**
     * create output trigger port
     * @function outTrigger
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outFunction = Op.prototype.outTrigger = function (name, v) {
      // old
      const p = this.addOutPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)
      );
      if (v !== undefined) p.set(v);
      return p;
    };

    /**
     * create output value port
     * @function outNumber
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {number} default value
     * @return {Port} created port
     */
    Op.prototype.outValue = Op.prototype.outNumber = function (name, v) {
      // old
      const p = this.addOutPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE)
      );
      if (v !== undefined) p.set(v);
      return p;
    };

    /**
     * deprecated create output boolean port
     * @deprecated
     * @function outBool
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outValueBool = Op.prototype.outBool = function (name, v) {
      // old: use outBoolNum
      const p = this.addOutPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
          display: "bool",
        })
      );
      if (v !== undefined) p.set(v);
      else p.set(0);
      return p;
    };

    /**
     * create output boolean port,value will be converted to 0 or 1
     * @function outBoolNum
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outBoolNum = function (name, v) {
      const p = this.addOutPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
          display: "boolnum",
        })
      );

      p.set = function (b) {
        this.setValue(b ? 1 : 0);
        // this._log.log("bool set", b, this.get());
      }.bind(p);

      if (v !== undefined) p.set(v);
      else p.set(0);
      return p;
    };

    /**
     * create output string port
     * @function outString
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outValueString = function (name, v) {
      const p = this.addOutPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {
          type: "string",
        })
      );
      if (v !== undefined) p.set(v);
      return p;
    };
    Op.prototype.outString = function (name, v) {
      const p = this.addOutPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_STRING, {
          type: "string",
        })
      );
      if (v !== undefined) p.set(v);
      else p.set("");
      return p;
    };

    /**
     * create output object port
     * @function outObject
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outObject = function (name, v, objType) {
      const p = this.addOutPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_OBJECT, {
          objType: objType || null,
        })
      );
      p.set(v || null);
      p.ignoreValueSerialize = true;
      return p;
    };

    /**
     * create output array port
     * @function outArray
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outArray = function (name, v, stride) {
      if (!stride && CABLES.UTILS.isNumeric(v)) stride = v;
      const p = this.addOutPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_ARRAY, {
          stride: stride,
        })
      );
      if (v !== undefined && (Array.isArray(v) || v == null)) p.set(v);

      p.ignoreValueSerialize = true;
      return p;
    };

    /**
     * create output texture port
     * @function outTexture
     * @instance
     * @memberof Op
     * @param {String} name
     * @return {Port} created port
     */
    Op.prototype.outTexture = function (name, v) {
      const p = this.addOutPort(
        new Port(this, name, CONSTANTS.OP.OP_PORT_TYPE_OBJECT, {
          preview: true,
          objType: "texture",
          display: "texture",
        })
      );
      if (v !== undefined)
        p.setRef(v || CGL.Texture.getEmptyTexture(this.patch.cgl));

      p.ignoreValueSerialize = true;
      return p;
    };

    Op.prototype.inDynamic = function (name, filter, options, v) {
      const p = new Port(
        this,
        name,
        CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC,
        options
      );

      p.shouldLink = function (p1, p2) {
        if (filter && UTILS.isArray(filter)) {
          for (let i = 0; i < filter.length; i++) {
            if (p1 == this && p2.type === filter[i]) return true;
            if (p2 == this && p1.type === filter[i]) return true;
          }
          return false; // types do not match
        }
        return true; // no filter set
      };

      this.addInPort(p);
      if (v !== undefined) {
        p.set(v);
        p.defaultValue = v;
      }
      return p;
    };

    Op.prototype.removeLinks = function () {
      for (let i = 0; i < this.portsIn.length; i++)
        this.portsIn[i].removeLinks();
      for (let i = 0; i < this.portsOut.length; i++)
        this.portsOut[i].removeLinks();
    };

    Op.prototype.getSerialized = function () {
      const opObj = {};

      if (this.opId) opObj.opId = this.opId;
      if (this.patch.storeObjNames) opObj.objName = this.objName;

      opObj.id = this.id;
      opObj.uiAttribs = JSON.parse(JSON.stringify(this.uiAttribs)) || {};

      if (this.storage && Object.keys(this.storage).length > 0)
        opObj.storage = JSON.parse(JSON.stringify(this.storage));
      if (
        this.uiAttribs.hasOwnProperty("working") &&
        this.uiAttribs.working == true
      )
        delete this.uiAttribs.working;
      if (opObj.uiAttribs.hasOwnProperty("uierrors"))
        delete opObj.uiAttribs.uierrors;

      if (opObj.uiAttribs.title === "") delete opObj.uiAttribs.title;
      if (opObj.uiAttribs.color === null) delete opObj.uiAttribs.color;
      if (opObj.uiAttribs.comment === null) delete opObj.uiAttribs.comment;

      if (
        opObj.uiAttribs.title == this._shortOpName ||
        (this.uiAttribs.title || "").toLowerCase() ==
          this._shortOpName.toLowerCase()
      )
        delete opObj.uiAttribs.title;

      opObj.portsIn = [];
      opObj.portsOut = [];

      for (let i = 0; i < this.portsIn.length; i++) {
        const s = this.portsIn[i].getSerialized();
        if (s) opObj.portsIn.push(s);
      }

      for (let i = 0; i < this.portsOut.length; i++) {
        const s = this.portsOut[i].getSerialized();
        if (s) opObj.portsOut.push(s);
      }

      if (opObj.portsIn.length == 0) delete opObj.portsIn;
      if (opObj.portsOut.length == 0) delete opObj.portsOut;
      cleanJson(opObj);

      return opObj;
    };

    Op.prototype.getFirstOutPortByType = function (type) {
      for (const ipo in this.portsOut)
        if (this.portsOut[ipo].type == type) return this.portsOut[ipo];
    };

    Op.prototype.getFirstInPortByType = function (type) {
      for (const ipo in this.portsIn)
        if (this.portsIn[ipo].type == type) return this.portsIn[ipo];
    };

    /**
     * return port by the name portName
     * @function getPort
     * @instance
     * @memberof Op
     * @param {String} portName
     * @return {Port}
     */
    Op.prototype.getPort = Op.prototype.getPortByName = function (
      name,
      lowerCase
    ) {
      if (lowerCase) {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++)
          if (
            this.portsIn[ipi].getName().toLowerCase() == name ||
            this.portsIn[ipi].id.toLowerCase() == name
          )
            return this.portsIn[ipi];

        for (let ipo = 0; ipo < this.portsOut.length; ipo++)
          if (
            this.portsOut[ipo].getName().toLowerCase() == name ||
            this.portsOut[ipo].id.toLowerCase() == name
          )
            return this.portsOut[ipo];
      } else {
        for (let ipi = 0; ipi < this.portsIn.length; ipi++)
          if (
            this.portsIn[ipi].getName() == name ||
            this.portsIn[ipi].id == name
          )
            return this.portsIn[ipi];

        for (let ipo = 0; ipo < this.portsOut.length; ipo++)
          if (
            this.portsOut[ipo].getName() == name ||
            this.portsOut[ipo].id == name
          )
            return this.portsOut[ipo];
      }
    };

    /**
     * return port by the name id
     * @function getPortById
     * @instance
     * @memberof Op
     * @param {String} id
     * @return {Port}
     */
    Op.prototype.getPortById = function (id) {
      for (let ipi = 0; ipi < this.portsIn.length; ipi++)
        if (this.portsIn[ipi].id == id) return this.portsIn[ipi];
      for (let ipo = 0; ipo < this.portsOut.length; ipo++)
        if (this.portsOut[ipo].id == id) return this.portsOut[ipo];
    };

    Op.prototype.updateAnims = function () {
      if (this._hasAnimPort)
        for (let i = 0; i < this.portsIn.length; i++)
          this.portsIn[i].updateAnim();
    };

    Op.prototype.log = function () {
      this._log.log(...arguments);
    };

    Op.prototype.error = Op.prototype.logError = function () {
      // if (!this)
      // {
      //     this._log.error("no this...!!!");
      //     debugger;
      //     return;
      // }
      // const initiator = "op " + this.objName;
      // if (CABLES.UI && !CABLES.UI.logFilter.filterLog({ "initiator": initiator, "opInstId": this.id, "level": 2 }, ...arguments)) return;

      // // if (this.patch.silent) return;
      // const args = ["[op " + CABLES.getShortOpName(this.objName) + "]"];
      // args.push.apply(args, arguments);
      // Function.prototype.apply.apply(this._log.error, [console, args]);// eslint-disable-line
      // if (window.gui) window.gui.emitEvent("opLogEvent", this.objName, "error", arguments);
      this._log.error(...arguments);
    };

    Op.prototype.warn = Op.prototype.logWarn = function () {
      this._log.warn(...arguments);

      // const initiator = "op " + this.objName;
      // if (CABLES.UI && !CABLES.UI.logFilter.filterLog({ "initiator": initiator, "opInstId": this.id, "level": 1 }, ...arguments)) return;

      // // if (this.patch.silent) return;
      // const args = ["[op " + CABLES.getShortOpName(this.objName) + "]"];
      // args.push.apply(args, arguments);
      // Function.prototype.apply.apply(this._log.warn, [console, args]);// eslint-disable-line
    };

    Op.prototype.verbose = Op.prototype.logVerbose = function () {
      // const initiator = "op " + CABLES.getShortOpName(this.objName);
      // if (CABLES.UI && !CABLES.UI.logFilter.filterLog({ "initiator": initiator, "opInstId": this.id, "level": 0 }, ...arguments)) return;

      // if (!CABLES.UI && this.patch.silent) return;

      // const args = ["[" + initiator + "]"];
      // args.push.apply(args, arguments);
      // Function.prototype.apply.apply(this._log.info, [console, args]);// eslint-disable-line
      this._log.verbose(...arguments);
    };

    Op.prototype.profile = function (enable) {
      for (let ipi = 0; ipi < this.portsIn.length; ipi++) {
        this.portsIn[ipi]._onTriggered =
          this.portsIn[ipi]._onTriggeredProfiling;
        this.portsIn[ipi].set = this.portsIn[ipi]._onSetProfiling;
      }
    };

    Op.prototype.findParent = function (objName) {
      for (let ipi = 0; ipi < this.portsIn.length; ipi++) {
        if (this.portsIn[ipi].isLinked()) {
          if (this.portsIn[ipi].links[0].portOut.parent.objName == objName)
            return this.portsIn[ipi].links[0].portOut.parent;

          let found = null;
          found = this.portsIn[ipi].links[0].portOut.parent.findParent(objName);
          if (found) return found;
        }
      }
      return null;
    };

    // todo: check instancing stuff?
    Op.prototype.cleanUp = function () {
      if (this._instances) {
        for (let i = 0; i < this._instances.length; i++) {
          if (this._instances[i].onDelete) this._instances[i].onDelete();
        }

        this._instances.length = 0;
      }
      for (let i = 0; i < this.portsIn.length; i++) {
        this.portsIn[i].setAnimated(false);
      }

      if (this.onAnimFrame) this.patch.removeOnAnimFrame(this);
    };

    // todo: check instancing stuff?
    Op.prototype.instanced = function (triggerPort) {
      return false;
      // this._log.log("instanced", this.patch.instancing.numCycles());
      // if (this.patch.instancing.numCycles() === 0) return false;

      // let i = 0;
      // let ipi = 0;
      // if (!this._instances || this._instances.length != this.patch.instancing.numCycles())
      // {
      //     if (!this._instances) this._instances = [];
      //     this._.log("creating instances of ", this.objName, this.patch.instancing.numCycles(), this._instances.length);
      //     this._instances.length = this.patch.instancing.numCycles();

      //     for (i = 0; i < this._instances.length; i++)
      //     {
      //         this._instances[i] = this.patch.createOp(this.objName, true);
      //         this._instances[i].instanced = function ()
      //         {
      //             return false;
      //         };
      //         this._instances[i].uiAttr(this.uiAttribs);

      //         for (let ipo = 0; ipo < this.portsOut.length; ipo++)
      //         {
      //             if (this.portsOut[ipo].type == CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)
      //             {
      //                 this._instances[i].getPortByName(this.portsOut[ipo].name).trigger = this.portsOut[ipo].trigger.bind(this.portsOut[ipo]);
      //             }
      //         }
      //     }

      //     for (ipi = 0; ipi < this.portsIn.length; ipi++)
      //     {
      //         this.portsIn[ipi].onChange = null;
      //         this.portsIn[ipi].onValueChanged = null;
      //     }
      // }

      // const theTriggerPort = null;
      // for (ipi = 0; ipi < this.portsIn.length; ipi++)
      // {
      //     if (
      //         this.portsIn[ipi].type == CONSTANTS.OP.OP_PORT_TYPE_VALUE ||
      //         this.portsIn[ipi].type == CONSTANTS.OP.OP_PORT_TYPE_ARRAY
      //     )
      //     {
      //         this._instances[this.patch.instancing.index()].portsIn[ipi].set(this.portsIn[ipi].get());
      //     }
      //     if (this.portsIn[ipi].type == CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)
      //     {
      //         // if(this._instances[ this.patch.instancing.index() ].portsIn[ipi].name==triggerPort.name)
      //         // theTriggerPort=this._instances[ this.patch.instancing.index() ].portsIn[ipi];
      //     }
      // }

      // if (theTriggerPort) theTriggerPort.onTriggered();

      // for (ipi = 0; ipi < this.portsOut.length; ipi++)
      // {
      //     if (this.portsOut[ipi].type == CONSTANTS.OP.OP_PORT_TYPE_VALUE)
      //     {
      //         this.portsOut[ipi].set(this._instances[this.patch.instancing.index()].portsOut[ipi].get());
      //     }
      // }

      // return true;
    };

    // todo: check instancing stuff?
    Op.prototype.initInstancable = function () {
      //         if(this.isInstanced)
      //         {
      //             this._log.log('cancel instancing');
      //             return;
      //         }
      //         this._instances=[];
      //         for(var ipi=0;ipi<this.portsIn.length;ipi++)
      //         {
      //             if(this.portsIn[ipi].type==CONSTANTS.OP.OP_PORT_TYPE_VALUE)
      //             {
      //
      //             }
      //             if(this.portsIn[ipi].type==CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)
      //             {
      //                 // var piIndex=ipi;
      //                 this.portsIn[ipi].onTriggered=function(piIndex)
      //                 {
      //
      //                     var i=0;
      // // this._log.log('trigger',this._instances.length);
      //
      //                 }.bind(this,ipi );
      //
      //             }
      // };
      // this._instances=null;
    };

    Op.prototype.setValues = function (obj) {
      for (const i in obj) {
        const port = this.getPortByName(i);
        if (port) port.set(obj[i]);
        else this._log.warn("op.setValues: port not found:", i);
      }
    };

    /**
     * return true if op has this error message id
     * @function hasUiError
     * @instance
     * @memberof Op
     * @param {id} error id
     * @returns {Boolean} - has id
     */
    Op.prototype.hasUiError = function (id) {
      return this._uiErrors.hasOwnProperty(id) && this._uiErrors[id];
    };

    /**
     * show op error message - set message to null to remove error message
     * @function setUiError
     * @instance
     * @memberof Op
     * @param {id} error id
     * @param {txt} text message
     * @param {level} level
     */
    Op.prototype.setUiError = function (id, txt, level) {
      // overwritten in ui: core_extend_op
    };

    // todo: remove
    Op.prototype.setError = function (id, txt) {
      this._log.warn("old error message op.error() - use op.setUiError()");
    };

    /**
     * enable/disable op
     * @function
     * @instance
     * @memberof Op
     * @param {boolean}
     */
    Op.prototype.setEnabled = function (b) {
      this.enabled = b;
      this.emitEvent("onEnabledChange", b);
    };

    /**
     * organize ports into a group
     * @function
     * @instance
     * @memberof Op
     * @param {String} name
     * @param {Array} ports
     */
    Op.prototype.setPortGroup = function (name, ports) {
      for (let i = 0; i < ports.length; i++) {
        if (ports[i])
          if (ports[i].setUiAttribs) ports[i].setUiAttribs({ group: name });
          else {
            this._log.error("setPortGroup: invalid port!");
          }
      }
    };

    /**
     * visually indicate ports that they are coordinate inputs
     * @function
     * @instance
     * @memberof Op
     * @param {Port} portX
     * @param {Port} portY
     * @param {Port} portZ
     */
    Op.prototype.setUiAxisPorts = function (px, py, pz) {
      if (px) px.setUiAttribs({ axis: "X" });
      if (py) py.setUiAttribs({ axis: "Y" });
      if (pz) pz.setUiAttribs({ axis: "Z" });
    };

    /**
     * remove port from op
     * @function removePort
     * @instance
     * @memberof Op
     * @param {Port} port to remove
     */
    Op.prototype.removePort = function (port) {
      for (let ipi = 0; ipi < this.portsIn.length; ipi++) {
        if (this.portsIn[ipi] == port) {
          this.portsIn.splice(ipi, 1);
          this.emitEvent("onUiAttribsChange", {});
          this.emitEvent("onPortRemoved", {});
          return;
        }
      }
      for (let ipi = 0; ipi < this.portsOut.length; ipi++) {
        if (this.portsOut[ipi] == port) {
          this.portsOut.splice(ipi, 1);
          this.emitEvent("onUiAttribsChange", {});
          this.emitEvent("onPortRemoved", {});
          return;
        }
      }
    };

    Op.prototype._checkLinksNeededToWork = function () {};

    /**
     * show a warning of this op is not a child of parentOpName
     * @function
     * @instance
     * @memberof Op
     * @param {String} parentOpName
     */
    Op.prototype.toWorkNeedsParent = function (parentOpName) {
      this._linkTimeRules.needsParentOp = parentOpName;
    };

    // /**
    //  * show a warning of this op is a child of parentOpName
    //  * @function
    //  * @instance
    //  * @memberof Op
    //  * @param {String} parentOpName
    //  */
    Op.prototype.toWorkShouldNotBeChild = function (parentOpName, type) {
      if (!this.patch.isEditorMode()) return;
      this._linkTimeRules.forbiddenParent = parentOpName;
      if (type != undefined) this._linkTimeRules.forbiddenParentType = type;
    };

    /**
     * show a small X to indicate op is not working when given ports are not linked
     * @function
     * @instance
     * @memberof Op
     * @param {Port} port1
     * @param {Port} port2
     * @param {Port} port3
     */
    Op.prototype.toWorkPortsNeedToBeLinked = function () {
      if (!this.patch.isEditorMode()) return;
      for (let i = 0; i < arguments.length; i++)
        if (this._linkTimeRules.needsLinkedToWork.indexOf(arguments[i]) == -1)
          this._linkTimeRules.needsLinkedToWork.push(arguments[i]);
    };
    Op.prototype.toWorkPortsNeedToBeLinkedReset = function () {
      if (!this.patch.isEditorMode()) return;
      this._linkTimeRules.needsLinkedToWork.length = 0;
      if (this.checkLinkTimeWarnings) this.checkLinkTimeWarnings();
    };

    Op.prototype.initVarPorts = function () {
      for (let i = 0; i < this.portsIn.length; i++) {
        if (this.portsIn[i].getVariableName())
          this.portsIn[i].setVariable(this.portsIn[i].getVariableName());
      }
    };

    /**
     * refresh op parameters, if current op is selected
     * @function
     * @instance
     * @memberof Op
     */
    Op.prototype.refreshParams = function () {
      if (this.patch && this.patch.isEditorMode() && this.isCurrentUiOp()) {
        gui.opParams.show(this);
      }
    };

    /**
     * Returns true if op is selected and parameter are shown in the editor, can only return true if in editor/ui
     * @function isCurrentUiOp
     * @instance
     * @memberof Op
     * @returns {Boolean} - is current ui op
     */
    Op.prototype.isCurrentUiOp = function () {
      if (this.patch.isEditorMode()) return gui.patchView.isCurrentOp(this);
    };

    /**
     * Implement to render 2d canvas based graphics from in an op
     * @function renderVizLayer
     * @instance
     * @memberof Op
     * @param {ctx} context of canvas 2d
     * @param {Object} layer info
     * @param {number} layer.x x position on canvas
     * @param {number} layer.y y position on canvas
     * @param {number} layer.width width of canvas
     * @param {number} layer.height height of canvas
     * @param {number} layer.scale current scaling of patchfield view
     */
    Op.prototype.renderVizLayer = null; // optionaly defined in op instance
  } // CONCATENATED MODULE: ./src/core/loadingstatus.js

  /**
   * LoadingStatus class, manages asynchronous loading jobs
   *
   * @namespace external:CABLES#LoadingStatus
   * @hideconstructor
   * @class
   * @param patch
   */
  const LoadingStatus = function (patch) {
    EventTarget.apply(this);

    this._log = new Logger("LoadingStatus");
    this._loadingAssets = {};
    this._cbFinished = [];
    this._assetTasks = [];
    this._percent = 0;
    this._count = 0;
    this._countFinished = 0;
    this._order = 0;
    this._startTime = 0;
    this._patch = patch;
    this._wasFinishedPrinted = false;
    this._loadingAssetTaskCb = false;
  };

  LoadingStatus.prototype.setOnFinishedLoading = function (cb) {
    this._cbFinished.push(cb);
  };

  LoadingStatus.prototype.getNumAssets = function () {
    return this._countFinished;
  };

  LoadingStatus.prototype.getProgress = function () {
    return this._percent;
  };

  LoadingStatus.prototype.checkStatus = function () {
    this._countFinished = 0;
    this._count = 0;

    for (const i in this._loadingAssets) {
      this._count++;
      if (!this._loadingAssets[i].finished) {
        this._countFinished++;
      }
    }

    this._percent = (this._count - this._countFinished) / this._count;

    if (this._countFinished === 0) {
      for (let j = 0; j < this._cbFinished.length; j++) {
        if (this._cbFinished[j]) {
          const cb = this._cbFinished[j];
          setTimeout(() => {
            cb(this._patch);
            this.emitEvent("finishedAll");
          }, 100);
        }
      }

      if (!this._wasFinishedPrinted) {
        this._wasFinishedPrinted = true;
        this.print();
      }
      this.emitEvent("finishedAll");
    }
  };

  LoadingStatus.prototype.getList = function () {
    let arr = [];
    for (const i in this._loadingAssets) {
      arr.push(this._loadingAssets[i]);
    }

    return arr;
  };

  LoadingStatus.prototype.getListJobs = function () {
    let arr = [];
    for (const i in this._loadingAssets) {
      if (!this._loadingAssets[i].finished)
        arr.push(this._loadingAssets[i].name);
    }

    return arr;
  };

  LoadingStatus.prototype.print = function () {
    if (this._patch.config.silent) return;

    const rows = [];

    for (const i in this._loadingAssets) {
      rows.push([
        this._loadingAssets[i].order,
        this._loadingAssets[i].type,
        this._loadingAssets[i].name,
        (this._loadingAssets[i].timeEnd - this._loadingAssets[i].timeStart) /
          1000 +
          "s",
      ]);
    }

    this._log.groupCollapsed(
      "finished loading " +
        this._order +
        " assets in " +
        (Date.now() - this._startTime) / 1000 +
        "s"
    );
    this._log.table(rows);
    this._log.groupEnd();
  };

  LoadingStatus.prototype.finished = function (id) {
    const l = this._loadingAssets[id];
    if (l) {
      if (l.finished) this._log.warn("loading job was already finished", l);

      if (l.op) l.op.setUiAttribs({ loading: false });
      l.finished = true;
      l.timeEnd = Date.now();
    }

    this.checkStatus();
    this.emitEvent("finishedTask");
    return null;
  };

  LoadingStatus.prototype._startAssetTasks = function () {
    for (let i = 0; i < this._assetTasks.length; i++) this._assetTasks[i]();
    this._assetTasks.length = 0;
  };

  /**
   * delay an asset loading task, mainly to wait for ui to be finished loading and showing, and only then start loading assets
   * @function addAssetLoadingTask
   * @instance
   * @memberof LoadingStatus
   * @param {function} cb callback
   */
  LoadingStatus.prototype.addAssetLoadingTask = function (cb) {
    if (this._patch.isEditorMode() && !CABLES.UI.loaded) {
      this._assetTasks.push(cb);

      if (!this._loadingAssetTaskCb)
        window.gui.addEventListener(
          "uiloaded",
          this._startAssetTasks.bind(this)
        );
      this._loadingAssetTaskCb = true;
    } else {
      cb();
    }
    this.emitEvent("addAssetTask");
  };

  LoadingStatus.prototype.existByName = function (name) {
    for (let i in this._loadingAssets) {
      if (
        this._loadingAssets[i].name == name &&
        !this._loadingAssets[i].finished
      )
        return true;
    }
  };

  LoadingStatus.prototype.start = function (type, name, op) {
    if (this._startTime == 0) this._startTime = Date.now();
    const id = generateUUID();

    name = name || "unknown";
    if (name.length > 100) name = name.substring(0, 100);

    if (op) op.setUiAttribs({ loading: true });

    this._loadingAssets[id] = {
      id: id,
      op: op,
      type: type,
      name: name,
      finished: false,
      timeStart: Date.now(),
      order: this._order,
    };
    this._order++;

    this.emitEvent("startTask");

    return id;
  }; // CONCATENATED MODULE: ./src/core/timer.js

  /** @namespace CABLES */

  const internalNow = function () {
    return window.performance.now();
  };

  /**
   * current time in milliseconds
   * @memberof CABLES
   * @function now
   * @static
   */
  const now = function () {
    return internalNow();
  };

  // ----------------------------

  /**
   * Measuring time
   * @namespace external:CABLES#Timer
   * @hideconstructor
   * @class
   */
  const Timer = function () {
    EventTarget.apply(this);

    this._timeStart = internalNow();
    this._timeOffset = 0;

    this._currentTime = 0;
    this._lastTime = 0;
    this._paused = true;
    this._delay = 0;
    this.overwriteTime = -1;
  };

  Timer.prototype._internalNow = function () {
    if (this._ts) return this._ts;
    return internalNow();
  };

  Timer.prototype._getTime = function () {
    this._lastTime = (this._internalNow() - this._timeStart) / 1000;
    return this._lastTime + this._timeOffset;
  };

  Timer.prototype.setDelay = function (d) {
    this._delay = d;
    this.emitEvent("timeChange");
  };

  /**
   * @function
   * @memberof Timer
   * @instance
   * @description returns true if timer is playing
   * @return {Boolean} value
   */
  Timer.prototype.isPlaying = function () {
    return !this._paused;
  };

  /**
   * @function
   * @memberof Timer
   * @instance
   * @param ts
   * @description update timer
   * @return {Number} time
   */
  Timer.prototype.update = function (ts) {
    if (ts) this._ts = ts;
    if (this._paused) return;
    this._currentTime = this._getTime();

    return this._currentTime;
  };

  /**
   * @function
   * @memberof Timer
   * @instance
   * @return {Number} time in milliseconds
   */
  Timer.prototype.getMillis = function () {
    return this.get() * 1000;
  };

  /**
   * @function
   * @memberof Timer
   * @instance
   * @return {Number} value time in seconds
   */
  Timer.prototype.get = Timer.prototype.getTime = function () {
    if (this.overwriteTime >= 0) return this.overwriteTime - this._delay;
    return this._currentTime - this._delay;
  };

  /**
   * toggle between play/pause state
   * @function
   * @memberof Timer
   * @instance
   */
  Timer.prototype.togglePlay = function () {
    if (this._paused) this.play();
    else this.pause();
  };

  /**
   * set current time
   * @function
   * @memberof Timer
   * @instance
   * @param {Number} t
   */
  Timer.prototype.setTime = function (t) {
    if (isNaN(t) || t < 0) t = 0;
    this._timeStart = this._internalNow();
    this._timeOffset = t;
    this._currentTime = t;
    this.emitEvent("timeChange");
  };

  Timer.prototype.setOffset = function (val) {
    if (this._currentTime + val < 0) {
      this._timeStart = this._internalNow();
      this._timeOffset = 0;
      this._currentTime = 0;
    } else {
      this._timeOffset += val;
      this._currentTime = this._lastTime + this._timeOffset;
    }
    this.emitEvent("timeChange");
  };

  /**
   * (re)starts the timer
   * @function
   * @memberof Timer
   * @instance
   */
  Timer.prototype.play = function () {
    this._timeStart = this._internalNow();
    this._paused = false;
    this.emitEvent("playPause");
  };

  /**
   * pauses the timer
   * @function
   * @memberof Timer
   * @instance
   */
  Timer.prototype.pause = function () {
    this._timeOffset = this._currentTime;
    this._paused = true;
    this.emitEvent("playPause");
  }; // CONCATENATED MODULE: ./src/core/core_profiler.js

  class Profiler {
    constructor(patch) {
      this.startFrame = patch.getFrameNum();
      this.items = {};
      this.currentId = null;
      this.currentStart = 0;
      this._patch = patch;
    }

    getItems() {
      return this.items;
    }

    clear() {
      if (this.paused) return;
      this.items = {};
    }

    togglePause() {
      this.paused = !this.paused;
      if (!this.paused) {
        this.items = {};
        this.currentStart = performance.now();
      }
    }

    add(type, object) {
      if (this.paused) return;

      if (this.currentId !== null) {
        if (!object || object.id != this.currentId) {
          if (this.items[this.currentId]) {
            this.items[this.currentId].timeUsed +=
              performance.now() - this.currentStart;

            if (
              !this.items[this.currentId].peakTime ||
              now() - this.items[this.currentId].peakTime > 5000
            ) {
              this.items[this.currentId].peak = 0;
              this.items[this.currentId].peakTime = now();
            }
            this.items[this.currentId].peak = Math.max(
              this.items[this.currentId].peak,
              performance.now() - this.currentStart
            );
          }
        }
      }

      if (object !== null) {
        if (!this.items[object.id]) {
          this.items[object.id] = {
            numTriggers: 0,
            timeUsed: 0,
          };
        }

        if (this.items[object.id].lastFrame != this._patch.getFrameNum())
          this.items[object.id].numTriggers = 0;

        this.items[object.id].lastFrame = this._patch.getFrameNum();
        this.items[object.id].numTriggers++;
        this.items[object.id].opid = object.op.id;
        this.items[object.id].title = object.op.name + "." + object.name;
        this.items[object.id].subPatch = object.op.uiAttribs.subPatch;

        this.currentId = object.id;
        this.currentStart = performance.now();
      } else {
        this.currentId = null;
      }
    }

    print() {
      console.log("--------");
      for (const i in this.items) {
        console.log(
          this.items[i].title +
            ": " +
            this.items[i].numTriggers +
            " / " +
            this.items[i].timeUsed
        );
      }
    }
  } // CONCATENATED MODULE: ./src/core/cgl/constants.js

  const SHADER = {
    // default attributes
    SHADERVAR_VERTEX_POSITION: "vPosition",
    SHADERVAR_VERTEX_NUMBER: "attrVertIndex",
    SHADERVAR_VERTEX_NORMAL: "attrVertNormal",
    SHADERVAR_VERTEX_TEXCOORD: "attrTexCoord",
    SHADERVAR_INSTANCE_MMATRIX: "instMat",
    SHADERVAR_VERTEX_COLOR: "attrVertColor",

    SHADERVAR_INSTANCE_INDEX: "instanceIndex",

    // default uniforms
    SHADERVAR_UNI_PROJMAT: "projMatrix",
    SHADERVAR_UNI_VIEWMAT: "viewMatrix",
    SHADERVAR_UNI_MODELMAT: "modelMatrix",
    SHADERVAR_UNI_NORMALMAT: "normalMatrix",
    SHADERVAR_UNI_INVVIEWMAT: "inverseViewMatrix",
    SHADERVAR_UNI_INVPROJMAT: "invProjMatrix",
    SHADERVAR_UNI_MATERIALID: "materialId",
    SHADERVAR_UNI_OBJECTID: "objectId",

    SHADERVAR_UNI_VIEWPOS: "camPos",
  };

  const BLEND_MODES = {
    BLEND_NONE: 0,
    BLEND_NORMAL: 1,
    BLEND_ADD: 2,
    BLEND_SUB: 3,
    BLEND_MUL: 4,
  };

  const RAD2DEG = 180.0 / Math.PI;
  const DEG2RAD = Math.PI / 180.0;

  const constants_CONSTANTS = {
    MATH: {
      DEG2RAD: DEG2RAD,
      RAD2DEG: RAD2DEG,
    },
    SHADER: SHADER,
    BLEND_MODES: BLEND_MODES,
  }; // CONCATENATED MODULE: ./src/core/cg/cg_uniform.js

  class CgUniform {
    constructor(
      __shader,
      __type,
      __name,
      _value,
      _port2,
      _port3,
      _port4,
      _structUniformName,
      _structName,
      _propertyName
    ) {
      this._log = new Logger("cg_uniform");
      this._type = __type;
      this._name = __name;
      this._shader = __shader;
      this._value = 0.00001;
      this._oldValue = null;
      this._port = null;
      this._structName = _structName;
      this._structUniformName = _structUniformName;
      this._propertyName = _propertyName;

      this._shader._addUniform(this);
      this.needsUpdate = true;
      this.shaderType = null;
      this.comment = null;

      if (__type == "f") {
        this.set = this.setValue = this.setValueF.bind(this);
        this.updateValue = this.updateValueF.bind(this);
      } else if (__type == "f[]") {
        this.set = this.setValue = this.setValueArrayF.bind(this);
        this.updateValue = this.updateValueArrayF.bind(this);
      } else if (__type == "2f[]") {
        this.set = this.setValue = this.setValueArray2F.bind(this);
        this.updateValue = this.updateValueArray2F.bind(this);
      } else if (__type == "3f[]") {
        this.set = this.setValue = this.setValueArray3F.bind(this);
        this.updateValue = this.updateValueArray3F.bind(this);
      } else if (__type == "4f[]") {
        this.set = this.setValue = this.setValueArray4F.bind(this);
        this.updateValue = this.updateValueArray4F.bind(this);
      } else if (__type == "i") {
        this.set = this.setValue = this.setValueI.bind(this);
        this.updateValue = this.updateValueI.bind(this);
      } else if (__type == "2i") {
        this.set = this.setValue = this.setValue2I.bind(this);
        this.updateValue = this.updateValue2I.bind(this);
      } else if (__type == "3i") {
        this.set = this.setValue = this.setValue3I.bind(this);
        this.updateValue = this.updateValue3I.bind(this);
      } else if (__type == "4i") {
        this.set = this.setValue = this.setValue4I.bind(this);
        this.updateValue = this.updateValue4I.bind(this);
      } else if (__type == "b") {
        this.set = this.setValue = this.setValueBool.bind(this);
        this.updateValue = this.updateValueBool.bind(this);
      } else if (__type == "4f") {
        this.set = this.setValue = this.setValue4F.bind(this);
        this.updateValue = this.updateValue4F.bind(this);
      } else if (__type == "3f") {
        this.set = this.setValue = this.setValue3F.bind(this);
        this.updateValue = this.updateValue3F.bind(this);
      } else if (__type == "2f") {
        this.set = this.setValue = this.setValue2F.bind(this);
        this.updateValue = this.updateValue2F.bind(this);
      } else if (__type == "t") {
        this.set = this.setValue = this.setValueT.bind(this);
        this.updateValue = this.updateValueT.bind(this);
      } else if (__type == "sampler") {
        if (this.setValueAny) {
          this.set = this.setValue = this.setValueAny.bind(this);
          this.updateValue = this.updateValueAny.bind(this);
        }
      } else if (__type == "tc") {
        this.set = this.setValue = this.setValueT.bind(this);
        this.updateValue = this.updateValueT.bind(this);
      } else if (__type == "t[]") {
        this.set = this.setValue = this.setValueArrayT.bind(this);
        this.updateValue = this.updateValueArrayT.bind(this);
      } else if (__type == "m4" || __type == "m4[]") {
        this.set = this.setValue = this.setValueM4.bind(this);
        this.updateValue = this.updateValueM4.bind(this);
      } else {
        // console.error("unknown");
        this._log.error("Unknown uniform type " + __type);
      }

      if (typeof _value == "object" && _value instanceof Port) {
        this._port = _value;
        this._value = this._port.get();

        if (_port2 && _port3 && _port4) {
          if (
            !(_port2 instanceof Port) ||
            !(_port3 instanceof Port) ||
            !(_port4 instanceof Port)
          ) {
            this._log.error(
              "[cgl_uniform] mixed port/value parameter for vec4 ",
              this._name
            );
          }

          this._value = [0, 0, 0, 0];
          this._port2 = _port2;
          this._port3 = _port3;
          this._port4 = _port4;

          this._port.on("change", this.updateFromPort4f.bind(this));
          this._port2.on("change", this.updateFromPort4f.bind(this));
          this._port3.on("change", this.updateFromPort4f.bind(this));
          this._port4.on("change", this.updateFromPort4f.bind(this));

          // this._port.onChange = this._port2.onChange = this._port3.onChange = this._port4.onChange = this.updateFromPort4f.bind(this);
          this.updateFromPort4f();
        } else if (_port2 && _port3) {
          if (!(_port2 instanceof Port) || !(_port3 instanceof Port)) {
            this._log.error(
              "[cgl_uniform] mixed port/value parameter for vec4 ",
              this._name
            );
          }

          this._value = [0, 0, 0];
          this._port2 = _port2;
          this._port3 = _port3;
          // this._port.onChange = this._port2.onChange = this._port3.onChange = this.updateFromPort3f.bind(this);
          this._port.on("change", this.updateFromPort3f.bind(this));
          this._port2.on("change", this.updateFromPort3f.bind(this));
          this._port3.on("change", this.updateFromPort3f.bind(this));

          this.updateFromPort3f();
        } else if (_port2) {
          if (!(_port2 instanceof Port)) {
            this._log.error(
              "[cgl_uniform] mixed port/value parameter for vec4 ",
              this._name
            );
          }

          this._value = [0, 0];
          this._port2 = _port2;
          // this._port.onChange = this._port2.onChange = this.updateFromPort2f.bind(this);
          this._port.on("change", this.updateFromPort2f.bind(this));
          this._port2.on("change", this.updateFromPort2f.bind(this));

          this.updateFromPort2f();
        } else {
          // this._port.on = this.updateFromPort.bind(this);
          this._port.on("change", this.updateFromPort.bind(this));
        }
      } else this._value = _value;

      if (this._value == undefined) {
        console.log("value undefined", this);
        this._value = 0;
      }

      this.setValue(this._value);

      this.needsUpdate = true;
    }

    getType() {
      return this._type;
    }

    get type() {
      return this._type;
    }

    get name() {
      return this._name;
    }

    getName() {
      return this._name;
    }

    getValue() {
      return this._value;
    }

    getShaderType() {
      return this.shaderType;
    }

    isStructMember() {
      return !!this._structName;
    }

    updateFromPort4f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this._value[3] = this._port4.get();
      this.setValue(this._value);
    }

    updateFromPort3f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this.setValue(this._value);
    }

    updateFromPort2f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this.setValue(this._value);
    }

    updateFromPort() {
      this.setValue(this._port.get());
    }
  }

  /* harmony default export */ const cg_uniform = CgUniform; // CONCATENATED MODULE: ./src/core/cgl/cgl_shader_uniform.js

  /**
   * Shader uniforms
   *
   * types:
   * <pre>
   * f    - float
   * 2f   - vec2
   * 3f   - vec3
   * 4f   - vec4
   * i    - integer
   * t    - texture
   * m4   - mat4, 4x4 float matrix
   * f[]  - array of floats
   * 2f[] - array of float vec2
   * 3f[] - array of float vec3
   * 4f[] - array of float vec4
   * </pre>
   *
   * @namespace external:CGL
   * @class
   * @param {Shader} shader
   * @param {String} [type=f]
   * @param {String} name
   * @param {Number|Port} value  can be a Number,Matrix or Port
   * @example
   * // bind float uniform called myfloat and initialize with value 1.0
   * const unir=new CGL.Uniform(shader,'f','myfloat',1.0);
   * unir.setValue(1.0);
   *
   * // bind float uniform called myfloat and automatically set it to input port value
   * const myPort=op.inFloat("input");
   * const pv=new CGL.Uniform(shader,'f','myfloat',myPort);
   *
   */

  // export const Uniform(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)

  class Uniform extends cg_uniform {
    constructor(
      __shader,
      __type,
      __name,
      _value,
      _port2,
      _port3,
      _port4,
      _structUniformName,
      _structName,
      _propertyName
    ) {
      super(
        __shader,
        __type,
        __name,
        _value,
        _port2,
        _port3,
        _port4,
        _structUniformName,
        _structName,
        _propertyName
      );
      this._loc = -1;
      this._cgl = __shader._cgl;
    }

    get name() {
      return this._name;
    }

    copy(newShader) {
      const uni = new Uniform(
        newShader,
        this._type,
        this._name,
        this._value,
        this._port2,
        this._port3,
        this._port4,
        this._structUniformName,
        this._structName,
        this._propertyName
      );
      uni.shaderType = this.shaderType;
      return uni;
    }

    /**
     * returns type as glsl type string. e.g. 'f' returns 'float'
     * @function getGlslTypeString
     * @memberof Uniform
     * @instance
     * @return {string} type as string
     */
    getGlslTypeString() {
      return Uniform.glslTypeString(this._type);
    }

    _isValidLoc() {
      return this._loc != -1; // && this._loc != null;
    }

    resetLoc() {
      this._loc = -1;
      this.needsUpdate = true;
    }

    bindTextures() {}

    getLoc() {
      return this._loc;
    }

    updateFromPort4f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this._value[3] = this._port4.get();
      this.setValue(this._value);
    }

    updateFromPort3f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this._value[2] = this._port3.get();
      this.setValue(this._value);
    }

    updateFromPort2f() {
      this._value[0] = this._port.get();
      this._value[1] = this._port2.get();
      this.setValue(this._value);
    }

    updateFromPort() {
      this.setValue(this._port.get());
    }

    updateValueF() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      this._shader.getCgl().gl.uniform1f(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    setValueF(v) {
      if (v != this._value) {
        this.needsUpdate = true;
        this._value = v;
      }
    }

    updateValueI() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      this._shader.getCgl().gl.uniform1i(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    updateValue2I() {
      if (!this._value) return;

      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }

      this._shader
        .getCgl()
        .gl.uniform2i(this._loc, this._value[0], this._value[1]);

      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }

    updateValue3I() {
      if (!this._value) return;
      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }

      this._shader
        .getCgl()
        .gl.uniform3i(
          this._loc,
          this._value[0],
          this._value[1],
          this._value[2]
        );
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }

    updateValue4I() {
      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      this._shader
        .getCgl()
        .gl.uniform4i(
          this._loc,
          this._value[0],
          this._value[1],
          this._value[2],
          this._value[3]
        );
      this._cgl.profileData.profileUniformCount++;
    }

    setValueI(v) {
      if (v != this._value) {
        this.needsUpdate = true;
        this._value = v;
      }
    }

    setValue2I(v) {
      if (!v) return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1];
        this.needsUpdate = true;
      } else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1]) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this.needsUpdate = true;
      }

      this._value = v;
    }

    setValue3I(v) {
      if (!v) return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1, 2];
        this.needsUpdate = true;
      } else if (
        v[0] != this._oldValue[0] ||
        v[1] != this._oldValue[1] ||
        v[2] != this._oldValue[2]
      ) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this._oldValue[2] = v[2];
        this.needsUpdate = true;
      }

      this._value = v;
    }

    setValue4I(v) {
      this.needsUpdate = true;
      this._value = v || vec4.create();
    }

    updateValueBool() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;
      this._shader.getCgl().gl.uniform1i(this._loc, this._value ? 1 : 0);

      this._cgl.profileData.profileUniformCount++;
    }

    setValueBool(v) {
      if (v != this._value) {
        this.needsUpdate = true;
        this._value = v;
      }
    }

    setValueArray4F(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValueArray4F() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      if (!this._value) return;
      this._shader.getCgl().gl.uniform4fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    setValueArray3F(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValueArray3F() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      if (!this._value) return;
      this._shader.getCgl().gl.uniform3fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    setValueArray2F(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValueArray2F() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      if (!this._value) return;
      this._shader.getCgl().gl.uniform2fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    setValueArrayF(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValueArrayF() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      if (!this._value) return;
      this._shader.getCgl().gl.uniform1fv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    setValueArrayT(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValue3F() {
      if (!this._value) return;
      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }

      this._shader
        .getCgl()
        .gl.uniform3f(
          this._loc,
          this._value[0],
          this._value[1],
          this._value[2]
        );
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }

    setValue3F(v) {
      if (!v) return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1, 2];
        this.needsUpdate = true;
      } else if (
        v[0] != this._oldValue[0] ||
        v[1] != this._oldValue[1] ||
        v[2] != this._oldValue[2]
      ) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this._oldValue[2] = v[2];
        this.needsUpdate = true;
      }

      this._value = v;
    }

    updateValue2F() {
      if (!this._value) return;

      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }

      this._shader
        .getCgl()
        .gl.uniform2f(this._loc, this._value[0], this._value[1]);
      this.needsUpdate = false;
      this._cgl.profileData.profileUniformCount++;
    }

    setValue2F(v) {
      if (!v) return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1];
        this.needsUpdate = true;
      } else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1]) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this.needsUpdate = true;
      }
      this._value = v;
    }

    updateValue4F() {
      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }

      if (!this._value) {
        this._log.warn("no value for uniform", this._name, this);
        this._value = [0, 0, 0, 0];
      }

      this.needsUpdate = false;
      this._shader
        .getCgl()
        .gl.uniform4f(
          this._loc,
          this._value[0],
          this._value[1],
          this._value[2],
          this._value[3]
        );
      this._cgl.profileData.profileUniformCount++;
    }

    setValue4F(v) {
      if (typeof this.value == "number") this.value = vec4.create(); // this should not be needed, but somehow it crashes with some shadermods

      if (!v) return;
      if (!this._oldValue) {
        this._oldValue = [v[0] - 1, 1, 2, 3];
        this.needsUpdate = true;
      } else if (
        v[0] != this._oldValue[0] ||
        v[1] != this._oldValue[1] ||
        v[2] != this._oldValue[2] ||
        v[3] != this._oldValue[3]
      ) {
        this._oldValue[0] = v[0];
        this._oldValue[1] = v[1];
        this._oldValue[2] = v[2];
        this.needsUpdate = true;
      }

      this._value = v;
    }

    updateValueM4() {
      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }
      if (!this._value || this._value.length % 16 != 0)
        return console.log("this.name", this._name, this._value);

      this._shader.getCgl().gl.uniformMatrix4fv(this._loc, false, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    setValueM4(v) {
      this.needsUpdate = true;
      this._value = v || mat4.create();
    }

    updateValueArrayT() {
      if (!this._isValidLoc())
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
      else this.needsUpdate = false;

      if (!this._value) return;
      this._shader.getCgl().gl.uniform1iv(this._loc, this._value);
      this._cgl.profileData.profileUniformCount++;
    }

    updateValueT() {
      if (!this._isValidLoc()) {
        this._loc = this._shader
          .getCgl()
          .gl.getUniformLocation(this._shader.getProgram(), this._name);
        this._cgl.profileData.profileShaderGetUniform++;
        this._cgl.profileData.profileShaderGetUniformName = this._name;
      }

      this._cgl.profileData.profileUniformCount++;
      this._shader.getCgl().gl.uniform1i(this._loc, this._value);
      this.needsUpdate = false;
    }

    setValueT(v) {
      this.needsUpdate = true;
      this._value = v;
    }
  }

  Uniform.glslTypeString = (t) => {
    if (t == "f") return "float";
    if (t == "b") return "bool";
    if (t == "i") return "int";
    if (t == "2i") return "ivec2";
    if (t == "2f") return "vec2";
    if (t == "3f") return "vec3";
    if (t == "4f") return "vec4";
    if (t == "m4") return "mat4";

    if (t == "t") return "sampler2D";
    if (t == "tc") return "samplerCube";

    if (t == "3f[]") return null; // ignore this for now...
    if (t == "m4[]") return null; // ignore this for now...
    if (t == "f[]") return null; // ignore this for now...

    console.warn("[CGL UNIFORM] unknown glsl type string ", t);
  }; // CONCATENATED MODULE: ./src/core/cg/cg_texture.js

  /**
   * @function setValue
   * @memberof Uniform
   * @instance
   * @param {Number|Array|Matrix|Texture} value
   */

  const DEFAULT_TEXTURE_SIZE = 8;

  class CgTexture {
    constructor(options = {}) {
      this.id = CABLES.uuid();
      this.width = 0;
      this.height = 0;
      this.name = "unknown";

      options = options || {};
      this.pixelFormat = options.pixelFormat || CgTexture.PFORMATSTR_RGBA8UB;

      this.name = options.name || "unknown";

      if (!options.width) options.width = DEFAULT_TEXTURE_SIZE;
      if (!options.height) options.height = DEFAULT_TEXTURE_SIZE;
    }
  }

  CgTexture.getDefaultTextureData = (name, size, options = {}) => {
    if (name == "empty") {
      return new Uint8Array(size * size * 4).fill(0);
    } else if (name == "color") {
      const data = new Uint8Array(size * size * 4);
      let r = options.r || 1;
      let g = options.g || 1;
      let b = options.b || 1;

      for (let x = 0; x < size * size; x++) {
        data[x * 4 + 0] = r;
        data[x * 4 + 1] = g;
        data[x * 4 + 2] = b;
        data[x * 4 + 3] = 255;
      }
      return data;
    } else if (name == "randomUInt") {
      const data = new Uint8Array(size * size * 4);

      for (let x = 0; x < size * size; x++) {
        data[x * 4 + 0] = Math.random() * 255;
        data[x * 4 + 1] = Math.random() * 255;
        data[x * 4 + 2] = Math.random() * 255;
        data[x * 4 + 3] = 255;
      }
      return data;
    } else if (name == "random" || name == "randomFloat") {
      const data = new Float32Array(size * size * 4);

      for (let x = 0; x < size * size; x++) {
        data[x * 4 + 0] = (Math.random() - 0.5) * 2.0;
        data[x * 4 + 1] = (Math.random() - 0.5) * 2.0;
        data[x * 4 + 2] = (Math.random() - 0.5) * 2.0;
        data[x * 4 + 3] = 1;
      }
      return data;
    } else if (name == "stripes") {
      const arr = [];

      let r = options.r;
      let g = options.g;
      let b = options.b;

      if (r === undefined) r = 1;
      if (g === undefined) g = 1;
      if (b === undefined) b = 1;

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if ((x + y) % 64 < 32) {
            arr.push((200 + (y / size) * 25 + (x / size) * 25) * r);
            arr.push((200 + (y / size) * 25 + (x / size) * 25) * g);
            arr.push((200 + (y / size) * 25 + (x / size) * 25) * b);
          } else {
            arr.push((40 + (y / size) * 25 + (x / size) * 25) * r);
            arr.push((40 + (y / size) * 25 + (x / size) * 25) * g);
            arr.push((40 + (y / size) * 25 + (x / size) * 25) * b);
          }
          arr.push(255);
        }
      }

      return new Uint8Array(arr);
    } else {
      console.warn("unknown default texture", name);
      return CgTexture.getDefaultTextureData("stripes", size, {
        r: 1,
        g: 0,
        b: 0,
      });
    }
  };

  CgTexture.FILTER_NEAREST = 0;
  CgTexture.FILTER_LINEAR = 1;
  CgTexture.FILTER_MIPMAP = 2;

  CgTexture.WRAP_REPEAT = 0;
  CgTexture.WRAP_MIRRORED_REPEAT = 1;
  CgTexture.WRAP_CLAMP_TO_EDGE = 2;

  CgTexture.TYPE_DEFAULT = 0;
  CgTexture.TYPE_DEPTH = 1;
  CgTexture.TYPE_FLOAT = 2;

  CgTexture.PFORMATSTR_RGB565 = "RGB 5/6/5bit ubyte";

  CgTexture.PFORMATSTR_R8UB = "R 8bit ubyte";
  CgTexture.PFORMATSTR_RG8UB = "RG 8bit ubyte";
  CgTexture.PFORMATSTR_RGB8UB = "RGB 8bit ubyte";
  CgTexture.PFORMATSTR_RGBA8UB = "RGBA 8bit ubyte";

  CgTexture.PFORMATSTR_SRGBA8 = "SRGBA 8bit ubyte";

  CgTexture.PFORMATSTR_R11FG11FB10F = "RGB 11/11/10bit float";

  CgTexture.PFORMATSTR_R16F = "R 16bit float";
  CgTexture.PFORMATSTR_RG16F = "RG 16bit float";
  CgTexture.PFORMATSTR_RGB16F = "RGB 16bit float";
  CgTexture.PFORMATSTR_RGBA16F = "RGBA 16bit float";

  CgTexture.PFORMATSTR_R32F = "R 32bit float";
  CgTexture.PFORMATSTR_RG32F = "RG 32bit float";
  CgTexture.PFORMATSTR_RGB32F = "RGB 32bit float";
  CgTexture.PFORMATSTR_RGBA32F = "RGBA 32bit float";

  CgTexture.PFORMATSTR_DEPTH = "DEPTH";

  CgTexture.PIXELFORMATS = [
    CgTexture.PFORMATSTR_RGB565,

    CgTexture.PFORMATSTR_R8UB,
    CgTexture.PFORMATSTR_RG8UB,
    CgTexture.PFORMATSTR_RGB8UB,
    CgTexture.PFORMATSTR_RGBA8UB,

    CgTexture.PFORMATSTR_SRGBA8,

    CgTexture.PFORMATSTR_R11FG11FB10F,
    CgTexture.PFORMATSTR_R16F,
    CgTexture.PFORMATSTR_RG16F,
    CgTexture.PFORMATSTR_RGBA16F,

    CgTexture.PFORMATSTR_R32F,
    CgTexture.PFORMATSTR_RGBA32F,
  ]; // CONCATENATED MODULE: ./src/core/cgl/cgl_texture.js

  const cgl_texture_DEFAULT_TEXTURE_SIZE = 8;

  /**
   * A Texture
   * @namespace external:CGL
   * @class
   * @param {Context} __cgl cgl
   * @param {Object} options
   * @hideconstructor
   * @example
   * // generate a 256x256 pixel texture of random colors
   * const size=256;
   * const data = new Uint8Array(size*size*4);
   *
   * for(var x=0;x<size*size*4;x++) data[ x*4+3]=255;
   *
   * const tex=new CGL.Texture(cgl);
   * tex.initFromData(data,size,size,CGL.Texture.FILTER_NEAREST,CGL.Texture.WRAP_REPEAT);
   */
  class Texture extends CgTexture {
    constructor(__cgl, options = {}) {
      super(options);
      if (!__cgl) throw new Error("no cgl");
      this._log = new Logger("cgl_texture");
      this._cgl = __cgl;
      this.tex = this._cgl.gl.createTexture();
      this.loading = false;
      this.flip = true;
      this.flipped = false;
      this.shadowMap = false;
      this.deleted = false;
      this.image = null;
      this.anisotropic = 0;
      this.filter = Texture.FILTER_NEAREST;
      this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
      this.texTarget = this._cgl.gl.TEXTURE_2D;
      if (options && options.type) this.texTarget = options.type;
      this.textureType = Texture.TYPE_DEFAULT;
      this.unpackAlpha = true;
      this._fromData = true;

      this._glDataType = -1;
      this._glInternalFormat = -1;
      this._glDataFormat = -1;

      if (options) {
        if (options.isDepthTexture) this.textureType = Texture.TYPE_DEPTH;
        if (options.isFloatingPointTexture === true)
          this.textureType = Texture.TYPE_FLOAT;

        if ("textureType" in options) this.textureType = options.textureType;
        if ("filter" in options) this.filter = options.filter;
        if ("wrap" in options) this.wrap = options.wrap;
        if ("unpackAlpha" in options) this.unpackAlpha = options.unpackAlpha;
        if ("flip" in options) this.flip = options.flip;
        if ("shadowMap" in options) this.shadowMap = options.shadowMap;
        if ("anisotropic" in options) this.anisotropic = options.anisotropic;
      } else {
        options = {};
      }

      if (!options.pixelFormat && options.isFloatingPointTexture)
        this.pixelFormat = Texture.PFORMATSTR_RGBA32F;

      if (this.textureType == Texture.TYPE_DEPTH)
        this.pixelFormat = Texture.PFORMATSTR_DEPTH;

      this._cgl.profileData.profileTextureNew++;

      this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));
      this._cgl.profileData.addHeavyEvent(
        "texture created",
        this.name,
        options.width + "x" + options.height
      );

      this.setSize(options.width, options.height);
      this.getInfoOneLine();
    }

    isFloatingPoint() {
      return Texture.isPixelFormatFloat(this.pixelFormat);
    }

    /**
     * returns true if otherTexture has same options (width/height/filter/wrap etc)
     * @function compareSettings
     * @memberof Texture
     * @instance
     * @param {Texture} tex otherTexture
     * @returns {Boolean}
     */
    compareSettings(tex) {
      // if (!tex) { this._log.warn("compare: no tex"); return false; }
      // if (tex.width != this.width) this._log.warn("tex.width not equal", tex.width, this.width);
      // if (tex.height != this.height) this._log.warn("tex.height not equal", tex.height, this.height);
      // if (tex.filter != this.filter) this._log.warn("tex.filter not equal");
      // if (tex.wrap != this.wrap) this._log.warn("tex.wrap not equal");
      // if (tex.textureType != this.textureType) this._log.warn("tex.textureType not equal");
      // if (tex.unpackAlpha != this.unpackAlpha) this._log.warn("tex.unpackAlpha not equal");
      // if (tex.anisotropic != this.anisotropic) this._log.warn("tex.anisotropic not equal");
      // if (tex.shadowMap != this.shadowMap) this._log.warn("tex.shadowMap not equal");
      // if (tex.texTarget != this.texTarget) this._log.warn("tex.texTarget not equal");
      // if (tex.flip != this.flip) this._log.warn("tex.flip not equal");

      if (!tex) return false;
      return (
        tex.width == this.width &&
        tex.height == this.height &&
        tex.filter == this.filter &&
        tex.wrap == this.wrap &&
        tex.textureType == this.textureType &&
        tex.unpackAlpha == this.unpackAlpha &&
        tex.anisotropic == this.anisotropic &&
        tex.shadowMap == this.shadowMap &&
        tex.texTarget == this.texTarget &&
        tex.flip == this.flip
      );
    }

    /**
     * returns a new texture with the same settings (does not copy texture itself)
     * @function clone
     * @memberof Texture
     * @instance
     * @returns {Texture}
     */
    clone() {
      const newTex = new Texture(this._cgl, {
        name: this.name,
        filter: this.filter,
        anisotropic: this.anisotropic,
        wrap: this.wrap,
        textureType: this.textureType,
        pixelFormat: this.pixelFormat,
        unpackAlpha: this.unpackAlpha,
        flip: this.flip,
        width: this.width,
        height: this.height,
      });

      this._cgl.profileData.addHeavyEvent(
        "texture created",
        this.name,
        this.width + "x" + this.height
      );

      if (!this.compareSettings(newTex)) {
        this._log.error("Cloned texture settings do not compare!");
        this._log.error(this);
        this._log.error(newTex);
      }

      return newTex;
    }

    setFormat(o) {
      this.pixelFormat = o.pixelFormat;
      this._glDataFormat = o.glDataFormat;
      this._glInternalFormat = o.glInternalFormat;
      this._glDataType = o.glDataType;
    }

    /**
     * set pixel size of texture
     * @function setSize
     * @memberof Texture
     * @instance
     * @param {Number} w width
     * @param {Number} h height
     */
    setSize(w, h) {
      if (this._cgl.aborted) return;
      if (w != w || w <= 0 || !w) w = cgl_texture_DEFAULT_TEXTURE_SIZE;
      if (h != h || h <= 0 || !h) h = cgl_texture_DEFAULT_TEXTURE_SIZE;

      if (w > this._cgl.maxTexSize || h > this._cgl.maxTexSize)
        this._log.error(
          "texture size too big! " +
            w +
            "x" +
            h +
            " / max: " +
            this._cgl.maxTexSize
        );

      w = Math.min(w, this._cgl.maxTexSize);
      h = Math.min(h, this._cgl.maxTexSize);

      w = Math.floor(w);
      h = Math.floor(h);
      if (this.width == w && this.height == h) return;

      w = this._cgl.checkTextureSize(w);
      h = this._cgl.checkTextureSize(h);

      this.width = w;
      this.height = h;
      this.deleted = false;

      this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

      this.shortInfoString = this.getInfoOneLine(); // w + "x" + h + "";

      this._cgl.gl.bindTexture(this.texTarget, this.tex);
      this._cgl.profileData.profileTextureResize++;

      const uarr = null;

      this._cgl.gl.texImage2D(
        this.texTarget,
        0,
        this._glInternalFormat,
        w,
        h,
        0,
        this._glDataFormat,
        this._glDataType,
        uarr
      );

      this._setFilter();

      this.updateMipMap();

      this._cgl.gl.bindTexture(this.texTarget, null);
    }

    /**
     * @function initFromData
     * @memberof Texture
     * @instance
     * @description create texturem from rgb data
     * @param {Array<Number>} data rgb color array [r,g,b,a,r,g,b,a,...]
     * @param {Number} w width
     * @param {Number} h height
     * @param {Number} filter
     * @param {Number} wrap
     */
    initFromData(data, w, h, filter, wrap) {
      this.filter = filter;
      this.wrap = wrap;
      if (filter == undefined) this.filter = Texture.FILTER_LINEAR;
      if (wrap == undefined) this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
      this.width = w;
      this.height = h;
      this._fromData = true;
      this.deleted = false;

      if (
        this.height > this._cgl.maxTexSize ||
        this.width > this._cgl.maxTexSize
      ) {
        const t = CGL.Texture.getTempTexture(this._cgl);
        this.width = t.width;
        this.height = t.height;
        this.tex = t.tex;
        this._log.warn(
          "[cgl_texture] texture size too big!",
          this.width,
          this.height,
          this._cgl.maxTexSize
        );
        return;
      }

      if (this.flip)
        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flip);

      this._cgl.gl.bindTexture(this.texTarget, this.tex);

      this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

      this._cgl.gl.texImage2D(
        this.texTarget,
        0,
        this._glInternalFormat,
        w,
        h,
        0,
        this._glDataFormat,
        this._glDataType,
        data
      );

      this._setFilter();
      this.updateMipMap();

      if (this.flip)
        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);
      this._cgl.gl.bindTexture(this.texTarget, null);
    }

    updateMipMap() {
      if (
        (this._cgl.glVersion == 2 || this.isPowerOfTwo()) &&
        this.filter == Texture.FILTER_MIPMAP
      ) {
        this._cgl.gl.generateMipmap(this.texTarget);
        this._cgl.profileData.profileGenMipMap++;
      }
    }

    /**
     * set texture data from an image/canvas object
     * @function initTexture
     * @memberof Texture
     * @instance
     * @param {Object} img image
     * @param {Number} filter
     */
    initTexture(img, filter) {
      this._cgl.printError("before initTexture");
      this._cgl.checkFrameStarted("texture inittexture");
      this._fromData = false;

      this._cgl.gl.pixelStorei(
        this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        this.unpackAlpha
      );
      if (img.width || img.videoWidth) this.width = img.videoWidth || img.width;
      if (img.height || img.videoHeight)
        this.height = img.videoHeight || img.height;

      if (filter !== undefined) this.filter = filter; // todo: can we remove this filter param?

      if (
        img.height > this._cgl.maxTexSize ||
        img.width > this._cgl.maxTexSize
      ) {
        const t = CGL.Texture.getTempTexture(this._cgl);
        this.width = t.width;
        this.height = t.height;
        this.tex = t.tex;
        this._log.warn(
          "[cgl_texture] texture size too big!",
          img.width,
          img.height,
          this._cgl.maxTexSize
        );
        return;
      }

      this._cgl.gl.bindTexture(this.texTarget, this.tex);

      this.deleted = false;
      this.flipped = !this.flip;
      if (this.flipped)
        this._cgl.gl.pixelStorei(
          this._cgl.gl.UNPACK_FLIP_Y_WEBGL,
          this.flipped
        );

      this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));

      this._cgl.gl.texImage2D(
        this.texTarget,
        0,
        this._glInternalFormat,
        this._glDataFormat,
        this._glDataType,
        img
      );

      this._setFilter();
      this.updateMipMap();

      this._cgl.gl.bindTexture(this.texTarget, null);
      this._cgl.gl.pixelStorei(
        this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        false
      );
      if (this.flipped)
        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);

      this.getInfoOneLine();
      this._cgl.printError("initTexture");
    }

    /**
     * delete texture. use this when texture is no longer needed
     * @function delete
     * @memberof Texture
     * @instance
     */
    dispose() {
      this.delete();
    }

    delete() {
      if (this.loading) {
        // cant delete texture when still loading
        // setTimeout(this.delete.bind(this), 50);
        return;
      }

      this.deleted = true;
      this.width = 0;
      this.height = 0;
      this._cgl.profileData.profileTextureDelete++;
      this._cgl.gl.deleteTexture(this.tex);
      this.image = null;

      this.tex = null;
    }

    /**
     * @function isPowerOfTwo
     * @memberof Texture
     * @instance
     * @description return true if texture width and height are both power of two
     * @return {Boolean}
     */
    isPowerOfTwo() {
      return (
        Texture.isPowerOfTwo(this.width) && Texture.isPowerOfTwo(this.height)
      );
    }

    printInfo() {
      console.log(this.getInfo());
    }

    getInfoReadable() {
      const info = this.getInfo();
      let html = "";

      info.name = info.name.substr(0, info.name.indexOf("?rnd="));

      for (const i in info) {
        html += "* " + i + ":  **" + info[i] + "**\n";
      }

      return html;
    }

    getInfoOneLine() {
      let txt = "" + this.width + "x" + this.height;
      txt += " ";
      // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
      // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
      txt += this.pixelFormat;

      if (this.filter === CGL.Texture.FILTER_NEAREST) txt += " nearest";
      if (this.filter === CGL.Texture.FILTER_LINEAR) txt += " linear";
      if (this.filter === CGL.Texture.FILTER_MIPMAP) txt += " mipmap";

      if (this.wrap === CGL.Texture.WRAP_CLAMP_TO_EDGE) txt += " clamp";
      if (this.wrap === CGL.Texture.WRAP_REPEAT) txt += " repeat";
      if (this.wrap === CGL.Texture.WRAP_MIRRORED_REPEAT) txt += " repeatmir";

      this.shortInfoString = txt;

      return txt;
    }

    getInfoOneLineShort() {
      let txt = "" + this.width + "x" + this.height;
      // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += " 32bit"; else txt += " 8bit";
      txt += " ";
      txt += this.pixelFormat;

      this.shortInfoString = txt;

      return txt;
    }

    getInfo() {
      return Texture.getTexInfo(this);
    }

    _setFilter() {
      this._cgl.printError("before _setFilter");

      if (!this._fromData) {
        this._cgl.gl.pixelStorei(
          this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
          this.unpackAlpha
        );
      }

      if (this.shadowMap) {
        this._cgl.gl.texParameteri(
          this._cgl.gl.TEXTURE_2D,
          this._cgl.gl.TEXTURE_COMPARE_MODE,
          this._cgl.gl.COMPARE_REF_TO_TEXTURE
        );
        this._cgl.gl.texParameteri(
          this._cgl.gl.TEXTURE_2D,
          this._cgl.gl.TEXTURE_COMPARE_FUNC,
          this._cgl.gl.LEQUAL
        );
      }

      if (
        this.textureType == Texture.TYPE_FLOAT &&
        this.filter == Texture.FILTER_MIPMAP
      ) {
        this.filter = Texture.FILTER_LINEAR;
        this._log.stack(
          "texture: HDR and mipmap filtering at the same time is not possible"
        );
      }

      if (this._cgl.glVersion == 1 && !this.isPowerOfTwo()) {
        this._cgl.gl.texParameteri(
          this.texTarget,
          this._cgl.gl.TEXTURE_MAG_FILTER,
          this._cgl.gl.NEAREST
        );
        this._cgl.gl.texParameteri(
          this.texTarget,
          this._cgl.gl.TEXTURE_MIN_FILTER,
          this._cgl.gl.NEAREST
        );

        this._cgl.gl.texParameteri(
          this.texTarget,
          this._cgl.gl.TEXTURE_WRAP_S,
          this._cgl.gl.CLAMP_TO_EDGE
        );
        this._cgl.gl.texParameteri(
          this.texTarget,
          this._cgl.gl.TEXTURE_WRAP_T,
          this._cgl.gl.CLAMP_TO_EDGE
        );

        this.filter = Texture.FILTER_NEAREST;
        this.wrap = Texture.WRAP_CLAMP_TO_EDGE;
      } else {
        if (this.wrap == Texture.WRAP_CLAMP_TO_EDGE) {
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_WRAP_S,
            this._cgl.gl.CLAMP_TO_EDGE
          );
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_WRAP_T,
            this._cgl.gl.CLAMP_TO_EDGE
          );
        } else if (this.wrap == Texture.WRAP_REPEAT) {
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_WRAP_S,
            this._cgl.gl.REPEAT
          );
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_WRAP_T,
            this._cgl.gl.REPEAT
          );
        } else if (this.wrap == Texture.WRAP_MIRRORED_REPEAT) {
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_WRAP_S,
            this._cgl.gl.MIRRORED_REPEAT
          );
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_WRAP_T,
            this._cgl.gl.MIRRORED_REPEAT
          );
        }

        if (this.filter == Texture.FILTER_NEAREST) {
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_MAG_FILTER,
            this._cgl.gl.NEAREST
          );
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_MIN_FILTER,
            this._cgl.gl.NEAREST
          );
        } else if (this.filter == Texture.FILTER_LINEAR) {
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_MIN_FILTER,
            this._cgl.gl.LINEAR
          );
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_MAG_FILTER,
            this._cgl.gl.LINEAR
          );
        } else if (this.filter == Texture.FILTER_MIPMAP) {
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_MAG_FILTER,
            this._cgl.gl.LINEAR
          );
          this._cgl.gl.texParameteri(
            this.texTarget,
            this._cgl.gl.TEXTURE_MIN_FILTER,
            this._cgl.gl.LINEAR_MIPMAP_LINEAR
          );
        } else {
          this._log.log("unknown texture filter!", this.filter);
          throw new Error("unknown texture filter!" + this.filter);
        }

        if (this.anisotropic) {
          const ext = this._cgl.enableExtension(
            "EXT_texture_filter_anisotropic"
          );

          if (this._cgl.maxAnisotropic) {
            const aniso = Math.min(this._cgl.maxAnisotropic, this.anisotropic);
            this._cgl.gl.texParameterf(
              this._cgl.gl.TEXTURE_2D,
              ext.TEXTURE_MAX_ANISOTROPY_EXT,
              aniso
            );
          }
        }
      }
      this.getInfoOneLine();
      this._cgl.printError("_setFilter");
    }
  }

  /**
   * @function load
   * @static
   * @memberof Texture
   * @description load an image from an url
   * @param {Context} cgl
   * @param {String} url
   * @param {Function} finishedCallback
   * @param {Object} settings
   * @return {Texture}
   */
  Texture.load = function (cgl, url, finishedCallback, settings) {
    if (!url) return finishedCallback({ error: true });
    let loadingId = null;
    if (!cgl.patch.loading.existByName(url))
      loadingId = cgl.patch.loading.start("cgl.texture", url);

    const texture = new Texture(cgl);
    texture.name = url;

    texture.image = new Image();
    texture.image.crossOrigin = "anonymous";
    texture.loading = true;

    if (settings && settings.hasOwnProperty("filter"))
      texture.filter = settings.filter;
    if (settings && settings.hasOwnProperty("flip"))
      texture.flip = settings.flip;
    if (settings && settings.hasOwnProperty("wrap"))
      texture.wrap = settings.wrap;
    if (settings && settings.hasOwnProperty("anisotropic"))
      texture.anisotropic = settings.anisotropic;
    if (settings && settings.hasOwnProperty("unpackAlpha"))
      texture.unpackAlpha = settings.unpackAlpha;
    if (settings && settings.hasOwnProperty("pixelFormat"))
      texture.pixelFormat = settings.pixelFormat;

    texture.image.onabort = texture.image.onerror = (e) => {
      console.warn("[cgl.texture.load] error loading texture", url, e);
      texture.loading = false;
      if (loadingId) cgl.patch.loading.finished(loadingId);
      const error = { error: true };
      if (finishedCallback) finishedCallback(error, texture);
    };

    texture.image.onload = function (e) {
      cgl.addNextFrameOnceCallback(() => {
        texture.initTexture(texture.image);
        if (loadingId) cgl.patch.loading.finished(loadingId);
        texture.loading = false;

        if (finishedCallback) finishedCallback(null, texture);
      });
    };
    texture.image.src = url;

    return texture;
  };

  /**
   * @static
   * @function getTempTexture
   * @memberof Texture
   * @description returns the default temporary texture (grey diagonal stipes)
   * @param {Context} cgl
   * @return {Texture}
   */
  Texture.getTempTexture = function (cgl) {
    if (!cgl) console.error("[getTempTexture] no cgl!");
    if (!cgl.tempTexture)
      cgl.tempTexture = Texture.getTemporaryTexture(
        cgl,
        256,
        Texture.FILTER_LINEAR,
        Texture.REPEAT
      );
    return cgl.tempTexture;
  };

  /**
   * @static
   * @function getErrorTexture
   * @memberof Texture
   * @description returns the default temporary texture (grey diagonal stipes)
   * @param {Context} cgl
   * @return {Texture}
   */
  Texture.getErrorTexture = function (cgl) {
    if (!cgl) console.error("[getTempTexture] no cgl!");
    if (!cgl.errorTexture)
      cgl.errorTexture = Texture.getTemporaryTexture(
        cgl,
        256,
        Texture.FILTER_LINEAR,
        Texture.REPEAT,
        1,
        0.2,
        0.2
      );
    return cgl.errorTexture;
  };

  /**
   * @function getEmptyTexture
   * @memberof Texture
   * @instance
   * @param cgl
   * @param fp
   * @description returns a reference to a small empty (transparent) texture
   * @return {Texture}
   */
  Texture.getEmptyTexture = function (cgl, fp) {
    if (fp) return Texture.getEmptyTextureFloat(cgl);
    if (!cgl) console.error("[getEmptyTexture] no cgl!");
    if (cgl.tempTextureEmpty) return cgl.tempTextureEmpty;

    let size = 8;

    cgl.tempTextureEmpty = new Texture(cgl, { name: "emptyTexture" });
    const data = Texture.getDefaultTextureData("empty", size);

    cgl.tempTextureEmpty.initFromData(
      data,
      size,
      size,
      Texture.FILTER_NEAREST,
      Texture.WRAP_REPEAT
    );

    return cgl.tempTextureEmpty;
  };

  /**
   * @function getEmptyTextureFloat
   * @memberof Texture
   * @instance
   * @param cgl
   * @description returns a reference to a small empty (transparent) 32bit texture
   * @return {Texture}
   */
  Texture.getEmptyTextureFloat = function (cgl) {
    if (!cgl) console.error("[getEmptyTextureFloat] no cgl!");
    if (cgl.tempTextureEmptyFloat) return cgl.tempTextureEmptyFloat;

    cgl.tempTextureEmptyFloat = new Texture(cgl, {
      name: "emptyTexture",
      isFloatingPointTexture: true,
    });
    const data = new Float32Array(8 * 8 * 4).fill(1);
    for (let i = 0; i < 8 * 8 * 4; i += 4) data[i + 3] = 0;

    cgl.tempTextureEmptyFloat.initFromData(
      data,
      8,
      8,
      Texture.FILTER_NEAREST,
      Texture.WRAP_REPEAT
    );

    return cgl.tempTextureEmptyFloat;
  };

  /**
   * @function getRandomTexture
   * @memberof Texture
   * @static
   * @param cgl
   * @description returns a reference to a random texture
   * @return {Texture}
   */
  Texture.getRandomTexture = function (cgl) {
    if (!cgl) console.error("[getRandomTexture] no cgl!");
    if (cgl.randomTexture) return cgl.randomTexture;

    const size = 256;
    const data = Texture.getDefaultTextureData("randomUInt", size);

    cgl.randomTexture = new Texture(cgl);
    cgl.randomTexture.initFromData(
      data,
      size,
      size,
      Texture.FILTER_NEAREST,
      Texture.WRAP_REPEAT
    );

    return cgl.randomTexture;
  };

  /**
   * @function getRandomFloatTexture
   * @memberof Texture
   * @static
   * @param cgl
   * @description returns a reference to a texture containing random numbers between -1 and 1
   * @return {Texture}
   */
  Texture.getRandomFloatTexture = function (cgl) {
    if (!cgl) console.error("[getRandomTexture] no cgl!");
    if (cgl.getRandomFloatTexture) return cgl.getRandomFloatTexture;

    const size = 256;
    const data = Texture.getDefaultTextureData("randomFloat", size);

    cgl.getRandomFloatTexture = new Texture(cgl, {
      isFloatingPointTexture: true,
    });
    cgl.getRandomFloatTexture.initFromData(
      data,
      size,
      size,
      Texture.FILTER_NEAREST,
      Texture.WRAP_REPEAT
    );

    return cgl.getRandomFloatTexture;
  };

  /**
   * @function getBlackTexture
   * @memberof Texture
   * @static
   * @param cgl
   * @description returns a reference to a black texture
   * @return {Texture}
   */
  Texture.getBlackTexture = function (cgl) {
    if (!cgl) this._log.error("[getBlackTexture] no cgl!");
    if (cgl.blackTexture) return cgl.blackTexture;

    const size = 8;
    const data = Texture.getDefaultTextureData("color", size, {
      r: 0,
      g: 0,
      b: 0,
    });

    cgl.blackTexture = new Texture(cgl);
    cgl.blackTexture.initFromData(
      data,
      size,
      size,
      Texture.FILTER_NEAREST,
      Texture.WRAP_REPEAT
    );

    return cgl.blackTexture;
  };

  /**
   * @function getEmptyCubemapTexture
   * @memberof Texture
   * @static
   * @param cgl
   * @description returns an empty cubemap texture with rgba = [0, 0, 0, 0]
   * @return {Texture}
   */
  Texture.getEmptyCubemapTexture = function (cgl) {
    const faces = [
      cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_X,
      cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
      cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
      cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
      cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
      cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
    ];

    const tex = cgl.gl.createTexture();
    const target = cgl.gl.TEXTURE_CUBE_MAP;
    const filter = Texture.FILTER_NEAREST;
    const wrap = Texture.WRAP_CLAMP_TO_EDGE;
    const width = 8;
    const height = 8;

    cgl.profileData.profileTextureNew++;

    cgl.gl.bindTexture(target, tex);
    cgl.profileData.profileTextureResize++;

    for (let i = 0; i < 6; i += 1) {
      const data = new Uint8Array(8 * 8 * 4);

      cgl.gl.texImage2D(
        faces[i],
        0,
        cgl.gl.RGBA,
        8,
        8,
        0,
        cgl.gl.RGBA,
        cgl.gl.UNSIGNED_BYTE,
        data
      );
      cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MAG_FILTER, cgl.gl.NEAREST);
      cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MIN_FILTER, cgl.gl.NEAREST);

      cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_S, cgl.gl.CLAMP_TO_EDGE);
      cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_T, cgl.gl.CLAMP_TO_EDGE);
    }

    cgl.gl.bindTexture(target, null);

    return {
      id: CABLES.uuid(),
      tex: tex,
      cubemap: tex,
      width: width,
      height: height,
      filter: filter,
      wrap: wrap,
      unpackAlpha: true,
      flip: true,
      _fromData: true,
      name: "emptyCubemapTexture",
      anisotropic: 0,
    };
  };

  Texture.getTempGradientTexture = function (
    cgl // deprecated...
  ) {
    if (!cgl) console.error("[getTempGradientTexture] no cgl!");
    return Texture.getTempTexture(cgl);
  };

  Texture.getTemporaryTexture = function (cgl, size, filter, wrap, r, g, b) {
    const data = Texture.getDefaultTextureData("stripes", 256, {
      r: r,
      g: g,
      b: b,
    });
    const temptex = new Texture(cgl);
    temptex.initFromData(data, size, size, filter, wrap);
    return temptex;
  };

  /**
   * @static
   * @function createFromImage
   * @memberof Texture
   * @description create texturem from image data (e.g. image or canvas)
   * @param {Context} cgl
   * @param {Object} img image
   * @param {Object} options
   */
  Texture.createFromImage = function (cgl, img, options) {
    options = options || {};
    const texture = new Texture(cgl, options);
    texture.flip = false;
    texture.image = img;
    texture.width = img.videoWidth || img.width || 8;
    texture.height = img.videoHeight || img.height || 8;
    if (options.hasOwnProperty("wrap")) texture.wrap = options.wrap;

    texture.initTexture(img, options.filter);

    return texture;
  };

  // deprecated!
  Texture.fromImage = function (cgl, img, filter, wrap) {
    console.error("deprecated texture from image...");

    const texture = new Texture(cgl);
    texture.flip = false;
    if (filter) texture.filter = filter;
    if (wrap) texture.wrap = wrap;
    texture.image = img;
    texture.initTexture(img);
    return texture;
  };

  /**
   * @static
   * @function isPowerOfTwo
   * @memberof Texture
   * @description returns true if x is power of two
   * @param {Number} x
   * @return {Boolean}
   */
  Texture.isPowerOfTwo = function (x) {
    return (
      x == 1 ||
      x == 2 ||
      x == 4 ||
      x == 8 ||
      x == 16 ||
      x == 32 ||
      x == 64 ||
      x == 128 ||
      x == 256 ||
      x == 512 ||
      x == 1024 ||
      x == 2048 ||
      x == 4096 ||
      x == 8192 ||
      x == 16384
    );
  };

  Texture.getTexInfo = function (tex) {
    const obj = {};

    obj.name = tex.name;
    obj["power of two"] = tex.isPowerOfTwo();
    obj.size = tex.width + " x " + tex.height;

    let targetString = tex.texTarget;
    if (tex.texTarget == tex._cgl.gl.TEXTURE_2D) targetString = "TEXTURE_2D";
    obj.target = targetString;

    obj.unpackAlpha = tex.unpackAlpha;

    if (tex.cubemap) obj.cubemap = true;

    if (tex.textureType == Texture.TYPE_FLOAT) obj.textureType = "TYPE_FLOAT";
    if (tex.textureType == Texture.TYPE_HALF_FLOAT)
      obj.textureType = "TYPE_HALF_FLOAT";
    else if (tex.textureType == Texture.TYPE_DEPTH)
      obj.textureType = "TYPE_DEPTH";
    else if (tex.textureType == Texture.TYPE_DEFAULT)
      obj.textureType = "TYPE_DEFAULT";
    else obj.textureType = "UNKNOWN " + this.textureType;

    if (tex.wrap == Texture.WRAP_CLAMP_TO_EDGE) obj.wrap = "CLAMP_TO_EDGE";
    else if (tex.wrap == Texture.WRAP_REPEAT) obj.wrap = "WRAP_REPEAT";
    else if (tex.wrap == Texture.WRAP_MIRRORED_REPEAT)
      obj.wrap = "WRAP_MIRRORED_REPEAT";
    else obj.wrap = "UNKNOWN";

    if (tex.filter == Texture.FILTER_NEAREST) obj.filter = "FILTER_NEAREST";
    else if (tex.filter == Texture.FILTER_LINEAR) obj.filter = "FILTER_LINEAR";
    else if (tex.filter == Texture.FILTER_MIPMAP) obj.filter = "FILTER_MIPMAP";
    else obj.filter = "UNKNOWN";

    obj.pixelFormat = tex.pixelFormat || "unknown";

    return obj;
  };

  Texture.setUpGlPixelFormat = function (cgl, pixelFormatStr) {
    const o = {};

    if (!pixelFormatStr) {
      cgl._log.error("no pixelformatstr!");
      cgl._log.log(new Error());
      pixelFormatStr = Texture.PFORMATSTR_RGBA8UB;
    }

    o.pixelFormatBase = pixelFormatStr;
    o.pixelFormat = pixelFormatStr;
    o.glDataType = cgl.gl.UNSIGNED_BYTE;
    o.glInternalFormat = cgl.gl.RGBA8;
    o.glDataFormat = cgl.gl.RGBA;

    let floatDatatype = cgl.gl.FLOAT;

    if (cgl.glUseHalfFloatTex) {
      if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F)
        pixelFormatStr = Texture.PFORMATSTR_RGBA16F;
      if (pixelFormatStr == Texture.PFORMATSTR_RG32F)
        pixelFormatStr = Texture.PFORMATSTR_RG16F;
      if (pixelFormatStr == Texture.PFORMATSTR_R32F)
        pixelFormatStr = Texture.PFORMATSTR_R16F;
    }

    if (pixelFormatStr.contains("16bit")) {
      if (cgl.glVersion == 2) {
        // cgl.enableExtension("OES_texture_half_float");
        const hasExt = cgl.enableExtension("EXT_color_buffer_half_float");

        if (!hasExt) {
          console.warn("no 16bit extension, fallback to 32bit", pixelFormatStr);
          // fallback to 32 bit?
          if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F)
            pixelFormatStr = Texture.PFORMATSTR_RGBA32F;
          if (pixelFormatStr == Texture.PFORMATSTR_RGB16F)
            pixelFormatStr = Texture.PFORMATSTR_RGB32F;
          if (pixelFormatStr == Texture.PFORMATSTR_RG16F)
            pixelFormatStr = Texture.PFORMATSTR_RG32F;
          if (pixelFormatStr == Texture.PFORMATSTR_R16F)
            pixelFormatStr = Texture.PFORMATSTR_R32F;
        } else {
          floatDatatype = cgl.gl.HALF_FLOAT;
        }
      }
    }

    if (cgl.glVersion == 1) {
      o.glInternalFormat = cgl.gl.RGBA;

      if (
        pixelFormatStr == Texture.PFORMATSTR_RGBA16F ||
        pixelFormatStr == Texture.PFORMATSTR_RG16F ||
        pixelFormatStr == Texture.PFORMATSTR_R16F
      ) {
        const ext = cgl.enableExtension("OES_texture_half_float");
        if (!ext) throw new Error("no half float texture extension");

        floatDatatype = ext.HALF_FLOAT_OES;
      }
    }

    if (pixelFormatStr == Texture.PFORMATSTR_RGBA8UB) {
    } else if (pixelFormatStr == Texture.PFORMATSTR_RGB565) {
      o.glInternalFormat = cgl.gl.RGB565;
      o.glDataFormat = cgl.gl.RGB;
    } else if (pixelFormatStr == Texture.PFORMATSTR_R8UB) {
      o.glInternalFormat = cgl.gl.R8;
      o.glDataFormat = cgl.gl.RED;
    } else if (pixelFormatStr == Texture.PFORMATSTR_RG8UB) {
      o.glInternalFormat = cgl.gl.RG8;
      o.glDataFormat = cgl.gl.RG;
    } else if (pixelFormatStr == Texture.PFORMATSTR_RGB8UB) {
      o.glInternalFormat = cgl.gl.RGB8;
      o.glDataFormat = cgl.gl.RGB;
    } else if (pixelFormatStr == Texture.PFORMATSTR_SRGBA8) {
      o.glInternalFormat = cgl.gl.SRGB8_ALPHA8;
    } else if (pixelFormatStr == Texture.PFORMATSTR_R32F) {
      o.glInternalFormat = cgl.gl.R32F;
      o.glDataFormat = cgl.gl.RED;
      o.glDataType = floatDatatype;
    } else if (pixelFormatStr == Texture.PFORMATSTR_R16F) {
      o.glInternalFormat = cgl.gl.R16F;
      o.glDataType = floatDatatype;
      o.glDataFormat = cgl.gl.RED;
    } else if (pixelFormatStr == Texture.PFORMATSTR_RG16F) {
      o.glInternalFormat = cgl.gl.RG16F;
      o.glDataType = floatDatatype;
      o.glDataFormat = cgl.gl.RG;
    } else if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F) {
      if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;
      else o.glInternalFormat = cgl.gl.RGBA16F;
      o.glDataType = floatDatatype;
    } else if (pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F) {
      o.glInternalFormat = cgl.gl.R11F_G11F_B10F;
      o.glDataType = floatDatatype;
      o.glDataFormat = cgl.gl.RGB;
    } else if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F) {
      if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;
      else o.glInternalFormat = cgl.gl.RGBA32F;
      o.glDataType = floatDatatype;
    } else if (pixelFormatStr == Texture.PFORMATSTR_DEPTH) {
      if (cgl.glVersion == 1) {
        o.glInternalFormat = cgl.gl.DEPTH_COMPONENT;
        o.glDataType = cgl.gl.UNSIGNED_SHORT;
        o.glDataFormat = cgl.gl.DEPTH_COMPONENT;
      } else {
        o.glInternalFormat = cgl.gl.DEPTH_COMPONENT32F;
        o.glDataType = cgl.gl.FLOAT;
        o.glDataFormat = cgl.gl.DEPTH_COMPONENT;
      }
    } else {
      console.log("unknown pixelformat ", pixelFormatStr);
    }

    /// //////

    if (
      pixelFormatStr.contains("32bit") ||
      pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F
    ) {
      if (cgl.glVersion == 2) cgl.enableExtension("EXT_color_buffer_float");
      if (cgl.glVersion == 2) cgl.enableExtension("EXT_float_blend");

      cgl.enableExtension("OES_texture_float_linear"); // yes, i am sure, this is a webgl 1 and 2 ext
    }

    o.numColorChannels = Texture.getPixelFormatNumChannels(pixelFormatStr);

    if (!o.glDataType || !o.glInternalFormat || !o.glDataFormat)
      console.log(
        "pixelformat wrong ?!",
        pixelFormatStr,
        o.glDataType,
        o.glInternalFormat,
        o.glDataFormat,
        this
      );

    return o;
  };

  Texture.getPixelFormatNumChannels = (pxlFrmtStr) => {
    if (pxlFrmtStr.startsWith("RGBA")) return 4;
    if (pxlFrmtStr.startsWith("RGB")) return 3;
    if (pxlFrmtStr.startsWith("RG")) return 2;
    return 1;
  };

  Texture.isPixelFormatFloat = (pxlFrmtStr) => {
    return (pxlFrmtStr || "").contains("float");
  };

  Texture.isPixelFormatHalfFloat = (pxlFrmtStr) => {
    return (
      (pxlFrmtStr || "").contains("float") &&
      (pxlFrmtStr || "").contains("16bit")
    );
  }; // CONCATENATED MODULE: ./src/core/cg/cg_boundingbox.js

  /**
   * bounding box
   *
   * @namespace external:CGL
   * @param {Geometry} geometry or bounding box
   */
  class BoundingBox {
    constructor(geom) {
      this._init();
      this._first = true;
      this._wireMesh = null;

      if (geom) this.apply(geom);
    }

    _init() {
      this._max = [-0, -0, -0];
      this._min = [0, 0, 0];
      this._center = [0, 0, 0];
      this._size = [0, 0, 0];
      this._maxAxis = 0.0;
      this._first = true;
    }

    /**
     * get biggest number of maxX,maxY,maxZ
     * @type {Number}
     */
    get maxAxis() {
      return this._maxAxis || 1;
    }

    /**
     * size of bounding box
     * @type {vec3}
     */
    get size() {
      return this._size;
    }

    /**
     * center of bounding box
     * @type {vec3}
     */
    get center() {
      return this._center;
    }

    /**
     * center x
     * @type {Number}
     */
    get x() {
      return this._center[0];
    }

    /**
     * center y
     * @type {Number}
     */
    get y() {
      return this._center[1];
    }

    /**
     * center z
     * @type {Number}
     */
    get z() {
      return this._center[2];
    }

    /**
     * minimum x
     * @type {Number}
     */
    get minX() {
      return this._min[0];
    }

    /**
     * minimum y
     * @type {Number}
     */
    get minY() {
      return this._min[1];
    }

    /**
     * minimum z
     * @type {Number}
     */
    get minZ() {
      return this._min[2];
    }

    /**
     * maximum x
     * @type {Number}
     */
    get maxX() {
      return this._max[0];
    }

    /**
     * maximum y
     * @type {Number}
     */
    get maxY() {
      return this._max[1];
    }

    /**
     * maximum z
     * @type {Number}
     */
    get maxZ() {
      return this._max[2];
    }

    apply(geom, mat) {
      if (!geom) {
        // console.warn("[boundingbox] no geom/vertices", geom);
        return;
      }

      if (geom instanceof BoundingBox) {
        const bb = geom;

        this.applyPos(bb.maxX, bb.maxY, bb.maxZ);
        this.applyPos(bb.minX, bb.minY, bb.minZ);
      } else {
        for (let i = 0; i < geom.vertices.length; i += 3)
          this.applyPos(
            geom.vertices[i],
            geom.vertices[i + 1],
            geom.vertices[i + 2]
          );
      }
      this.calcCenterSize();
    }

    /**
     * returns a copy of the bounding box
     * @function copy
     * @memberof BoundingBox
     * @instance
     */
    copy() {
      return new BoundingBox(this);
    }

    get changed() {
      return !(
        this._max[0] == -Number.MAX_VALUE &&
        this._max[1] == -Number.MAX_VALUE &&
        this._max[2] == -Number.MAX_VALUE
      );
    }

    applyPos(x, y, z) {
      if (
        x == Number.MAX_VALUE ||
        x == -Number.MAX_VALUE ||
        y == Number.MAX_VALUE ||
        y == -Number.MAX_VALUE ||
        z == Number.MAX_VALUE ||
        z == -Number.MAX_VALUE
      )
        return;

      if (
        !CABLES.UTILS.isNumeric(x) ||
        !CABLES.UTILS.isNumeric(y) ||
        !CABLES.UTILS.isNumeric(z)
      )
        return;

      if (this._first) {
        this._max[0] = x;
        this._max[1] = y;
        this._max[2] = z;

        this._min[0] = x;
        this._min[1] = y;
        this._min[2] = z;
        this._first = false;
        return;
      }

      this._max[0] = Math.max(this._max[0], x);
      this._max[1] = Math.max(this._max[1], y);
      this._max[2] = Math.max(this._max[2], z);

      this._min[0] = Math.min(this._min[0], x);
      this._min[1] = Math.min(this._min[1], y);
      this._min[2] = Math.min(this._min[2], z);
    }

    calcCenterSize() {
      if (this._first) return;

      this._size[0] = this._max[0] - this._min[0];
      this._size[1] = this._max[1] - this._min[1];
      this._size[2] = this._max[2] - this._min[2];

      this._center[0] = (this._min[0] + this._max[0]) / 2;
      this._center[1] = (this._min[1] + this._max[1]) / 2;
      this._center[2] = (this._min[2] + this._max[2]) / 2;

      this._maxAxis = Math.max(
        this._size[2],
        Math.max(this._size[0], this._size[1])
      );
    }

    mulMat4(m) {
      if (this._first) {
        this._max[0] = 0;
        this._max[1] = 0;
        this._max[2] = 0;

        this._min[0] = 0;
        this._min[1] = 0;
        this._min[2] = 0;
        this._first = false;
      }
      vec3.transformMat4(this._max, this._max, m);
      vec3.transformMat4(this._min, this._min, m);
      this.calcCenterSize();
    }

    render(cgl, shader, op) {
      if (!this._wireMesh) this._wireMesh = new CGL.WireCube(cgl);

      cgl.pushModelMatrix();
      mat4.translate(cgl.mMatrix, cgl.mMatrix, this._center);

      if (CABLES.UI && op) {
        CABLES.UI.OverlayMeshes.drawCube(
          op,
          this._size[0] / 2,
          this._size[1] / 2,
          this._size[2] / 2
        );
      }

      cgl.popModelMatrix();
    }
  } // CONCATENATED MODULE: ./src/core/cg/cg_geom.js

  // import { vec2, vec3 } from "gl-matrix";

  /**
   * a geometry contains all information about a mesh, vertices, texturecoordinates etc. etc.
   * @namespace external:CGL#Geometry
   * @param {String} name
   * @class
   * @example
   * // create a triangle with all attributes
   * const geom=new Geometry("triangle"),
   *
   * geom.vertices = [
   *      0.0,           sizeH.get(),  0.0,
   *     -sizeW.get(),  -sizeH.get(),  0.0,
   *      sizeW.get(),  -sizeH.get(),  0.0 ];
   *
   * geom.vertexNormals = [
   *      0.0,  0.0,  1.0,
   *      0.0,  0.0,  1.0,
   *      0.0,  0.0,  1.0 ];
   *
   * geom.tangents = [
   *     1,0,0,
   *     1,0,0,
   *     1,0,0 ];
   *
   * geom.biTangents = [
   *     0,1,0,
   *     0,1,0,
   *     0,1,0 ];
   *
   * geom.texCoords = [
   *      0.5,  0.0,
   *      1.0,  1.0,
   *      0.0,  1.0, ];
   *
   * geom.verticesIndices = [
   *     0, 1, 2 ];
   *
   */
  const Geometry = function (name) {
    this.name = name || "unknown";
    this._log = new Logger("cgl_geometry");

    this.faceVertCount = 3;
    this.glPrimitive = null;
    this._attributes = {};

    this._vertices = [];
    this.verticesIndices = [];

    this.isGeometry = true;

    this.morphTargets = [];

    Object.defineProperty(this, "vertices", {
      get() {
        return this._vertices;
      },
      set(v) {
        this.setVertices(v);
      },
    });

    Object.defineProperty(this, "texCoords", {
      get() {
        const att = this.getAttribute("texCoords");
        if (!att) return [];
        return att.data;
      },
      set(v) {
        this.setAttribute("texCoords", v, 2);
      },
    });

    Object.defineProperty(this, "vertexNormals", {
      get() {
        const att = this.getAttribute("vertexNormals");
        if (!att) return [];
        return att.data;
      },
      set(v) {
        this.setAttribute("vertexNormals", v, 3);
      },
    });

    Object.defineProperty(this, "tangents", {
      get() {
        const att = this.getAttribute("tangents");
        if (!att) return [];
        return att.data;
      },
      set(v) {
        this.setAttribute("tangents", v, 3);
      },
    });

    Object.defineProperty(this, "biTangents", {
      get() {
        const att = this.getAttribute("biTangents");
        if (!att) return [];
        return att.data;
      },
      set(v) {
        this.setAttribute("biTangents", v, 3);
      },
    });

    Object.defineProperty(this, "vertexColors", {
      get() {
        const att = this.getAttribute("vertexColors");
        if (!att) return [];
        return att.data;
      },
      set(v) {
        this.setAttribute("vertexColors", v, 4);
      },
    });
  };

  /**
   * @function clear
   * @memberof Geometry
   * @instance
   * @description clear all buffers/set them to length 0
   */
  Geometry.prototype.clear = function () {
    this._vertices = new Float32Array([]);
    this.verticesIndices = [];
    this.texCoords = new Float32Array([]);
    this.vertexNormals = new Float32Array([]);
    this.tangents = [];
    this.biTangents = [];
    this._attributes = {};
  };

  /**
 * @function getAttributes
   @memberof Geometry
 * @instance
 * @return {Array<Object>} returns array of attribute objects
 */
  Geometry.prototype.getAttributes = function () {
    return this._attributes;
  };

  /**
   * @function getAttribute
   * @memberof Geometry
   * @instance
   * @param {String} name
   * @return {Object}
   */
  Geometry.prototype.getAttribute = function (name) {
    for (const i in this._attributes) {
      if (this._attributes[i].name == name) return this._attributes[i];
    }
    return null;
  };

  /**
   * @function setAttribute
   * @description create an attribute
   * @memberof Geometry
   * @instance
   * @param {String} name
   * @param {Array} arr
   * @param {Number} itemSize
   */
  Geometry.prototype.setAttribute = function (name, arr, itemSize) {
    let attrType = "";
    if (!itemSize || itemSize > 4) {
      console.log("itemsize wrong?", itemSize, name);
      this._log.stack("itemsize");

      itemSize = 3;
    }

    if (itemSize == 1) attrType = "float";
    else if (itemSize == 2) attrType = "vec2";
    else if (itemSize == 3) attrType = "vec3";
    else if (itemSize == 4) attrType = "vec4";

    const attr = {
      name: name,
      data: arr,
      itemSize: itemSize,
      type: attrType,
    };

    this._attributes[name] = attr;
  };

  Geometry.prototype.copyAttribute = function (name, newgeom) {
    const attr = this.getAttribute(name);
    newgeom.setAttribute(name, new Float32Array(attr.data), attr.itemSize);
  };

  /**
   * @function setVertices
   * @memberof Geometry
   * @instance
   * @description set vertices
   * @param {Array|Float32Array} arr [x,y,z,x,y,z,...]
   */
  Geometry.prototype.setVertices = function (arr) {
    if (arr instanceof Float32Array) this._vertices = arr;
    else this._vertices = new Float32Array(arr);
  };

  /**
   * @function setTexCoords
   * @memberof Geometry
   * @instance
   * @description set texcoords
   * @param {Array|Float32Array} arr [u,v,u,v,...]
   */
  Geometry.prototype.setTexCoords = function (arr) {
    if (arr instanceof Float32Array) this.texCoords = arr;
    else this.texCoords = new Float32Array(arr);
  };

  // Geometry.prototype.testIndices = function ()
  // {
  //     var foundError = false;
  //     for (var i = 0; i < this.verticesIndices.length; i++)
  //     {
  //         if (this.verticesIndices[i * 3 + 0] >= this._vertices.length / 3 || this.verticesIndices[i * 3 + 1] >= this._vertices.length / 3 || this.verticesIndices[i * 3 + 2] >= this._vertices.length / 3)
  //         {
  //             foundError = true;
  //             console.log("index error!");
  //         }
  //     }
  // };

  // deprecated
  Geometry.prototype.calcNormals = function (smooth) {
    const options = { smooth: smooth };
    this.calculateNormals(options);
  };

  /**
   * @function flipNormals
   * @memberof Geometry
   * @param x
   * @param y
   * @param z
   * @description flip normals
   */
  Geometry.prototype.flipNormals = function (x, y, z) {
    let vec = vec3.create();

    if (x == undefined) x = 1;
    if (y == undefined) y = 1;
    if (z == undefined) z = 1;

    for (let i = 0; i < this.vertexNormals.length; i += 3) {
      vec3.set(
        vec,
        this.vertexNormals[i + 0],
        this.vertexNormals[i + 1],
        this.vertexNormals[i + 2]
      );

      vec[0] *= -x;
      vec[1] *= -y;
      vec[2] *= -z;

      vec3.normalize(vec, vec);

      this.vertexNormals[i + 0] = vec[0];
      this.vertexNormals[i + 1] = vec[1];
      this.vertexNormals[i + 2] = vec[2];
    }
  };

  Geometry.prototype.getNumTriangles = function () {
    if (this.verticesIndices && this.verticesIndices.length)
      return this.verticesIndices.length / 3;
    return this.vertices.length / 3;
  };

  /**
   * @function flipVertDir
   * @memberof Geometry
   * @description flip order of vertices in geom faces
   */
  Geometry.prototype.flipVertDir = function () {
    const newInd = [];
    newInd.length = this.verticesIndices.length;
    for (let i = 0; i < this.verticesIndices.length; i += 3) {
      newInd[i] = this.verticesIndices[i + 2];
      newInd[i + 1] = this.verticesIndices[i + 1];
      newInd[i + 2] = this.verticesIndices[i];
    }
    this.verticesIndices = newInd;
  };

  Geometry.prototype.setPointVertices = function (verts) {
    if (verts.length % 3 !== 0) {
      this._log.error("SetPointVertices: Array must be multiple of three.");
      return;
    }

    if (!(verts instanceof Float32Array))
      this.vertices = new Float32Array(verts);
    else this.vertices = verts;

    if (!(this.texCoords instanceof Float32Array))
      this.texCoords = new Float32Array((verts.length / 3) * 2);

    // this.texCoords.length=verts.length/3*2;
    this.verticesIndices.length = verts.length / 3;
    // this.verticesIndices=[];

    for (let i = 0; i < verts.length / 3; i++) {
      this.verticesIndices[i] = i;
      this.texCoords[i * 2] = 0;
      this.texCoords[i * 2 + 1] = 0;
    }
  };

  /**
   * merge a different geometry into the this geometry
   * @function merge
   * @param {Geometry} geom
   * @memberof Geometry
   * @instance
   */
  Geometry.prototype.merge = function (geom) {
    if (!geom) return;

    if (this.isIndexed() != geom.isIndexed()) {
      if (this.isIndexed()) {
        this.unIndex(false, true);
      }
      if (geom.isIndexed()) {
        const g = geom.copy();
        g.unIndex(false, true);
        geom = g;
      }
    }

    const oldIndizesLength = this.verticesIndices.length;
    const vertLength = this._vertices.length / 3;

    this.verticesIndices.length += geom.verticesIndices.length;
    for (let i = 0; i < geom.verticesIndices.length; i++)
      this.verticesIndices[oldIndizesLength + i] =
        geom.verticesIndices[i] + vertLength;

    this.vertices = UTILS.float32Concat(this._vertices, geom.vertices);
    this.texCoords = UTILS.float32Concat(this.texCoords, geom.texCoords);
    this.vertexNormals = UTILS.float32Concat(
      this.vertexNormals,
      geom.vertexNormals
    );
    this.tangents = UTILS.float32Concat(this.tangents, geom.tangents);
    this.biTangents = UTILS.float32Concat(this.biTangents, geom.biTangents);
  };

  /**
   *   a copy of the geometry
   * @function copy
   * @memberof Geometry
   * @instance
   */
  Geometry.prototype.copy = function () {
    const geom = new Geometry(this.name + " copy");
    geom.faceVertCount = this.faceVertCount;
    geom.glPrimitive = this.glPrimitive;

    geom.setVertices(this._vertices.slice(0));

    if (this.verticesIndices) {
      geom.verticesIndices.length = this.verticesIndices.length;
      for (let i = 0; i < this.verticesIndices.length; i++)
        geom.verticesIndices[i] = this.verticesIndices[i];
    }

    for (let i in this._attributes) this.copyAttribute(i, geom);

    geom.morphTargets.length = this.morphTargets.length;
    for (let i = 0; i < this.morphTargets.length; i++)
      geom.morphTargets[i] = this.morphTargets[i];

    return geom;
  };

  /**
   * Calculaten normals
   * @function calculateNormals
   * @memberof Geometry
   * @param options
   * @instance
   */
  Geometry.prototype.calculateNormals = function (options) {
    // todo: should check angle of normals to get edges    https://community.khronos.org/t/calculating-accurate-vertex-normals/28152
    options = options || {};
    if (options.smooth === false) this.unIndex();

    const u = vec3.create();
    const v = vec3.create();
    const n = vec3.create();

    function calcNormal(triangle) {
      vec3.subtract(u, triangle[0], triangle[1]);
      vec3.subtract(v, triangle[0], triangle[2]);
      vec3.cross(n, u, v);
      vec3.normalize(n, n);

      if (options && options.forceZUp) {
        if (n[2] < 0) {
          n[0] *= -1;
          n[1] *= -1;
          n[2] *= -1;
        }
      }
      return n;
    }

    this.getVertexVec = function (which) {
      const vec = [0, 0, 0];
      vec[0] = this.vertices[which * 3 + 0];
      vec[1] = this.vertices[which * 3 + 1];
      vec[2] = this.vertices[which * 3 + 2];
      return vec;
    };

    if (
      !(this.vertexNormals instanceof Float32Array) ||
      this.vertexNormals.length != this.vertices.length
    )
      this.vertexNormals = new Float32Array(this.vertices.length);

    for (let i = 0; i < this.vertices.length; i++) {
      this.vertexNormals[i] = 0;
    }

    if (!this.isIndexed()) {
      const norms = [];
      for (let i = 0; i < this.vertices.length; i += 9) {
        const triangle = [
          [this.vertices[i + 0], this.vertices[i + 1], this.vertices[i + 2]],
          [this.vertices[i + 3], this.vertices[i + 4], this.vertices[i + 5]],
          [this.vertices[i + 6], this.vertices[i + 7], this.vertices[i + 8]],
        ];
        const nn = calcNormal(triangle);
        norms.push(
          nn[0],
          nn[1],
          nn[2],
          nn[0],
          nn[1],
          nn[2],
          nn[0],
          nn[1],
          nn[2]
        );
      }
      this.vertexNormals = norms;
    } else {
      const faceNormals = [];

      faceNormals.length = Math.floor(this.verticesIndices.length / 3);

      for (let i = 0; i < this.verticesIndices.length; i += 3) {
        const triangle = [
          this.getVertexVec(this.verticesIndices[i + 0]),
          this.getVertexVec(this.verticesIndices[i + 1]),
          this.getVertexVec(this.verticesIndices[i + 2]),
        ];

        faceNormals[i / 3] = calcNormal(triangle);

        this.vertexNormals[this.verticesIndices[i + 0] * 3 + 0] +=
          faceNormals[i / 3][0];
        this.vertexNormals[this.verticesIndices[i + 0] * 3 + 1] +=
          faceNormals[i / 3][1];
        this.vertexNormals[this.verticesIndices[i + 0] * 3 + 2] +=
          faceNormals[i / 3][2];

        this.vertexNormals[this.verticesIndices[i + 1] * 3 + 0] +=
          faceNormals[i / 3][0];
        this.vertexNormals[this.verticesIndices[i + 1] * 3 + 1] +=
          faceNormals[i / 3][1];
        this.vertexNormals[this.verticesIndices[i + 1] * 3 + 2] +=
          faceNormals[i / 3][2];

        this.vertexNormals[this.verticesIndices[i + 2] * 3 + 0] +=
          faceNormals[i / 3][0];
        this.vertexNormals[this.verticesIndices[i + 2] * 3 + 1] +=
          faceNormals[i / 3][1];
        this.vertexNormals[this.verticesIndices[i + 2] * 3 + 2] +=
          faceNormals[i / 3][2];
      }

      for (
        let i = 0;
        i < this.verticesIndices.length;
        i += 3 // faces
      ) {
        for (
          let k = 0;
          k < 3;
          k++ // triangles
        ) {
          const vv = [
            this.vertexNormals[this.verticesIndices[i + k] * 3 + 0],
            this.vertexNormals[this.verticesIndices[i + k] * 3 + 1],
            this.vertexNormals[this.verticesIndices[i + k] * 3 + 2],
          ];
          vec3.normalize(vv, vv);
          this.vertexNormals[this.verticesIndices[i + k] * 3 + 0] = vv[0];
          this.vertexNormals[this.verticesIndices[i + k] * 3 + 1] = vv[1];
          this.vertexNormals[this.verticesIndices[i + k] * 3 + 2] = vv[2];
        }
      }
    }
  };

  /**
   * Calculates tangents & bitangents with the help of uv-coordinates. Adapted from
   * Lengyel, Eric. “Computing Tangent Space Basis Vectors for an Arbitrary Mesh”.
   * Terathon Software 3D Graphics Library.
   * https://fenix.tecnico.ulisboa.pt/downloadFile/845043405449073/Tangent%20Space%20Calculation.pdf
   *
   * @function calcTangentsBitangents
   * @memberof Geometry
   * @instance
   */
  Geometry.prototype.calcTangentsBitangents = function () {
    if (!this.vertices.length) {
      // this._log.error("Cannot calculate tangents/bitangents without vertices.");
      return;
    }
    if (!this.vertexNormals.length) {
      // this._log.error("Cannot calculate tangents/bitangents without normals.");
      return;
    }
    if (!this.texCoords.length) {
      // console.warn("No texcoords. Replacing with default values [0, 0].");
      const texCoordLength = (this.vertices.length / 3) * 2;
      this.texCoords = new Float32Array(texCoordLength);
      for (let i = 0; i < texCoordLength; i += 1) this.texCoords[i] = 0;
    }
    if (!this.verticesIndices || !this.verticesIndices.length) {
      // this._log.error("Cannot calculate tangents/bitangents without vertex indices.");
      return;
    }
    // this code assumes that we have three indices per triangle
    if (this.verticesIndices.length % 3 !== 0) {
      this._log.error("Vertex indices mismatch!");
      return;
    }

    const triangleCount = this.verticesIndices.length / 3;
    const vertexCount = this.vertices.length / 3;

    this.tangents = new Float32Array(this.vertexNormals.length);
    this.biTangents = new Float32Array(this.vertexNormals.length);

    // temporary buffers
    const tempVertices = [];
    tempVertices.length = vertexCount * 2;
    const v1 = vec3.create();
    const v2 = vec3.create();
    const v3 = vec3.create();

    const w1 = vec2.create();
    const w2 = vec2.create();
    const w3 = vec2.create();

    const sdir = vec3.create();
    const tdir = vec3.create();

    // for details on calculation, see article referenced above
    for (let tri = 0; tri < triangleCount; tri += 1) {
      // indices of the three vertices for a triangle
      const i1 = this.verticesIndices[tri * 3];
      const i2 = this.verticesIndices[tri * 3 + 1];
      const i3 = this.verticesIndices[tri * 3 + 2];

      // vertex position as vec3
      vec3.set(
        v1,
        this.vertices[i1 * 3],
        this.vertices[i1 * 3 + 1],
        this.vertices[i1 * 3 + 2]
      );
      vec3.set(
        v2,
        this.vertices[i2 * 3],
        this.vertices[i2 * 3 + 1],
        this.vertices[i2 * 3 + 2]
      );
      vec3.set(
        v3,
        this.vertices[i3 * 3],
        this.vertices[i3 * 3 + 1],
        this.vertices[i3 * 3 + 2]
      );

      // texture coordinate as vec2
      vec2.set(w1, this.texCoords[i1 * 2], this.texCoords[i1 * 2 + 1]);
      vec2.set(w2, this.texCoords[i2 * 2], this.texCoords[i2 * 2 + 1]);
      vec2.set(w3, this.texCoords[i3 * 2], this.texCoords[i3 * 2 + 1]);

      const x1 = v2[0] - v1[0];
      const x2 = v3[0] - v1[0];
      const y1 = v2[1] - v1[1];
      const y2 = v3[1] - v1[1];
      const z1 = v2[2] - v1[2];
      const z2 = v3[2] - v1[2];

      const s1 = w2[0] - w1[0];
      const s2 = w3[0] - w1[0];
      const t1 = w2[1] - w1[1];
      const t2 = w3[1] - w1[1];

      const r = 1.0 / (s1 * t2 - s2 * t1);

      vec3.set(
        sdir,
        (t2 * x1 - t1 * x2) * r,
        (t2 * y1 - t1 * y2) * r,
        (t2 * z1 - t1 * z2) * r
      );
      vec3.set(
        tdir,
        (s1 * x2 - s2 * x1) * r,
        (s1 * y2 - s2 * y1) * r,
        (s1 * z2 - s2 * z1) * r
      );

      tempVertices[i1] = sdir;
      tempVertices[i2] = sdir;
      tempVertices[i3] = sdir;

      tempVertices[i1 + vertexCount] = tdir;
      tempVertices[i2 + vertexCount] = tdir;
      tempVertices[i3 + vertexCount] = tdir;
    }

    const normal = vec3.create();
    const tempVert = vec3.create();
    const tan = vec3.create();
    const bitan = vec3.create();
    const temp1 = vec3.create();
    const temp2 = vec3.create();
    const crossPd = vec3.create();
    const normalized = vec3.create();

    for (let vert = 0; vert < vertexCount; vert += 1) {
      // NOTE: some meshes don't have index 0 - n in their indexbuffer, if this is the case, skip calculation of this vertex
      if (!tempVertices[vert]) continue;

      vec3.set(
        normal,
        this.vertexNormals[vert * 3],
        this.vertexNormals[vert * 3 + 1],
        this.vertexNormals[vert * 3 + 2]
      );
      vec3.set(
        tempVert,
        tempVertices[vert][0],
        tempVertices[vert][1],
        tempVertices[vert][2]
      );

      // Gram-Schmidt orthagonalize
      const _dp = vec3.dot(normal, tempVert);
      vec3.scale(temp1, normal, _dp);
      vec3.subtract(temp2, tempVert, temp1);

      vec3.normalize(normalized, temp2);
      vec3.cross(crossPd, normal, tempVert);

      // const intermDot = vec3.dot(crossPd, tempVertices[vert + vertexCount]);
      const w = 1.0; // intermDot < 0.0 ? -1.0 : 1.0;

      vec3.scale(tan, normalized, 1 / w);
      vec3.cross(bitan, normal, tan);

      this.tangents[vert * 3 + 0] = tan[0];
      this.tangents[vert * 3 + 1] = tan[1];
      this.tangents[vert * 3 + 2] = tan[2];
      this.biTangents[vert * 3 + 0] = bitan[0];
      this.biTangents[vert * 3 + 1] = bitan[1];
      this.biTangents[vert * 3 + 2] = bitan[2];
    }
  };

  Geometry.prototype.isIndexed = function () {
    if (this._vertices.length == 0) return true;
    return this.verticesIndices.length != 0;
  };

  /**
   * @function unIndex
   * @memberof Geometry
   * @instance
   * @description remove all vertex indizes, vertices array will contain 3*XYZ for every triangle
   * @param {boolean} reIndex
   * @param {boolean} dontCalcNormals
   */
  Geometry.prototype.unIndex = function (reIndex, dontCalcNormals) {
    const newVerts = [];
    const newIndizes = [];
    let count = 0;

    for (let j in this._attributes) {
      const attr = this._attributes[j];
      let na = [];

      for (let i = 0; i < this.verticesIndices.length; i += 3) {
        for (let s = 0; s < 3; s++) {
          if (attr.itemSize == 3)
            na.push(
              attr.data[this.verticesIndices[i + s] * 3 + 0],
              attr.data[this.verticesIndices[i + s] * 3 + 1],
              attr.data[this.verticesIndices[i + s] * 3 + 2]
            );
          else if (attr.itemSize == 4)
            na.push(
              attr.data[this.verticesIndices[i + s] * 4 + 0],
              attr.data[this.verticesIndices[i + s] * 4 + 1],
              attr.data[this.verticesIndices[i + s] * 4 + 2],
              attr.data[this.verticesIndices[i + s] * 4 + 3]
            );
          else if (attr.itemSize == 2)
            na.push(
              attr.data[this.verticesIndices[i + s] * 2 + 0],
              attr.data[this.verticesIndices[i + s] * 2 + 1]
            );
          else if (attr.itemSize == 1)
            na.push(attr.data[this.verticesIndices[i + s]]);
          else console.log("unknown attr", attr);
        }
      }
      this.setAttribute(attr.name, na, attr.itemSize);
    }

    for (let i = 0; i < this.verticesIndices.length; i += 3) {
      newVerts.push(
        this.vertices[this.verticesIndices[i + 0] * 3 + 0],
        this.vertices[this.verticesIndices[i + 0] * 3 + 1],
        this.vertices[this.verticesIndices[i + 0] * 3 + 2]
      );

      newIndizes.push(count);
      count++;

      newVerts.push(
        this.vertices[this.verticesIndices[i + 1] * 3 + 0],
        this.vertices[this.verticesIndices[i + 1] * 3 + 1],
        this.vertices[this.verticesIndices[i + 1] * 3 + 2]
      );

      newIndizes.push(count);
      count++;

      newVerts.push(
        this.vertices[this.verticesIndices[i + 2] * 3 + 0],
        this.vertices[this.verticesIndices[i + 2] * 3 + 1],
        this.vertices[this.verticesIndices[i + 2] * 3 + 2]
      );

      newIndizes.push(count);
      count++;
    }

    this.vertices = newVerts;

    this.verticesIndices = [];
    if (reIndex) this.verticesIndices = newIndizes;

    if (!dontCalcNormals) this.calculateNormals();
  };

  Geometry.prototype.calcBarycentric = function () {
    let barycentrics = [];
    barycentrics.length = this.vertices.length;
    for (let i = 0; i < this.vertices.length; i++) barycentrics[i] = 0;

    let count = 0;
    for (let i = 0; i < this.vertices.length; i += 3) {
      barycentrics[i + count] = 1;
      count++;
      if (count == 3) count = 0;
    }

    this.setAttribute("attrBarycentric", barycentrics, 3);
  };

  Geometry.prototype.getBounds = function () {
    return new BoundingBox(this);
  };

  Geometry.prototype.center = function (x, y, z) {
    if (x === undefined) {
      x = true;
      y = true;
      z = true;
    }

    let i = 0;
    const bounds = this.getBounds();
    const offset = [
      bounds.minX + (bounds.maxX - bounds.minX) / 2,
      bounds.minY + (bounds.maxY - bounds.minY) / 2,
      bounds.minZ + (bounds.maxZ - bounds.minZ) / 2,
    ];

    for (i = 0; i < this.vertices.length; i += 3) {
      if (this.vertices[i + 0] == this.vertices[i + 0]) {
        if (x) this.vertices[i + 0] -= offset[0];
        if (y) this.vertices[i + 1] -= offset[1];
        if (z) this.vertices[i + 2] -= offset[2];
      }
    }

    return offset;
  };

  Geometry.prototype.mapTexCoords2d = function () {
    const bounds = this.getBounds();
    const num = this.vertices.length / 3;

    this.texCoords = new Float32Array(num * 2);

    for (let i = 0; i < num; i++) {
      const vertX = this.vertices[i * 3 + 0];
      const vertY = this.vertices[i * 3 + 1];
      this.texCoords[i * 2 + 0] = vertX / (bounds.maxX - bounds.minX) + 0.5;
      this.texCoords[i * 2 + 1] =
        1.0 - vertY / (bounds.maxY - bounds.minY) + 0.5;
    }
  };

  Geometry.prototype.getInfoOneLine = function () {
    let txt = "";
    if (this.faceVertCount == 3 && this.verticesIndices)
      txt += this.verticesIndices.length / 3;
    else txt += 0;

    txt += " tris ";

    if (this.vertices) txt += this.vertices.length / 3;
    else txt += 0;

    txt += " verts";

    return txt;
  };

  Geometry.prototype.getInfo = function () {
    const info = {};

    if (this.faceVertCount == 3 && this.verticesIndices)
      info.numFaces = this.verticesIndices.length / 3;
    else info.numFaces = 0;

    if (this.verticesIndices && this.verticesIndices.length)
      info.indices = this.verticesIndices.length;

    if (this.vertices) info.numVerts = this.vertices.length / 3;
    else info.numVerts = 0;

    if (this.vertexNormals) info.numNormals = this.vertexNormals.length / 3;
    else info.numNormals = 0;

    if (this.texCoords) info.numTexCoords = this.texCoords.length / 2;
    else info.numTexCoords = 0;

    if (this.tangents) info.numTangents = this.tangents.length / 3;
    else info.numTangents = 0;

    if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;
    else info.numBiTangents = 0;

    if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;
    else info.numBiTangents = 0;

    if (this.vertexColors) info.numVertexColors = this.vertexColors.length / 4;
    else info.numVertexColors = 0;

    if (this.getAttributes())
      info.numAttribs = Object.keys(this.getAttributes()).length;
    else info.numAttribs = 0;

    info.isIndexed = this.isIndexed();

    return info;
  };

  // -----------------

  // TODO : rewritwe circle op
  Geometry.buildFromFaces = function (arr, name, optimize) {
    const vertices = [];
    const verticesIndices = [];

    for (let i = 0; i < arr.length; i += 3) {
      const a = arr[i + 0];
      const b = arr[i + 1];
      const c = arr[i + 2];
      const face = [-1, -1, -1];

      if (optimize)
        for (let iv = 0; iv < vertices.length; iv += 3) {
          if (
            vertices[iv + 0] == a[0] &&
            vertices[iv + 1] == a[1] &&
            vertices[iv + 2] == a[2]
          )
            face[0] = iv / 3;
          if (
            vertices[iv + 0] == b[0] &&
            vertices[iv + 1] == b[1] &&
            vertices[iv + 2] == b[2]
          )
            face[1] = iv / 3;
          if (
            vertices[iv + 0] == c[0] &&
            vertices[iv + 1] == c[1] &&
            vertices[iv + 2] == c[2]
          )
            face[2] = iv / 3;
        }

      if (face[0] == -1) {
        vertices.push(a[0], a[1], a[2]);
        face[0] = (vertices.length - 1) / 3;
      }

      if (face[1] == -1) {
        vertices.push(b[0], b[1], b[2]);
        face[1] = (vertices.length - 1) / 3;
      }

      if (face[2] == -1) {
        vertices.push(c[0], c[1], c[2]);
        face[2] = (vertices.length - 1) / 3;
      }

      verticesIndices.push(parseInt(face[0], 10));
      verticesIndices.push(parseInt(face[1], 10));
      verticesIndices.push(parseInt(face[2], 10));
    }

    const geom = new Geometry(name);
    geom.name = name;
    geom.vertices = vertices;
    geom.verticesIndices = verticesIndices;

    return geom;
  }; // CONCATENATED MODULE: ./src/core/cgl/cgl_mesh.js

  const MESH = {};
  MESH.lastMesh = null;

  /**
   * webgl renderable 3d object
   * @class
   * @namespace external:CGL
   * @hideconstructor
   * @param {Context} _cgl cgl
   * @param {Geometry} __geom geometry
   * @param {Number} _options glPrimitive
   * @example
   * const cgl=this._cgl
   * const mesh=new CGL.Mesh(cgl, geometry);
   *
   * function render()
   * {
   *   mesh.render(cgl.getShader());
   * }
   */
  const Mesh = function (_cgl, __geom, _options) {
    this._cgl = _cgl;

    let options = _options || {};
    if (CABLES.UTILS.isNumeric(options)) options = { glPrimitive: _options }; // old constructor fallback...
    this._log = new Logger("cgl_mesh");
    this._bufVertexAttrib = null;
    this._bufVerticesIndizes = this._cgl.gl.createBuffer();
    this._indexType = this._cgl.gl.UNSIGNED_SHORT;
    this._attributes = [];
    this._attribLocs = {};
    this._geom = null;
    this._lastShader = null;
    this._numInstances = 0;
    this._glPrimitive = options.glPrimitive;

    this.opId = options.opId || "";
    this._preWireframeGeom = null;
    this.addVertexNumbers = false;
    this._name = "unknown";

    this.feedBackAttributes = [];
    this.setGeom(__geom);

    this._feedBacks = [];
    this._feedBacksChanged = false;
    this._transformFeedBackLoc = -1;
    this._lastAttrUpdate = 0;

    this.memFreed = false;

    this._cgl.profileData.addHeavyEvent("mesh constructed", this._name);

    this._queryExt = null;

    Object.defineProperty(this, "numInstances", {
      get() {
        return this._numInstances;
      },
      set(v) {
        this.setNumInstances(v);
      },
    });
  };

  Mesh.prototype.freeMem = function () {
    this.memFreed = true;

    for (let i = 0; i < this._attributes.length; i++) {
      this._attributes[i].floatArray = null;
    }
  };

  /**
   * @function updateVertices
   * @memberof Mesh
   * @instance
   * @description update vertices only from a geometry
   * @param {Geometry} geom
   */
  Mesh.prototype.updateVertices = function (geom) {
    this.setAttribute(
      constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION,
      geom.vertices,
      3
    );
    this._numVerts = geom.vertices.length / 3;
  };

  Mesh.prototype.setAttributePointer = function (
    attrName,
    name,
    stride,
    offset
  ) {
    for (let i = 0; i < this._attributes.length; i++) {
      if (this._attributes[i].name == attrName) {
        if (!this._attributes[i].pointer) this._attributes[i].pointer = [];

        this._attributes[i].pointer.push({
          loc: -1,
          name: name,
          stride: stride,
          offset: offset,
          instanced:
            attrName == constants_CONSTANTS.SHADER.SHADERVAR_INSTANCE_MMATRIX,
        });
      }
    }
  };

  Mesh.prototype.getAttribute = function (name) {
    for (let i = 0; i < this._attributes.length; i++)
      if (this._attributes[i].name == name) return this._attributes[i];
  };

  Mesh.prototype.setAttributeRange = function (attr, array, start, end) {
    if (!attr) return;
    if (!start && !end) return;

    if (!attr.name) {
      this._log.stack("no attrname?!");
    }

    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);
    this._cgl.profileData.profileMeshAttributes += end - start || 0;

    this._cgl.profileData.profileSingleMeshAttribute[this._name] =
      this._cgl.profileData.profileSingleMeshAttribute[this._name] || 0;
    this._cgl.profileData.profileSingleMeshAttribute[this._name] +=
      end - start || 0;

    if (attr.numItems < array.length / attr.itemSize) {
      this._resizeAttr(array, attr);
    }

    if (end > array.length) {
      if (CABLES.platform.isDevEnv())
        this._log.log(
          this._cgl.canvas.id +
            " " +
            attr.name +
            " buffersubdata out of bounds ?",
          array.length,
          end,
          start,
          attr
        );
      // end = array.length - 1;
      return;
    }

    if (this._cgl.glVersion == 1)
      this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, 0, array);
    // probably slow/ maybe create and array with only changed size ??
    else
      this._cgl.gl.bufferSubData(
        this._cgl.gl.ARRAY_BUFFER,
        start * 4,
        array,
        start,
        end - start
      );
  };

  Mesh.prototype._resizeAttr = function (array, attr) {
    if (attr.buffer) this._cgl.gl.deleteBuffer(attr.buffer);

    attr.buffer = this._cgl.gl.createBuffer();
    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);
    this._bufferArray(array, attr);
    attr.numItems = array.length / attr.itemSize; // numItems;
  };

  Mesh.prototype._bufferArray = function (array, attr) {
    let floatArray = attr.floatArray || null;
    if (!array) return;

    if (this._cgl.debugOneFrame) {
      console.log("_bufferArray", array.length, attr.name); // eslint-disable-line
    }

    if (!(array instanceof Float32Array)) {
      if (attr && floatArray && floatArray.length == array.length) {
        floatArray.set(array);
        // floatArray = floatArray;
      } else {
        floatArray = new Float32Array(array);

        if (this._cgl.debugOneFrame) {
          console.log(
            "_bufferArray create new float32array",
            array.length,
            attr.name
          ); // eslint-disable-line
        }

        if (array.length > 10000) {
          this._cgl.profileData.profileNonTypedAttrib++;
          this._cgl.profileData.profileNonTypedAttribNames =
            "(" + this._name + ":" + attr.name + ")";
        }
      }
    } else floatArray = array;

    attr.arrayLength = floatArray.length;
    attr.floatArray = null; // floatArray;

    this._cgl.gl.bufferData(
      this._cgl.gl.ARRAY_BUFFER,
      floatArray,
      this._cgl.gl.DYNAMIC_DRAW
    );
  };

  /**
   * @function setAttribute
   * @description update attribute
   * @memberof Mesh
   * @instance
   * @param {String} attribute name
   * @param {Array} data
   * @param {Number} itemSize
   * @param {Object} options
   */
  Mesh.prototype.addAttribute =
    Mesh.prototype.updateAttribute =
    Mesh.prototype.setAttribute =
      function (name, array, itemSize, options) {
        if (!array) {
          this._log.error("mesh addAttribute - no array given! " + name);
          throw new Error();
        }
        let cb = null;
        let instanced = false;
        let i = 0;
        const numItems = array.length / itemSize;

        this._cgl.profileData.profileMeshAttributes += numItems || 0;

        if (typeof options == "function") {
          cb = options;
        }

        if (typeof options == "object") {
          if (options.cb) cb = options.cb;
          if (options.instanced) instanced = options.instanced;
        }

        if (name == constants_CONSTANTS.SHADER.SHADERVAR_INSTANCE_MMATRIX)
          instanced = true;

        for (i = 0; i < this._attributes.length; i++) {
          const attr = this._attributes[i];
          if (attr.name == name) {
            if (attr.numItems === numItems) {
            } else {
              // this._log.log("wrong buffer size", this._geom.name, attr.name, attr.numItems, numItems);
              this._resizeAttr(array, attr);
            }

            this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);
            this._bufferArray(array, attr);

            return attr;
          }
        }

        // create new buffer...

        const buffer = this._cgl.gl.createBuffer();

        this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, buffer);
        // this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, floatArray, this._cgl.gl.DYNAMIC_DRAW);

        let type = this._cgl.gl.FLOAT;
        if (options && options.type) type = options.type;
        const attr = {
          buffer: buffer,
          name: name,
          cb: cb,
          itemSize: itemSize,
          numItems: numItems,
          startItem: 0,
          instanced: instanced,
          type: type,
        };

        this._bufferArray(array, attr);

        if (name == constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION)
          this._bufVertexAttrib = attr;
        this._attributes.push(attr);
        this._attribLocs = {};

        return attr;
      };

  Mesh.prototype.getAttributes = function () {
    return this._attributes;
  };

  /**
   * @function updateTexCoords
   * @description update texture coordinates only from a geometry
   * @memberof Mesh
   * @instance
   * @param {Geometry} geom
   */
  Mesh.prototype.updateTexCoords = function (geom) {
    if (geom.texCoords && geom.texCoords.length > 0) {
      this.setAttribute(
        constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD,
        geom.texCoords,
        2
      );
    } else {
      const tcBuff = new Float32Array(
        Math.round((geom.vertices.length / 3) * 2)
      );
      this.setAttribute(
        constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD,
        tcBuff,
        2
      );
    }
  };

  /**
   * @function updateNormals
   * @description update normals only from a geometry
   * @memberof Mesh
   * @instance
   * @param {Geometry} geom
   */
  Mesh.prototype.updateNormals = function (geom) {
    if (geom.vertexNormals && geom.vertexNormals.length > 0) {
      this.setAttribute(
        constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL,
        geom.vertexNormals,
        3
      );
    } else {
      const tcBuff = new Float32Array(Math.round(geom.vertices.length));
      this.setAttribute(
        constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL,
        tcBuff,
        3
      );
    }
  };

  Mesh.prototype._setVertexNumbers = function (arr) {
    if (
      !this._verticesNumbers ||
      this._verticesNumbers.length != this._numVerts ||
      arr
    ) {
      if (arr) this._verticesNumbers = arr;
      else {
        this._verticesNumbers = new Float32Array(this._numVerts);
        for (let i = 0; i < this._numVerts; i++) this._verticesNumbers[i] = i;
      }

      this.setAttribute(
        constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_NUMBER,
        this._verticesNumbers,
        1,
        (attr, geom, shader) => {
          if (!shader.uniformNumVertices)
            shader.uniformNumVertices = new Uniform(
              shader,
              "f",
              "numVertices",
              this._numVerts
            );
          shader.uniformNumVertices.setValue(this._numVerts);

          // console.log("this._numVerts", this._numVerts, attr, shader.uniformNumVertices);
        }
      );
    }
  };

  /**
   * @function setVertexIndices
   * @description update vertex indices / faces
   * @memberof Mesh
   * @instance
   * @param {array} vertIndices
   */
  Mesh.prototype.setVertexIndices = function (vertIndices) {
    if (!this._bufVerticesIndizes) {
      this._log.warn("no bufVerticesIndizes: " + this._name);
      return;
    }
    if (vertIndices.length > 0) {
      if (vertIndices instanceof Float32Array)
        this._log.warn("vertIndices float32Array: " + this._name);

      for (let i = 0; i < vertIndices.length; i++) {
        if (vertIndices[i] >= this._numVerts) {
          this._log.warn("invalid index in " + this._name, i, vertIndices[i]);
          return;
        }
      }

      this._cgl.gl.bindBuffer(
        this._cgl.gl.ELEMENT_ARRAY_BUFFER,
        this._bufVerticesIndizes
      );

      // todo cache this ?
      // if(!this.vertIndicesTyped || this.vertIndicesTyped.length!=this._geom.verticesIndices.length)

      if (vertIndices.length > 65535) {
        this.vertIndicesTyped = new Uint32Array(vertIndices);
        this._indexType = this._cgl.gl.UNSIGNED_INT;
      } else if (vertIndices instanceof Uint32Array) {
        this.vertIndicesTyped = vertIndices;
        this._indexType = this._cgl.gl.UNSIGNED_INT;
      } else if (!(vertIndices instanceof Uint16Array)) {
        this.vertIndicesTyped = new Uint16Array(vertIndices);
        this._indexType = this._cgl.gl.UNSIGNED_SHORT;
      } else this.vertIndicesTyped = vertIndices;

      this._cgl.gl.bufferData(
        this._cgl.gl.ELEMENT_ARRAY_BUFFER,
        this.vertIndicesTyped,
        this._cgl.gl.DYNAMIC_DRAW
      );
      this._bufVerticesIndizes.itemSize = 1;
      this._bufVerticesIndizes.numItems = vertIndices.length;
    } else this._bufVerticesIndizes.numItems = 0;
  };

  /**
   * @function setGeom
   * @memberof Mesh
   * @instance
   * @description set geometry for mesh
   * @param {Geometry} geom
   * @param {boolean} removeRef
   */
  Mesh.prototype.setGeom = function (geom, removeRef) {
    this._geom = geom;
    if (geom.glPrimitive != null) this._glPrimitive = geom.glPrimitive;
    if (this._geom && this._geom.name) this._name = "mesh " + this._geom.name;

    MESH.lastMesh = null;
    this._cgl.profileData.profileMeshSetGeom++;

    this._disposeAttributes();

    this.updateVertices(this._geom);
    this.setVertexIndices(this._geom.verticesIndices);

    if (this.addVertexNumbers) this._setVertexNumbers();

    const geomAttribs = this._geom.getAttributes();

    const attribAssoc = {
      texCoords: constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD,
      vertexNormals: constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL,
      vertexColors: constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_COLOR,
      tangents: "attrTangent",
      biTangents: "attrBiTangent",
    };

    for (const index in geomAttribs)
      if (geomAttribs[index].data && geomAttribs[index].data.length)
        this.setAttribute(
          attribAssoc[index] || index,
          geomAttribs[index].data,
          geomAttribs[index].itemSize
        );

    if (removeRef) {
      this._geom = null;
    }
  };

  Mesh.prototype._preBind = function (shader) {
    for (let i = 0; i < this._attributes.length; i++)
      if (this._attributes[i].cb)
        this._attributes[i].cb(this._attributes[i], this._geom, shader);
  };

  Mesh.prototype._checkAttrLengths = function () {
    if (this.memFreed) return;
    // check length
    for (let i = 0; i < this._attributes.length; i++) {
      if (
        this._attributes[i].arrayLength / this._attributes[i].itemSize <
        this._attributes[0].arrayLength / this._attributes[0].itemSize
      ) {
        let name = "unknown";
        if (this._geom) name = this._geom.name;
        // this._log.warn(
        //     name + ": " + this._attributes[i].name +
        //     " wrong attr length. is:", this._attributes[i].arrayLength / this._attributes[i].itemSize,
        //     " should be:", this._attributes[0].arrayLength / this._attributes[0].itemSize,
        // );
      }
    }
  };

  Mesh.prototype._bind = function (shader) {
    if (!shader.isValid()) return;

    let attrLocs = [];
    if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];
    else this._attribLocs[shader.id] = attrLocs;

    this._lastShader = shader;
    if (
      shader.lastCompile > this._lastAttrUpdate ||
      attrLocs.length != this._attributes.length
    ) {
      this._lastAttrUpdate = shader.lastCompile;
      for (let i = 0; i < this._attributes.length; i++) attrLocs[i] = -1;
    }

    for (let i = 0; i < this._attributes.length; i++) {
      const attribute = this._attributes[i];
      if (attrLocs[i] == -1) {
        if (attribute._attrLocationLastShaderTime != shader.lastCompile) {
          attribute._attrLocationLastShaderTime = shader.lastCompile;
          attrLocs[i] = this._cgl.glGetAttribLocation(
            shader.getProgram(),
            attribute.name
          );
          // this._log.log('attribloc',attribute.name,attrLocs[i]);
          this._cgl.profileData.profileAttrLoc++;
        }
      }

      if (attrLocs[i] != -1) {
        this._cgl.gl.enableVertexAttribArray(attrLocs[i]);
        this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attribute.buffer);

        if (attribute.instanced) {
          // todo: easier way to fill mat4 attribs...
          if (attribute.itemSize <= 4) {
            if (!attribute.itemSize || attribute.itemSize == 0)
              this._log.warn(
                "instanced attrib itemsize error",
                this._geom.name,
                attribute
              );

            this._cgl.gl.vertexAttribPointer(
              attrLocs[i],
              attribute.itemSize,
              attribute.type,
              false,
              attribute.itemSize * 4,
              0
            );
            this._cgl.gl.vertexAttribDivisor(attrLocs[i], 1);
          } else if (attribute.itemSize == 16) {
            const stride = 16 * 4;

            this._cgl.gl.vertexAttribPointer(
              attrLocs[i],
              4,
              attribute.type,
              false,
              stride,
              0
            );
            this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 1);
            this._cgl.gl.vertexAttribPointer(
              attrLocs[i] + 1,
              4,
              attribute.type,
              false,
              stride,
              4 * 4 * 1
            );
            this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 2);
            this._cgl.gl.vertexAttribPointer(
              attrLocs[i] + 2,
              4,
              attribute.type,
              false,
              stride,
              4 * 4 * 2
            );
            this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 3);
            this._cgl.gl.vertexAttribPointer(
              attrLocs[i] + 3,
              4,
              attribute.type,
              false,
              stride,
              4 * 4 * 3
            );

            this._cgl.gl.vertexAttribDivisor(attrLocs[i], 1);
            this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 1);
            this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 1);
            this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 1);
          } else {
            this._log.warn("unknown instance attrib size", attribute.name);
          }
        } else {
          if (!attribute.itemSize || attribute.itemSize == 0)
            this._log.warn("attrib itemsize error", this._name, attribute);
          this._cgl.gl.vertexAttribPointer(
            attrLocs[i],
            attribute.itemSize,
            attribute.type,
            false,
            attribute.itemSize * 4,
            0
          );

          if (attribute.pointer) {
            for (let ip = 0; ip < attribute.pointer.length; ip++) {
              const pointer = attribute.pointer[ip];

              if (pointer.loc == -1)
                pointer.loc = this._cgl.glGetAttribLocation(
                  shader.getProgram(),
                  pointer.name
                );

              this._cgl.profileData.profileAttrLoc++;

              this._cgl.gl.enableVertexAttribArray(pointer.loc);
              this._cgl.gl.vertexAttribPointer(
                pointer.loc,
                attribute.itemSize,
                attribute.type,
                false,
                pointer.stride,
                pointer.offset
              );
            }
          }
          if (this.bindFeedback) this.bindFeedback(attribute);
        }
      }
    }

    if (this._bufVerticesIndizes && this._bufVerticesIndizes.numItems !== 0)
      this._cgl.gl.bindBuffer(
        this._cgl.gl.ELEMENT_ARRAY_BUFFER,
        this._bufVerticesIndizes
      );
  };

  Mesh.prototype.unBind = function () {
    const shader = this._lastShader;
    this._lastShader = null;
    if (!shader) return;

    let attrLocs = [];
    if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];
    else this._attribLocs[shader.id] = attrLocs;

    MESH.lastMesh = null;

    for (let i = 0; i < this._attributes.length; i++) {
      if (this._attributes[i].instanced) {
        // todo: easier way to fill mat4 attribs...
        if (this._attributes[i].itemSize <= 4) {
          if (attrLocs[i] != -1)
            this._cgl.gl.vertexAttribDivisor(attrLocs[i], 0);
          if (attrLocs[i] >= 0)
            this._cgl.gl.disableVertexAttribArray(attrLocs[i]);
        } else {
          this._cgl.gl.vertexAttribDivisor(attrLocs[i], 0);
          this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 0);
          this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 0);
          this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 0);
          this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 1);
          this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 2);
          this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 3);
        }
      }

      if (attrLocs[i] != -1) this._cgl.gl.disableVertexAttribArray(attrLocs[i]);
    }
  };

  Mesh.prototype.meshChanged = function () {
    return this._cgl.lastMesh && this._cgl.lastMesh != this;
  };

  Mesh.prototype.printDebug = function (shader) {
    console.log("--attributes");
    for (let i = 0; i < this._attributes.length; i++) {
      console.log("attribute " + i + " " + this._attributes[i].name);
    }
  };

  Mesh.prototype.setNumVertices = function (num) {
    this._bufVertexAttrib.numItems = num;
  };

  Mesh.prototype.getNumVertices = function () {
    return this._bufVertexAttrib.numItems;
  };

  /**
   * @function render
   * @memberof Mesh
   * @instance
   * @description draw mesh to screen
   * @param {Shader} shader
   */
  Mesh.prototype.render = function (shader) {
    // TODO: enable/disablevertex only if the mesh has changed... think drawing 10000x the same mesh

    if (!shader || !shader.isValid() || this._cgl.aborted) return;

    this._checkAttrLengths();

    if (this._geom) {
      if (
        this._preWireframeGeom &&
        !shader.wireframe &&
        !this._geom.isIndexed()
      ) {
        this.setGeom(this._preWireframeGeom);
        this._preWireframeGeom = null;
        // console.log("remove prewireframe geom");
      }

      if (shader.wireframe) {
        let changed = false;

        if (this._geom.isIndexed()) {
          if (!this._preWireframeGeom) {
            this._preWireframeGeom = this._geom;
            this._geom = this._geom.copy();
          }

          this._geom.unIndex();
          changed = true;
        }

        if (!this._geom.getAttribute("attrBarycentric")) {
          if (!this._preWireframeGeom) {
            this._preWireframeGeom = this._geom;
            this._geom = this._geom.copy();
          }
          changed = true;

          this._geom.calcBarycentric();
        }
        if (changed) this.setGeom(this._geom);
      }
      // if (shader.wireframe)
      // console.log(shader.wireframe, this._geom.isIndexed());
    }

    let needsBind = false;
    if (MESH.lastMesh != this) {
      if (MESH.lastMesh) MESH.lastMesh.unBind();
      needsBind = true;
    }

    // var needsBind=false;
    // {
    //     needsBind=true;
    // }
    if (needsBind) this._preBind(shader);

    if (!shader.bind()) return;

    // if(needsBind)
    this._bind(shader);
    if (this.addVertexNumbers) this._setVertexNumbers();

    MESH.lastMesh = this;

    let prim = this._cgl.gl.TRIANGLES;
    if (this._glPrimitive !== undefined) prim = this._glPrimitive;
    if (shader.glPrimitive !== null) prim = shader.glPrimitive;

    let elementDiv = 1;
    let doQuery = this._cgl.profileData.doProfileGlQuery;
    let queryStarted = false;
    if (doQuery) {
      let id = this._name + " - " + shader.getName() + " #" + shader.id;
      if (this._numInstances) id += " instanced " + this._numInstances + "x";

      let queryProfilerData = this._cgl.profileData.glQueryData[id];

      if (!queryProfilerData) queryProfilerData = { id: id, num: 0 };

      if (shader.opId) queryProfilerData.shaderOp = shader.opId;
      if (this.opId) queryProfilerData.meshOp = this.opId;

      this._cgl.profileData.glQueryData[id] = queryProfilerData;

      if (!this._queryExt && this._queryExt !== false)
        this._queryExt =
          this._cgl.enableExtension("EXT_disjoint_timer_query_webgl2") || false;
      if (this._queryExt) {
        if (queryProfilerData._drawQuery) {
          const available = this._cgl.gl.getQueryParameter(
            queryProfilerData._drawQuery,
            this._cgl.gl.QUERY_RESULT_AVAILABLE
          );
          if (available) {
            const elapsedNanos = this._cgl.gl.getQueryParameter(
              queryProfilerData._drawQuery,
              this._cgl.gl.QUERY_RESULT
            );
            const currentTimeGPU = elapsedNanos / 1000000;

            queryProfilerData._times = queryProfilerData._times || 0;
            queryProfilerData._times += currentTimeGPU;
            queryProfilerData._numcount++;
            queryProfilerData.when = performance.now();
            queryProfilerData._drawQuery = null;
            queryProfilerData.queryStarted = false;
          }
        }

        if (!queryProfilerData.queryStarted) {
          queryProfilerData._drawQuery = this._cgl.gl.createQuery();
          this._cgl.gl.beginQuery(
            this._queryExt.TIME_ELAPSED_EXT,
            queryProfilerData._drawQuery
          );
          queryStarted = queryProfilerData.queryStarted = true;
        }
      }
    }

    if (this.hasFeedbacks && this.hasFeedbacks())
      this.drawFeedbacks(shader, prim);
    else if (
      !this._bufVerticesIndizes ||
      this._bufVerticesIndizes.numItems === 0
    ) {
      // for (let i = 0; i < this._attributes.length; i++)
      // {
      //     if (this._attributes[i].arrayLength / this._attributes[i].itemSize != this._bufVertexAttrib.floatArray.length / 3)
      //     {
      //         this._log.warn("attrib buffer length wrong! ", this._attributes[i].name, this._attributes[i].arrayLength / this._attributes[i].itemSize, this._bufVertexAttrib.floatArray.length / 3, this._attributes[i].itemSize);
      //         // this._log.log(this);
      //         // debugger;
      //         return;
      //     }
      // }

      if (prim == this._cgl.gl.TRIANGLES) elementDiv = 3;
      if (this._numInstances === 0)
        this._cgl.gl.drawArrays(
          prim,
          this._bufVertexAttrib.startItem,
          this._bufVertexAttrib.numItems - this._bufVertexAttrib.startItem
        );
      else
        this._cgl.gl.drawArraysInstanced(
          prim,
          this._bufVertexAttrib.startItem,
          this._bufVertexAttrib.numItems,
          this._numInstances
        );
    } else {
      if (prim == this._cgl.gl.TRIANGLES) elementDiv = 3;
      if (this._numInstances === 0) {
        // console.log("la", this._bufVerticesIndizes.numItems);

        this._cgl.gl.drawElements(
          prim,
          this._bufVerticesIndizes.numItems,
          this._indexType,
          0
        );
      } else {
        this._cgl.gl.drawElementsInstanced(
          prim,
          this._bufVerticesIndizes.numItems,
          this._indexType,
          0,
          this._numInstances
        );
      }
    }

    if (
      this._cgl.debugOneFrame &&
      this._cgl.gl.getError() != this._cgl.gl.NO_ERROR
    ) {
      this._log.error("mesh draw gl error");
      this._log.error("mesh", this);
      this._log.error("shader", shader);

      const attribNames = [];
      for (
        let i = 0;
        i <
        this._cgl.gl.getProgramParameter(
          shader.getProgram(),
          this._cgl.gl.ACTIVE_ATTRIBUTES
        );
        i++
      ) {
        const name = this._cgl.gl.getActiveAttrib(shader.getProgram(), i).name;
        this._log.error("attrib ", name);
      }
    }

    this._cgl.profileData.profileMeshNumElements +=
      (this._bufVertexAttrib.numItems / elementDiv) * (this._numInstances || 1);
    this._cgl.profileData.profileMeshDraw++;

    if (doQuery && queryStarted) {
      this._cgl.gl.endQuery(this._queryExt.TIME_ELAPSED_EXT);
    }

    this._cgl.printError("mesh render " + this._name);

    this.unBind();
  };

  Mesh.prototype.setNumInstances = function (n) {
    n = Math.max(0, n);
    if (this._numInstances != n) {
      this._numInstances = n;
      const indexArr = new Float32Array(n);
      for (let i = 0; i < n; i++) indexArr[i] = i;
      this.setAttribute(
        constants_CONSTANTS.SHADER.SHADERVAR_INSTANCE_INDEX,
        indexArr,
        1,
        { instanced: true }
      );
    }
  };

  Mesh.prototype._disposeAttributes = function () {
    if (!this._attributes) return;

    for (let i = 0; i < this._attributes.length; i++) {
      if (this._attributes[i].buffer) {
        this._cgl.gl.deleteBuffer(this._attributes[i].buffer);
        this._attributes[i].buffer = null;
      }
    }
    this._attributes.length = 0;
  };

  Mesh.prototype.dispose = function () {
    if (this._bufVertexAttrib && this._bufVertexAttrib.buffer)
      this._cgl.gl.deleteBuffer(this._bufVertexAttrib.buffer);
    if (this._bufVerticesIndizes)
      this._cgl.gl.deleteBuffer(this._bufVerticesIndizes);
    this._bufVerticesIndizes = null;

    this._disposeAttributes();
  }; // CONCATENATED MODULE: ./src/core/cgl/cgl_simplerect.js

  const MESHES = {};

  MESHES.getSimpleRect = function (cgl, name, size = 1.0) {
    const geom = new Geometry(name);

    geom.vertices = [
      1.0 * size,
      1.0 * size,
      0.0,
      -1.0 * size,
      1.0 * size,
      0.0,
      1.0 * size,
      -1.0 * size,
      0.0,
      -1.0 * size,
      -1.0 * size,
      0.0,
    ];
    geom.texCoords = [1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0];
    geom.verticesIndices = [0, 1, 2, 2, 1, 3];
    geom.vertexNormals = [
      0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    ];

    return cgl.createMesh(geom);
    // return new Mesh(cgl, geom);
  };

  MESHES.getSimpleCube = function (cgl, name) {
    const geom = new Geometry(name);
    geom.vertices = [
      -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1,
      -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1,
      1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1,
      -1, -1, 1, -1, 1, 1, -1, 1, -1,
    ];
    geom.setTexCoords([
      0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1,
      0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0,
    ]);
    geom.verticesIndices = [
      0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12,
      14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23,
    ];
    geom.vertexNormals = new Float32Array([
      0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0,
      1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,
      0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,
      0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0,
      0.0, 0.0,
    ]);
    geom.tangents = new Float32Array([
      0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
      -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
      0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
      0, 1,
    ]);
    geom.biTangents = new Float32Array([
      -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
      0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,
      -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,
      0, -1,
    ]);

    return new Mesh(cgl, geom);
  }; // CONCATENATED MODULE: ./src/core/cgl/cgl_textureeffect.js

  const TextureEffect = function (cgl, options) {
    this._cgl = cgl;
    this._log = new Logger("cgl_TextureEffect");

    if (!cgl.TextureEffectMesh) this.createMesh();

    this._textureSource = null;
    this._options = options;
    this.name = options.name || "unknown";

    // TODO: do we still need the options ?
    // var opts=options ||
    //     {
    //         isFloatingPointTexture:false,
    //         filter:CGL.Texture.FILTER_LINEAR
    //     };
    // if(options && options.fp)opts.isFloatingPointTexture=true;

    this.imgCompVer = 0;
    this.aspectRatio = 1;
    this._textureTarget = null; // new CGL.Texture(this._cgl,opts);
    this._frameBuf = this._cgl.gl.createFramebuffer();
    this._frameBuf2 = this._cgl.gl.createFramebuffer();
    this._renderbuffer = this._cgl.gl.createRenderbuffer();
    this._renderbuffer2 = this._cgl.gl.createRenderbuffer();
    this.switched = false;
    this.depth = false;
  };

  TextureEffect.prototype.dispose = function () {
    if (this._renderbuffer) this._cgl.gl.deleteRenderbuffer(this._renderbuffer);
    if (this._frameBuf) this._cgl.gl.deleteFramebuffer(this._frameBuf);
    if (this._renderbuffer2)
      this._cgl.gl.deleteRenderbuffer(this._renderbuffer2);
    if (this._frameBuf2) this._cgl.gl.deleteFramebuffer(this._frameBuf2);
  };

  TextureEffect.prototype.getWidth = function () {
    return this._textureSource.width;
  };

  TextureEffect.prototype.getHeight = function () {
    return this._textureSource.height;
  };

  TextureEffect.prototype.setSourceTexture = function (tex) {
    if (tex === null) {
      this._textureSource = new Texture(this._cgl);
      this._textureSource.setSize(16, 16);
    } else {
      this._textureSource = tex;
    }

    if (!this._textureSource.compareSettings(this._textureTarget)) {
      if (this._textureTarget) this._textureTarget.delete();

      this._textureTarget = this._textureSource.clone();

      this._cgl.profileData.profileEffectBuffercreate++;

      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);

      this._cgl.gl.bindRenderbuffer(
        this._cgl.gl.RENDERBUFFER,
        this._renderbuffer
      );

      // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);
      // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);

      if (this.depth)
        this._cgl.gl.renderbufferStorage(
          this._cgl.gl.RENDERBUFFER,
          this._cgl.gl.DEPTH_COMPONENT16,
          this._textureSource.width,
          this._textureSource.height
        );
      this._cgl.gl.framebufferTexture2D(
        this._cgl.gl.FRAMEBUFFER,
        this._cgl.gl.COLOR_ATTACHMENT0,
        this._cgl.gl.TEXTURE_2D,
        this._textureTarget.tex,
        0
      );
      if (this.depth)
        this._cgl.gl.framebufferRenderbuffer(
          this._cgl.gl.FRAMEBUFFER,
          this._cgl.gl.DEPTH_ATTACHMENT,
          this._cgl.gl.RENDERBUFFER,
          this._renderbuffer
        );

      // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0);

      this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
      this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);

      this._cgl.gl.bindRenderbuffer(
        this._cgl.gl.RENDERBUFFER,
        this._renderbuffer2
      );

      // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);
      // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);

      if (this.depth)
        this._cgl.gl.renderbufferStorage(
          this._cgl.gl.RENDERBUFFER,
          this._cgl.gl.DEPTH_COMPONENT16,
          this._textureSource.width,
          this._textureSource.height
        );
      this._cgl.gl.framebufferTexture2D(
        this._cgl.gl.FRAMEBUFFER,
        this._cgl.gl.COLOR_ATTACHMENT0,
        this._cgl.gl.TEXTURE_2D,
        this._textureSource.tex,
        0
      );

      if (this.depth)
        this._cgl.gl.framebufferRenderbuffer(
          this._cgl.gl.FRAMEBUFFER,
          this._cgl.gl.DEPTH_ATTACHMENT,
          this._cgl.gl.RENDERBUFFER,
          this._renderbuffer2
        );

      // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0);

      this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
      this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
    }

    this.aspectRatio = this._textureSource.width / this._textureSource.height;
  };
  TextureEffect.prototype.continueEffect = function () {
    this._cgl.pushDepthTest(false);
    this._cgl.pushModelMatrix();
    this._cgl.pushPMatrix();
    // todo why two pushs?

    this._cgl.pushViewPort(
      0,
      0,
      this.getCurrentTargetTexture().width,
      this.getCurrentTargetTexture().height
    );

    mat4.perspective(
      this._cgl.pMatrix,
      45,
      this.getCurrentTargetTexture().width /
        this.getCurrentTargetTexture().height,
      0.1,
      1100.0
    ); // todo: why?

    this._cgl.pushPMatrix();
    mat4.identity(this._cgl.pMatrix);

    this._cgl.pushViewMatrix();
    mat4.identity(this._cgl.vMatrix);

    this._cgl.pushModelMatrix();
    mat4.identity(this._cgl.mMatrix);
  };

  TextureEffect.prototype.startEffect = function (bgTex) {
    if (!this._textureTarget) {
      this._log.warn("effect has no target");
      return;
    }

    this.switched = false;

    this.continueEffect();

    if (bgTex) {
      this._bgTex = bgTex;
    }
    this._countEffects = 0;
  };

  TextureEffect.prototype.endEffect = function () {
    this._cgl.popDepthTest();
    this._cgl.popModelMatrix();

    this._cgl.popPMatrix();
    this._cgl.popModelMatrix();
    this._cgl.popViewMatrix();

    this._cgl.popPMatrix();
    this._cgl.popViewPort();
  };

  TextureEffect.prototype.bind = function () {
    if (this._textureSource === null) {
      this._log.warn("no base texture set!");
      return;
    }

    if (!this.switched) {
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);
      this._cgl.pushGlFrameBuffer(this._frameBuf);
    } else {
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);
      this._cgl.pushGlFrameBuffer(this._frameBuf2);
    }
  };

  TextureEffect.prototype.finish = function () {
    if (this._textureSource === null) {
      this._log.warn("no base texture set!");
      return;
    }

    this._cgl.TextureEffectMesh.render(this._cgl.getShader());

    this._cgl.gl.bindFramebuffer(
      this._cgl.gl.FRAMEBUFFER,
      this._cgl.popGlFrameBuffer()
    );

    this._cgl.profileData.profileTextureEffect++;

    if (this._textureTarget.filter == Texture.FILTER_MIPMAP) {
      if (!this.switched) {
        this._cgl.gl.bindTexture(
          this._cgl.gl.TEXTURE_2D,
          this._textureTarget.tex
        );
        this._textureTarget.updateMipMap();
      } else {
        this._cgl.gl.bindTexture(
          this._cgl.gl.TEXTURE_2D,
          this._textureSource.tex
        );
        this._textureSource.updateMipMap();
      }

      this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
    }

    this.switched = !this.switched;
    this._countEffects++;
  };

  TextureEffect.prototype.getCurrentTargetTexture = function () {
    if (this.switched) return this._textureSource;
    return this._textureTarget;
  };

  TextureEffect.prototype.getCurrentSourceTexture = function () {
    if (this._countEffects == 0 && this._bgTex) return this._bgTex;

    if (this.switched) return this._textureTarget;
    return this._textureSource;
  };

  TextureEffect.prototype.delete = function () {
    if (this._textureTarget) this._textureTarget.delete();
    if (this._textureSource) this._textureSource.delete();
    this._cgl.gl.deleteRenderbuffer(this._renderbuffer);
    this._cgl.gl.deleteFramebuffer(this._frameBuf);
  };

  TextureEffect.prototype.createMesh = function () {
    this._cgl.TextureEffectMesh = MESHES.getSimpleRect(
      this._cgl,
      "texEffectRect"
    );
  };

  // ---------------------------------------------------------------------------------

  TextureEffect.checkOpNotInTextureEffect = function (op) {
    if (!op.patch.cgl) return true;
    if (op.uiAttribs.error && !op.patch.cgl.currentTextureEffect) {
      op.setUiError("textureeffect", null);
      return true;
    }
    if (!op.patch.cgl.currentTextureEffect) return true;

    if (op.patch.cgl.currentTextureEffect && !op.uiAttribs.error) {
      op.setUiError(
        "textureeffect",
        "This op can not be a child of a ImageCompose/texture effect! imagecompose should only have textureeffect childs.",
        0
      );
      return false;
    }

    if (op.patch.cgl.currentTextureEffect) return false;
    return true;
  };

  TextureEffect.checkOpInEffect = function (op, minver) {
    minver = minver || 0;

    if (op.patch.cgl.currentTextureEffect) {
      if (
        op.uiAttribs.uierrors &&
        op.patch.cgl.currentTextureEffect.imgCompVer >= minver
      ) {
        op.setUiError("texeffect", null);
        return true;
      }

      if (minver && op.patch.cgl.currentTextureEffect.imgCompVer < minver) {
        op.setUiError(
          "texeffect",
          "This op must be a child of an ImageCompose op with version >=" +
            minver +
            ' <span class="button-small" onclick="gui.patchView.downGradeOp(\'' +
            op.id +
            "','" +
            op.name +
            "')\">Downgrade</span> to previous version",
          1
        );
      }
    }

    if (op.patch.cgl.currentTextureEffect) return true;

    if (
      !op.patch.cgl.currentTextureEffect &&
      (!op.uiAttribs.uierrors || op.uiAttribs.uierrors.length == 0)
    ) {
      op.setUiError(
        "texeffect",
        'This op must be a child of an ImageCompose op! More infos <a href="https://cables.gl/docs/image_composition/image_composition.html" target="_blank">here</a>. ',
        1
      );
      return false;
    }

    if (!op.patch.cgl.currentTextureEffect) return false;
    return true;
  };

  TextureEffect.getBlendCode = function (ver) {
    let src =
      "".endl() +
      "vec3 _blend(vec3 base,vec3 blend)".endl() +
      "{".endl() +
      "   vec3 colNew=blend;".endl() +
      "   #ifdef BM_MULTIPLY".endl() +
      "       colNew=base*blend;".endl() +
      "   #endif".endl() +
      "   #ifdef BM_MULTIPLY_INV".endl() +
      "       colNew=base* vec3(1.0)-blend;".endl() +
      "   #endif".endl() +
      "   #ifdef BM_AVERAGE".endl() +
      "       colNew=((base + blend) / 2.0);".endl() +
      "   #endif".endl() +
      "   #ifdef BM_ADD".endl() +
      "       colNew=min(base + blend, vec3(1.0));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_SUBTRACT_ONE".endl() +
      "       colNew=max(base + blend - vec3(1.0), vec3(0.0));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_SUBTRACT".endl() +
      "       colNew=base - blend;".endl() +
      "   #endif".endl() +
      "   #ifdef BM_DIFFERENCE".endl() +
      "       colNew=abs(base - blend);".endl() +
      "   #endif".endl() +
      "   #ifdef BM_NEGATION".endl() +
      "       colNew=(vec3(1.0) - abs(vec3(1.0) - base - blend));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_EXCLUSION".endl() +
      "       colNew=(base + blend - 2.0 * base * blend);".endl() +
      "   #endif".endl() +
      "   #ifdef BM_LIGHTEN".endl() +
      "       colNew=max(blend, base);".endl() +
      "   #endif".endl() +
      "   #ifdef BM_DARKEN".endl() +
      "       colNew=min(blend, base);".endl() +
      "   #endif".endl() +
      "   #ifdef BM_OVERLAY".endl() +
      "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))"
        // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'
        //    .endl()+'      colNew=Blend(base, blend, BlendOverlayf);'
        .endl() +
      "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_SCREEN".endl() +
      "      #define BlendScreenf(base, blend)       (1.0 - ((1.0 - base) * (1.0 - blend)))"
        // .endl()+'       #define BlendScreen(base, blend)        Blend(base, blend, BlendScreenf)'
        // .endl()+'      colNew=Blend(base, blend, BlendScreenf);'
        .endl() +
      "      colNew=vec3(BlendScreenf(base.r, blend.r),BlendScreenf(base.g, blend.g),BlendScreenf(base.b, blend.b));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_SOFTLIGHT".endl() +
      "      #define BlendSoftLightf(base, blend)    ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))"
        // .endl()+'       #define BlendSoftLight(base, blend)     Blend(base, blend, BlendSoftLightf)'
        //    .endl()+'      colNew=Blend(base, blend, BlendSoftLightf);'
        .endl() +
      "      colNew=vec3(BlendSoftLightf(base.r, blend.r),BlendSoftLightf(base.g, blend.g),BlendSoftLightf(base.b, blend.b));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_HARDLIGHT".endl() +
      "      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))"
        // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'
        // .endl()+'      colNew=Blend(blend, base, BlendOverlayf);'
        .endl() +
      "      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_COLORDODGE".endl() +
      "      #define BlendColorDodgef(base, blend)   ((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))"
        // .endl()+'      colNew=Blend(base, blend, BlendColorDodgef);'
        .endl() +
      "      colNew=vec3(BlendColorDodgef(base.r, blend.r),BlendColorDodgef(base.g, blend.g),BlendColorDodgef(base.b, blend.b));".endl() +
      "   #endif".endl() +
      "   #ifdef BM_COLORBURN".endl() +
      "      #define BlendColorBurnf(base, blend)    ((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))"
        // .endl()+'      colNew=Blend(base, blend, BlendColorBurnf);'
        .endl() +
      "      colNew=vec3(BlendColorBurnf(base.r, blend.r),BlendColorBurnf(base.g, blend.g),BlendColorBurnf(base.b, blend.b));".endl() +
      "   #endif".endl() +
      "   return colNew;".endl() +
      "}".endl();

    if (!ver)
      src +=
        "vec4 cgl_blend(vec4 oldColor,vec4 newColor,float amount)".endl() +
        "{".endl() +
        "vec4 col=vec4( _blend(oldColor.rgb,newColor.rgb) ,1.0);".endl() +
        "col=vec4( mix( col.rgb, oldColor.rgb ,1.0-oldColor.a*amount),1.0);".endl() +
        "return col;".endl() +
        "}".endl();

    if (ver >= 3)
      src +=
        "vec4 cgl_blendPixel(vec4 base,vec4 col,float amount)".endl() +
        "{".endl() +
        "#ifdef BM_MATH_ADD".endl() +
        "   return vec4(base.rgb+col.rgb*amount,1.0);".endl() +
        "#endif".endl() +
        "#ifdef BM_MATH_SUB".endl() +
        "   return vec4(base.rgb-col.rgb*amount,1.0);".endl() +
        "#endif".endl() +
        "#ifdef BM_MATH_MUL".endl() +
        "   return vec4(base.rgb*col.rgb*amount,1.0);".endl() +
        "#endif".endl() +
        "#ifdef BM_MATH_DIV".endl() +
        "   return vec4(base.rgb/col.rgb*amount,1.0);".endl() +
        "#endif".endl() +
        "#ifndef BM_MATH".endl() +
        "vec3 colNew=_blend(base.rgb,col.rgb);".endl() +
        "float newA=clamp(base.a+(col.a*amount),0.,1.);".endl() +
        "#ifdef BM_ALPHAMASKED".endl() +
        "newA=base.a;".endl() +
        "#endif".endl() +
        "return vec4(".endl() +
        "mix(colNew,base.rgb,1.0-(amount*col.a)),".endl() +
        "newA);".endl() +
        "#endif".endl() +
        "}".endl();

    return src;
  };

  TextureEffect.onChangeBlendSelect = function (
    shader,
    blendName,
    maskAlpha = false
  ) {
    blendName = String(blendName);
    shader.toggleDefine("BM_NORMAL", blendName == "normal");
    shader.toggleDefine("BM_MULTIPLY", blendName == "multiply");
    shader.toggleDefine("BM_MULTIPLY_INV", blendName == "multiply invert");
    shader.toggleDefine("BM_AVERAGE", blendName == "average");
    shader.toggleDefine("BM_ADD", blendName == "add");
    shader.toggleDefine("BM_SUBTRACT_ONE", blendName == "subtract one");
    shader.toggleDefine("BM_SUBTRACT", blendName == "subtract");
    shader.toggleDefine("BM_DIFFERENCE", blendName == "difference");
    shader.toggleDefine("BM_NEGATION", blendName == "negation");
    shader.toggleDefine("BM_EXCLUSION", blendName == "exclusion");
    shader.toggleDefine("BM_LIGHTEN", blendName == "lighten");
    shader.toggleDefine("BM_DARKEN", blendName == "darken");
    shader.toggleDefine("BM_OVERLAY", blendName == "overlay");
    shader.toggleDefine("BM_SCREEN", blendName == "screen");
    shader.toggleDefine("BM_SOFTLIGHT", blendName == "softlight");
    shader.toggleDefine("BM_HARDLIGHT", blendName == "hardlight");
    shader.toggleDefine("BM_COLORDODGE", blendName == "color dodge");
    shader.toggleDefine("BM_COLORBURN", blendName == "color burn");

    shader.toggleDefine("BM_MATH_ADD", blendName == "Math Add");
    shader.toggleDefine("BM_MATH_SUB", blendName == "Math Subtract");
    shader.toggleDefine("BM_MATH_MUL", blendName == "Math Multiply");
    shader.toggleDefine("BM_MATH_DIV", blendName == "Math Divide");

    shader.toggleDefine("BM_MATH", blendName.indexOf("Math ") == 0);

    shader.toggleDefine("BM_ALPHAMASKED", maskAlpha);
  };

  TextureEffect.AddBlendSelect = function (op, name, defaultMode) {
    const p = op.inValueSelect(
      name || "Blend Mode",
      [
        "normal",
        "lighten",
        "darken",
        "multiply",
        "multiply invert",
        "average",
        "add",
        "subtract",
        "difference",
        "negation",
        "exclusion",
        "overlay",
        "screen",
        "color dodge",
        "color burn",
        "softlight",
        "hardlight",
        "subtract one",
        "Math Add",
        "Math Subtract",
        "Math Multiply",
        "Math Divide",
      ],
      defaultMode || "normal"
    );
    return p;
  };

  TextureEffect.AddBlendAlphaMask = function (op, name, defaultMode) {
    const p = op.inSwitch(
      name || "Alpha Mask",
      ["Off", "On"],
      defaultMode || "Off"
    );
    return p;
  };

  TextureEffect.setupBlending = function (
    op,
    shader,
    blendPort,
    amountPort,
    alphaMaskPort
  ) {
    const onChange = () => {
      let maskAlpha = false;
      if (alphaMaskPort) maskAlpha = alphaMaskPort.get() == "On";
      TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);

      let str = blendPort.get();
      if (str == "normal") str = null;
      else if (str == "multiply") str = "mul";
      else if (str == "multiply invert") str = "mulinv";
      else if (str == "lighten") str = "light";
      else if (str == "darken") str = "darken";
      else if (str == "average") str = "avg";
      else if (str == "subtract one") str = "sub one";
      else if (str == "subtract") str = "sub";
      else if (str == "difference") str = "diff";
      else if (str == "negation") str = "neg";
      else if (str == "exclusion") str = "exc";
      else if (str == "overlay") str = "ovl";
      else if (str == "color dodge") str = "dodge";
      else if (str == "color burn") str = "burn";
      else if (str == "softlight") str = "soft";
      else if (str == "hardlight") str = "hard";
      else if (str == "Math Add") str = "+";
      else if (str == "Math Subtract") str = "-";
      else if (str == "Math Multiply") str = "*";
      else if (str == "Math Divide") str = "/";

      op.setUiAttrib({ extendTitle: str });
    };
    op.setPortGroup("Blending", [blendPort, amountPort, alphaMaskPort]);

    let maskAlpha = false;

    blendPort.onChange = onChange;
    if (alphaMaskPort) {
      alphaMaskPort.onChange = onChange;
      maskAlpha = alphaMaskPort.get() == "On";
    }

    TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);
  }; // CONCATENATED MODULE: ./src/core/cgl/cgl_shader_lib.js

  const ShaderLibMods = {
    "CGL.BLENDMODES": function () {
      this.name = "blendmodes";
      this.srcHeadFrag = TextureEffect.getBlendCode();
    },
    "CGL.BLENDMODES3": function () {
      this.name = "blendmodes3";
      this.srcHeadFrag = TextureEffect.getBlendCode(3);
    },

    "CGL.LUMINANCE": function () {
      this.name = "luminance";
      this.srcHeadFrag =
        "".endl() +
        "float cgl_luminance(vec3 c)".endl() +
        "{".endl() +
        "    return dot(vec3(0.2126,0.7152,0.0722),c);".endl() +
        "}".endl();
    },

    // quite good random numbers, but somehow don't work in ANGLE
    "CGL.RANDOM_OLD": function () {
      this.name = "randomNumber";
      this.srcHeadFrag =
        "".endl() +
        "float cgl_random(vec2 co)".endl() +
        "{".endl() +
        "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 432758.5453);".endl() +
        "}".endl() +
        "vec3 cgl_random3(vec2 co)".endl() +
        "{".endl() +
        "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl() +
        "}";
    },

    // low quality generative ranodm numbers
    "CGL.RANDOM_LOW": function () {
      this.name = "randomNumber";
      this.srcHeadFrag =
        "".endl() +
        "float cgl_random(vec2 co)".endl() +
        "{".endl() +
        "    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 358.5453);".endl() +
        "}".endl() +
        "vec3 cgl_random3(vec2 co)".endl() +
        "{".endl() +
        "    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));".endl() +
        "}";
    },

    // texture based random numbers
    "CGL.RANDOM_TEX": function () {
      this.name = "randomNumbertex";
      this.srcHeadFrag =
        "".endl() +
        "UNI sampler2D CGLRNDTEX;".endl() +
        "float cgl_random(vec2 co)".endl() +
        "{".endl() +
        "    return texture(CGLRNDTEX,co*5711.0).r;".endl() +
        "}".endl() +
        "vec3 cgl_random3(vec2 co)".endl() +
        "{".endl() +
        "    return texture(CGLRNDTEX,co*5711.0).rgb;".endl() +
        "}";

      this.initUniforms = function (shader) {
        return [new Uniform(shader, "t", "CGLRNDTEX", 7)];
      };

      this.onBind = function (cgl, shader) {
        Texture.getRandomTexture(cgl);
        cgl.setTexture(7, Texture.getRandomTexture(cgl).tex);
      };
    },
  }; // CONCATENATED MODULE: ./src/core/cgl/cgl_utils.js

  /** @namespace CGL */

  /**
   * multiply to get radians from degree, e.g. `360 * CGL.DEG2RAD`
   * @const {Number}
   * @memberof CGL
   * @static
   */
  const cgl_utils_DEG2RAD = Math.PI / 180.0;

  /**
   * to get degrees from radians, e.g. `3.14 * CGL.RAD2DEG`
   * @const {number}
   * @memberof CGL
   */
  const cgl_utils_RAD2DEG = 180.0 / Math.PI;

  const onLoadingAssetsFinished = null; // deprecated / remove later

  /**
   * get normalized mouse wheel delta (including browser specific adjustment)
   * @function getWheelDelta
   * @static
   * @memberof CGL
   * @param {MouseEvent} event
   * @return {Number} normalized delta
   */
  const isWindows = window.navigator.userAgent.contains("Windows");
  const getWheelDelta_ = function (event) {
    let normalized;
    if (event.wheelDelta) {
      // chrome
      normalized =
        (event.wheelDelta % 120) - 0 == -0
          ? event.wheelDelta / 120
          : event.wheelDelta / 30;
      normalized *= -1.5;
      if (isWindows) normalized *= 2;
    } else {
      // firefox
      let d = event.deltaY;
      if (event.shiftKey) d = event.deltaX;
      const rawAmmount = d || event.detail;
      normalized = -(rawAmmount % 3 ? rawAmmount * 10 : rawAmmount / 3);
      normalized *= -3;
    }

    if (normalized > 20) normalized = 20;
    if (normalized < -20) normalized = -20;

    return normalized;
  };

  const getWheelSpeed = getWheelDelta_;
  const getWheelDelta = getWheelDelta_;

  // from https://github.com/lodash/lodash/blob/master/escape.js

  const htmlEscapes = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
  };

  /** Used to match HTML entities and HTML characters. */
  const reUnescapedHtml = /[&<>"']/g;
  const reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /*  eslint-disable */
  const escapeHTML = function (string) {
    return string && reHasUnescapedHtml.test(string)
      ? string.replace(reUnescapedHtml, function (chr) {
          return htmlEscapes[chr];
        })
      : string || "";
  }; // CONCATENATED MODULE: ./src/core/cg/cg_shader.js
  /* eslint-enable */

  class CgShader extends EventTarget {
    constructor() {
      super();
      this.id = simpleId();
      this._isValid = true;
      this._defines = [];

      this._moduleNames = [];
      this._modules = [];
      this._moduleNumId = 0;
    }

    /**
     * easily enable/disable a define without a value
     * @function toggleDefine
     * @memberof Shader
     * @instance
     * @param {name} name
     * @param {any} enabled value or port
     */
    toggleDefine(name, enabled) {
      if (enabled && typeof enabled == "object" && enabled.addEventListener) {
        // port
        if (enabled.changeListener)
          enabled.removeEventListener(enabled.changeListener);

        enabled.onToggleDefine = (v) => {
          this.toggleDefine(name, v);
        };

        enabled.changeListener = enabled.on("change", enabled.onToggleDefine);
        enabled = enabled.get();
      }

      if (enabled) this.define(name);
      else this.removeDefine(name);
    }

    /**
     * add a define to a shader, e.g.  #define DO_THIS_THAT 1
     * @function define
     * @memberof Shader
     * @instance
     * @param {String} name
     * @param {Any} value (can be empty)
     */
    define(name, value) {
      if (value === null || value === undefined) value = "";

      if (typeof value == "object") {
        // port
        value.removeEventListener("change", value.onDefineChange);
        value.onDefineChange = (v) => {
          this.define(name, v);
        };
        value.on("change", value.onDefineChange);

        value = value.get();
      }

      for (let i = 0; i < this._defines.length; i++) {
        if (this._defines[i][0] == name && this._defines[i][1] == value) return;
        if (this._defines[i][0] == name) {
          this._defines[i][1] = value;
          this.setWhyCompile("define " + name + " " + value);

          this._needsRecompile = true;
          return;
        }
      }
      this.setWhyCompile("define " + name + " " + value);
      this._needsRecompile = true;
      this._defines.push([name, value]);
    }

    getDefines() {
      return this._defines;
    }

    getDefine(name) {
      for (let i = 0; i < this._defines.length; i++)
        if (this._defines[i][0] == name) return this._defines[i][1];
      return null;
    }

    /**
     * return true if shader has define
     * @function hasDefine
     * @memberof Shader
     * @instance
     * @param {String} name
     * @return {Boolean}
     */
    hasDefine(name) {
      for (let i = 0; i < this._defines.length; i++)
        if (this._defines[i][0] == name) return true;
    }

    /**
     * remove a define from a shader
     * @param {name} name
     * @function removeDefine
     * @memberof Shader
     * @instance
     */
    removeDefine(name) {
      for (let i = 0; i < this._defines.length; i++) {
        if (this._defines[i][0] == name) {
          this._defines.splice(i, 1);
          this._needsRecompile = true;

          this.setWhyCompile("define removed:" + name);

          return;
        }
      }
    }

    hasModule(modId) {
      for (let i = 0; i < this._modules.length; i++) {
        if (this._modules[i].id == modId) return true;
      }
      return false;
    }

    setModules(names) {
      this._moduleNames = names;
    }

    /**
     * remove a module from shader
     * @function removeModule
     * @memberof Shader
     * @instance
     * @param {shaderModule} mod the module to be removed
     */
    removeModule(mod) {
      for (let i = 0; i < this._modules.length; i++) {
        if (mod && mod.id) {
          if (this._modules[i].id == mod.id || !this._modules[i]) {
            let found = true;
            while (found) {
              found = false;
              for (let j = 0; j < this._uniforms.length; j++) {
                if (this._uniforms[j].getName().startsWith(mod.prefix)) {
                  this._uniforms.splice(j, 1);
                  found = true;
                  continue;
                }
              }
            }

            this._needsRecompile = true;
            this.setWhyCompile("remove module " + mod.title);
            this._modules.splice(i, 1);
            break;
          }
        }
      }
    }

    getNumModules() {
      return this._modules.length;
    }

    getCurrentModules() {
      return this._modules;
    }

    /**
     * add a module
     * @function addModule
     * @memberof Shader
     * @instance
     * @param {shaderModule} mod the module to be added
     * @param {shaderModule} [sibling] sibling module, new module will share the same group
     */
    addModule(mod, sibling) {
      if (this.hasModule(mod.id)) return;
      if (!mod.id) mod.id = CABLES.simpleId();
      if (!mod.numId) mod.numId = this._moduleNumId;
      if (!mod.num) mod.num = this._modules.length;
      if (sibling && !sibling.group) sibling.group = simpleId();

      if (!mod.group)
        if (sibling) mod.group = sibling.group;
        else mod.group = simpleId();

      mod.prefix = "mod" + mod.group + "_";
      this._modules.push(mod);

      this._needsRecompile = true;
      this.setWhyCompile("add module " + mod.title);
      this._moduleNumId++;

      return mod;
    }

    getAttributeSrc(mod, srcHeadVert, srcVert) {
      if (mod.attributes)
        for (let k = 0; k < mod.attributes.length; k++) {
          const r = this._getAttrSrc(mod.attributes[k], false);
          if (r.srcHeadVert) srcHeadVert += r.srcHeadVert;
          if (r.srcVert) srcVert += r.srcVert;
        }

      return { srcHeadVert: srcHeadVert, srcVert: srcVert };
    }

    replaceModuleSrc() {
      let srcHeadVert = "";

      for (let j = 0; j < this._modules.length; j++) {
        const mod = this._modules[j];
        if (mod.name == this._moduleNames[i]) {
          srcHeadVert +=
            "\n//---- MOD: group:" +
            mod.group +
            ": idx:" +
            j +
            " - prfx:" +
            mod.prefix +
            " - " +
            mod.title +
            " ------\n";

          srcVert +=
            "\n\n//---- MOD: " + mod.title + " / " + mod.priority + " ------\n";

          if (mod.getAttributeSrc) {
            const r = getAttributeSrc(mod, srcHeadVert, srcVert);
            if (r.srcHeadVert) srcHeadVert += r.srcHeadVert;
            if (r.srcVert) srcVert += r.srcVert;
          }

          srcHeadVert += mod.srcHeadVert || "";
          srcVert += mod.srcBodyVert || "";

          srcHeadVert += "\n//---- end mod ------\n";

          srcVert += "\n//---- end mod ------\n";

          srcVert = srcVert.replace(/{{mod}}/g, mod.prefix);
          srcHeadVert = srcHeadVert.replace(/{{mod}}/g, mod.prefix);

          srcVert = srcVert.replace(/MOD_/g, mod.prefix);
          srcHeadVert = srcHeadVert.replace(/MOD_/g, mod.prefix);
        }
      }

      vs = vs.replace("{{" + this._moduleNames[i] + "}}", srcVert);
    }
  } // CONCATENATED MODULE: ./src/core/cgl/cgl_shader_default_glsl.vert

  /* harmony default export */ const cgl_shader_default_glsl =
    "{{MODULES_HEAD}}\nIN vec3 vPosition; //!@\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN vec3 attrTangent,attrBiTangent;\n\nIN float attrVertIndex;\n\nOUT vec2 texCoord;\nOUT vec3 norm;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n    texCoord=attrTexCoord;\n    norm=attrVertNormal;\n    vec4 pos=vec4(vPosition,  1.0);\n    vec3 tangent=attrTangent;\n    vec3 bitangent=attrBiTangent;\n    mat4 mMatrix=modelMatrix;\n    gl_PointSize=10.0;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mat4 modelViewMatrix=viewMatrix*mMatrix;\n    {{MODULE_VERTEX_MODELVIEW}}\n\n    gl_Position = projMatrix * modelViewMatrix * pos;\n}\n"; // CONCATENATED MODULE: ./src/core/cgl/cgl_shader.js
  // ---------------------------------------------------------------------------

  /*

proposal default shader variable names:

attrVertex - currently: vPosition
attrVertexIndex - currently: attrVertIndex
attrTexCoord
attrInstMat - currently: instMat
attrVertColor
attrTangent
attrBiTangent

uProjMatrix - currently: projMatrix
uModelMatrix - currently: modelMatrix
uNormalMatrix - currently: normalMatrix
uCamPosition - currently: camPos

*/

  // ---------------------------------------------------------------------------

  let materialIdCounter = 0;

  function getDefaultVertexShader() {
    return cgl_shader_default_glsl;
  }

  function getDefaultFragmentShader(r, g, b) {
    if (r == undefined) {
      r = 0.5;
      g = 0.5;
      b = 0.5;
    }
    return (
      "".endl() +
      "IN vec2 texCoord;".endl() +
      "{{MODULES_HEAD}}".endl() +
      "void main()".endl() +
      "{".endl() +
      "    vec4 col=vec4(" +
      r +
      "," +
      g +
      "," +
      b +
      ",1.0);".endl() +
      "    {{MODULE_COLOR}}".endl() +
      "    outColor = col;".endl() +
      "}"
    );
  }

  /**
   * @class
   * @namespace external:CGL
   * @hideconstructor
   * @param _cgl
   * @param _name
   * @param _op
   * @example
   * var shader=new CGL.Shader(cgl,'MinimalMaterial');
   * shader.setSource(attachments.shader_vert,attachments.shader_frag);
   */
  class Shader extends CgShader {
    constructor(_cgl, _name, _op) {
      super();
      if (!_cgl) throw new Error("shader constructed without cgl " + _name);

      this._log = new Logger("cgl_shader");
      this._cgl = _cgl;

      if (!_name) this._log.stack("no shader name given");
      this._name = _name || "unknown";

      if (_op) this.opId = _op.id;
      this.glslVersion = 0;
      if (_cgl.glVersion > 1) this.glslVersion = 300;

      this._materialId = ++materialIdCounter;

      this._program = null;
      this._uniforms = [];
      this._drawBuffers = [true];

      this._needsRecompile = true;
      this._compileReason = "initial";

      this.ignoreMissingUniforms = false;
      this._projMatrixUniform = null;
      this._mvMatrixUniform = null;
      this._mMatrixUniform = null;
      this._vMatrixUniform = null;
      this._camPosUniform = null;
      this._normalMatrixUniform = null;
      this._inverseViewMatrixUniform = null;
      this._fromUserInteraction = false;

      this._attrVertexPos = -1;
      this.precision = _cgl.patch.config.glslPrecision || "highp";

      this._pMatrixState = -1;
      this._vMatrixState = -1;

      this._countMissingUniforms = 0;
      this._modGroupCount = 0; // not needed anymore...
      this._feedBackNames = [];
      this._attributes = [];

      this.glPrimitive = null;
      this.offScreenPass = false;
      this._extensions = [];
      this.srcVert = getDefaultVertexShader();
      this.srcFrag = getDefaultFragmentShader();
      this.lastCompile = 0;

      this._libs = [];
      this._structNames = [];
      this._structUniformNames = [];
      this._textureStackUni = [];
      this._textureStackTex = [];
      this._textureStackType = [];
      this._textureStackTexCgl = [];

      this._tempNormalMatrix = mat4.create();
      this._tempCamPosMatrix = mat4.create();
      this._tempInverseViewMatrix = mat4.create();
      this._tempInverseProjMatrix = mat4.create();

      this.setModules([
        "MODULE_VERTEX_POSITION",
        "MODULE_COLOR",
        "MODULE_BEGIN_FRAG",
        "MODULE_VERTEX_MODELVIEW",
      ]);
    }

    isValid() {
      return this._isValid;
    }

    getCgl() {
      return this._cgl;
    }

    getName() {
      return this._name;
    }

    /**
     * enable an extension for the shader
     * @function enableExtension
     * @memberof Shader
     * @instance
     * @param name extension name
     */
    enableExtension(name) {
      this.setWhyCompile("enable extension " + name);
      this._needsRecompile = true;
      this._extensions.push(name);
    }

    getAttrVertexPos() {
      return this._attrVertexPos;
    }

    hasTextureUniforms() {
      for (let i = 0; i < this._uniforms.length; i++)
        if (this._uniforms[i].getType() == "t") return true;
      return false;
    }

    setWhyCompile(why) {
      this._compileReason = why;
    }

    /**
     * copy all uniform values from another shader
     * @function copyUniforms
     * @memberof Shader
     * @instance
     * @param origShader uniform values will be copied from this shader
     */
    copyUniformValues(origShader) {
      // console.log(origShader._uniforms);
      for (let i = 0; i < origShader._uniforms.length; i++) {
        if (!this._uniforms[i]) {
          this._log.log("unknown uniform?!");
          continue;
        }

        // this._log.log(origShader._uniforms[i].getName());
        // this.getUniform(origShader._uniforms[i].)
        // this._uniforms[i].set(origShader._uniforms[i].getValue());

        // if (origShader._uniforms[i].getName().contains("pathPoints"))
        //     console.log("copyUniformValues", origShader._uniforms[i].getName(), origShader._uniforms[i].getValue());

        this.getUniform(origShader._uniforms[i].getName()).set(
          origShader._uniforms[i].getValue()
        );
      }

      this.popTextures();
      for (let i = 0; i < origShader._textureStackUni.length; i++) {
        this._textureStackUni[i] = origShader._textureStackUni[i];
        this._textureStackTex[i] = origShader._textureStackTex[i];
        this._textureStackType[i] = origShader._textureStackType[i];
        this._textureStackTexCgl[i] = origShader._textureStackTexCgl[i];
      }

      // this._textureStackUni = [];
      // this._textureStackTex = [];
      // this._textureStackType = [];
      // this._textureStackTexCgl = [];
    }

    /**
     * copy current shader
     * @function copy
     * @memberof Shader
     * @instance
     * @returns newShader
     */
    copy() {
      const shader = new Shader(this._cgl, this._name + " copy");
      shader.setSource(this.srcVert, this.srcFrag);

      shader._modules = JSON.parse(JSON.stringify(this._modules));
      shader._defines = JSON.parse(JSON.stringify(this._defines));

      shader._modGroupCount = this._modGroupCount;
      shader._moduleNames = this._moduleNames;
      shader.glPrimitive = this.glPrimitive;
      shader.offScreenPass = this.offScreenPass;
      shader._extensions = this._extensions;
      shader.wireframe = this.wireframe;
      shader._attributes = this._attributes;

      for (let i = 0; i < this._uniforms.length; i++) {
        const u = this._uniforms[i].copy(shader);
        u.resetLoc();
      }

      this.setWhyCompile("copy");
      shader._needsRecompile = true;
      return shader;
    }

    /**
     * set shader source code
     * @function setSource
     * @memberof Shader
     * @instance
     * @param {String} srcVert
     * @param {String} srcFrag
     * @param {Bool} fromUserInteraction
     */
    setSource(srcVert, srcFrag, fromUserInteraction) {
      this._fromUserInteraction = fromUserInteraction;
      this.srcVert = srcVert;
      this.srcFrag = srcFrag;
      this.setWhyCompile("Source changed");
      this._needsRecompile = true;
      this._isValid = true;
    }

    _addLibs(src) {
      for (const id in ShaderLibMods) {
        if (src.contains(id)) {
          const lib = new ShaderLibMods[id]();
          src = src.replace("{{" + id + "}}", lib.srcHeadFrag);
          this._libs.push(lib);
          if (lib.initUniforms) lib.initUniforms(this);
        }
      }

      return src;
    }

    createStructUniforms() {
      // * create structs
      let structStrFrag = "";
      let structStrVert = ""; // TODO: not used yet

      this._structNames = [];
      // * reset the arrays holding the value each recompile so we don't skip structs
      // * key value mapping so the same struct can be added twice (two times the same modifier)
      this._injectedStringsFrag = {};
      this._injectedStringsVert = {};

      this._structUniformNamesIndicesFrag = [];
      this._structUniformNamesIndicesVert = [];

      for (let i = 0; i < this._uniforms.length; i++) {
        // * only add uniforms to struct that are a member of a struct
        if (this._uniforms[i].isStructMember()) {
          const injectionString =
            "{{INJECTION_POINT_STRUCT_" + this._uniforms[i]._structName + "}}";

          // * check if struct is not already part of shader
          if (!this._structNames.includes(this._uniforms[i]._structName)) {
            // * create struct definition with placeholder string to inject
            const structDefinition =
              "struct " +
              this._uniforms[i]._structName +
              " {".endl() +
              injectionString +
              "};".endl().endl();

            if (
              this._uniforms[i].getShaderType() === "both" ||
              this._uniforms[i].getShaderType() === "frag"
            )
              structStrFrag = structStrFrag.concat(structDefinition);

            if (
              this._uniforms[i].getShaderType() === "both" ||
              this._uniforms[i].getShaderType() === "vert"
            )
              structStrVert = structStrVert.concat(structDefinition);

            this._structNames.push(this._uniforms[i]._structName);
            this._injectedStringsFrag[this._uniforms[i]._structName] = [];
            this._injectedStringsVert[this._uniforms[i]._structName] = [];
          }

          // * create member & comment
          let comment = "";
          if (this._uniforms[i].comment)
            comment = " // " + this._uniforms[i].comment;

          let stringToInsert = "";
          if (this._uniforms[i].getGlslTypeString() == undefined)
            stringToInsert += "//";
          stringToInsert +=
            "  " +
            this._uniforms[i].getGlslTypeString() +
            " " +
            this._uniforms[i]._propertyName +
            ";" +
            comment;

          if (this._uniforms[i].getShaderType() === "both") {
            // * inject member before {injectionString}
            if (
              !this._injectedStringsFrag[
                this._uniforms[i]._structName
              ].contains(stringToInsert) &&
              !this._injectedStringsVert[
                this._uniforms[i]._structName
              ].contains(stringToInsert)
            ) {
              const insertionIndexFrag =
                structStrFrag.lastIndexOf(injectionString);
              const insertionIndexVert =
                structStrVert.lastIndexOf(injectionString);

              structStrFrag =
                structStrFrag.slice(0, insertionIndexFrag) +
                stringToInsert +
                structStrFrag.slice(insertionIndexFrag - 1);

              structStrVert =
                structStrVert.slice(0, insertionIndexVert) +
                stringToInsert +
                structStrVert.slice(insertionIndexVert - 1);

              this._injectedStringsFrag[this._uniforms[i]._structName].push(
                stringToInsert
              );
              this._injectedStringsVert[this._uniforms[i]._structName].push(
                stringToInsert
              );
            }

            if (!this._structUniformNamesIndicesFrag.includes(i))
              this._structUniformNamesIndicesFrag.push(i);
            if (!this._structUniformNamesIndicesVert.includes(i))
              this._structUniformNamesIndicesVert.push(i);
          } else if (this._uniforms[i].getShaderType() === "frag") {
            // * inject member before {injectionString}
            if (
              !this._injectedStringsFrag[
                this._uniforms[i]._structName
              ].includes(stringToInsert)
            ) {
              //
              const insertionIndexFrag =
                structStrFrag.lastIndexOf(injectionString);

              structStrFrag =
                structStrFrag.slice(0, insertionIndexFrag) +
                stringToInsert +
                structStrFrag.slice(insertionIndexFrag - 1);

              this._injectedStringsFrag[this._uniforms[i]._structName].push(
                stringToInsert
              );
            }

            if (!this._structUniformNamesIndicesFrag.includes(i))
              this._structUniformNamesIndicesFrag.push(i);
          } else if (this._uniforms[i].getShaderType() === "vert") {
            // * inject member before {injectionString}
            if (
              !this._injectedStringsVert[
                this._uniforms[i]._structName
              ].includes(stringToInsert)
            ) {
              const insertionIndexVert =
                structStrVert.lastIndexOf(injectionString);

              structStrVert =
                structStrVert.slice(0, insertionIndexVert) +
                stringToInsert +
                structStrVert.slice(insertionIndexVert - 1);

              this._injectedStringsVert[this._uniforms[i]._structName].push(
                stringToInsert
              );
            }

            if (!this._structUniformNamesIndicesVert.includes(i))
              this._structUniformNamesIndicesVert.push(i);
          }
        }
      }

      // * dedupe injected uni declarations
      this._uniDeclarationsFrag = [];
      this._uniDeclarationsVert = [];

      // * remove struct injection points and add uniform in fragment
      for (let i = 0; i < this._structUniformNamesIndicesFrag.length; i += 1) {
        const index = this._structUniformNamesIndicesFrag[i];
        const uniDeclarationString =
          "UNI " +
          this._uniforms[index]._structName +
          " " +
          this._uniforms[index]._structUniformName +
          ";".endl();

        if (!this._uniDeclarationsFrag.includes(uniDeclarationString)) {
          const injectionString =
            "{{INJECTION_POINT_STRUCT_" +
            this._uniforms[index]._structName +
            "}}";

          structStrFrag = structStrFrag.replace(injectionString, "");
          structStrFrag += uniDeclarationString;

          this._uniDeclarationsFrag.push(uniDeclarationString);
        }
      }

      // * remove struct injection points and add uniform in vertex
      for (let i = 0; i < this._structUniformNamesIndicesVert.length; i += 1) {
        const index = this._structUniformNamesIndicesVert[i];
        const uniDeclarationString =
          "UNI " +
          this._uniforms[index]._structName +
          " " +
          this._uniforms[index]._structUniformName +
          ";".endl();

        if (!this._uniDeclarationsVert.includes(uniDeclarationString)) {
          const injectionString =
            "{{INJECTION_POINT_STRUCT_" +
            this._uniforms[index]._structName +
            "}}";

          structStrVert = structStrVert.replace(injectionString, "");
          structStrVert += uniDeclarationString;
          this._uniDeclarationsVert.push(uniDeclarationString);
        }
      }

      return [structStrVert, structStrFrag];
    }

    _getAttrSrc(attr, firstLevel) {
      const r = {};
      if (attr.name && attr.type) {
        r.srcHeadVert = "";
        if (!firstLevel) r.srcHeadVert += "#ifndef ATTRIB_" + attr.name.endl();
        r.srcHeadVert += "#define ATTRIB_" + attr.name.endl();
        r.srcHeadVert += "IN " + attr.type + " " + attr.name + ";".endl();
        if (!firstLevel) r.srcHeadVert += "#endif".endl();

        if (attr.nameFrag) {
          r.srcHeadVert += "";
          if (!firstLevel)
            r.srcHeadVert += "#ifndef ATTRIB_" + attr.nameFrag.endl();
          r.srcHeadVert += "#define ATTRIB_" + attr.nameFrag.endl();
          r.srcHeadVert +=
            "OUT " + attr.type + " " + attr.nameFrag + ";".endl();
          if (!firstLevel) r.srcHeadVert += "#endif".endl();

          r.srcVert = "".endl() + attr.nameFrag + "=" + attr.name + ";";

          r.srcHeadFrag = "";
          if (!firstLevel)
            r.srcHeadFrag += "#ifndef ATTRIB_" + attr.nameFrag.endl();
          r.srcHeadFrag += "#define ATTRIB_" + attr.nameFrag.endl();
          r.srcHeadFrag += "IN " + attr.type + " " + attr.nameFrag + ";".endl();
          if (!firstLevel) r.srcHeadFrag += "#endif".endl();
        }
      }
      return r;
    }

    compile() {
      if (this._cgl.aborted) return;
      const startTime = performance.now();

      this._cgl.profileData.profileShaderCompiles++;
      this._cgl.profileData.profileShaderCompileName =
        this._name + " [" + this._compileReason + "]";

      let extensionString = "";
      if (this._extensions)
        for (let i = 0; i < this._extensions.length; i++)
          extensionString +=
            "#extension " + this._extensions[i] + " : enable".endl();

      let definesStr = "";
      if (this._defines.length) definesStr = "\n// cgl generated".endl();
      for (let i = 0; i < this._defines.length; i++)
        definesStr +=
          "#define " +
          this._defines[i][0] +
          " " +
          this._defines[i][1] +
          "".endl();

      const structStrings = this.createStructUniforms();
      this._cgl.profileData.addHeavyEvent(
        "shader compile",
        this._name + " [" + this._compileReason + "]"
      );
      this._compileReason = "";

      if (this._uniforms) {
        // * we create an array of the uniform names to check our indices & an array to save them
        const uniNames = this._uniforms.map((uni) => {
          return uni._name;
        });
        const indicesToRemove = [];

        // * we go through our uniforms and check if the same name is contained somewhere further in the array
        // * if so, we add the current index to be removed later
        for (let i = 0; i < this._uniforms.length; i++) {
          const uni = this._uniforms[i];
          const nextIndex = uniNames.indexOf(uni._name, i + 1);
          if (nextIndex > -1) indicesToRemove.push(i);
        }

        // * after that, we go through the uniforms backwards (so we keep the order) and remove the indices
        // * also, we reset the locations of all the other valid uniforms
        for (let j = this._uniforms.length - 1; j >= 0; j -= 1) {
          if (indicesToRemove.includes(j)) this._uniforms.splice(j, 1);
          else this._uniforms[j].resetLoc();
        }
      }

      this._cgl.printError("uniform resets");

      if (this.hasTextureUniforms())
        definesStr += "#define HAS_TEXTURES".endl();

      let vs = "";
      let fs = "";

      if (!this.srcFrag) {
        this._log.warn(
          "[cgl shader] has no fragment source!",
          this._name,
          this
        );
        this.srcVert = getDefaultVertexShader();
        this.srcFrag = getDefaultFragmentShader();
        // return;
      }

      if (this.glslVersion == 300) {
        vs =
          "#version 300 es".endl() +
          "// ".endl() +
          "// vertex shader " +
          this._name.endl() +
          "// ".endl() +
          "precision " +
          this.precision +
          " float;".endl() +
          "precision " +
          this.precision +
          " sampler2D;".endl() +
          "".endl() +
          "#define WEBGL2".endl() +
          "#define texture2D texture".endl() +
          "#define UNI uniform".endl() +
          "#define IN in".endl() +
          "#define OUT out".endl();

        fs =
          "#version 300 es".endl() +
          "// ".endl() +
          "// fragment shader " +
          this._name.endl() +
          "// ".endl() +
          "precision " +
          this.precision +
          " float;".endl() +
          "precision " +
          this.precision +
          " sampler2D;".endl() +
          "".endl() +
          "#define WEBGL2".endl() +
          "#define texture2D texture".endl() +
          "#define IN in".endl() +
          "#define OUT out".endl() +
          "#define UNI uniform".endl() +
          "{{DRAWBUFFER}}".endl();
      } else {
        fs =
          "".endl() +
          "// ".endl() +
          "// fragment shader " +
          this._name.endl() +
          "// ".endl() +
          "#define WEBGL1".endl() +
          "#define texture texture2D".endl() +
          "#define outColor gl_FragColor".endl() +
          "#define IN varying".endl() +
          "#define UNI uniform".endl();

        vs =
          "".endl() +
          "// ".endl() +
          "// vertex shader " +
          this._name.endl() +
          "// ".endl() +
          "#define WEBGL1".endl() +
          "#define texture texture2D".endl() +
          "#define OUT varying".endl() +
          "#define IN attribute".endl() +
          "#define UNI uniform".endl();
      }

      let uniformsStrVert = "\n// cgl generated".endl();
      let uniformsStrFrag = "\n// cgl generated".endl();

      fs += "\n// active mods: --------------- ";
      vs += "\n// active mods: --------------- ";

      let foundModsFrag = false;
      let foundModsVert = false;
      for (let i = 0; i < this._moduleNames.length; i++) {
        for (let j = 0; j < this._modules.length; j++) {
          if (this._modules[j].name == this._moduleNames[i]) {
            if (this._modules[j].srcBodyFrag || this._modules[j].srcHeadFrag) {
              foundModsFrag = true;
              fs +=
                "\n// " +
                i +
                "." +
                j +
                ". " +
                this._modules[j].title +
                " (" +
                this._modules[j].name +
                ")";
            }
            if (this._modules[j].srcBodyVert || this._modules[j].srcHeadVert) {
              vs +=
                "\n// " +
                i +
                "." +
                j +
                ". " +
                this._modules[j].title +
                " (" +
                this._modules[j].name +
                ")";
              foundModsVert = true;
            }
          }
        }
      }
      if (!foundModsVert) fs += "\n// no mods used...";
      if (!foundModsFrag) fs += "\n// no mods used...";
      fs += "\n";
      vs += "\n";

      for (let i = 0; i < this._uniforms.length; i++) {
        if (
          this._uniforms[i].shaderType &&
          !this._uniforms[i].isStructMember()
        ) {
          let uniStr = "";
          if (!this._uniforms[i].getGlslTypeString()) uniStr += "// ";
          uniStr +=
            "UNI " +
            this._uniforms[i].getGlslTypeString() +
            " " +
            this._uniforms[i].getName();
          let comment = "";
          if (this._uniforms[i].comment)
            comment = " // " + this._uniforms[i].comment;

          if (
            this._uniforms[i].shaderType == "vert" ||
            this._uniforms[i].shaderType == "both"
          )
            if (
              !this.srcVert.contains(uniStr) &&
              !this.srcVert.contains(
                "uniform " +
                  this._uniforms[i].getGlslTypeString() +
                  " " +
                  this._uniforms[i].getName()
              )
            )
              uniformsStrVert += uniStr + ";" + comment.endl();

          if (
            this._uniforms[i].shaderType == "frag" ||
            this._uniforms[i].shaderType == "both"
          )
            if (
              !this.srcFrag.contains(uniStr) &&
              !this.srcFrag.contains(
                "uniform " +
                  this._uniforms[i].getGlslTypeString() +
                  " " +
                  this._uniforms[i].getName()
              )
            )
              uniformsStrFrag += uniStr + ";" + comment.endl();
        }
      }

      let countUniFrag = 0;
      let countUniVert = 0;
      for (let i = 0; i < this._uniforms.length; i++) {
        if (
          this._uniforms[i].shaderType &&
          !this._uniforms[i].isStructMember()
        ) {
          if (
            this._uniforms[i].shaderType == "vert" ||
            this._uniforms[i].shaderType == "both"
          )
            countUniVert++;
          if (
            this._uniforms[i].shaderType == "frag" ||
            this._uniforms[i].shaderType == "both"
          )
            countUniFrag++;
        }
      }
      if (countUniFrag >= this._cgl.maxUniformsFrag)
        this._log.warn(
          "[cgl_shader] num uniforms frag: " +
            countUniFrag +
            " / " +
            this._cgl.maxUniformsFrag
        );
      if (countUniVert >= this._cgl.maxUniformsVert)
        this._log.warn(
          "[cgl_shader] num uniforms vert: " +
            countUniVert +
            " / " +
            this._cgl.maxUniformsVert
        );

      if (!fs.contains("precision"))
        fs = "precision " + this.precision + " float;".endl() + fs;
      if (!vs.contains("precision"))
        vs = "precision " + this.precision + " float;".endl() + vs;
      if (
        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        )
      ) {
        fs += "#define MOBILE".endl();
        vs += "#define MOBILE".endl();
      }
      vs =
        extensionString +
        vs +
        definesStr +
        structStrings[0] +
        uniformsStrVert +
        "\n// -- \n" +
        this.srcVert;
      fs =
        extensionString +
        fs +
        definesStr +
        structStrings[1] +
        uniformsStrFrag +
        "\n// -- \n" +
        this.srcFrag;

      let srcHeadVert = "";
      let srcHeadFrag = "";

      // testing if this breaks things...
      // this._modules.sort(function (a, b)
      // {
      //     return a.group - b.group;
      // });

      this._modules.sort(function (a, b) {
        return a.priority || 0 - b.priority || 0;
      });

      let addedAttribs = false;

      for (let i = 0; i < this._moduleNames.length; i++) {
        let srcVert = "";
        let srcFrag = "";

        if (!addedAttribs) {
          addedAttribs = true;

          for (let k = 0; k < this._attributes.length; k++) {
            const r = this._getAttrSrc(this._attributes[k], true);
            if (r.srcHeadVert) srcHeadVert += r.srcHeadVert;
            if (r.srcVert) srcVert += r.srcVert;
            if (r.srcHeadFrag) srcHeadFrag += r.srcHeadFrag;
          }
        }

        for (let j = 0; j < this._modules.length; j++) {
          const mod = this._modules[j];
          if (mod.name == this._moduleNames[i]) {
            srcHeadVert +=
              "\n//---- MOD: group:" +
              mod.group +
              ": idx:" +
              j +
              " - prfx:" +
              mod.prefix +
              " - " +
              mod.title +
              " ------\n";
            srcHeadFrag +=
              "\n//---- MOD: group:" +
              mod.group +
              ": idx:" +
              j +
              " - prfx:" +
              mod.prefix +
              " - " +
              mod.title +
              " ------\n";

            srcVert +=
              "\n\n//---- MOD: " +
              mod.title +
              " / " +
              mod.priority +
              " ------\n";
            srcFrag +=
              "\n\n//---- MOD: " +
              mod.title +
              " / " +
              mod.priority +
              " ------\n";

            if (mod.attributes)
              for (let k = 0; k < mod.attributes.length; k++) {
                const r = this._getAttrSrc(mod.attributes[k], false);
                if (r.srcHeadVert) srcHeadVert += r.srcHeadVert;
                if (r.srcVert) srcVert += r.srcVert;
                if (r.srcHeadFrag) srcHeadFrag += r.srcHeadFrag;
              }

            srcHeadVert += mod.srcHeadVert || "";
            srcHeadFrag += mod.srcHeadFrag || "";
            srcVert += mod.srcBodyVert || "";
            srcFrag += mod.srcBodyFrag || "";

            srcHeadVert += "\n//---- end mod ------\n";
            srcHeadFrag += "\n//---- end mod ------\n";

            srcVert += "\n//---- end mod ------\n";
            srcFrag += "\n//---- end mod ------\n";

            srcVert = srcVert.replace(/{{mod}}/g, mod.prefix);
            srcFrag = srcFrag.replace(/{{mod}}/g, mod.prefix);
            srcHeadVert = srcHeadVert.replace(/{{mod}}/g, mod.prefix);
            srcHeadFrag = srcHeadFrag.replace(/{{mod}}/g, mod.prefix);

            srcVert = srcVert.replace(/MOD_/g, mod.prefix);
            srcFrag = srcFrag.replace(/MOD_/g, mod.prefix);
            srcHeadVert = srcHeadVert.replace(/MOD_/g, mod.prefix);
            srcHeadFrag = srcHeadFrag.replace(/MOD_/g, mod.prefix);
          }
        }

        vs = vs.replace("{{" + this._moduleNames[i] + "}}", srcVert);
        fs = fs.replace("{{" + this._moduleNames[i] + "}}", srcFrag);
      }

      vs = vs.replace("{{MODULES_HEAD}}", srcHeadVert);
      fs = fs.replace("{{MODULES_HEAD}}", srcHeadFrag);

      vs = this._addLibs(vs);
      fs = this._addLibs(fs);

      // SETUP draw buffers / multi texture render targets

      let drawBufferStr = "";
      for (let i = 0; i < 16; i++)
        if (fs.contains("outColor" + i)) this._drawBuffers[i] = true;

      if (this._drawBuffers.length == 1) {
        drawBufferStr = "out vec4 outColor;".endl();
        drawBufferStr += "#define gl_FragColor outColor".endl();
      } else {
        drawBufferStr += "#define MULTI_COLORTARGETS".endl();
        drawBufferStr += "vec4 outColor;".endl();

        let count = 0;
        for (let i = 0; i < this._drawBuffers.length; i++) {
          if (count == 0)
            drawBufferStr += "#define gl_FragColor outColor" + i + "".endl();
          drawBufferStr +=
            "layout(location = " + i + ") out vec4 outColor" + i + ";".endl();
          count++;
        }
      }

      fs = fs.replace("{{DRAWBUFFER}}", drawBufferStr);
      // //////

      if (!this._program) {
        this._program = this._createProgram(vs, fs);
      } else {
        // this.vshader=createShader(vs, gl.VERTEX_SHADER, this.vshader );
        // this.fshader=createShader(fs, gl.FRAGMENT_SHADER, this.fshader );
        // linkProgram(program);
        this._program = this._createProgram(vs, fs);

        this._projMatrixUniform = null;

        for (let i = 0; i < this._uniforms.length; i++)
          this._uniforms[i].resetLoc();
      }

      this.finalShaderFrag = fs;
      this.finalShaderVert = vs;

      MESH.lastMesh = null;
      MESH.lastShader = null;

      this._countMissingUniforms = 0;
      this._needsRecompile = false;
      this.lastCompile = now();

      // this._cgl.printError("shader compile");

      this._cgl.profileData.shaderCompileTime += performance.now() - startTime;
    }

    hasChanged() {
      return this._needsRecompile;
    }

    bind() {
      if (!this._isValid || this._cgl.aborted) return;

      MESH.lastShader = this;

      if (!this._program || this._needsRecompile) this.compile();
      if (!this._isValid) return;

      if (!this._projMatrixUniform && !this.ignoreMissingUniforms) {
        this._countMissingUniforms++;
        // if (this._countMissingUniforms == 10)console.log("stopping getlocation of missing uniforms...", this._name);
        if (this._countMissingUniforms < 10) {
          this._projMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            constants_CONSTANTS.SHADER.SHADERVAR_UNI_PROJMAT
          );
          this._attrVertexPos = this._cgl.glGetAttribLocation(
            this._program,
            constants_CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION
          );
          this._mvMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            "mvMatrix"
          );
          this._vMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            constants_CONSTANTS.SHADER.SHADERVAR_UNI_VIEWMAT
          );
          this._mMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            constants_CONSTANTS.SHADER.SHADERVAR_UNI_MODELMAT
          );
          this._camPosUniform = this._cgl.gl.getUniformLocation(
            this._program,
            constants_CONSTANTS.SHADER.SHADERVAR_UNI_VIEWPOS
          );
          this._normalMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            constants_CONSTANTS.SHADER.SHADERVAR_UNI_NORMALMAT
          );
          this._inverseViewMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            constants_CONSTANTS.SHADER.SHADERVAR_UNI_INVVIEWMAT
          );
          this._inverseProjMatrixUniform = this._cgl.gl.getUniformLocation(
            this._program,
            constants_CONSTANTS.SHADER.SHADERVAR_UNI_INVPROJMAT
          );
          this._materialIdUniform = this._cgl.gl.getUniformLocation(
            this._program,
            constants_CONSTANTS.SHADER.SHADERVAR_UNI_MATERIALID
          );
          this._objectIdUniform = this._cgl.gl.getUniformLocation(
            this._program,
            constants_CONSTANTS.SHADER.SHADERVAR_UNI_OBJECTID
          );

          for (let i = 0; i < this._uniforms.length; i++)
            this._uniforms[i].needsUpdate = true;
        }
      }

      if (this._cgl.currentProgram != this._program) {
        this._cgl.profileData.profileShaderBinds++;
        this._cgl.gl.useProgram(this._program);
        this._cgl.currentProgram = this._program;
      }

      for (let i = 0; i < this._uniforms.length; i++)
        if (this._uniforms[i].needsUpdate) this._uniforms[i].updateValue();

      if (this._pMatrixState != this._cgl.getProjectionMatrixStateCount()) {
        this._pMatrixState = this._cgl.getProjectionMatrixStateCount();
        this._cgl.gl.uniformMatrix4fv(
          this._projMatrixUniform,
          false,
          this._cgl.pMatrix
        );
        this._cgl.profileData.profileMVPMatrixCount++;
      }

      if (this._objectIdUniform)
        this._cgl.gl.uniform1f(
          this._objectIdUniform,
          ++this._cgl.tempData.objectIdCounter
        );

      if (this._materialIdUniform)
        this._cgl.gl.uniform1f(this._materialIdUniform, this._materialId);

      if (this._vMatrixUniform) {
        if (this._vMatrixState != this._cgl.getViewMatrixStateCount()) {
          this._cgl.gl.uniformMatrix4fv(
            this._vMatrixUniform,
            false,
            this._cgl.vMatrix
          );
          this._cgl.profileData.profileMVPMatrixCount++;
          this._vMatrixState = this._cgl.getViewMatrixStateCount();

          if (this._inverseViewMatrixUniform) {
            mat4.invert(this._tempInverseViewMatrix, this._cgl.vMatrix);
            this._cgl.gl.uniformMatrix4fv(
              this._inverseViewMatrixUniform,
              false,
              this._tempInverseViewMatrix
            );
            this._cgl.profileData.profileMVPMatrixCount++;
          }
          if (this._inverseProjMatrixUniform) {
            mat4.invert(this._tempInverseProjMatrix, this._cgl.pMatrix);
            this._cgl.gl.uniformMatrix4fv(
              this._inverseProjMatrixUniform,
              false,
              this._tempInverseProjMatrix
            );
            this._cgl.profileData.profileMVPMatrixCount++;
          }
        }
        this._cgl.gl.uniformMatrix4fv(
          this._mMatrixUniform,
          false,
          this._cgl.mMatrix
        );
        this._cgl.profileData.profileMVPMatrixCount++;

        if (this._camPosUniform) {
          mat4.invert(this._tempCamPosMatrix, this._cgl.vMatrix);
          this._cgl.gl.uniform3f(
            this._camPosUniform,
            this._tempCamPosMatrix[12],
            this._tempCamPosMatrix[13],
            this._tempCamPosMatrix[14]
          );
          this._cgl.profileData.profileMVPMatrixCount++;
        }
      } else {
        // mvmatrix deprecated....
        const tempmv = mat4.create();

        mat4.mul(tempmv, this._cgl.vMatrix, this._cgl.mMatrix);
        this._cgl.gl.uniformMatrix4fv(this._mvMatrixUniform, false, tempmv);
        this._cgl.profileData.profileMVPMatrixCount++;
      }

      if (this._normalMatrixUniform) {
        // mat4.mul(this._tempNormalMatrix, this._cgl.vMatrix, this._cgl.mMatrix);
        mat4.invert(this._tempNormalMatrix, this._cgl.mMatrix);
        mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix);

        this._cgl.gl.uniformMatrix4fv(
          this._normalMatrixUniform,
          false,
          this._tempNormalMatrix
        );
        this._cgl.profileData.profileMVPMatrixCount++;
      }

      for (let i = 0; i < this._libs.length; i++) {
        if (this._libs[i].onBind)
          this._libs[i].onBind.bind(this._libs[i])(this._cgl, this);
      }

      this._bindTextures();

      return this._isValid;
    }

    unBind() {}

    dispose() {
      this._cgl.gl.deleteProgram(this._program);
    }

    needsRecompile() {
      return this._needsRecompile;
    }

    setDrawBuffers(arr) {
      console.log("useless drawbuffers...?!");
      // if (this._drawBuffers.length !== arr.length)
      // {
      //     this._drawBuffers = arr;
      //     this._needsRecompile = true;
      //     this.setWhyCompile("setDrawBuffers");
      //     return;
      // }
      // for (let i = 0; i < arr.length; i++)
      // {
      //     if (arr[i] !== this._drawBuffers[i])
      //     {
      //         this._drawBuffers = arr;
      //         this._needsRecompile = true;
      //         this.setWhyCompile("setDrawBuffers");
      //         return;
      //     }
      // }
    }

    getUniforms() {
      return this._uniforms;
    }

    getUniform(name) {
      for (let i = 0; i < this._uniforms.length; i++)
        if (this._uniforms[i].getName() == name) return this._uniforms[i];
      return null;
    }

    removeAllUniforms() {
      this._uniforms = [];
      // for (let i = 0; i < this._uniforms.length; i++)
      //     this.removeUniform(this._uniforms[i].name);
    }

    removeUniform(name) {
      for (let i = 0; i < this._uniforms.length; i++) {
        if (this._uniforms[i].getName() == name) {
          this._uniforms.splice(i, 1);
        }
      }
      this._needsRecompile = true;
      this.setWhyCompile("remove uniform " + name);
    }

    _addUniform(uni) {
      this._uniforms.push(uni);
      this.setWhyCompile("add uniform " + name);
      this._needsRecompile = true;
    }

    /**
     * add a uniform to the fragment shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniformFrag
     * @returns {CGL.Uniform}
     */
    addUniformFrag(type, name, valueOrPort, p2, p3, p4) {
      const uni = new CGL.Uniform(this, type, name, valueOrPort, p2, p3, p4);
      uni.shaderType = "frag";
      return uni;
    }

    /**
     * add a uniform to the vertex shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniformVert
     * @returns {CGL.Uniform}
     */
    addUniformVert(type, name, valueOrPort, p2, p3, p4) {
      const uni = new CGL.Uniform(this, type, name, valueOrPort, p2, p3, p4);
      uni.shaderType = "vert";
      return uni;
    }
    /**
     * add a uniform to both shaders
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniformBoth
     * @returns {CGL.Uniform}
     */
    addUniformBoth(type, name, valueOrPort, p2, p3, p4) {
      const uni = new CGL.Uniform(this, type, name, valueOrPort, p2, p3, p4);
      uni.shaderType = "both";
      return uni;
    }

    /**
     * add a struct & its uniforms to the fragment shader
     * @param {String} structName name of the struct, i.e.: LightStruct
     * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
     * @param {Array} members array of objects containing the struct members. see example for structure

     * @memberof Shader
     * @instance
     * @function addUniformStructFrag
     * @returns {Object}
     * @example
     * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
     * shader.setSource(attachments.shader_vert, attachments.shader_frag);
     * shader.addUniformStructFrag("Light", "uniformLight", [
     * { "type": "3f", "name": "position", "v1": null },
     * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
     * ]);
     */
    addUniformStructFrag(structName, uniformName, members) {
      const uniforms = {};

      if (!members) return uniforms;

      for (let i = 0; i < members.length; i += 1) {
        const member = members[i];
        if (!this.hasUniform(uniformName + "." + member.name)) {
          const uni = new CGL.Uniform(
            this,
            member.type,
            uniformName + "." + member.name,
            member.v1,
            member.v2,
            member.v3,
            member.v4,
            uniformName,
            structName,
            member.name
          );
          uni.shaderType = "frag";
          uniforms[uniformName + "." + member.name] = uni;
        }
      }

      return uniforms;
    }

    /**
     * add a struct & its uniforms to the vertex shader
     * @param {String} structName name of the struct, i.e.: LightStruct
     * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
     * @param {Array} members array of objects containing the struct members. see example for structure

     * @memberof Shader
     * @instance
     * @function addUniformStructVert
     * @returns {CGL.Uniform}
     * @example
     * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
     * shader.setSource(attachments.shader_vert, attachments.shader_frag);
     * shader.addUniformStructVert("Light", "uniformLight", [
     * { "type": "3f", "name": "position", "v1": null },
     * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
     * ]);
     */
    addUniformStructVert(structName, uniformName, members) {
      const uniforms = {};

      if (!members) return uniforms;

      for (let i = 0; i < members.length; i += 1) {
        const member = members[i];
        if (!this.hasUniform(uniformName + "." + member.name)) {
          const uni = new CGL.Uniform(
            this,
            member.type,
            uniformName + "." + member.name,
            member.v1,
            member.v2,
            member.v3,
            member.v4,
            uniformName,
            structName,
            member.name
          );
          uni.shaderType = "vert";
          uniforms[uniformName + "." + member.name] = uni;
        }
      }

      return uniforms;
    }

    /**
     * add a struct & its uniforms to the both shaders. PLEASE NOTE: it is not possible to add the same struct to both shaders when it contains ANY integer members.
     * @param {String} structName name of the struct, i.e.: LightStruct
     * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni
     * @param {Array} members array of objects containing the struct members. see example for structure

     * @memberof Shader
     * @instance
     * @function addUniformStructBoth
     * @returns {Object}
     * @example
     * const shader = new CGL.Shader(cgl, 'MinimalMaterial');
     * shader.setSource(attachments.shader_vert, attachments.shader_frag);
     * shader.addUniformStructBoth("Light", "uniformLight", [
     * { "type": "3f", "name": "position", "v1": null },
     * { "type": "4f", "name": "color", "v1": inR, v2: inG, v3: inB, v4: inAlpha }
     * ]);
     */
    addUniformStructBoth(structName, uniformName, members) {
      const uniforms = {};

      if (!members) return uniforms;

      for (let i = 0; i < members.length; i += 1) {
        const member = members[i];
        if (member.type === "2i" || member.type === "i" || member.type === "3i")
          this._log.error(
            "Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:",
            structName,
            " with member:",
            member.name,
            " of type:",
            member.type,
            "."
          );
        if (!this.hasUniform(uniformName + "." + member.name)) {
          const uni = new CGL.Uniform(
            this,
            member.type,
            uniformName + "." + member.name,
            member.v1,
            member.v2,
            member.v3,
            member.v4,
            uniformName,
            structName,
            member.name
          );
          uni.shaderType = "both";
          uniforms[uniformName + "." + member.name] = uni;
        }
      }

      return uniforms;
    }

    hasUniform(name) {
      for (let i = 0; i < this._uniforms.length; i++) {
        if (this._uniforms[i].getName() == name) return true;
      }
      return false;
    }

    _createProgram(vstr, fstr) {
      this._cgl.printError("before _createprogram");

      const program = this._cgl.gl.createProgram();

      this.vshader = Shader.createShader(
        this._cgl,
        vstr,
        this._cgl.gl.VERTEX_SHADER,
        this
      );
      this.fshader = Shader.createShader(
        this._cgl,
        fstr,
        this._cgl.gl.FRAGMENT_SHADER,
        this
      );

      if (this.vshader && this.fshader) {
        this._cgl.gl.attachShader(program, this.vshader);
        this._cgl.gl.attachShader(program, this.fshader);

        this._linkProgram(program, vstr, fstr);
      } else {
        this._isValid = false;
        this._cgl.printError("shader _createProgram");
        this._log.error("could not link shaderprogram");
        return null;
      }

      this._cgl.printError("shader _createProgram");
      return program;
    }

    hasErrors() {
      return this._hasErrors;
    }

    _linkProgram(program, vstr, fstr) {
      this._cgl.printError("before _linkprogram");

      if (this._feedBackNames.length > 0) {
        this._cgl.gl.transformFeedbackVaryings(
          program,
          this._feedBackNames,
          this._cgl.gl.SEPARATE_ATTRIBS
        );
        // INTERLEAVED_ATTRIBS
        // SEPARATE_ATTRIBS
      }

      this._cgl.gl.linkProgram(program);
      this._cgl.printError("gl.linkprogram");
      this._isValid = true;

      this._hasErrors = false;

      if (this._cgl.patch.config.glValidateShader !== false) {
        this._cgl.gl.validateProgram(program);

        if (
          !this._cgl.gl.getProgramParameter(
            program,
            this._cgl.gl.VALIDATE_STATUS
          )
        ) {
          // validation failed
          console.log("shaderprogram validation failed...");
          console.log(
            this._name + " programinfo: ",
            this._cgl.gl.getProgramInfoLog(program)
          );
        }

        if (
          !this._cgl.gl.getProgramParameter(program, this._cgl.gl.LINK_STATUS)
        ) {
          this._hasErrors = true;

          const infoLogFrag = this._cgl.gl.getShaderInfoLog(this.fshader);
          const infoLogVert = this._cgl.gl.getShaderInfoLog(this.vshader);

          if (infoLogFrag)
            this._log.warn(this._cgl.gl.getShaderInfoLog(this.fshader));
          if (infoLogVert)
            this._log.warn(this._cgl.gl.getShaderInfoLog(this.vshader));

          this._log.error(this._name + " shader linking fail...");

          console.log(
            this._name + " programinfo: ",
            this._cgl.gl.getProgramInfoLog(program)
          );
          console.log(this);
          this._isValid = false;

          this._name = "errorshader";
          this.setSource(
            Shader.getDefaultVertexShader(),
            Shader.getErrorFragmentShader()
          );
          this._cgl.printError("shader link err");
        }
      }
    }

    getProgram() {
      return this._program;
    }

    setFeedbackNames(names) {
      this.setWhyCompile("setFeedbackNames");
      this._needsRecompile = true;
      this._feedBackNames = names;
    }

    // getDefaultVertexShader()
    // {
    //     return defaultShaderSrcVert;
    // }

    // getDefaultFragmentShader()
    // {
    //     return this.getDefaultFragmentShader()
    // }

    /**
     * adds attribute definition to shader header without colliding with other shader modules...
     * when attrFrag is defined, vertex shader will output this attribute to the fragment shader
     * @function
     * @memberof Shader
     * @instance
     * @param {Object} attr {type:x,name:x,[nameFrag:x]}
     * @return {Object}
     */
    addAttribute = function (attr) {
      for (let i = 0; i < this._attributes.length; i++) {
        if (
          this._attributes[i].name == attr.name &&
          this._attributes[i].nameFrag == attr.nameFrag
        )
          return;
      }
      this._attributes.push(attr);
      this._needsRecompile = true;
      this.setWhyCompile("addAttribute");
    };

    bindTextures() {
      this._bindTextures();
    }
    _bindTextures() {
      if (this._textureStackTex.length > this._cgl.maxTextureUnits) {
        this._log.warn(
          "[shader._bindTextures] too many textures bound",
          this._textureStackTex.length + "/" + this._cgl.maxTextureUnits
        );
      }

      // for (let i = this._textureStackTex.length + 1; i < this._cgl.maxTextureUnits; i++) this._cgl.setTexture(i, null);

      for (let i = 0; i < this._textureStackTex.length; i++) {
        // console.log(this._textureStackTex.length, i);
        if (!this._textureStackTex[i] && !this._textureStackTexCgl[i]) {
          this._log.warn("no texture for pushtexture", this._name);
        } else {
          let t = this._textureStackTex[i];
          if (this._textureStackTexCgl[i]) {
            t =
              this._textureStackTexCgl[i].tex ||
              CGL.Texture.getEmptyTexture(this._cgl).tex;
          }

          let bindOk = true;

          if (!this._textureStackUni[i]) {
            // throw(new Error('no uniform given to texturestack'));
            this._log.warn("no uniform for pushtexture", this._name);
            bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);
          } else {
            this._textureStackUni[i].setValue(i);
            bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);

            // console.log(bindOk, i, t, this._textureStackType[i]);
          }
          if (!bindOk)
            console.warn(
              "tex bind failed",
              this.getName(),
              this._textureStackUni[i]
            );
        }
      }
    }

    setUniformTexture = function (uni, tex) {
      tex = tex || CGL.Texture.getTempTexture(this._cgl);
      for (let i = 0; i < this._textureStackUni.length; i++)
        if (this._textureStackUni[i] == uni) {
          const old = this._textureStackTex[i] || this._textureStackTexCgl[i];
          if (tex.hasOwnProperty("tex")) {
            this._textureStackTexCgl[i] = tex;
            this._textureStackTex[i] = null;
          } else {
            this._textureStackTexCgl[i] = null;
            this._textureStackTex[i] = tex;
          }

          // this._textureStackTex[i] = tex;
          // this._cgl.setTexture(i, tex, this._textureStackType[i]);
          return old;
        }
      return null;
    };

    /**
     * push a texture on the stack. those textures will be bound when binding the shader. texture slots are automatically set
     * @param {uniform} uniform texture uniform
     * @param {texture} t texture
     * @param {type} type texture type, can be ignored when TEXTURE_2D
     * @function pushTexture
     * @memberof Shader
     * @instance
     */
    pushTexture = function (uniform, t, type) {
      if (!uniform) {
        // console.log("pushtexture: no uniform given to texturestack", "shader:"+this._name,uniform,t,type);
        return;
      }
      if (!t) {
        // if(uniform)this._log.warn("pushtexture: no tex","shader:"+this._name," uniform:"+uniform.name);
        return;
      }
      if (!t.hasOwnProperty("tex") && !(t instanceof WebGLTexture)) {
        this._log.warn(new Error("invalid texture").stack);

        this._log.warn("[cgl_shader] invalid texture...", t);
        return;
      }

      this._textureStackUni.push(uniform);

      if (t.hasOwnProperty("tex")) {
        this._textureStackTexCgl.push(t);
        this._textureStackTex.push(null);
      } else {
        this._textureStackTexCgl.push(null);
        this._textureStackTex.push(t);
      }

      this._textureStackType.push(type);
    };

    /**
     * pop last texture
     * @function popTexture
     * @memberof Shader
     * @instance
     */
    popTexture = function () {
      this._textureStackUni.pop();
      this._textureStackTex.pop();
      this._textureStackTexCgl.pop();
      this._textureStackType.pop();
    };

    /**
     * pop all textures
     * @function popTextures
     * @memberof Shader
     * @instance
     */
    popTextures = function () {
      this._textureStackTex.length =
        this._textureStackTexCgl.length =
        this._textureStackType.length =
        this._textureStackUni.length =
          0;
    };

    getMaterialId() {
      return this._materialId;
    }

    getInfo() {
      const info = {};
      info.name = this._name;
      // info.modules = JSON.parse(JSON.stringify(this._modules));
      // info.defines = JSON.parse(JSON.stringify(this._defines));
      info.defines = this.getDefines();
      info.hasErrors = this.hasErrors();

      return info;
    }

    getDefaultFragmentShader = function (r, g, b, a) {
      return getDefaultFragmentShader(r, g, b, a);
    };

    getDefaultVertexShader = function () {
      return getDefaultVertexShader();
    };
  }

  // --------------------------

  Shader.getDefaultVertexShader = getDefaultVertexShader;
  Shader.getDefaultFragmentShader = getDefaultFragmentShader;

  Shader.getErrorFragmentShader = function () {
    return (
      "".endl() +
      "void main()".endl() +
      "{".endl() +
      "   float g=mod((gl_FragCoord.y+gl_FragCoord.x),50.0)/50.0;".endl() +
      "   g= step(0.1,g);".endl() +
      "   outColor = vec4( g+0.5, 0.0, 0.0, 1.0);".endl() +
      "}"
    );
  };

  Shader.createShader = function (cgl, str, type, cglShader) {
    if (cgl.aborted) return;

    // cgl.printError("[Shader.createShader] ", cglShader._name);

    function getBadLines(infoLog) {
      const basLines = [];
      const lines = infoLog.split("\n");
      for (const i in lines) {
        const divide = lines[i].split(":");
        if (parseInt(divide[2], 10)) basLines.push(parseInt(divide[2], 10));
      }
      return basLines;
    }

    const shader = cgl.gl.createShader(type);
    cgl.gl.shaderSource(shader, str);
    cgl.gl.compileShader(shader);

    if (!cgl.gl.getShaderParameter(shader, cgl.gl.COMPILE_STATUS)) {
      let infoLog = cgl.gl.getShaderInfoLog(shader);
      if (!infoLog) {
        console.warn("empty shader info log", this._name);
        return;
      }

      const badLines = getBadLines(infoLog);
      let htmlWarning =
        '<pre style="margin-bottom:0px;"><code class="shaderErrorCode language-glsl" style="padding-bottom:0px;max-height: initial;max-width: initial;">';
      const lines = str.match(/^.*((\r\n|\n|\r)|$)/gm);

      if (!cgl.aborted && infoLog) {
        if (type == cgl.gl.VERTEX_SHADER) console.log("VERTEX_SHADER");
        if (type == cgl.gl.FRAGMENT_SHADER) console.log("FRAGMENT_SHADER");

        for (const i in lines) {
          const j = parseInt(i, 10) + 1;
          const line = j + ": " + lines[i];

          let isBadLine = false;
          for (const bj in badLines) if (badLines[bj] == j) isBadLine = true;

          if (isBadLine) {
            htmlWarning += "</code></pre>";
            htmlWarning +=
              '<pre style="margin:0"><code class="language-glsl" style="background-color:#660000;padding-top:0px;padding-bottom:0px">';

            cglShader._log.log("bad line: `" + line + "`");
          }
          htmlWarning += escapeHTML(line);

          if (isBadLine) {
            htmlWarning += "</code></pre>";
            htmlWarning +=
              '<pre style="margin:0"><code class="language-glsl" style=";padding-top:0px;padding-bottom:0px">';
          }
        }
      }

      infoLog = infoLog.replace(/\n/g, "<br/>");
      if (cgl.patch.isEditorMode())
        console.log("Shader error ", cglShader._name, infoLog, this);

      htmlWarning = infoLog + "<br/>" + htmlWarning + "<br/><br/>";
      htmlWarning += "</code></pre>";

      if (this._fromUserInteraction) {
        // console.log("todo show modal?");
        // cgl.patch.emitEvent("criticalError", { "title": "Shader error " + cglShader._name, "text": htmlWarning, "exception": { "message": infoLog } });
      }

      cglShader.setSource(
        Shader.getDefaultVertexShader(),
        Shader.getErrorFragmentShader()
      );
    } else {
      // console.log(name+' shader compiled...');
    }
    // cgl.printError("shader create2");
    return shader;
  }; // CONCATENATED MODULE: ./src/core/cgl/cgl_profiledata.js

  class ProfileData {
    constructor(cgl) {
      this._cgl = cgl;
      this._lastTime = 0;
      this.pause = false;
      this.profileUniformCount = 0;
      this.profileShaderBinds = 0;
      this.profileUniformCount = 0;
      this.profileShaderCompiles = 0;
      this.profileVideosPlaying = 0;
      this.profileMVPMatrixCount = 0;
      this.profileEffectBuffercreate = 0;
      this.profileShaderGetUniform = 0;
      this.profileFrameBuffercreate = 0;
      this.profileMeshSetGeom = 0;
      this.profileTextureNew = 0;
      this.profileGenMipMap = 0;
      this.profileOnAnimFrameOps = 0;

      this.profileFencedPixelRead = 0;
      this.profileMainloopMs = 0;
      this.profileMeshDraw = 0;
      this.profileTextureEffect = 0;
      this.profileTexPreviews = 0;
      this.shaderCompileTime = 0;
      this.profileMeshNumElements = 0;
      this.profileMeshAttributes = 0;
      this.profileSingleMeshAttribute = [];
      this.heavyEvents = [];

      this.doProfileGlQuery = false;
      this.glQueryData = {};
    }

    clear() {
      this.profileSingleMeshAttribute = {};
      this.profileMeshAttributes = 0;
      this.profileUniformCount = 0;
      this.profileShaderGetUniform = 0;
      this.profileShaderCompiles = 0;
      this.profileShaderBinds = 0;
      this.profileTextureResize = 0;
      this.profileFrameBuffercreate = 0;
      this.profileEffectBuffercreate = 0;
      this.profileTextureDelete = 0;
      this.profileMeshSetGeom = 0;
      this.profileVideosPlaying = 0;
      this.profileMVPMatrixCount = 0;
      this.profileNonTypedAttrib = 0;
      this.profileNonTypedAttribNames = "";
      this.profileTextureNew = 0;
      this.profileGenMipMap = 0;
      this.profileFramebuffer = 0;
      this.profileMeshDraw = 0;
      this.profileTextureEffect = 0;
      this.profileTexPreviews = 0;
      this.profileMeshNumElements = 0;
      this.profileFencedPixelRead = 0;
    }

    clearGlQuery() {
      for (let i in this.glQueryData) {
        if (
          !this.glQueryData[i].lastClear ||
          performance.now() - this.glQueryData[i].lastClear > 1000
        ) {
          this.glQueryData[i].time =
            this.glQueryData[i]._times / this.glQueryData[i]._numcount;
          this.glQueryData[i].num = this.glQueryData[i]._numcount;

          this.glQueryData[i]._times = 0;
          this.glQueryData[i]._numcount = 0;
          this.glQueryData[i].lastClear = performance.now();
        }
      }
    }

    addHeavyEvent(event, name, info) {
      const e = {
        event: event,
        name: name,
        info: info,
        date: performance.now(),
      };
      this.heavyEvents.push(e);
      this._cgl.emitEvent("heavyEvent", e);
    }
  } // CONCATENATED MODULE: ../shared/client/src/helper.js

  /**
   * Shared helper methods for cables uis
   */
  class Helper {
    constructor() {
      this._simpleIdCounter = 0;
    }

    /**
     * generate a random v4 uuid
     *
     * @return {string}
     */
    uuid() {
      let d = new Date().getTime();
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === "x" ? r : (r & 0x3) | 0x8).toString(16);
      });
    }

    /**
     * checks value for !isNan and isFinite
     *
     * @param n
     * @return {boolean}
     */
    isNumeric(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * generate a simple ID using an internal counter
     *
     * @return {Number} new id
     * @static
     */
    simpleId() {
      this._simpleIdCounter++;
      return this._simpleIdCounter;
    }

    deletePropertyByPath(obj, path) {
      if (!obj || !path) {
        return;
      }

      if (typeof path === "string") {
        path = path.split(".");
      }

      for (let i = 0; i < path.length - 1; i++) {
        obj = obj[path[i]];

        if (typeof obj === "undefined") {
          return;
        }
      }

      delete obj[path.pop()];
    }
  }
  /* harmony default export */ const helper = new Helper(); // CONCATENATED MODULE: ../shared/client/src/eventtarget.js

  /**
   * add eventlistener functionality to classes
   */
  class Events {
    constructor() {
      this._log = new Logger("eventtarget");
      this._eventCallbacks = {};
      this._logName = "";
      this._logEvents = false;
      this._listeners = {};

      this.on = this.addEventListener;
      this.off = this.removeEventListener;
    }

    /**
     * add event listener
     * @param which event name
     * @param cb callback
     * @param {string} idPrefix prefix for id, default empty
     * @return {string} event id
     */
    addEventListener(which, cb, idPrefix = "") {
      const event = {
        id: (idPrefix || "") + helper.simpleId(),
        name: which,
        cb: cb,
      };
      if (!this._eventCallbacks[which]) this._eventCallbacks[which] = [event];
      else this._eventCallbacks[which].push(event);

      this._listeners[event.id] = event;

      return event.id;
    }

    /**
     * check event listener registration
     * @param id event id
     * @param cb callback - deprecated
     * @return {boolean}
     */
    hasEventListener(id, cb = null) {
      if (id && !cb) {
        // check by id
        return !!this._listeners[id];
      } else {
        this._log.warn("old eventtarget function haseventlistener!");
        if (id && cb) {
          if (this._eventCallbacks[id]) {
            const idx = this._eventCallbacks[id].indexOf(cb);
            return idx !== -1;
          }
        }
      }
    }

    /**
     * check event listener by name
     * @param eventName event name
     * @return {boolean}
     */
    hasListenerForEventName(eventName) {
      return (
        this._eventCallbacks[eventName] &&
        this._eventCallbacks[eventName].length > 0
      );
    }

    /**
     * rempve event listener registration
     * @param id event id
     * @param cb callback - deprecated
     * @return
     */
    removeEventListener(id, cb = null) {
      if (id === null || id === undefined) return;

      if (!cb) {
        // new style, remove by id, not by name/callback
        const event = this._listeners[id];
        if (!event) {
          this._log.log("could not find event...", id, this);
          return;
        }

        let found = true;
        while (found) {
          found = false;
          let index = -1;
          for (let i = 0; i < this._eventCallbacks[event.name].length; i++) {
            if (this._eventCallbacks[event.name][i].id.indexOf(id) === 0) {
              // this._eventCallbacks[event.name][i].id == which ||
              found = true;
              index = i;
            }
          }

          if (index !== -1) {
            this._eventCallbacks[event.name].splice(index, 1);
            delete this._listeners[id];
          }
        }

        return;
      }

      this._log.info(
        "[eventtaget] ",
        "old function signature: removeEventListener! use listener id"
      );
      this._log.log(new Error().stack);

      let index = null;
      for (let i = 0; i < this._eventCallbacks[id].length; i++)
        if (this._eventCallbacks[id][i].cb === cb) index = i;

      if (index !== null) {
        delete this._eventCallbacks[index];
      } else this._log.warn("removeEventListener not found " + id);
    }

    /**
     * enable/disable logging of events for the class
     *
     * @param {boolean} enabled
     * @param {string} logName
     */
    logEvents(enabled, logName) {
      this._logEvents = enabled;
      this._logName = logName;
    }

    /**
     * emit event
     *
     * @param {string} which event name
     * @param {*} param1
     * @param {*} param2
     * @param {*} param3
     * @param {*} param4
     * @param {*} param5
     * @param {*} param6
     */
    emitEvent(
      which,
      param1 = null,
      param2 = null,
      param3 = null,
      param4 = null,
      param5 = null,
      param6 = null
    ) {
      if (this._logEvents)
        this._log.log("[event] ", this._logName, which, this._eventCallbacks);

      if (this._eventCallbacks[which]) {
        for (let i = 0; i < this._eventCallbacks[which].length; i++) {
          if (this._eventCallbacks[which][i]) {
            this._eventCallbacks[which][i].cb(
              param1,
              param2,
              param3,
              param4,
              param5,
              param6
            );
          }
        }
      } else {
        if (this._logEvents)
          this._log.log(
            "[event] has no event callback",
            which,
            this._eventCallbacks
          );
      }
    }
  } // CONCATENATED MODULE: ./src/core/cg/cg_canvas.js

  class CgCanvas {
    constructor(options) {
      if (!options) {
        console.error("CgCanvas no options");
      } else {
        this._canvasEle = options.canvasEle;
      }

      if (!options.cg) console.error("CgCanvas options has no cg");
      if (!options.canvasEle)
        console.error("CgCanvas options has no canvasEle");

      this._cg = options.cg;
      this.pixelDensity = 1;
      this.canvasWidth = this.canvasEle.clientWidth;
      this.canvasHeight = this.canvasEle.clientHeight;

      this._oldWidthRp = -1;
      this._oldHeightRp = -1;

      this.setSize(this.canvasWidth, this.canvasHeight);
    }

    get canvasEle() {
      return this._canvasEle;
    }

    setSize(w, h, ignorestyle) {
      if (
        this._oldWidthRp != w * this.pixelDensity ||
        this._oldHeightRp != h * this.pixelDensity
      ) {
        this._oldWidthRp = this.canvasEle.width = w * this.pixelDensity;
        this._oldHeightRp = this.canvasEle.height = h * this.pixelDensity;

        if (!ignorestyle) {
          this.canvasEle.style.width = w + "px";
          this.canvasEle.style.height = h + "px";
        }

        this.updateSize();

        this._cg.emitEvent("resize");
      }
    }

    updateSize() {
      this.canvasEle.width = this.canvasWidth =
        this.canvasEle.clientWidth * this.pixelDensity;
      this.canvasEle.height = this.canvasHeight =
        this.canvasEle.clientHeight * this.pixelDensity;
    }

    dispose() {
      this._canvasEle.remove();
      this._canvasEle = null;
    }
  } // CONCATENATED MODULE: ./src/core/cg/cg_matrixstack.js

  const MatrixStack = function () {
    this._arr = [mat4.create()];
    this._index = 0;
    this.stateCounter = 0;
  };

  MatrixStack.prototype.push = function (m) {
    this._index++;
    this.stateCounter++;

    if (this._index == this._arr.length) {
      const copy = mat4.create();
      this._arr.push(copy);
    }

    mat4.copy(this._arr[this._index], m || this._arr[this._index - 1]);

    return this._arr[this._index];
  };

  MatrixStack.prototype.pop = function () {
    this.stateCounter++;

    this._index--;
    if (this._index < 0) this._index = 0;

    return this._arr[this._index];
  };

  MatrixStack.prototype.length = function () {
    return this._index;
  }; // CONCATENATED MODULE: ./src/core/cg/cg_state.js

  class CGState extends Events {
    constructor(_patch) {
      super();
      this.tempData = this.frameStore = this.frameStore || {};
      // this.canvas = null;

      this.fpsCounter = new CABLES.CG.FpsCounter();
      this._identView = vec3.create();
      this._ident = vec3.create();
      vec3.set(this._identView, 0, 0, -2);
      vec3.set(this._ident, 0, 0, 0);

      this.patch = _patch;
      this.autoReSize = true;

      this.DEPTH_COMPARE_FUNC_NEVER = 0;
      this.DEPTH_COMPARE_FUNC_LESS = 1;
      this.DEPTH_COMPARE_FUNC_EQUAL = 2;
      this.DEPTH_COMPARE_FUNC_LESSEQUAL = 3;
      this.DEPTH_COMPARE_FUNC_GREATER = 4;
      this.DEPTH_COMPARE_FUNC_NOTEQUAL = 5;
      this.DEPTH_COMPARE_FUNC_GREATEREQUAL = 6;
      this.DEPTH_COMPARE_FUNC_ALWAYS = 7;

      /**
       * Current projection matrix
       * @memberof Context
       * @instance
       * @type {mat4}
       */
      this.pMatrix = mat4.create();

      /**
       * Current model matrix
       * @memberof Context
       * @instance
       * @type {mat4}
       */
      this.mMatrix = mat4.create();

      /**
       * Current view matrix
       * @memberof Context
       * @instance
       * @type {mat4}
       */
      this.vMatrix = mat4.create();
      this._textureslots = [];

      this._pMatrixStack = new MatrixStack();
      this._mMatrixStack = new MatrixStack();
      this._vMatrixStack = new MatrixStack();

      this.canvasScale = 1;

      mat4.identity(this.mMatrix);
      mat4.identity(this.vMatrix);

      window
        .matchMedia("screen and (min-resolution: 2dppx)")
        .addEventListener("change", (e) => {
          this.emitEvent("resize");
        });
    }

    get canvasWidth() {
      return this.cgCanvas.canvasWidth;
    }

    get canvasHeight() {
      return this.cgCanvas.canvasHeight;
    }

    set pixelDensity(p) {
      if (this.cgCanvas.pixelDensity != p) {
        this.cgCanvas.pixelDensity = p;
        this.cgCanvas.updateSize();
        this.emitEvent("resize");
      }
    }

    get pixelDensity() {
      return this.cgCanvas.pixelDensity;
    }

    getGApiName() {
      return ["WebGL", "WebGPU"][this.gApi];
    }

    get canvas() {
      return this.cgCanvas.canvasEle;
    }

    setCanvas(canvEle) {
      if (this.cgCanvas && canvEle == this.cgCanvas.canvasEle) return;
      if (typeof canvEle === "string")
        canvEle = document.getElementById(canvEle);

      this.cgCanvas = new CgCanvas({ canvasEle: canvEle, cg: this });

      canvEle.parentElement.classList.add("cablesContainer");
      if (this._setCanvas) this._setCanvas(canvEle);

      this.updateSize();
    }

    updateSize() {
      this.cgCanvas.updateSize();
    }

    setSize(w, h, ignorestyle) {
      this.cgCanvas.setSize(w, h, ignorestyle);
    }

    _resizeToWindowSize() {
      if (this.autoReSize) {
        this.setSize(window.innerWidth, window.innerHeight);
        this.updateSize();
      }
    }

    _resizeToParentSize() {
      if (this.autoReSize) {
        const p = this.canvas.parentElement;
        if (!p) {
          this._log.error("cables: can not resize to container element");
          return;
        }

        this.setSize(p.clientWidth, p.clientHeight);
        this.updateSize();
      }
    }

    setAutoResize(parent) {
      window.removeEventListener("resize", this._resizeToWindowSize.bind(this));
      window.removeEventListener("resize", this._resizeToParentSize.bind(this));

      if (parent == "window") {
        window.addEventListener("resize", this._resizeToWindowSize.bind(this));
        window.addEventListener(
          "orientationchange",
          this._resizeToWindowSize.bind(this)
        );
        this._resizeToWindowSize();
      }
      if (parent == "parent") {
        window.addEventListener("resize", this._resizeToParentSize.bind(this));
        this._resizeToParentSize();
      }
    }

    /**
     * push a matrix to the projection matrix stack
     * @function pushPMatrix
     * @memberof Context
     * @instance
     */
    pushPMatrix() {
      this.pMatrix = this._pMatrixStack.push(this.pMatrix);
    }

    /**
     * pop projection matrix stack
     * @function popPMatrix
     * @memberof Context
     * @instance
     * @returns {mat4} current projectionmatrix
     */
    popPMatrix() {
      this.pMatrix = this._pMatrixStack.pop();
      return this.pMatrix;
    }

    getProjectionMatrixStateCount() {
      return this._pMatrixStack.stateCounter;
    }

    /**
     * push a matrix to the model matrix stack
     * @function pushModelMatrix
     * @memberof Context
     * @instance
     * @example
     * // see source code of translate op:
     * cgl.pushModelMatrix();
     * mat4.translate(cgl.mMatrix,cgl.mMatrix, vec);
     * trigger.trigger();
     * cgl.popModelMatrix();
     */
    pushModelMatrix() {
      this.mMatrix = this._mMatrixStack.push(this.mMatrix);
    }

    /**
     * pop model matrix stack
     * @function popModelMatrix
     * @memberof Context
     * @instance
     * @returns {mat4} current modelmatrix
     */
    popModelMatrix() {
      // todo: DEPRECATE
      // if (this._mMatrixStack.length === 0) throw "Invalid modelview popMatrix!";
      this.mMatrix = this._mMatrixStack.pop();
      return this.mMatrix;
    }

    /**
     * get model matrix
     * @function modelMatrix
     * @memberof Context
     * @instance
     * @returns {mat4} current modelmatrix
     */
    modelMatrix() {
      return this.mMatrix;
    }

    /**
     * push a matrix to the view matrix stack
     * @function pushviewMatrix
     * @memberof Context
     * @instance
     */
    pushViewMatrix() {
      this.vMatrix = this._vMatrixStack.push(this.vMatrix);
    }

    /**
     * pop view matrix stack
     * @function popViewMatrix
     * @memberof Context
     * @instance
     * @returns {mat4} current viewmatrix
     * @function
     */
    popViewMatrix() {
      this.vMatrix = this._vMatrixStack.pop();
    }

    getViewMatrixStateCount() {
      return this._vMatrixStack.stateCounter;
    }

    _startMatrixStacks(identTranslate, identTranslateView) {
      identTranslate = identTranslate || this._ident;
      identTranslateView = identTranslateView || this._identView;

      mat4.perspective(
        this.pMatrix,
        45,
        this.canvasWidth / this.canvasHeight,
        0.1,
        1000.0
      );

      mat4.identity(this.mMatrix);
      mat4.identity(this.vMatrix);
      mat4.translate(this.mMatrix, this.mMatrix, identTranslate);
      mat4.translate(this.vMatrix, this.vMatrix, identTranslateView);

      this.pushPMatrix();
      this.pushModelMatrix();
      this.pushViewMatrix();
    }

    _endMatrixStacks() {
      this.popViewMatrix();
      this.popModelMatrix();
      this.popPMatrix();
    }

    dispose() {
      this.aborted = true;
      if (this.cgCanvas) this.cgCanvas.dispose();
      if (this._dispose) this._dispose();
    }

    shouldDrawHelpers() {
      return false;
    }
  } // CONCATENATED MODULE: ./src/core/cg/sg_fpscounter.js

  class FpsCounter extends Events {
    constructor() {
      super();
      this._timeStartFrame = 0;
      this._timeStartSecond = 0;
      this._fpsCounter = 0;
      this._msCounter = 0;
      this._frameCount = 0;

      this.stats = { ms: 0, fps: 0 };
    }

    get frameCount() {
      return this._frameCount;
    }

    startFrame() {
      this._timeStartFrame = CABLES.now();
    }

    endFrame() {
      this._frameCount++;
      this._fpsCounter++;

      const timeFrame = CABLES.now() - this._timeStartFrame;
      this._msCounter += timeFrame;

      if (CABLES.now() - this._timeStartSecond > 1000) {
        this.endSecond();
      }
    }

    endSecond() {
      this.stats.fps = this._fpsCounter;
      this.stats.ms =
        Math.round((this._msCounter / this._fpsCounter) * 100) / 100;

      this.emitEvent("performance", this.stats);

      // reset
      this._fpsCounter = 0;
      this._msCounter = 0;
      this._timeStartSecond = CABLES.now();
    }
  } // CONCATENATED MODULE: ./src/core/cg/cg_constants.js

  const CG = {
    GAPI_WEBGL: 0,
    GAPI_WEBGPU: 1,

    DEPTH_COMPARE_NEVER: 0,
    DEPTH_COMPARE_LESS: 1,
    DEPTH_COMPARE_EQUAL: 2,
    DEPTH_COMPARE_LESSEQUAL: 3,
    DEPTH_COMPARE_GREATER: 4,
    DEPTH_COMPARE_NOTEQUAL: 5,
    DEPTH_COMPARE_GREATEREQUAL: 6,
    DEPTH_COMPARE_ALWAYS: 7,

    CULL_NONE: 0,
    CULL_BACK: 1,
    CULL_FRONT: 2,
    CULL_BOTH: 3,

    Geometry: Geometry,
    BoundingBox: BoundingBox,
    FpsCounter: FpsCounter,

    CgCanvas: CgCanvas,
  }; // CONCATENATED MODULE: ./src/core/cgl/cgl_state.js

  /**
   * cables gl context/state manager
   * @class
   * @namespace external:CGL
   * @hideconstructor
   */
  // const Context(_patch)
  class Context extends CGState {
    constructor(_patch) {
      super(_patch);

      this.gApi = CG.GAPI_WEBGL;
      this.aborted = false;

      this.pushMvMatrix = this.pushModelMatrix; // deprecated and wrong... still used??
      this.popMvMatrix = this.popmMatrix = this.popModelMatrix; // deprecated and wrong... still used??

      this.profileData = new ProfileData(this);
      this._log = new Logger("cgl_context", { onError: _patch.config.onError });
      this._viewPort = [0, 0, 0, 0];
      this.glVersion = 0;
      this.glUseHalfFloatTex = false;
      this.clearCanvasTransparent = true;
      this.clearCanvasDepth = true;
      this.debugOneFrame = false;
      this.checkGlErrors = false; // true is slow // false should be default...
      this.maxTextureUnits = 0;
      this.maxVaryingVectors = 0;
      this.currentProgram = null;
      this._hadStackError = false;
      this.glSlowRenderer = false;
      this._isSafariCrap = false;

      this.temporaryTexture = null;
      this._onetimeCallbacks = [];
      this.gl = null;

      this._cursor = "auto";
      this._currentCursor = "";

      this._viewPortStack = [];
      this._glFrameBufferStack = [];
      this._frameBufferStack = [];
      this._shaderStack = [];
      this._stackDepthTest = [];
      this.mainloopOp = null;

      this._simpleShader = new Shader(this, "simpleshader");
      this._simpleShader.setModules([
        "MODULE_VERTEX_POSITION",
        "MODULE_COLOR",
        "MODULE_BEGIN_FRAG",
        "MODULE_VERTEX_MODELVIEW",
      ]);
      this._simpleShader.setSource(
        Shader.getDefaultVertexShader(),
        Shader.getDefaultFragmentShader()
      );

      this._currentShader = this._simpleShader;

      this._oldCanvasWidth = -1;
      this._oldCanvasHeight = -1;
      this._enabledExtensions = {};
    }

    // set pixelDensity(p)
    // {
    //     this._pixelDensity = p;
    // }

    // get pixelDensity()
    // {
    //     return this._pixelDensity;
    // }

    get viewPort() {
      if (this._viewPortStack.length > 3) {
        const l = this._viewPortStack.length;

        return [
          this._viewPortStack[l - 4],
          this._viewPortStack[l - 3],
          this._viewPortStack[l - 2],
          this._viewPortStack[l - 1],
        ];
      } else {
        // workaround pre viewport stack times / or+and initial value...

        return this._viewPort;
      }
    }

    get mvMatrix() {
      // deprecate
      return this.mMatrix;
    }

    set mvMatrix(
      m // deprecate
    ) {
      this.mMatrix = m;
    }

    _setCanvas(canv) {
      if (!canv) this._log.stack("_setCanvas undef");

      if (!this.patch.config.canvas) this.patch.config.canvas = {};
      if (!this.patch.config.canvas.hasOwnProperty("preserveDrawingBuffer"))
        this.patch.config.canvas.preserveDrawingBuffer = false;
      if (!this.patch.config.canvas.hasOwnProperty("premultipliedAlpha"))
        this.patch.config.canvas.premultipliedAlpha = false;
      if (!this.patch.config.canvas.hasOwnProperty("alpha"))
        this.patch.config.canvas.alpha = false;

      this.patch.config.canvas.stencil = true;

      if (this.patch.config.hasOwnProperty("clearCanvasColor"))
        this.clearCanvasTransparent = this.patch.config.clearCanvasColor;
      if (this.patch.config.hasOwnProperty("clearCanvasDepth"))
        this.clearCanvasDepth = this.patch.config.clearCanvasDepth;

      // safari stuff..........
      if (
        /^((?!chrome|android).)*safari/i.test(navigator.userAgent) &&
        navigator.userAgent.match(/iPhone/i)
      ) {
        this._isSafariCrap = true;
        this.glUseHalfFloatTex = true;
      }

      if (!this.patch.config.canvas.forceWebGl1)
        this.gl = canv.getContext("webgl2", this.patch.config.canvas);

      if (!this.gl || this.gl.isContextLost()) {
        this.aborted = true;
        this._log.error(
          "NO_WEBGL",
          "sorry, could not initialize WebGL. Please check if your Browser supports WebGL or try to restart your browser."
        );
        return;
      }

      if (this.gl.getParameter(this.gl.VERSION) != "WebGL 1.0") {
        this.glVersion = 2;
      } else {
        this.gl =
          canv.getContext("webgl", this.patch.config.canvas) ||
          canv.getContext("experimental-webgl", this.patch.config.canvas);
        this.glVersion = 1;

        // safari
        // if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && (navigator.userAgent.match(/iPhone/i)))
        // {
        //     this.glUseHalfFloatTex = true;
        // }

        // ios
        if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) {
          if (!this.patch.config.canvas.hasOwnProperty("powerPreference"))
            this.patch.config.canvas.powerPreference = "high-performance";
        }

        this.enableExtension("OES_standard_derivatives");
        // this.enableExtension("GL_OES_standard_derivatives");
        const instancingExt =
          this.enableExtension("ANGLE_instanced_arrays") || this.gl;
        if (instancingExt.vertexAttribDivisorANGLE) {
          this.gl.vertexAttribDivisor =
            instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);
          this.gl.drawElementsInstanced =
            instancingExt.drawElementsInstancedANGLE.bind(instancingExt);
        }
      }

      const dbgRenderInfo = this.enableExtension("WEBGL_debug_renderer_info");
      if (dbgRenderInfo) {
        this.glRenderer = this.gl.getParameter(
          dbgRenderInfo.UNMASKED_RENDERER_WEBGL
        );
        if (this.glRenderer === "Google SwiftShader")
          this.glSlowRenderer = true;
      }

      this.canvas.addEventListener("webglcontextlost", (event) => {
        if (this.aborted)
          return this._log.warn(
            "[cgl_state] aborted context lost... can be ignored..."
          );
        this._log.error("canvas lost...", event);
        this.emitEvent("webglcontextlost");
        this.aborted = true;
      });

      this.maxAnisotropic = 0;
      if (this.enableExtension("EXT_texture_filter_anisotropic"))
        this.maxAnisotropic = this.gl.getParameter(
          this.enableExtension("EXT_texture_filter_anisotropic")
            .MAX_TEXTURE_MAX_ANISOTROPY_EXT
        );

      this.maxVaryingVectors = this.gl.getParameter(
        this.gl.MAX_VARYING_VECTORS
      );
      this.maxTextureUnits = this.gl.getParameter(
        this.gl.MAX_TEXTURE_IMAGE_UNITS
      );
      this.maxTexSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);
      this.maxUniformsFrag = this.gl.getParameter(
        this.gl.MAX_FRAGMENT_UNIFORM_VECTORS
      );
      this.maxUniformsVert = this.gl.getParameter(
        this.gl.MAX_VERTEX_UNIFORM_VECTORS
      );
      this.maxSamples = 0;
      if (this.gl.MAX_SAMPLES)
        this.maxSamples = this.gl.getParameter(this.gl.MAX_SAMPLES);

      if (this.glVersion == 1) {
        this.enableExtension("OES_standard_derivatives");
        const instancingExt =
          this.enableExtension("ANGLE_instanced_arrays") || this.gl;

        if (instancingExt.vertexAttribDivisorANGLE) {
          this.gl.vertexAttribDivisor =
            instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);
          this.gl.drawElementsInstanced =
            instancingExt.drawElementsInstancedANGLE.bind(instancingExt);
        }
      }

      this.DEPTH_FUNCS = [
        this.gl.NEVER,
        this.gl.ALWAYS,
        this.gl.LESS,
        this.gl.LEQUAL,
        this.gl.GREATER,
        this.gl.GEQUAL,
        this.gl.EQUAL,
        this.gl.NOTEQUAL,
      ];
      this.CULL_MODES = [
        null,
        this.gl.BACK,
        this.gl.FRONT,
        this.gl.FRONT_AND_BACK,
      ];
    }

    getInfo() {
      return {
        glVersion: this.glVersion,
        glRenderer: this.glRenderer,
        glUseHalfFloatTex: this.glUseHalfFloatTex,
        maxVaryingVectors: this.maxVaryingVectors,
        maxTextureUnits: this.maxTextureUnits,
        maxTexSize: this.maxTexSize,
        maxUniformsFrag: this.maxUniformsFrag,
        maxUniformsVert: this.maxUniformsVert,
        maxSamples: this.maxSamples,
      };
    }

    /**
     * @function popViewPort
     * @memberof Context
     * @instance
     * @description pop viewPort stack
     */

    popViewPort() {
      this._viewPortStack.pop();
      this._viewPortStack.pop();
      this._viewPortStack.pop();
      this._viewPortStack.pop();

      if (this._viewPortStack.length == 0) {
        this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);
        // this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);
        // this.setViewPort(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);
      } else {
        // this.viewPort = [this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]];
        // this.gl.viewport(this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]);
        this.setViewPort(
          this._viewPortStack[this._viewPort.length - 4],
          this._viewPortStack[this._viewPort.length - 3],
          this._viewPortStack[this._viewPort.length - 2],
          this._viewPortStack[this._viewPort.length - 1]
        );
      }
    }

    /**
     * @function pushViewPort
     * @memberof Context
     * @instance
     * @description push a new viewport onto stack
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     */

    pushViewPort(x, y, w, h) {
      this._viewPortStack.push(x, y, w, h);
      this.setViewPort(x, y, w, h);
    }

    // old
    getViewPort() {
      return this._viewPort;
    }

    // old
    resetViewPort() {
      this.gl.viewport(
        this._viewPort[0],
        this._viewPort[1],
        this._viewPort[2],
        this._viewPort[3]
      );
    }

    // old
    setViewPort(x, y, w, h) {
      this._viewPort[0] = Math.round(x);
      this._viewPort[1] = Math.round(y);
      this._viewPort[2] = Math.round(w);
      this._viewPort[3] = Math.round(h);
      this.gl.viewport(
        this._viewPort[0],
        this._viewPort[1],
        this._viewPort[2],
        this._viewPort[3]
      );
    }

    screenShot(cb, doScreenshotClearAlpha, mimeType, quality) {
      if (doScreenshotClearAlpha) {
        this.gl.clearColor(1, 1, 1, 1);
        this.gl.colorMask(false, false, false, true);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        this.gl.colorMask(true, true, true, true);
      }

      if (this.canvas && this.canvas.toBlob) {
        this.canvas.toBlob(
          (blob) => {
            if (cb) cb(blob);
            else this._log.log("no screenshot callback...");
          },
          mimeType,
          quality
        );
      }
    }

    endFrame() {
      if (this.patch.isEditorMode()) CABLES.GL_MARKER.drawMarkerLayer(this);

      this.setPreviousShader();

      if (this._vMatrixStack.length() > 0)
        this.logStackError(
          "view matrix stack length !=0 at end of rendering..."
        );
      if (this._mMatrixStack.length() > 0)
        this.logStackError("mvmatrix stack length !=0 at end of rendering...");
      if (this._pMatrixStack.length() > 0)
        this.logStackError("pmatrix stack length !=0 at end of rendering...");
      if (this._glFrameBufferStack.length > 0)
        this.logStackError(
          "glFrameBuffer stack length !=0 at end of rendering..."
        );
      if (this._stackDepthTest.length > 0)
        this.logStackError("depthtest stack length !=0 at end of rendering...");
      if (this._stackDepthWrite.length > 0)
        this.logStackError(
          "depthwrite stack length !=0 at end of rendering..."
        );
      if (this._stackDepthFunc.length > 0)
        this.logStackError("depthfunc stack length !=0 at end of rendering...");
      if (this._stackBlend.length > 0)
        this.logStackError("blend stack length !=0 at end of rendering...");
      if (this._stackBlendMode.length > 0)
        this.logStackError("blendMode stack length !=0 at end of rendering...");
      if (this._shaderStack.length > 0)
        this.logStackError(
          "this._shaderStack length !=0 at end of rendering..."
        );
      if (this._stackCullFace.length > 0)
        this.logStackError(
          "this._stackCullFace length !=0 at end of rendering..."
        );
      if (this._stackCullFaceFacing.length > 0)
        this.logStackError(
          "this._stackCullFaceFacing length !=0 at end of rendering..."
        );
      if (this._viewPortStack.length > 0)
        this.logStackError("viewport stack length !=0 at end of rendering...");

      this._frameStarted = false;

      if (
        this._oldCanvasWidth != this.canvasWidth ||
        this._oldCanvasHeight != this.canvasHeight
      ) {
        this._oldCanvasWidth = this.canvasWidth;
        this._oldCanvasHeight = this.canvasHeight;
        this.emitEvent("resize");
      }

      if (this._cursor != this._currentCursor) {
        this._currentCursor = this.canvas.style.cursor = this._cursor;
      }

      this.emitEvent("endframe");

      this.fpsCounter.endFrame();
    }

    logStackError(str) {
      if (!this._hadStackError) {
        this._hadStackError = true;
        this._log.warn("[" + this.canvas.id + "]: ", str);
      }
    }

    // shader stack
    getShader() {
      if (this._currentShader)
        if (
          !this.tempData ||
          ((this.tempData.renderOffscreen === true) ==
            this._currentShader.offScreenPass) ===
            true
        )
          return this._currentShader;

      for (let i = this._shaderStack.length - 1; i >= 0; i--)
        if (this._shaderStack[i])
          if (
            this.tempData.renderOffscreen == this._shaderStack[i].offScreenPass
          )
            return this._shaderStack[i];
    }

    getDefaultShader() {
      return this._simpleShader;
    }

    /**
     * push a shader to the shader stack
     * @function pushShader
     * @memberof Context
     * @instance
     * @param {Object} shader
     * @function
     */

    pushShader(shader) {
      if (this.tempData.forceShaderMods) {
        for (let i = 0; i < this.tempData.forceShaderMods.length; i++) {
          // if (!currentShader.forcedMod && currentShader != this.tempData.forceShaderMods[i])
          // {
          //     currentShader.forcedMod = this.tempData.forceShaderMods[i];
          shader = this.tempData.forceShaderMods[i].bind(shader, false);
          // }
          // return currentShader;
          // if (this.tempData.forceShaderMods[i].currentShader() && shader != this.tempData.forceShaderMods[i].currentShader().shader)
        }
      }

      this._shaderStack.push(shader);
      this._currentShader = shader;
    }

    /**
     * pop current used shader from shader stack
     * @function popShader
     * @memberof Context
     * @instance
     * @function
     */
    setPreviousShader() {
      if (this.tempData.forceShaderMods) {
        for (let i = 0; i < this.tempData.forceShaderMods.length; i++) {
          // const a =
          this.tempData.forceShaderMods[i].unbind(false);
          // if (a) return;
          // this.popShader();
        }
      }

      if (this._shaderStack.length === 0)
        throw new Error("Invalid shader stack pop!");
      this._shaderStack.pop();
      this._currentShader = this._shaderStack[this._shaderStack.length - 1];
    }

    /**
     * push a framebuffer to the framebuffer stack
     * @function pushGlFrameBuffer
     * @memberof Context
     * @instance
     * @param {Object} fb framebuffer
     * @function
     */
    pushGlFrameBuffer(fb) {
      this._glFrameBufferStack.push(fb);
    }

    /**
     * pop framebuffer stack
     * @function popGlFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Object} current framebuffer or null
     */
    popGlFrameBuffer() {
      if (this._glFrameBufferStack.length == 0) return null;
      this._glFrameBufferStack.pop();
      return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];
    }

    /**
     * get current framebuffer
     * @function getCurrentFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Object} current framebuffer or null
     */
    getCurrentGlFrameBuffer() {
      if (this._glFrameBufferStack.length === 0) return null;
      return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];
    }

    /**
     * push a framebuffer to the framebuffer stack
     * @function pushGlFrameBuffer
     * @memberof Context
     * @instance
     * @param {Framebuffer} fb framebuffer
     */
    pushFrameBuffer(fb) {
      this._frameBufferStack.push(fb);
    }

    /**
     * pop framebuffer stack
     * @function popFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Framebuffer} current framebuffer or null
     */
    popFrameBuffer() {
      if (this._frameBufferStack.length == 0) return null;
      this._frameBufferStack.pop();
      return this._frameBufferStack[this._frameBufferStack.length - 1];
    }

    /**
     * get current framebuffer
     * @function getCurrentFrameBuffer
     * @memberof Context
     * @instance
     * @returns {Framebuffer} current framebuffer or null
     */
    getCurrentFrameBuffer() {
      if (this._frameBufferStack.length === 0) return null;
      return this._frameBufferStack[this._frameBufferStack.length - 1];
    }

    renderStart(cgl, identTranslate, identTranslateView) {
      this.fpsCounter.startFrame();
      this.pushDepthTest(true);
      this.pushDepthWrite(true);
      this.pushDepthFunc(cgl.gl.LEQUAL);
      this.pushCullFaceFacing(cgl.gl.BACK);
      this.pushCullFace(false);

      // if (this.clearCanvasTransparent)
      // {
      //     cgl.gl.clearColor(0, 0, 0, 0);
      //     cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT);
      // }
      // if (this.clearCanvasDepth) cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);

      cgl.setViewPort(0, 0, cgl.canvasWidth, cgl.canvasHeight);

      this._startMatrixStacks(identTranslate, identTranslateView);

      cgl.pushBlendMode(constants_CONSTANTS.BLEND_MODES.BLEND_NORMAL, false);

      for (let i = 0; i < this._textureslots.length; i++)
        this._textureslots[i] = null;

      this.pushShader(this._simpleShader);

      this._frameStarted = true;

      if (this._onetimeCallbacks.length > 0) {
        for (let i = 0; i < this._onetimeCallbacks.length; i++)
          this._onetimeCallbacks[i]();
        this._onetimeCallbacks.length = 0;
      }

      for (let i = 0; i < this._textureslots.length; i++) {
        this.gl.activeTexture(this.gl.TEXTURE0 + i);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this._textureslots[i] = null;
      }

      this.emitEvent("beginFrame");
    }

    renderEnd(cgl) {
      this._endMatrixStacks();

      this.popDepthTest();
      this.popDepthWrite();
      this.popDepthFunc();
      this.popCullFaceFacing();
      this.popCullFace();
      this.popBlend();
      this.popBlendMode();

      cgl.endFrame();

      this.emitEvent("endFrame");
    }

    getTexture(slot) {
      return this._textureslots[slot];
    }

    hasFrameStarted() {
      return this._frameStarted;
    }

    /**
     * log warning to console if the rendering of one frame has not been started / handy to check for async problems
     * @function checkFrameStarted
     * @memberof Context
     * @param string
     * @instance
     */
    checkFrameStarted(string) {
      if (!this._frameStarted) {
        this._log.warn("frame not started " + string);
        this.patch.printTriggerStack();
      }
    }

    setTexture(slot, t, type) {
      this.checkFrameStarted("cgl setTexture");

      if (t === null) t = CGL.Texture.getEmptyTexture(this).tex;

      if (this._textureslots[slot] != t) {
        this.gl.activeTexture(this.gl.TEXTURE0 + slot);
        this.gl.bindTexture(type || this.gl.TEXTURE_2D, t);
        this._textureslots[slot] = t;
      }

      return true;
    }

    fullScreen() {
      if (this.canvas.requestFullscreen) this.canvas.requestFullscreen();
      else if (this.canvas.mozRequestFullScreen)
        this.canvas.mozRequestFullScreen();
      else if (this.canvas.webkitRequestFullscreen)
        this.canvas.webkitRequestFullscreen();
      else if (this.canvas.msRequestFullscreen)
        this.canvas.msRequestFullscreen();
    }

    printError(str) {
      if (!this.checkGlErrors) return;
      let found = false;
      let error = this.gl.getError();

      if (error != this.gl.NO_ERROR) {
        let errStr = "";
        if (error == this.gl.OUT_OF_MEMORY) errStr = "OUT_OF_MEMORY";
        if (error == this.gl.INVALID_ENUM) errStr = "INVALID_ENUM";
        if (error == this.gl.INVALID_OPERATION) errStr = "INVALID_OPERATION";
        if (error == this.gl.INVALID_FRAMEBUFFER_OPERATION)
          errStr = "INVALID_FRAMEBUFFER_OPERATION";
        if (error == this.gl.INVALID_VALUE) errStr = "INVALID_VALUE";
        if (error == this.gl.CONTEXT_LOST_WEBGL) {
          this.aborted = true;
          errStr = "CONTEXT_LOST_WEBGL";
        }
        if (error == this.gl.NO_ERROR) errStr = "NO_ERROR";

        found = true;

        this._log.warn(
          "gl error [" + this.canvas.id + "]: ",
          str,
          error,
          errStr
        );

        if (this.canvas.id.contains("glGuiCanvas"))
          if (!this._loggedGlError) {
            this.patch.printTriggerStack();
            this._log.stack("glerror");
            this._loggedGlError = true;
          }
      }
      error = this.gl.getError();

      return found;
    }

    saveScreenshot(filename, cb, pw, ph, noclearalpha) {
      this.patch.renderOneFrame();

      let w = this.canvas.clientWidth * this.pixelDensity;
      let h = this.canvas.clientHeight * this.pixelDensity;

      if (pw) {
        this.canvas.width = pw;
        w = pw;
      }
      if (ph) {
        this.canvas.height = ph;
        h = ph;
      }

      function padLeft(nr, n, str) {
        return Array(n - String(nr).length + 1).join(str || "0") + nr;
      }

      const d = new Date();

      const dateStr = ""
        .concat(
          String(d.getFullYear()) +
            String(d.getMonth() + 1) +
            String(d.getDate()),
          "_"
        )
        .concat(padLeft(d.getHours(), 2))
        .concat(padLeft(d.getMinutes(), 2))
        .concat(padLeft(d.getSeconds(), 2));

      if (!filename) filename = "cables_" + dateStr + ".png";
      else filename += ".png";

      this.patch.cgl.screenShot(
        function (blob) {
          this.canvas.width = w;
          this.canvas.height = h;

          if (blob) {
            const anchor = document.createElement("a");

            anchor.download = filename;
            anchor.href = URL.createObjectURL(blob);

            setTimeout(function () {
              anchor.click();
              if (cb) cb(blob);
            }, 100);
          } else {
            this._log.log("screenshot: no blob");
          }
        }.bind(this),
        noclearalpha
      );
    }

    _dispose() {
      this._simpleShader.dispose();
      this.gl = null;
    }
  }

  Context.prototype.popShader = Context.prototype.setPreviousShader;
  Context.prototype.setShader = Context.prototype.pushShader;

  /**
   * execute the callback next frame, once
   * @function addNextFrameOnceCallback
   * @memberof Context
   * @instance
   * @param {function} cb
   */
  Context.prototype.addNextFrameOnceCallback = function (cb) {
    if (cb && this._onetimeCallbacks.indexOf(cb) == -1)
      this._onetimeCallbacks.push(cb);
  };

  // state depthtest

  /**
   * push depth testing enabled state
   * @function pushDepthTest
   * @param {Boolean} enabled
   * @memberof Context
   * @instance
   */
  Context.prototype._stackDepthTest = [];
  Context.prototype.pushDepthTest = function (b) {
    this._stackDepthTest.push(b);
    if (!b) this.gl.disable(this.gl.DEPTH_TEST);
    else this.gl.enable(this.gl.DEPTH_TEST);
  };
  /**
   * current state of depth testing
   * @function stateCullFace
   * @returns {Boolean} enabled
   * @memberof Context
   * @instance
   */
  Context.prototype.stateDepthTest = function () {
    return this._stackDepthTest[this._stackDepthTest.length - 1];
  };

  /**
   * pop depth testing state
   * @function popCullFace
   * @memberof Context
   * @instance
   */
  Context.prototype.popDepthTest = function () {
    this._stackDepthTest.pop();

    if (!this._stackDepthTest[this._stackDepthTest.length - 1])
      this.gl.disable(this.gl.DEPTH_TEST);
    else this.gl.enable(this.gl.DEPTH_TEST);
  };

  // --------------------------------------
  // state depthwrite

  /**
   * push depth write enabled state
   * @function pushDepthTest
   * @param {Boolean} enabled
   * @memberof Context
   * @instance
   */
  Context.prototype._stackDepthWrite = [];
  Context.prototype.pushDepthWrite = function (b) {
    b = b || false;
    this._stackDepthWrite.push(b);
    this.gl.depthMask(b);
  };

  /**
   * current state of depth writing
   * @function stateDepthWrite
   * @returns {Boolean} enabled
   * @memberof Context
   * @instance
   */
  Context.prototype.stateDepthWrite = function () {
    return this._stackDepthWrite[this._stackDepthWrite.length - 1];
  };

  /**
   * pop depth writing state
   * @function popDepthWrite
   * @memberof Context
   * @instance
   */
  Context.prototype.popDepthWrite = function () {
    this._stackDepthWrite.pop();
    this.gl.depthMask(
      this._stackDepthWrite[this._stackDepthWrite.length - 1] || false
    );
  };

  // --------------------------------------
  // state CullFace

  Context.prototype._stackCullFace = [];

  /**
   * push face culling face enabled state
   * @function pushCullFace
   * @param {Boolean} b enabled
   * @memberof Context
   * @instance
   */
  Context.prototype.pushCullFace = function (b) {
    this._stackCullFace.push(b);

    if (b) this.gl.enable(this.gl.CULL_FACE);
    else this.gl.disable(this.gl.CULL_FACE);
  };

  /**
   * current state of face culling
   * @function stateCullFace
   * @returns {Boolean} enabled
   * @memberof Context
   * @instance
   */
  Context.prototype.stateCullFace = function () {
    return this._stackCullFace[this._stackCullFace.length - 1];
  };

  /**
   * pop face culling enabled state
   * @function popCullFace
   * @memberof Context
   * @instance
   */
  Context.prototype.popCullFace = function () {
    this._stackCullFace.pop();

    if (this._stackCullFace[this._stackCullFace.length - 1])
      this.gl.enable(this.gl.CULL_FACE);
    else this.gl.disable(this.gl.CULL_FACE);
  };

  // --------------------------------------
  // state CullFace Facing

  /**
   * push face culling face side
   * @function pushCullFaceFacing
   * @param {Number} cgl.gl.FRONT_AND_BACK, cgl.gl.BACK or cgl.gl.FRONT
   * @memberof Context
   * @instance
   */
  Context.prototype._stackCullFaceFacing = [];
  Context.prototype.pushCullFaceFacing = function (b) {
    this._stackCullFaceFacing.push(b);
    this.gl.cullFace(
      this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]
    );
  };

  /**
   * current state of face culling side
   * @function stateCullFaceFacing
   * @returns {Boolean} enabled
   * @memberof Context
   * @instance
   */
  Context.prototype.stateCullFaceFacing = function () {
    return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];
  };

  /**
   * pop face culling face side
   * @function popCullFaceFacing
   * @memberof Context
   * @instance
   */
  Context.prototype.popCullFaceFacing = function () {
    this._stackCullFaceFacing.pop();
    if (this._stackCullFaceFacing.length > 0)
      this.gl.cullFace(
        this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]
      );
  };

  // --------------------------------------
  // state depthfunc

  Context.prototype._stackDepthFunc = [];

  /**
   * enable / disable depth testing
   * like `gl.depthFunc(boolean);`
   * @function pushDepthFunc
   * @memberof Context
   * @instance
   * @param {Boolean} f depthtesting
   */
  Context.prototype.pushDepthFunc = function (f) {
    this._stackDepthFunc.push(f);
    this.gl.depthFunc(f);
  };

  /**
   * current state of blend
   * @function stateDepthFunc
   * @memberof Context
   * @instance
   * @returns {Boolean} depth testing enabled/disabled
   */
  Context.prototype.stateDepthFunc = function () {
    if (this._stackDepthFunc.length > 0)
      return this._stackDepthFunc[this._stackDepthFunc.length - 1];
    return false;
  };

  /**
   * pop depth testing and set the previous state
   * @function popDepthFunc
   * @memberof Context
   * @instance
   */
  Context.prototype.popDepthFunc = function () {
    this._stackDepthFunc.pop();
    if (this._stackDepthFunc.length > 0)
      this.gl.depthFunc(this._stackDepthFunc[this._stackDepthFunc.length - 1]);
  };

  // --------------------------------------
  // state blending

  Context.prototype._stackBlend = [];

  /**
   * enable / disable blend
   * like gl.enable(gl.BLEND); / gl.disable(gl.BLEND);
   * @function pushBlend
   * @memberof Context
   * @instance
   * @param {boolean} b blending
   */
  Context.prototype.pushBlend = function (b) {
    this._stackBlend.push(b);
    if (!b) this.gl.disable(this.gl.BLEND);
    else this.gl.enable(this.gl.BLEND);
  };

  /**
   * pop blend state and set the previous state
   * @function popBlend
   * @memberof Context
   * @instance
   */
  Context.prototype.popBlend = function () {
    this._stackBlend.pop();

    if (!this._stackBlend[this._stackBlend.length - 1])
      this.gl.disable(this.gl.BLEND);
    else this.gl.enable(this.gl.BLEND);
  };

  /**
   * current state of blend
   * @function stateBlend
   * @returns {boolean} blending enabled/disabled
   * @memberof Context
   * @instance
   */
  Context.prototype.stateBlend = function () {
    return this._stackBlend[this._stackBlend.length - 1];
  };

  const BLENDS = {
    BLEND_NONE: 0,
    BLEND_NORMAL: 1,
    BLEND_ADD: 2,
    BLEND_SUB: 3,
    BLEND_MUL: 4,
  };

  Context.prototype._stackBlendMode = [];
  Context.prototype._stackBlendModePremul = [];

  /**
   * push and switch to predefined blendmode (CONSTANTS.BLEND_MODES.BLEND_NONE,CONSTANTS.BLEND_MODES.BLEND_NORMAL,CONSTANTS.BLEND_MODES.BLEND_ADD,CONSTANTS.BLEND_MODES.BLEND_SUB,CONSTANTS.BLEND_MODES.BLEND_MUL)
   * @function pushBlendMode
   * @memberof Context
   * @instance
   * @param {Number} blendMode
   * @param {Boolean} premul premultiplied mode
   */
  Context.prototype.pushBlendMode = function (blendMode, premul) {
    this._stackBlendMode.push(blendMode);
    this._stackBlendModePremul.push(premul);

    const n = this._stackBlendMode.length - 1;

    this.pushBlend(
      this._stackBlendMode[n] !== constants_CONSTANTS.BLEND_MODES.BLEND_NONE
    );
    this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);
  };

  /**
   * pop predefined blendmode / switch back to previous blendmode
   * @function popBlendMode
   * @memberof Context
   * @instance
   */
  Context.prototype.popBlendMode = function () {
    this._stackBlendMode.pop();
    this._stackBlendModePremul.pop();

    const n = this._stackBlendMode.length - 1;

    this.popBlend(
      this._stackBlendMode[n] !== constants_CONSTANTS.BLEND_MODES.BLEND_NONE
    );

    if (n >= 0)
      this._setBlendMode(
        this._stackBlendMode[n],
        this._stackBlendModePremul[n]
      );
  };

  // --------------------------------------
  // state stencil

  Context.prototype._stackStencil = [];

  /**
 * enable / disable stencil testing

* @function pushStencil
 * @memberof Context
 * @instance
 * @param {Boolean} b enable
 */
  Context.prototype.pushStencil = function (b) {
    this._stackStencil.push(b);
    if (!b) this.gl.disable(this.gl.STENCIL_TEST);
    else this.gl.enable(this.gl.STENCIL_TEST);
  };

  /**
   * pop stencil test state and set the previous state
   * @function popStencil
   * @memberof Context
   * @instance
   */
  Context.prototype.popStencil = function () {
    this._stackStencil.pop();

    if (!this._stackStencil[this._stackStencil.length - 1])
      this.gl.disable(this.gl.STENCIL_TEST);
    else this.gl.enable(this.gl.STENCIL_TEST);
  };

  // --------------------------------------

  Context.prototype.glGetAttribLocation = function (prog, name) {
    const l = this.gl.getAttribLocation(prog, name);
    // if (l == -1)
    // {
    //     this._log.warn("get attr loc -1 ", name);
    // }
    return l;
  };

  /**
   * should an op now draw helpermeshes
   * @function shouldDrawHelpers
   * @memberof Context
   * @param op
   * @instance
   */
  Context.prototype.shouldDrawHelpers = function (op) {
    if (this.tempData.shadowPass) return false;
    if (!op.patch.isEditorMode()) return false;

    // const fb = this.getCurrentFrameBuffer();
    // if (fb && fb.getWidth)
    // {
    //     const fbshould = this.canvasWidth / this.canvasHeight == fb.getWidth() / fb.getHeight();
    //     if (!fbshould) return false;
    // }

    return gui.shouldDrawOverlay; // || (CABLES.UI.renderHelperCurrent && op.isCurrentUiOp());
  };

  Context.prototype._setBlendMode = function (blendMode, premul) {
    const gl = this.gl;

    if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_NONE) {
      // this.gl.disable(this.gl.BLEND);
    } else if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_ADD) {
      if (premul) {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
      } else {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
      }
    } else if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_SUB) {
      if (premul) {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(
          gl.ZERO,
          gl.ZERO,
          gl.ONE_MINUS_SRC_COLOR,
          gl.ONE_MINUS_SRC_ALPHA
        );
      } else {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
      }
    } else if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_MUL) {
      if (premul) {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
      } else {
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
      }
    } else if (blendMode == constants_CONSTANTS.BLEND_MODES.BLEND_NORMAL) {
      if (premul) {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(
          gl.ONE,
          gl.ONE_MINUS_SRC_ALPHA,
          gl.ONE,
          gl.ONE_MINUS_SRC_ALPHA
        );
      } else {
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(
          gl.SRC_ALPHA,
          gl.ONE_MINUS_SRC_ALPHA,
          gl.ONE,
          gl.ONE_MINUS_SRC_ALPHA
        );
      }
    } else {
      this._log.log("setblendmode: unknown blendmode");
    }
  };

  Context.prototype.createMesh = function (geom, options) {
    if (CABLES.UTILS.isNumeric(options)) options = { glPrimitive: options }; // old constructor fallback...
    return new CGL.Mesh(this, geom, options);
  };

  /**
   * set cursor
   * @function setCursor
   * @memberof Context
   * @instance
   * @param {String} str css cursor string
   */
  Context.prototype.setCursor = function (str) {
    this._cursor = str;
  };

  /**
   * enable a webgl extension
   * @function enableExtension
   * @memberof Context
   * @instance
   * @param {String} name extension name
   * @returns {Object} extension object or null
   */
  Context.prototype.enableExtension = function (name) {
    if (!this.gl) return null;

    if (this._enabledExtensions.hasOwnProperty(name))
      return this._enabledExtensions[name];

    const o = this.gl.getExtension(name);
    this._enabledExtensions[name] = o;

    if (!o) this._log.warn("[cgl_state] extension not available " + name);
    // else
    // this._log.log("enabled extension", name);

    return o;
  };

  Context.prototype.checkTextureSize = function (x) {
    x = x || 1;
    x = Math.floor(x);
    x = Math.min(x, this.maxTexSize);
    x = Math.max(x, 1);
    return x;
  }; // CONCATENATED MODULE: ./src/core/core_variable.js

  /**
   * @type {Object}
   * @name PatchVariable
   * @param {String} name
   * @param {String|Number} value
   * @memberof Patch
   * @constructor
   */
  class PatchVariable extends Events {
    constructor(name, val, type) {
      super();
      this._name = name;
      this.type = type;
      this.setValue(val);
    }

    /**
     * keeping this for backwards compatibility in older
     * exports before using eventtarget
     *
     * @param cb
     */
    addListener(cb) {
      this.on("change", cb, "var");
    }

    /**
     * @function Variable.getValue
     * @memberof PatchVariable
     * @returns {String|Number|Boolean}
     */
    getValue() {
      return this._v;
    }

    /**
     * @function getName
     * @memberof PatchVariable
     * @instance
     * @returns {String|Number|Boolean}
     * @function
     */
    getName() {
      return this._name;
    }

    /**
     * @function setValue
     * @memberof PatchVariable
     * @instance
     * @param v
     * @returns {String|Number|Boolean}
     * @function
     */
    setValue(v) {
      this._v = v;
      this.emitEvent("change", v, this);
    }
  }

  /* harmony default export */ const core_variable = PatchVariable; // CONCATENATED MODULE: ./src/core/core_patch.js

  /**
   * Patch class, contains all operators,values,links etc. manages loading and running of the whole patch
   *
   * see {@link PatchConfig}
   *
   * @namespace external:CABLES#Patch
   * @hideconstructor
   * @param {PatchConfig} cfg The configuration object.
   * @class
   * @example
   * CABLES.patch=new CABLES.Patch(
   * {
   *     patch:pStr,
   *     glCanvasId:'glcanvas',
   *     glCanvasResizeToWindow:true,
   *     canvas:{powerPreference:"high-performance"},
   *     prefixAssetPath:'/assets/',
   *     prefixJsPath:'/js/',
   *     onError:function(e){console.log(e);}
   *     glslPrecision:'highp'
   * });
   */

  class Patch extends EventTarget {
    // const Patch(cfg)
    constructor(cfg) {
      super();
      // EventTarget.apply(this);

      this._log = new Logger("core_patch", { onError: cfg.onError });
      this.ops = [];
      this.settings = {};
      this.config = cfg || {
        glCanvasResizeToWindow: false,
        prefixAssetPath: "",
        prefixJsPath: "",
        silent: true,
        onError: null,
        onFinishedLoading: null,
        onFirstFrameRendered: null,
        onPatchLoaded: null,
        fpsLimit: 0,
      };
      this.timer = new Timer();
      this.freeTimer = new Timer();
      this.animFrameOps = [];
      this.animFrameCallbacks = [];
      this.gui = false;
      CABLES.logSilent = this.silent = true;
      this.profiler = null;
      this.aborted = false;
      this._crashedOps = [];
      this._renderOneFrame = false;
      this._animReq = null;
      this._opIdCache = {};
      this._triggerStack = [];
      this.storeObjNames = false; // remove after may release

      this.loading = new LoadingStatus(this);

      this._volumeListeners = [];
      this._paused = false;
      this._frameNum = 0;
      this.onOneFrameRendered = null;
      this.namedTriggers = {};

      this._origData = null;
      this._frameNext = 0;
      this._frameInterval = 0;
      this._lastFrameTime = 0;
      this._frameWasdelayed = true;
      this.tempData = this.frameStore = {};
      this.deSerialized = false;
      this.reqAnimTimeStamp = 0;

      this.cgCanvas = null;

      if (
        !(function () {
          return !this;
        })()
      )
        console.log("not in strict mode: core patch");

      this._isLocal = document.location.href.indexOf("file:") === 0;

      if (this.config.hasOwnProperty("silent"))
        this.silent = CABLES.logSilent = this.config.silent;
      if (!this.config.hasOwnProperty("doRequestAnimation"))
        this.config.doRequestAnimation = true;

      if (!this.config.prefixAssetPath) this.config.prefixAssetPath = "";
      if (!this.config.prefixJsPath) this.config.prefixJsPath = "";
      if (!this.config.masterVolume) this.config.masterVolume = 1.0;

      this._variables = {};
      this._variableListeners = [];
      this.vars = {};
      if (cfg && cfg.vars) this.vars = cfg.vars; // vars is old!

      this.cgl = new Context(this);
      this.cgp = null;

      this._subpatchOpCache = {};

      this.cgl.setCanvas(
        this.config.glCanvasId || this.config.glCanvas || "glcanvas"
      );
      if (this.config.glCanvasResizeToWindow === true)
        this.cgl.setAutoResize("window");
      if (this.config.glCanvasResizeToParent === true)
        this.cgl.setAutoResize("parent");
      this.loading.setOnFinishedLoading(this.config.onFinishedLoading);

      if (this.cgl.aborted) this.aborted = true;
      if (this.cgl.silent) this.silent = true;

      this.freeTimer.play();
      this.exec();

      if (!this.aborted) {
        if (this.config.patch) {
          this.deSerialize(this.config.patch);
        } else if (this.config.patchFile) {
          ajax(this.config.patchFile, (err, _data) => {
            try {
              const data = JSON.parse(_data);
              if (err) {
                const txt = "";
                this._log.error("err", err);
                this._log.error("data", data);
                this._log.error("data", data.msg);
                return;
              }
              this.deSerialize(data);
            } catch (e) {
              this._log.error("could not load/parse patch ", e);
            }
          });
        }
        this.timer.play();
      }

      console.log("made with https://cables.gl"); // eslint-disable-line
    }

    isPlaying() {
      return !this._paused;
    }

    isRenderingOneFrame() {
      return this._renderOneFrame;
    }

    renderOneFrame() {
      this._paused = true;
      this._renderOneFrame = true;
      this.exec();
      this._renderOneFrame = false;
    }

    /**
     * current number of frames per second
     * @function getFPS
     * @memberof Patch
     * @instance
     * @return {Number} fps
     */
    getFPS() {
      this._log.error("deprecated getfps");
      return 0;
    }

    /**
     * returns true if patch is opened in editor/gui mode
     * @function isEditorMode
     * @memberof Patch
     * @instance
     * @return {Boolean} editor mode
     */
    isEditorMode() {
      return this.config.editorMode === true;
    }

    /**
     * pauses patch execution
     * @function pause
     * @memberof Patch
     * @instance
     */
    pause() {
      cancelAnimationFrame(this._animReq);
      this.emitEvent("pause");
      this._animReq = null;
      this._paused = true;
      this.freeTimer.pause();
    }

    /**
     * resumes patch execution
     * @function resume
     * @memberof Patch
     * @instance
     */
    resume() {
      if (this._paused) {
        cancelAnimationFrame(this._animReq);
        this._paused = false;
        this.freeTimer.play();
        this.emitEvent("resume");
        this.exec();
      }
    }

    /**
     * set volume [0-1]
     * @function setVolume
     * @param {Number} v volume
     * @memberof Patch
     * @instance
     */
    setVolume(v) {
      this.config.masterVolume = v;
      for (let i = 0; i < this._volumeListeners.length; i++)
        this._volumeListeners[i].onMasterVolumeChanged(v);
    }

    /**
     * get asset path
     * @function getAssetPath
     * @memberof Patch
     * @param patchId
     * @instance
     */
    getAssetPath(patchId = null) {
      if (this.config.hasOwnProperty("assetPath")) {
        return this.config.assetPath;
      } else if (this.isEditorMode()) {
        let id = patchId || gui.project()._id;
        return "/assets/" + id + "/";
      } else if (
        document.location.href.indexOf("cables.gl") > 0 ||
        document.location.href.indexOf("cables.local") > 0
      ) {
        const parts = document.location.pathname.split("/");
        let id = patchId || parts[parts.length - 1];
        return "/assets/" + id + "/";
      } else {
        return "assets/";
      }
    }

    /**
     * get js path
     * @function getJsPath
     * @memberof Patch
     * @instance
     */
    getJsPath() {
      if (this.config.hasOwnProperty("jsPath")) {
        return this.config.jsPath;
      } else {
        return "js/";
      }
    }

    /**
     * get url/filepath for a filename
     * this uses prefixAssetpath in exported patches
     * @function getFilePath
     * @memberof Patch
     * @instance
     * @param {String} filename
     * @return {String} url
     */
    getFilePath(filename) {
      if (!filename) return filename;
      filename = String(filename);
      if (filename.indexOf("https:") === 0 || filename.indexOf("http:") === 0)
        return filename;
      if (filename.indexOf("data:") === 0) return filename;
      if (filename.indexOf("file:") === 0) return filename;
      filename = filename.replace("//", "/");
      if (filename.startsWith(this.config.prefixAssetPath))
        filename = filename.replace(this.config.prefixAssetPath, "");
      return (
        this.config.prefixAssetPath +
        filename +
        (this.config.suffixAssetPath || "")
      );
    }

    clear() {
      this.emitEvent("patchClearStart");
      this.cgl.TextureEffectMesh = null;
      this.animFrameOps.length = 0;
      this.timer = new Timer();
      while (this.ops.length > 0) this.deleteOp(this.ops[0].id);

      this._opIdCache = {};
      this.emitEvent("patchClearEnd");
    }

    createOp(identifier, id, opName = null) {
      let op = null;
      let objName = "";

      try {
        if (!identifier) {
          console.error("createop identifier false", identifier);
          console.log(new Error().stack);
          return;
        }
        if (identifier.indexOf("Ops.") === -1) {
          // this should be a uuid, not a namespace
          // creating ops by id should be the default way from now on!
          const opId = identifier;

          if (CABLES.OPS[opId]) {
            objName = CABLES.OPS[opId].objName;
            op = new CABLES.OPS[opId].f(this, objName, id, opId);
            op.opId = opId;
          } else {
            if (opName) {
              identifier = opName;
              this._log.warn("could not find op by id: " + opId);
            } else {
              throw new Error("could not find op by id: " + opId, {
                cause: "opId:" + opId,
              });
            }
          }
        }

        if (!op) {
          // fallback: create by objname!
          objName = identifier;
          const parts = identifier.split(".");
          const opObj = Patch.getOpClass(objName);

          if (!opObj) {
            this.emitEvent("criticalError", {
              title: "unknown op" + objName,
              text: "unknown op: " + objName,
            });

            this._log.error("unknown op: " + objName);
            throw new Error("unknown op: " + objName);
          } else {
            if (parts.length == 2)
              op = new window[parts[0]][parts[1]](this, objName, id);
            else if (parts.length == 3)
              op = new window[parts[0]][parts[1]][parts[2]](this, objName, id);
            else if (parts.length == 4)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]](
                this,
                objName,
                id
              );
            else if (parts.length == 5)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]](
                this,
                objName,
                id
              );
            else if (parts.length == 6)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][
                parts[5]
              ](this, objName, id);
            else if (parts.length == 7)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][
                parts[5]
              ][parts[6]](this, objName, id);
            else if (parts.length == 8)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][
                parts[5]
              ][parts[6]][parts[7]](this, objName, id);
            else if (parts.length == 9)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][
                parts[5]
              ][parts[6]][parts[7]][parts[8]](this, objName, id);
            else if (parts.length == 10)
              op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][
                parts[5]
              ][parts[6]][parts[7]][parts[8]][parts[9]](this, objName, id);
            else console.log("parts.length", parts.length);
          }

          if (op) {
            op.opId = null;
            for (const i in CABLES.OPS) {
              if (CABLES.OPS[i].objName == objName) op.opId = i;
            }
          }
        }
      } catch (e) {
        this._crashedOps.push(objName);

        this._log.error("[instancing error] " + objName, e);

        if (!this.isEditorMode()) {
          this._log.error("INSTANCE_ERR", "Instancing Error: " + objName, e);
          // throw new Error("instancing error 1" + objName);
        }
      }

      if (op) {
        op._objName = objName;
        op.patch = this;
      } else {
        this._log.log("no op was created!?", identifier, id);
      }
      return op;
    }

    /**
     * create a new op in patch
     * @function addOp
     * @memberof Patch
     * @instance
     * @param {string} opIdentifier uuid or name, e.g. Ops.Math.Sum
     * @param {Object} uiAttribs Attributes
     * @param {string} id
     * @param {boolean} fromDeserialize
     * @param {string} opName e.g. Ops.Math.Sum
     * @example
     * // add invisible op
     * patch.addOp('Ops.Math.Sum', { showUiAttribs: false });
     */
    addOp(opIdentifier, uiAttribs, id, fromDeserialize, opName) {
      const op = this.createOp(opIdentifier, id, opName);

      if (op) {
        uiAttribs = uiAttribs || {};
        if (uiAttribs.hasOwnProperty("errors")) delete uiAttribs.errors;
        if (uiAttribs.hasOwnProperty("error")) delete uiAttribs.error;
        uiAttribs.subPatch = uiAttribs.subPatch || 0;

        op.setUiAttribs(uiAttribs);
        if (op.onCreate) op.onCreate();

        if (op.hasOwnProperty("onAnimFrame")) this.addOnAnimFrame(op);
        if (op.hasOwnProperty("onMasterVolumeChanged"))
          this._volumeListeners.push(op);

        if (this._opIdCache[op.id]) {
          this._log.warn("opid with id " + op.id + " already exists in patch!");
          this.deleteOp(op.id); // strange with subpatch ops: why is this needed, somehow ops get added twice ???.....
          // return;
        }

        this.ops.push(op);
        this._opIdCache[op.id] = op;

        if (this._subPatchCacheAdd)
          this._subPatchCacheAdd(uiAttribs.subPatch, op);
        this.emitEvent("onOpAdd", op, fromDeserialize);

        if (op.init) op.init();

        op.emitEvent("init", fromDeserialize);
      } else {
        this._log.error("addop: op could not be created: ", opIdentifier);
      }

      return op;
    }

    addOnAnimFrame(op) {
      for (let i = 0; i < this.animFrameOps.length; i++)
        if (this.animFrameOps[i] == op) {
          return;
        }

      this.animFrameOps.push(op);
    }

    removeOnAnimFrame(op) {
      for (let i = 0; i < this.animFrameOps.length; i++) {
        if (this.animFrameOps[i] == op) {
          this.animFrameOps.splice(i, 1);
          return;
        }
      }
    }

    addOnAnimFrameCallback(cb) {
      this.animFrameCallbacks.push(cb);
    }

    removeOnAnimCallback(cb) {
      for (let i = 0; i < this.animFrameCallbacks.length; i++) {
        if (this.animFrameCallbacks[i] == cb) {
          this.animFrameCallbacks.splice(i, 1);
          return;
        }
      }
    }

    deleteOp(opid, tryRelink, reloadingOp) {
      let found = false;
      for (const i in this.ops) {
        if (this.ops[i].id == opid) {
          const op = this.ops[i];
          let reLinkP1 = null;
          let reLinkP2 = null;

          if (op) {
            found = true;
            if (tryRelink) {
              if (
                op.portsIn.length > 0 &&
                op.portsIn[0].isLinked() &&
                op.portsOut.length > 0 &&
                op.portsOut[0].isLinked()
              ) {
                if (
                  op.portsIn[0].getType() == op.portsOut[0].getType() &&
                  op.portsIn[0].links[0]
                ) {
                  reLinkP1 = op.portsIn[0].links[0].getOtherPort(op.portsIn[0]);
                  reLinkP2 = op.portsOut[0].links[0].getOtherPort(
                    op.portsOut[0]
                  );
                }
              }
            }

            const opToDelete = this.ops[i];
            opToDelete.removeLinks();

            if (this.onDelete) {
              // todo: remove
              this._log.warn("deprecated this.onDelete", this.onDelete);
              this.onDelete(opToDelete);
            }

            this.ops.splice(i, 1);
            opToDelete.emitEvent("delete", opToDelete);
            this.emitEvent("onOpDelete", opToDelete, reloadingOp);

            if (this.clearSubPatchCache)
              this.clearSubPatchCache(opToDelete.uiAttribs.subPatch);

            if (opToDelete.onDelete) opToDelete.onDelete(reloadingOp);
            opToDelete.cleanUp();

            if (reLinkP1 !== null && reLinkP2 !== null) {
              this.link(
                reLinkP1.op,
                reLinkP1.getName(),
                reLinkP2.op,
                reLinkP2.getName()
              );
            }

            delete this._opIdCache[opid];
            break;
          }
        }
      }

      if (!found) this._log.warn("core patch deleteop: not found...", opid);
    }

    getFrameNum() {
      return this._frameNum;
    }

    emitOnAnimFrameEvent(time, delta) {
      time = time || this.timer.getTime();

      for (let i = 0; i < this.animFrameCallbacks.length; ++i)
        if (this.animFrameCallbacks[i])
          this.animFrameCallbacks[i](time, this._frameNum, delta);

      for (let i = 0; i < this.animFrameOps.length; ++i)
        if (this.animFrameOps[i].onAnimFrame)
          this.animFrameOps[i].onAnimFrame(time, this._frameNum, delta);
    }

    renderFrame(timestamp) {
      this.timer.update(this.reqAnimTimeStamp);
      this.freeTimer.update(this.reqAnimTimeStamp);
      const time = this.timer.getTime();
      const startTime = performance.now();
      this.cgl.frameStartTime = this.timer.getTime();

      const delta = timestamp - this.reqAnimTimeStamp || timestamp;

      this.emitOnAnimFrameEvent(null, delta);

      this.cgl.profileData.profileFrameDelta = delta;
      this.reqAnimTimeStamp = timestamp;
      this.cgl.profileData.profileOnAnimFrameOps =
        performance.now() - startTime;

      this.emitEvent("onRenderFrame", time);

      this._frameNum++;
      if (this._frameNum == 1) {
        if (this.config.onFirstFrameRendered)
          this.config.onFirstFrameRendered();
      }
    }

    exec(timestamp) {
      if (!this._renderOneFrame && (this._paused || this.aborted)) return;
      this.emitEvent("reqAnimFrame");
      cancelAnimationFrame(this._animReq);

      this.config.fpsLimit = this.config.fpsLimit || 0;
      if (this.config.fpsLimit) {
        this._frameInterval = 1000 / this.config.fpsLimit;
      }

      const now = CABLES.now();
      const frameDelta = now - this._frameNext;

      if (this.isEditorMode()) {
        if (!this._renderOneFrame) {
          if (
            now - this._lastFrameTime >= 500 &&
            this._lastFrameTime !== 0 &&
            !this._frameWasdelayed
          ) {
            this._lastFrameTime = 0;
            setTimeout(this.exec.bind(this), 500);
            this.emitEvent("renderDelayStart");
            this._frameWasdelayed = true;
            return;
          }
        }
      }

      if (
        this._renderOneFrame ||
        this.config.fpsLimit === 0 ||
        frameDelta > this._frameInterval ||
        this._frameWasdelayed
      ) {
        this.renderFrame(timestamp);

        if (this._frameInterval)
          this._frameNext = now - (frameDelta % this._frameInterval);
      }

      if (this._frameWasdelayed) {
        this.emitEvent("renderDelayEnd");
        this._frameWasdelayed = false;
      }

      if (this._renderOneFrame) {
        if (this.onOneFrameRendered) this.onOneFrameRendered(); // todo remove everywhere and use propper event...
        this.emitEvent("renderedOneFrame");
        this._renderOneFrame = false;
      }

      if (this.config.doRequestAnimation)
        this._animReq =
          this.cgl.canvas.ownerDocument.defaultView.requestAnimationFrame(
            this.exec.bind(this)
          );
    }

    /**
     * link two ops/ports
     * @function link
     * @memberof Patch
     * @instance
     * @param {Op} op1
     * @param {String} port1Name
     * @param {Op} op2
     * @param {String} port2Name
     * @param {boolean} lowerCase
     * @param {boolean} fromDeserialize
     */
    link(op1, port1Name, op2, port2Name, lowerCase, fromDeserialize) {
      if (!op1) return this._log.warn("link: op1 is null ");
      if (!op2) return this._log.warn("link: op2 is null");

      const port1 = op1.getPort(port1Name, lowerCase);
      const port2 = op2.getPort(port2Name, lowerCase);

      if (!port1)
        return op1._log.warn(
          "port1 not found! " + port1Name + " (" + op1.objName + ")"
        );
      if (!port2)
        return op1._log.warn(
          "port2 not found! " +
            port2Name +
            " of " +
            op2.name +
            "(" +
            op2.objName +
            ")",
          op2
        );

      if (!port1.shouldLink(port1, port2) || !port2.shouldLink(port1, port2))
        return false;

      if (Link.canLink(port1, port2)) {
        const link = new Link(this);
        link.link(port1, port2);

        this.emitEvent("onLink", port1, port2, link, fromDeserialize);
        return link;
      }
    }

    serialize(options) {
      const obj = {};

      options = options || {};
      obj.ops = [];
      obj.settings = this.settings;
      for (const i in this.ops) {
        const op = this.ops[i];
        if (op && op.getSerialized) obj.ops.push(op.getSerialized());
      }

      cleanJson(obj);

      if (options.asObject) return obj;
      return JSON.stringify(obj);
    }

    getOpsByRefId(refId) {
      const perf = CABLES.UI.uiProfiler.start("[corepatchetend] getOpsByRefId");
      const refOps = [];
      const ops = gui.corePatch().ops;
      for (let i = 0; i < ops.length; i++)
        if (ops[i].storage && ops[i].storage.ref == refId) refOps.push(ops[i]);
      perf.finish();
      return refOps;
    }

    getOpById(opid) {
      return this._opIdCache[opid];
    }

    getOpsByName(name) {
      // TODO: is this still needed ? unclear behaviour....
      const arr = [];
      for (const i in this.ops)
        if (this.ops[i].name == name) arr.push(this.ops[i]);
      return arr;
    }

    getOpsByObjName(name) {
      const arr = [];
      for (const i in this.ops)
        if (this.ops[i].objName == name) arr.push(this.ops[i]);
      return arr;
    }

    getOpsByOpId(opid) {
      const arr = [];
      for (const i in this.ops)
        if (this.ops[i].opId == opid) arr.push(this.ops[i]);
      return arr;
    }

    loadLib(which) {
      ajaxSync(
        "/ui/libs/" + which + ".js",
        (err, res) => {
          const se = document.createElement("script");
          se.type = "text/javascript";
          se.text = res;
          document.getElementsByTagName("head")[0].appendChild(se);
        },
        "GET"
      );
    }

    getSubPatchOpsByName(patchId, objName) {
      const arr = [];
      for (const i in this.ops)
        if (
          this.ops[i].uiAttribs &&
          this.ops[i].uiAttribs.subPatch == patchId &&
          this.ops[i].objName == objName
        )
          arr.push(this.ops[i]);

      return arr;
    }

    getSubPatchOp(patchId, objName) {
      return this.getFirstSubPatchOpByName(patchId, objName);
    }

    getFirstSubPatchOpByName(patchId, objName) {
      for (const i in this.ops)
        if (
          this.ops[i].uiAttribs &&
          this.ops[i].uiAttribs.subPatch == patchId &&
          this.ops[i].objName == objName
        )
          return this.ops[i];

      return false;
    }

    _addLink(opinid, opoutid, inName, outName) {
      return this.link(
        this.getOpById(opinid),
        inName,
        this.getOpById(opoutid),
        outName,
        false,
        true
      );
    }

    deSerialize(obj, options) {
      options = options || { genIds: false, createRef: false };
      if (this.aborted) return;
      const newOps = [];
      const loadingId = this.loading.start("core", "deserialize");

      this.namespace = obj.namespace || "";
      this.name = obj.name || "";

      if (typeof obj === "string") obj = JSON.parse(obj);

      this.settings = obj.settings;

      this.emitEvent("patchLoadStart");

      obj.ops = obj.ops || [];

      if (window.logStartup) logStartup("add " + obj.ops.length + " ops... ");

      const addedOps = [];

      // add ops...
      for (let iop = 0; iop < obj.ops.length; iop++) {
        const start = CABLES.now();
        const opData = obj.ops[iop];
        let op = null;

        try {
          if (opData.opId)
            op = this.addOp(
              opData.opId,
              opData.uiAttribs,
              opData.id,
              true,
              opData.objName
            );
          else
            op = this.addOp(opData.objName, opData.uiAttribs, opData.id, true);
        } catch (e) {
          this._log.error("[instancing error] op data:", opData, e);
          // throw new Error("could not create op by id: <b>" + (opData.objName || opData.opId) + "</b> (" + opData.id + ")");
        }

        if (op) {
          addedOps.push(op);
          if (options.genIds) op.id = shortId();
          op.portsInData = opData.portsIn;
          op._origData = JSON.parse(JSON.stringify(opData));
          op.storage = opData.storage;
          // if (opData.hasOwnProperty("disabled"))op.setEnabled(!opData.disabled);

          for (const ipi in opData.portsIn) {
            const objPort = opData.portsIn[ipi];
            if (objPort && objPort.hasOwnProperty("name")) {
              const port = op.getPort(objPort.name);

              if (
                port &&
                (port.uiAttribs.display == "bool" ||
                  port.uiAttribs.type == "bool") &&
                !isNaN(objPort.value)
              )
                objPort.value = objPort.value == true ? 1 : 0;
              if (
                port &&
                objPort.value !== undefined &&
                port.type != CONSTANTS.OP.OP_PORT_TYPE_TEXTURE
              )
                port.set(objPort.value);

              if (port) {
                port.deSerializeSettings(objPort);
              } else {
                // if (port.uiAttribs.hasOwnProperty("title"))
                // {
                //     op.preservedPortTitles = op.preservedPortTitles || {};
                //     op.preservedPortTitles[port.name] = port.uiAttribs.title;
                // }
                op.preservedPortValues = op.preservedPortValues || {};
                op.preservedPortValues[objPort.name] = objPort.value;
              }
            }
          }

          for (const ipo in opData.portsOut) {
            const objPort = opData.portsOut[ipo];
            if (objPort && objPort.hasOwnProperty("name")) {
              const port2 = op.getPort(objPort.name);

              if (port2) {
                port2.deSerializeSettings(objPort);

                if (port2.uiAttribs.hasOwnProperty("title")) {
                  op.preservedPortTitles = op.preservedPortTitles || {};
                  op.preservedPortTitles[port2.name] = port2.uiAttribs.title;
                }

                if (
                  port2.type != CONSTANTS.OP.OP_PORT_TYPE_TEXTURE &&
                  objPort.hasOwnProperty("value")
                )
                  port2.set(obj.ops[iop].portsOut[ipo].value);

                if (objPort.expose) port2.setUiAttribs({ expose: true });
              }
            }
          }
          newOps.push(op);
        }

        const timeused = Math.round(100 * (CABLES.now() - start)) / 100;
        if (!this.silent && timeused > 5)
          console.log("long op init ", obj.ops[iop].objName, timeused);
      }
      if (window.logStartup) logStartup("add ops done");

      for (const i in this.ops) {
        if (this.ops[i].onLoadedValueSet) {
          this.ops[i].onLoadedValueSet(this.ops[i]._origData);
          this.ops[i].onLoadedValueSet = null;
          this.ops[i]._origData = null;
        }
        this.ops[i].emitEvent("loadedValueSet");
      }

      if (window.logStartup) logStartup("creating links");

      if (options.opsCreated) options.opsCreated(addedOps);
      // create links...
      if (obj.ops) {
        for (let iop = 0; iop < obj.ops.length; iop++) {
          if (obj.ops[iop].portsIn) {
            for (let ipi2 = 0; ipi2 < obj.ops[iop].portsIn.length; ipi2++) {
              if (
                obj.ops[iop].portsIn[ipi2] &&
                obj.ops[iop].portsIn[ipi2].links
              ) {
                for (
                  let ili = 0;
                  ili < obj.ops[iop].portsIn[ipi2].links.length;
                  ili++
                ) {
                  const l = this._addLink(
                    obj.ops[iop].portsIn[ipi2].links[ili].objIn,
                    obj.ops[iop].portsIn[ipi2].links[ili].objOut,
                    obj.ops[iop].portsIn[ipi2].links[ili].portIn,
                    obj.ops[iop].portsIn[ipi2].links[ili].portOut
                  );

                  // const took = performance.now - startTime;
                  // if (took > 100)console.log(obj().ops[iop].portsIn[ipi2].links[ili].objIn, obj.ops[iop].portsIn[ipi2].links[ili].objOut, took);
                }
              }
            }
          }
          if (obj.ops[iop].portsOut)
            for (let ipi2 = 0; ipi2 < obj.ops[iop].portsOut.length; ipi2++)
              if (
                obj.ops[iop].portsOut[ipi2] &&
                obj.ops[iop].portsOut[ipi2].links
              ) {
                for (
                  let ili = 0;
                  ili < obj.ops[iop].portsOut[ipi2].links.length;
                  ili++
                ) {
                  if (obj.ops[iop].portsOut[ipi2].links[ili]) {
                    if (obj.ops[iop].portsOut[ipi2].links[ili].subOpRef) {
                      // lost link
                      const outOp = this.getOpById(
                        obj.ops[iop].portsOut[ipi2].links[ili].objOut
                      );
                      let dstOp = null;
                      let theSubPatch = 0;

                      for (let i = 0; i < this.ops.length; i++) {
                        if (
                          this.ops[i].storage &&
                          this.ops[i].storage.ref ==
                            obj.ops[iop].portsOut[ipi2].links[ili].subOpRef &&
                          outOp.uiAttribs.subPatch ==
                            this.ops[i].uiAttribs.subPatch
                        ) {
                          theSubPatch = this.ops[i].patchId.get();
                          break;
                        }
                      }

                      for (let i = 0; i < this.ops.length; i++) {
                        if (
                          this.ops[i].storage &&
                          this.ops[i].storage.ref ==
                            obj.ops[iop].portsOut[ipi2].links[ili].refOp &&
                          this.ops[i].uiAttribs.subPatch == theSubPatch
                        ) {
                          dstOp = this.ops[i];
                          break;
                        }
                      }

                      if (!dstOp)
                        this._log.warn("could not find op for lost link");
                      else {
                        const l = this._addLink(
                          dstOp.id,
                          obj.ops[iop].portsOut[ipi2].links[ili].objOut,

                          obj.ops[iop].portsOut[ipi2].links[ili].portIn,
                          obj.ops[iop].portsOut[ipi2].links[ili].portOut
                        );
                      }
                    } else {
                      const l = this._addLink(
                        obj.ops[iop].portsOut[ipi2].links[ili].objIn,
                        obj.ops[iop].portsOut[ipi2].links[ili].objOut,
                        obj.ops[iop].portsOut[ipi2].links[ili].portIn,
                        obj.ops[iop].portsOut[ipi2].links[ili].portOut
                      );

                      if (!l) {
                        const op1 = this.getOpById(
                          obj.ops[iop].portsOut[ipi2].links[ili].objIn
                        );
                        const op2 = this.getOpById(
                          obj.ops[iop].portsOut[ipi2].links[ili].objOut
                        );

                        if (!op1) console.log("could not find link op1");
                        if (!op2) console.log("could not find link op2");

                        const p1Name =
                          obj.ops[iop].portsOut[ipi2].links[ili].portIn;

                        if (op1 && !op1.getPort(p1Name)) {
                          // console.log("PRESERVE port 1 not found", p1Name);

                          op1.preservedPortLinks[p1Name] =
                            op1.preservedPortLinks[p1Name] || [];
                          op1.preservedPortLinks[p1Name].push(
                            obj.ops[iop].portsOut[ipi2].links[ili]
                          );
                        }

                        const p2Name =
                          obj.ops[iop].portsOut[ipi2].links[ili].portOut;
                        if (op2 && !op2.getPort(p2Name)) {
                          // console.log("PRESERVE port 2 not found", obj.ops[iop].portsOut[ipi2].links[ili].portOut);
                          op2.preservedPortLinks[p1Name] =
                            op2.preservedPortLinks[p1Name] || [];
                          op2.preservedPortLinks[p1Name].push(
                            obj.ops[iop].portsOut[ipi2].links[ili]
                          );
                        }
                      }
                    }
                  }
                }
              }
        }
      }

      if (window.logStartup) logStartup("calling ops onloaded");

      for (const i in this.ops) {
        if (this.ops[i].onLoaded) {
          // TODO: deprecate!!!
          this.ops[i].onLoaded();
          this.ops[i].onLoaded = null;
        }
      }

      if (window.logStartup) logStartup("initializing ops...");
      for (const i in this.ops) {
        if (this.ops[i].init) {
          try {
            this.ops[i].init();
            this.ops[i].init = null;
          } catch (e) {
            console.error("op.init crash", e);
          }
        }
      }

      if (window.logStartup) logStartup("initializing vars...");

      if (this.config.variables)
        for (const varName in this.config.variables)
          this.setVarValue(varName, this.config.variables[varName]);

      if (window.logStartup) logStartup("initializing var ports");

      for (const i in this.ops) {
        this.ops[i].initVarPorts();
        delete this.ops[i].uiAttribs.pasted;
      }

      setTimeout(() => {
        this.loading.finished(loadingId);
      }, 100);

      if (this.config.onPatchLoaded) this.config.onPatchLoaded(this);

      this.deSerialized = true;
      this.emitEvent("patchLoadEnd", newOps, obj, options.genIds);
    }

    profile(enable) {
      this.profiler = new Profiler(this);
      for (const i in this.ops) {
        this.ops[i].profile(enable);
      }
    }

    // ----------------------

    /**
     * set variable value
     * @function setVariable
     * @memberof Patch
     * @instance
     * @param {String} name of variable
     * @param {Number|String|Boolean} val value
     */
    setVariable(name, val) {
      // if (this._variables.hasOwnProperty(name))
      if (this._variables[name] !== undefined) {
        this._variables[name].setValue(val);
      } else {
        this._log.warn("variable " + name + " not found!");
      }
    }

    _sortVars() {
      if (!this.isEditorMode()) return;
      const ordered = {};
      Object.keys(this._variables)
        .sort((a, b) => {
          return a.localeCompare(b, "en", { sensitivity: "base" });
        })
        .forEach((key) => {
          ordered[key] = this._variables[key];
        });
      this._variables = ordered;
    }

    /**
     * has variable
     * @function hasVariable
     * @memberof Patch
     * @instance
     * @param {String} name of variable
     */
    hasVar(name) {
      return this._variables[name] !== undefined;

      // return this._variables.hasOwnProperty(name);
    }

    // used internally
    setVarValue(name, val, type) {
      if (this.hasVar(name)) {
        this._variables[name].setValue(val);
      } else {
        this._variables[name] = new core_variable(name, val, type);
        this._sortVars();
        this.emitEvent("variablesChanged");
      }
      return this._variables[name];
    }

    // old?
    getVarValue(name, val) {
      if (this._variables.hasOwnProperty(name))
        return this._variables[name].getValue();
    }

    /**
     * @function getVar
     * @memberof Patch
     * @instance
     * @param {String} name
     * @return {Variable} variable
     */
    getVar(name) {
      if (this._variables.hasOwnProperty(name)) return this._variables[name];
    }

    deleteVar(name) {
      for (let i = 0; i < this.ops.length; i++)
        for (let j = 0; j < this.ops[i].portsIn.length; j++)
          if (this.ops[i].portsIn[j].getVariableName() == name)
            this.ops[i].portsIn[j].setVariable(null);

      delete this._variables[name];
      this.emitEvent("variableDeleted", name);
      this.emitEvent("variablesChanged");
    }

    /**
     * @function getVars
     * @memberof Patch
     * @instance
     * @param t
     * @return {Array<Variable>} variables
     * @function
     */
    getVars(t) {
      if (t === undefined) return this._variables;

      const vars = [];
      if (t == CABLES.OP_PORT_TYPE_STRING) t = "string";
      if (t == CABLES.OP_PORT_TYPE_VALUE) t = "number";
      if (t == CABLES.OP_PORT_TYPE_ARRAY) t = "array";
      if (t == CABLES.OP_PORT_TYPE_OBJECT) t = "object";

      for (const i in this._variables) {
        if (!this._variables[i].type || this._variables[i].type == t)
          vars.push(this._variables[i]);
      }
      return vars;
    }

    /**
     * @function preRenderOps
     * @memberof Patch
     * @instance
     * @description invoke pre rendering of ops
     * @function
     */
    preRenderOps() {
      this._log.log("prerendering...");

      for (let i = 0; i < this.ops.length; i++) {
        if (this.ops[i].preRender) {
          this.ops[i].preRender();
          this._log.log("prerender " + this.ops[i].objName);
        }
      }
    }

    /**
     * @function dispose
     * @memberof Patch
     * @instance
     * @description stop, dispose and cleanup patch
     */
    dispose() {
      this.pause();
      this.clear();
      this.cgl.dispose();
    }

    pushTriggerStack(p) {
      this._triggerStack.push(p);
    }

    popTriggerStack() {
      this._triggerStack.pop();
    }

    printTriggerStack() {
      if (this._triggerStack.length == 0) {
        // console.log("stack length", this._triggerStack.length); // eslint-disable-line
        return;
      }
      console.groupCollapsed(
        // eslint-disable-line
        "trigger port stack " +
          this._triggerStack[this._triggerStack.length - 1].op.objName +
          "." +
          this._triggerStack[this._triggerStack.length - 1].name
      );

      const rows = [];
      for (let i = 0; i < this._triggerStack.length; i++) {
        rows.push(
          i +
            ". " +
            this._triggerStack[i].op.objName +
            " " +
            this._triggerStack[i].name
        );
      }

      console.table(rows); // eslint-disable-line
      console.groupEnd(); // eslint-disable-line
    }

    /**
     * returns document object of the patch could be != global document object when opening canvas ina popout window
     * @function getDocument
     * @memberof Patch
     * @instance
     * @return {Object} document
     */
    getDocument() {
      return this.cgl.canvas.ownerDocument;
    }
  }

  Patch.getOpClass = function (objName) {
    const parts = objName.split(".");
    let opObj = null;

    try {
      if (parts.length == 2) opObj = window[parts[0]][parts[1]];
      else if (parts.length == 3) opObj = window[parts[0]][parts[1]][parts[2]];
      else if (parts.length == 4)
        opObj = window[parts[0]][parts[1]][parts[2]][parts[3]];
      else if (parts.length == 5)
        opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]];
      else if (parts.length == 6)
        opObj =
          window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]];
      else if (parts.length == 7)
        opObj =
          window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][
            parts[6]
          ];
      else if (parts.length == 8)
        opObj =
          window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][
            parts[6]
          ][parts[7]];
      else if (parts.length == 9)
        opObj =
          window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][
            parts[6]
          ][parts[7]][parts[8]];
      else if (parts.length == 10)
        opObj =
          window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][
            parts[6]
          ][parts[7]][parts[8]][parts[9]];
      return opObj;
    } catch (e) {
      return null;
    }
  };

  Patch.replaceOpIds = function (json, options) {
    const opids = {};
    for (const i in json.ops) {
      opids[json.ops[i].id] = json.ops[i];
    }

    for (const j in json.ops) {
      for (const k in json.ops[j].portsOut) {
        const links = json.ops[j].portsOut[k].links;
        if (links) {
          let l = links.length;

          while (l--) {
            if (
              links[l] &&
              (!opids[links[l].objIn] || !opids[links[l].objOut])
            ) {
              if (!options.doNotUnlinkLostLinks) {
                links.splice(l, 1);
              } else {
                if (options.fixLostLinks) {
                  // console.log("lost link...?", links[l]);
                  const op = gui.corePatch().getOpById(links[l].objIn);
                  if (!op) console.log("op not found!");
                  else {
                    const outerOp = gui.patchView.getSubPatchOuterOp(
                      op.uiAttribs.subPatch
                    );
                    if (outerOp) {
                      op.storage = op.storage || {};
                      op.storage.ref = op.storage.ref || CABLES.shortId();
                      links[l].refOp = op.storage.ref;
                      links[l].subOpRef = outerOp.storage.ref;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    for (const i in json.ops) {
      const op = json.ops[i];
      const oldId = op.id;
      let newId = CABLES.shortId();

      if (options.prefixHash) newId = prefixedHash(options.prefixHash + oldId);
      else if (options.prefixId) newId = options.prefixId + oldId;
      else if (options.refAsId) {
        // when saving json
        if (op.storage && op.storage.ref) {
          newId = op.storage.ref;
          delete op.storage.ref;
        } else {
          op.storage = op.storage || {};
          op.storage.ref = newId = CABLES.shortId();
        }
      }

      const newID = (op.id = newId);

      if (options.oldIdAsRef) {
        // when loading json
        op.storage = op.storage || {};
        op.storage.ref = oldId;
      }

      for (const j in json.ops) {
        if (json.ops[j].portsIn)
          for (const k in json.ops[j].portsIn) {
            if (json.ops[j].portsIn[k].links) {
              let l = json.ops[j].portsIn[k].links.length;

              while (l--)
                if (json.ops[j].portsIn[k].links[l] === null)
                  json.ops[j].portsIn[k].links.splice(l, 1);

              for (l in json.ops[j].portsIn[k].links) {
                if (json.ops[j].portsIn[k].links[l].objIn === oldId)
                  json.ops[j].portsIn[k].links[l].objIn = newID;
                if (json.ops[j].portsIn[k].links[l].objOut === oldId)
                  json.ops[j].portsIn[k].links[l].objOut = newID;
              }
            }
          }

        if (json.ops[j].portsOut)
          for (const k in json.ops[j].portsOut) {
            if (json.ops[j].portsOut[k].links) {
              let l = json.ops[j].portsOut[k].links.length;

              while (l--)
                if (json.ops[j].portsOut[k].links[l] === null)
                  json.ops[j].portsOut[k].links.splice(l, 1);

              for (l in json.ops[j].portsOut[k].links) {
                if (json.ops[j].portsOut[k].links[l].objIn === oldId)
                  json.ops[j].portsOut[k].links[l].objIn = newID;
                if (json.ops[j].portsOut[k].links[l].objOut === oldId)
                  json.ops[j].portsOut[k].links[l].objOut = newID;
              }
            }
          }
      }
    }

    // set correct subpatch
    const subpatchIds = [];
    const fixedSubPatches = [];

    for (let i = 0; i < json.ops.length; i++) {
      // if (CABLES.Op.isSubPatchOpName(json.ops[i].objName))
      if (json.ops[i].storage && json.ops[i].storage.subPatchVer) {
        for (const k in json.ops[i].portsIn) {
          if (json.ops[i].portsIn[k].name === "patchId") {
            let newId = shortId();

            if (options.prefixHash)
              newId = prefixedHash(
                options.prefixHash + json.ops[i].portsIn[k].value
              );

            const oldSubPatchId = json.ops[i].portsIn[k].value;
            const newSubPatchId = (json.ops[i].portsIn[k].value = newId);

            subpatchIds.push(newSubPatchId);

            for (let j = 0; j < json.ops.length; j++) {
              // op has no uiAttribs in export, we don't care about subpatches in export though
              if (json.ops[j].uiAttribs) {
                if (json.ops[j].uiAttribs.subPatch === oldSubPatchId) {
                  json.ops[j].uiAttribs.subPatch = newSubPatchId;
                  fixedSubPatches.push(json.ops[j].id);
                }
              }
            }
          }
        }
      }
    }

    for (const kk in json.ops) {
      let found = false;
      for (let j = 0; j < fixedSubPatches.length; j++) {
        if (json.ops[kk].id === fixedSubPatches[j]) {
          found = true;
          break;
        }
      }
      // op has no uiAttribs in export, we don't care about subpatches in export though
      if (!found && json.ops[kk].uiAttribs && options.parentSubPatchId != null)
        json.ops[kk].uiAttribs.subPatch = options.parentSubPatchId;
    }

    return json;
  };
  /**
   * remove an eventlistener
   * @instance
   * @function addEventListener
   * @param {String} name of event
   * @param {function} callback
   */

  /**
   * remove an eventlistener
   * @instance
   * @function removeEventListener
   * @param {String} name of event
   * @param {function} callback
   */

  /**
   * op added to patch event
   * @event onOpAdd
   *
   * @memberof Patch
   * @type {Object}
   * @property {Op} op new op
   */

  /**
   * op deleted from patch
   * @event onOpDelete
   * @memberof Patch
   * @type {Object}
   * @property {Op} op that will be deleted
   */

  /**
   * link event - two ports will be linked
   * @event onLink
   * @memberof Patch
   * @type {Object}
   * @property {Port} port1
   * @property {Port} port2
   */

  /**
   * unlink event - a link was deleted
   * @event onUnLink
   * @memberof Patch
   * @type {Object}
   */

  /**
   * variables has been changed / a variable has been added to the patch
   * @event variablesChanged
   * @memberof Patch
   * @type {Object}
   * @property {Port} port1
   * @property {Port} port2
   */

  /**
   * configuration object for loading a patch
   * @typedef {Object} PatchConfig
   * @hideconstructor
   * @property {String} [prefixAssetPath=''] prefix for path to assets
   * @property {String} [assetPath=''] path to assets
   * @property {String} [jsPath=''] path to javascript files
   * @property {String} [glCanvasId='glcanvas'] dom element id of canvas element
   * @property {Function} [onError=null] called when an error occurs
   * @property {Function} [onFinishedLoading=null] called when patch finished loading all assets
   * @property {Function} [onFirstFrameRendered=null] called when patch rendered it's first frame
   * @property {Boolean} [glCanvasResizeToWindow=false] resize canvas automatically to window size
   * @property {Boolean} [doRequestAnimation=true] do requestAnimationFrame set to false if you want to trigger exec() from outside (only do if you know what you are doing)
   * @property {Boolean} [clearCanvasColor=true] clear canvas in transparent color every frame
   * @property {Boolean} [clearCanvasDepth=true] clear depth every frame
   * @property {Boolean} [glValidateShader=true] enable/disable validation of shaders *
   * @property {Boolean} [silent=false]
   * @property {Number} [fpsLimit=0] 0 for maximum possible frames per second
   * @property {String} [glslPrecision='mediump'] default precision for glsl shader
   *
   */

  /* harmony default export */ const core_patch = Patch; // CONCATENATED MODULE: ./src/core/embedding.js

  const EMBED = {};

  /**
   * add patch into html element (will create canvas and set size to fill containerElement)
   * @name CABLES.EMBED#addPatch
   * @param {object|string} _element containerElement dom element or id of element
   * @param {object} options patch options
   * @function
   */
  EMBED.addPatch = function (_element, options) {
    let el = _element;
    let id = generateUUID();
    if (typeof _element == "string") {
      id = _element;
      el = document.getElementById(id);

      if (!el) {
        console.error(id + " Polyshape Container Element not found!");
        return;
      }
    }

    const canvEl = document.createElement("canvas");
    canvEl.id = "glcanvas_" + id;
    canvEl.width = el.clientWidth;
    canvEl.height = el.clientHeight;

    window.addEventListener(
      "resize",
      function () {
        this.setAttribute("width", el.clientWidth);
        this.height = el.clientHeight;
      }.bind(canvEl)
    );

    el.appendChild(canvEl);

    options = options || {};
    options.glCanvasId = canvEl.id;

    if (!options.onError) {
      options.onError = function (err) {
        console.error(err);
      };
    }

    CABLES.patch = new core_patch(options);
    return canvEl;
  }; // CONCATENATED MODULE: ./src/core/webaudio.js

  /** @namespace WEBAUDIO */

  const WEBAUDIO = {};

  WEBAUDIO.toneJsInitialized = false;

  /*
   * External JSDoc definitions
   */

  /**
   * Part of the Web Audio API, the AudioBuffer interface represents a short audio asset residing in memory.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer}
   */

  /**
   * Part of the Web Audio API, the AudioNode interface is a generic interface for representing an audio processing module.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioNode}
   */

  /**
   * The AudioContext interface represents an audio-processing graph built from audio modules linked together
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext}
   */

  /**
   * Checks if a global audio context has been created and creates
   * it if necessary. This audio context can be used for native Web Audio as well as Tone.js ops.
   * Associates the audio context with Tone.js if it is being used
   * @param {CABLES.Op} op - The operator which needs the Audio Context
   */
  WEBAUDIO.createAudioContext = function (op) {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    if (window.AudioContext) {
      if (!window.audioContext) {
        window.audioContext = new AudioContext();
      }
      // check if tone.js lib is being used
      if (window.Tone && !WEBAUDIO.toneJsInitialized) {
        // set current audio context in tone.js
        Tone.setContext(window.audioContext);
        WEBAUDIO.toneJsInitialized = true;
      }
    } else {
      if (op.patch.config.onError)
        op.logError(
          "NO_WEBAUDIO",
          "Web Audio is not supported in this browser."
        );
      return;
    }
    return window.audioContext;
  };

  /**
   * Returns the audio context.
   * Before `createAudioContext` must have been called at least once.
   * It most cases you should use `createAudioContext`, which just returns the audio context
   * when it has been created already.
   */
  WEBAUDIO.getAudioContext = function () {
    return window.audioContext;
  };

  /**
   * Creates an audio in port for the op with name `portName`
   * When disconnected it will disconnect the previous connected audio node
   * from the op's audio node.
   * @param {CABLES.Op} op - The operator to create the audio port in
   * @param {string} portName - The name of the port
   * @param {AudioNode} audioNode - The audionode incoming connections should connect to
   * @param {number} [inputChannelIndex=0] - If the audio node has multiple inputs, this is the index of the input channel to connect to
   * @returns {CABLES.Port|undefined} - The newly created audio in port or `undefined` if there was an error
   */
  WEBAUDIO.createAudioInPort = function (
    op,
    portName,
    audioNode,
    inputChannelIndex
  ) {
    if (!op || !portName || !audioNode) {
      const msg =
        "ERROR: createAudioInPort needs three parameters, op, portName and audioNode";
      op.log(msg);
      throw new Error(msg);
      // return;
    }
    if (!inputChannelIndex) {
      inputChannelIndex = 0;
    }
    op.webAudio = op.webAudio || {};
    op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];
    const port = op.inObject(portName);
    port.webAudio = {};
    port.webAudio.previousAudioInNode = null;
    port.webAudio.audioNode = audioNode;

    op.webAudio.audioInPorts[portName] = port;

    port.onChange = function () {
      const audioInNode = port.get();
      // when port disconnected, disconnect audio nodes
      if (!audioInNode) {
        if (port.webAudio.previousAudioInNode) {
          try {
            if (port.webAudio.previousAudioInNode.disconnect)
              port.webAudio.previousAudioInNode.disconnect(
                port.webAudio.audioNode,
                0,
                inputChannelIndex
              );
            op.setUiError("audioCtx", null);
          } catch (e) {
            try {
              port.webAudio.previousAudioInNode.disconnect(
                port.webAudio.audioNode
              );
            } catch (er) {
              op.log(
                "Disconnecting audio node with in/out port index, as well as without in/out-port-index did not work ",
                e
              );
              if (e.printStackTrace) {
                e.printStackTrace();
              }
              throw e;
            }
          }
        }
      } else {
        try {
          if (audioInNode.connect) {
            audioInNode.connect(port.webAudio.audioNode, 0, inputChannelIndex);
            op.setUiError("audioCtx", null);
          } else
            op.setUiError(
              "audioCtx",
              "The passed input is not an audio context. Please make sure you connect an audio context to the input.",
              2
            );
        } catch (e) {
          op.log("Error: Failed to connect web audio node!", e);
          op.log("port.webAudio.audioNode", port.webAudio.audioNode);
          op.log("audioInNode: ", audioInNode);
          op.log("inputChannelIndex:", inputChannelIndex);
          op.log("audioInNode.connect: ", audioInNode.connect);
          throw e;
        }
      }
      port.webAudio.previousAudioInNode = audioInNode;
    };
    // TODO: Maybe add subtype to audio-node-object?
    return port;
  };

  /**
   * Sometimes it is necessary to replace a node of a port, if so all
   * connections to this node must be disconnected and connections to the new
   * node must be made.
   * Can be used for both Audio ports as well as AudioParam ports
   * if used with an AudioParam pass e.g. `synth.frequency` as newNode
   * @param {CABLES.Port} port - The port where the audio node needs to be replaced
   * @param oldNode
   * @param newNode
   */
  WEBAUDIO.replaceNodeInPort = function (port, oldNode, newNode) {
    const connectedNode = port.webAudio.previousAudioInNode;
    // check if connected
    if (connectedNode && connectedNode.disconnect) {
      try {
        connectedNode.disconnect(oldNode);
      } catch (e) {
        if (e.printStackTrace) {
          e.printStackTrace();
        }
        throw new Error(
          "replaceNodeInPort: Could not disconnect old audio node. " +
            e.name +
            " " +
            e.message
        );
      }
      port.webAudio.audioNode = newNode;
      try {
        connectedNode.connect(newNode);
      } catch (e) {
        if (e.printStackTrace) {
          e.printStackTrace();
        }
        throw new Error(
          "replaceNodeInPort: Could not connect to new node. " +
            e.name +
            " " +
            e.message
        );
      }
    }
  };

  /**
   * Creates an audio out port which takes care of (dis-)connecting on it’s own
   * @param {CABLES.op} op - The op to create an audio out port for
   * @param {string} portName - The name of the port to be created
   * @param {AudioNode} audioNode - The audio node to link to the port
   * @returns {(CABLES.Port|undefined)} - The newly created audio out port or `undefined` if there was an error
   */
  WEBAUDIO.createAudioOutPort = function (op, portName, audioNode) {
    if (!op || !portName || !audioNode) {
      const msg =
        "ERROR: createAudioOutPort needs three parameters, op, portName and audioNode";
      op.log(msg);
      throw new Error(msg);
    }

    const port = op.outObject(portName);
    // TODO: Maybe add subtype to audio-node-object?
    port.set(audioNode);
    return port;
  };

  /**
   * Creates an audio param in port for the op with name portName.
   * The port accepts other audio nodes as signals as well as values (numbers)
   * When the port is disconnected it will disconnect the previous connected audio node
   * from the op's audio node and restore the number value set before.
   * @param {CABLES.Op} op - The operator to create an audio param input port for
   * @param {string} portName - The name of the port to create
   * @param audioNode
   * @param options
   * @param defaultValue
   * @returns {(CABLES.Port|undefined)} - The newly created port, which takes care of (dis-)connecting on its own, or `undefined` if there was an error
   */
  WEBAUDIO.createAudioParamInPort = function (
    op,
    portName,
    audioNode,
    options,
    defaultValue
  ) {
    if (!op || !portName || !audioNode) {
      op.log(
        "ERROR: createAudioParamInPort needs three parameters, op, portName and audioNode"
      );
      if (op && op.name) op.log("opname: ", op.name);
      op.log("portName", portName);
      op.log("audioNode: ", audioNode);
      return;
    }
    op.webAudio = op.webAudio || {};
    op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];
    // var port = op.inObject(portName);
    const port = op.inDynamic(
      portName,
      [CONSTANTS.OP.OP_PORT_TYPE_VALUE, CONSTANTS.OP.OP_PORT_TYPE_OBJECT],
      options,
      defaultValue
    );
    port.webAudio = {};
    port.webAudio.previousAudioInNode = null;
    port.webAudio.audioNode = audioNode;

    op.webAudio.audioInPorts[portName] = port;

    // port.onLinkChanged = function() {
    //   op.log("onLinkChanged");
    //   if(port.isLinked()) {
    //
    //       if(port.links[0].portOut.type === CABLES.CONSTANTS.OP.OP_PORT_TYPE_) { // value
    //
    //       } else if(port.links[0].portOut.type === CABLES.CONSTANTS.OP.OP_PORT_TYPE_OBJECT) { // object
    //
    //       }
    //   } else { // unlinked
    //
    //   }
    // };

    port.onChange = function () {
      const audioInNode = port.get();
      const node = port.webAudio.audioNode;
      const audioCtx = WEBAUDIO.getAudioContext();

      if (audioInNode != undefined) {
        if (typeof audioInNode === "object" && audioInNode.connect) {
          try {
            audioInNode.connect(node);
          } catch (e) {
            op.log("Could not connect audio node: ", e);
            if (e.printStackTrace) {
              e.printStackTrace();
            }
            throw e;
          }
          port.webAudio.previousAudioInNode = audioInNode;
        } else {
          // tone.js audio param
          if (node._param && node._param.minValue && node._param.maxValue) {
            if (
              audioInNode >= node._param.minValue &&
              audioInNode <= node._param.maxValue
            ) {
              try {
                if (node.setValueAtTime) {
                  node.setValueAtTime(audioInNode, audioCtx.currentTime);
                } else {
                  node.value = audioInNode;
                }
              } catch (e) {
                op.log("Possible AudioParam problem with tone.js op: ", e);
                if (e.printStackTrace) {
                  e.printStackTrace();
                }
                throw e;
              }
            } else {
              op.log(
                "Warning: The value for an audio parameter is out of range!"
              );
            }
          } // native Web Audio param
          else if (node.minValue && node.maxValue) {
            if (audioInNode >= node.minValue && audioInNode <= node.maxValue) {
              try {
                if (node.setValueAtTime) {
                  node.setValueAtTime(audioInNode, audioCtx.currentTime);
                } else {
                  node.value = audioInNode;
                }
              } catch (e) {
                op.log(
                  "AudioParam has minValue / maxValue defined, and value is in range, but setting the value failed! ",
                  e
                );
                if (e.printStackTrace) {
                  e.printStackTrace();
                }
                throw e;
              }
            } else {
              op.log(
                "Warning: The value for an audio parameter is out of range!"
              );
            }
          } // no min-max values, try anyway
          else {
            try {
              if (node.setValueAtTime) {
                node.setValueAtTime(audioInNode, audioCtx.currentTime);
              } else {
                node.value = audioInNode;
              }
            } catch (e) {
              op.log(
                "Possible AudioParam problem (without minValue / maxValue): ",
                e
              );
              if (e.printStackTrace) {
                e.printStackTrace();
              }
              throw e;
            }
          }

          if (
            port.webAudio.previousAudioInNode &&
            port.webAudio.previousAudioInNode.disconnect
          ) {
            try {
              port.webAudio.previousAudioInNode.disconnect(node);
            } catch (e) {
              op.log("Could not disconnect previous audio node: ", e);
              throw e;
            }
            port.webAudio.previousAudioInNode = undefined;
          }
        }
      } else {
        // disconnected
        if (port.webAudio.previousAudioInNode) {
        }
      }
    };
    return port;
  };

  /**
   * Loads an audio file and updates the loading indicators when cables is run in the editor.
   * @param {CABLES.Patch} patch - The cables patch, when called from inside an op this is `op.patch`
   * @param {string} url - The url of the audio file to load
   * @param {function} onFinished - The callback to be called when the loading is finished, passes the AudioBuffer
   * @param {function} onError - The callback when there was an error loading the file, the rror message is passed
   * @param loadingTask
   * @see {@link https://developer.mozilla.org/de/docs/Web/API/AudioContext/decodeAudioData}
   */
  WEBAUDIO.loadAudioFile = function (
    patch,
    url,
    onFinished,
    onError,
    loadingTask
  ) {
    const audioContext = WEBAUDIO.createAudioContext();

    if (!audioContext) onError(new Error("No Audiocontext"));

    let loadingId = null;
    if (loadingTask || loadingTask === undefined) {
      loadingId = patch.loading.start("audio", url);
      if (patch.isEditorMode())
        gui.jobs().start({
          id: "loadaudio" + loadingId,
          title: " loading audio (" + url + ")",
        });
    }
    const request = new XMLHttpRequest();

    if (!url) return;

    request.open("GET", url, true);
    request.responseType = "arraybuffer";

    request.onload = function () {
      patch.loading.finished(loadingId);
      if (patch.isEditorMode()) gui.jobs().finish("loadaudio" + loadingId);

      audioContext
        .decodeAudioData(request.response, onFinished, onError)
        .catch((e) => {
          onError(e);
        });
    };
    request.send();
  };

  /**
   * Checks if the passed time is a valid time to be used in any of the Tone.js ops.
   * @param {(string|number)} t - The time to check
   * @returns {boolean} - True if time is valid, false if not
   */
  WEBAUDIO.isValidToneTime = function (t) {
    try {
      const time = new Tone.Time(t);
    } catch (e) {
      return false;
    }
    return true;
  };

  /**
   * Checks if the passed note is a valid note to be used with Tone.js
   * @param {string} note - The note to be checked, e.g. `"C4"`
   * @returns {boolean} - True if the note is a valid note, false otherwise
   */
  WEBAUDIO.isValidToneNote = function (note) {
    try {
      Tone.Frequency(note);
    } catch (e) {
      return false;
    }
    return true;
  }; // CONCATENATED MODULE: ./src/core/sessionvar.js

  // todo: old... remove this from ops...

  /**
   * todo: old... remove this from ops...
   *
   * @class
   */
  const Variable = function () {
    let value = null;
    const changedCallbacks = [];

    this.onChanged = function (f) {
      changedCallbacks.push(f);
    };

    this.getValue = function () {
      return value;
    };

    this.setValue = function (v) {
      value = v;
      this.emitChanged();
    };

    this.emitChanged = function () {
      for (let i = 0; i < changedCallbacks.length; i++) {
        changedCallbacks[i]();
      }
    };
  }; // CONCATENATED MODULE: ./src/core/cgp/cgp_uniform.js

  class cgp_uniform_Uniform extends cg_uniform {
    constructor(
      __shader,
      __type,
      __name,
      _value,
      _port2,
      _port3,
      _port4,
      _structUniformName,
      _structName,
      _propertyName
    ) {
      super(
        __shader,
        __type,
        __name,
        _value,
        _port2,
        _port3,
        _port4,
        _structUniformName,
        _structName,
        _propertyName
      );
      this._cgp = __shader._cgp;

      if (!_value) {
        // if (this.getType() == "m4") this._value = mat4.create();
        if (this.getType() == "t") this._value = this._cgp.getEmptyTexture();
        // else if (this.getType() == "2f") this._value = [0, 0];
        // else if (this.getType() == "4f") this._value = [0, 1, 0, 1];
        // else if (this.getType() == "3f") this._value = [0, 1, 0];
      }

      this.gpuBuffer = null;
    }

    updateValueF() {}

    updateValueArrayF() {}

    setValueArrayF(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    setValueF(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValue2F() {}

    setValue2F(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValue3F() {}

    setValue3F(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValue4F() {}

    setValue4F(v) {
      if (v[0] == undefined) {
        this._log.stack("uniform value undefined");
        console.error("uniform value undefined");
      }
      this.needsUpdate = true;
      this._value = v;
    }

    setValueT(v) {
      if (this._value != v)
        this._shader.needsPipelineUpdate = "texture changed"; // todo really needed ? change binding instead?

      this.needsUpdate = true;
      this._value = v;
    }

    updateValueM4(v) {}

    setValueM4(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    setValueAny(v) {
      this.needsUpdate = true;
      this._value = v;
    }

    updateValueAny() {}

    updateValueT() {}

    setGpuBuffer(b) {
      this.gpuBuffer = b;
    }

    copyToBuffer(buff, pos = 0) {
      if (this._type == "f") {
        buff[pos] = this._value;
      } else if (this._type == "t") {
      } else if (this._type == "4f") {
        buff[pos] = this._value[0];
        buff[pos + 1] = this._value[1];
        buff[pos + 2] = this._value[2];
        buff[pos + 3] = this._value[3];
      } else if (this._type == "f[]") {
        for (let i = 0; i < this._value.length; i++)
          buff[pos + i] = this._value[i];
      } else if (this._type == "m4") {
        for (let i = 0; i < 16; i++) buff[pos + i] = this._value[i];
      } else {
        this._log.warn("uniform copy to buffer unknown", this._type);
      }
    }

    getWgslTypeStr() {
      if (this._type == "m4") return "mat4x4f";
      if (this._type == "4f") return "vec4f";
      if (this._type == "3f") return "vec3f";
      if (this._type == "2f") return "vec2f";
      if (this._type == "f") return "float";
      if (this._type == "f[]") return "array<vec4f>";
      if (this._type == "i") return "int";
      if (this._type == "sampler") return "sampler";
      if (this._type == "t") return "texture_2d<f32>";
      this._log.warn("unknown type getWgslTypeStr", this._type);
      return "???";
    }

    getSizeBytes() {
      const bytesPerFloat = 4;
      const bytesPerInt = 4;
      if (this._type == "t") return 4;
      if (this._type == "sampler") return 4;
      if (this._type == "f") return 1 * bytesPerFloat;
      if (this._type == "2f") return 2 * bytesPerFloat;
      if (this._type == "3f") return 3 * bytesPerFloat;
      if (this._type == "4f") return 4 * bytesPerFloat;
      if (this._type == "f[]") return this._value.length * bytesPerFloat;

      if (this._type == "m4") return 4 * 4 * bytesPerFloat;

      if (this._type == "i") return 1 * bytesPerInt;
      if (this._type == "2i") return 2 * bytesPerInt;

      this._log.warn("unknown type getSizeBytes", this._type);
      return 4;
    }

    copy(newShader) {
      const uni = new cgp_uniform_Uniform(
        newShader,
        this._type,
        this._name,
        this._value,
        this._port2,
        this._port3,
        this._port4,
        this._structUniformName,
        this._structName,
        this._propertyName
      );
      uni.shaderType = this.shaderType;

      console.log(this._name, this._value, uni._value);

      return uni;
    }
  } // CONCATENATED MODULE: ./src/core/cg/preproc.js

  function preproc(str, vars) {
    const lines = str.split("\n");
    const outLines = [];
    let stack = [];

    for (let i = 0; i < lines.length; i++) {
      let line = lines[i].trim();
      let parts = line.split(" ");

      if (line.startsWith("#ifdef ")) {
        const s = vars[parts[1]];
        stack.push({ state: s });
        continue;
      }
      if (line.startsWith("#ifndef ")) {
        const s = vars[parts[1]];
        stack.push({ state: !s });
        continue;
      }
      if (line.startsWith("#endif")) {
        stack.pop();
        continue;
      }
      const state = stack[stack.length - 1];

      if (line.startsWith("#else")) {
        state.state = !state.state;
        continue;
      }

      if (!state || state.state) {
        outLines.push(lines[i]);
      }
    }

    return outLines.join("\n");
  } // CONCATENATED MODULE: ./src/core/cgp/cgp_gpubuffer.js

  class GPUBuffer extends EventTarget {
    constructor(cgp, name, data = null, options = {}) {
      super();

      this.id = CABLES.shortId();

      this._name = name;
      this.floatArr = null;
      this._gpuBuffer = null;

      this.setData([0, 0, 0, 0]);
      this.needsUpdate = true;
      this._length = 0;

      if (options.buffCfg) {
        this._buffCfg = options.buffCfg;
      }

      if (data) this.setData(data);

      if (options.length) this.setLength(options.length);

      this.updateGpuBuffer(cgp);
    }

    setData(d) {
      // console.log((new Error()).stack);

      this.floatArr = new Float32Array(d);
      this.setLength(this.floatArr.length);

      // console.log(this.name, this.floatArr);
      this.needsUpdate = true;
    }

    setLength(s) {
      this._length = s;
      if (!this.floatArr || s != this.floatArr.length) {
        this.floatArr = new Float32Array(this._length);
        this.needsUpdate = true;
      }
    }

    updateGpuBuffer(cgp) {
      if (cgp) this._cgp = cgp;
      if (!this._cgp || !this._cgp.device) {
        console.log("no cgp...", this._name, this._cgp);
        return;
      }

      this._cgp.pushErrorScope("updateGpuBuffer");
      if (!this._gpuBuffer) {
        this._buffCfg = this._buffCfg || {};
        this._buffCfg.label = "gpuBuffer-" + this._name;
        if (!this._buffCfg.hasOwnProperty("size") && this.floatArr)
          this._buffCfg.size = this.floatArr.length * 4;
        this._buffCfg.usage =
          this._buffCfg.usage ||
          GPUBufferUsage.COPY_DST |
            GPUBufferUsage.STORAGE |
            GPUBufferUsage.COPY_SRC;

        this._gpuBuffer = this._cgp.device.createBuffer(this._buffCfg);
      }

      // if (!isNaN(this.floatArr[0]))console.log("shit", this._name);

      if (this.floatArr)
        this._cgp.device.queue.writeBuffer(
          this._gpuBuffer,
          0,
          this.floatArr.buffer,
          this.floatArr.byteOffset,
          this.floatArr.byteLength
        );

      // this._gpuBuffer.unmap();

      this._cgp.popErrorScope();

      this.needsUpdate = false;
    }

    get name() {
      return this._name;
    }

    get gpuBuffer() {
      if (!this._gpuBuffer || this.needsUpdate) this.updateGpuBuffer();

      return this._gpuBuffer;
    }

    get length() {
      return this._length;
    }

    getSizeBytes() {
      return this.floatArr.length * 4;
    }

    dispose() {
      // setTimeout(() =>
      // {
      //     if (this._gpuBuffer) this._gpuBuffer.destroy();
      // }, 100);
    }
  } // CONCATENATED MODULE: ./src/core/cgp/cgp_binding.js

  class Binding {
    /**
     * Description
     * @param {any} cgp
     * @param {any} idx
     * @param {string} name
     * @param {any} options={}
     */
    constructor(cgp, name, options = {}) {
      if (typeof options != "object")
        this._log.error("binding options is not an object");
      this._index = -1;

      this._name = name;
      this._cgp = cgp;
      this._log = new Logger("cgp_binding");
      this.uniforms = [];
      this.cGpuBuffers = [];
      this._options = options;
      this.shader = null;
      this.bindingInstances = [];
      this.stageStr = options.stage;
      this.bindingType = options.bindingType || "uniform"; // "uniform", "storage", "read-only-storage",

      if (this.stageStr == "frag") this.stage = GPUShaderStage.FRAGMENT;
      else this.stage = GPUShaderStage.VERTEX;
      if (options.hasOwnProperty("index")) this._index = options.index;

      if (options.shader) this.shader = options.shader;

      this._buffer = null;
      this.isValid = true;
      this.changed = 0;

      if (this.shader) {
        if (this.stageStr == "frag") this.shader.bindingsFrag.push(this);
        if (this.stageStr == "vert") this.shader.bindingsVert.push(this);
        if (this._index == -1) this._index = this.shader.getNewBindingIndex();
      }

      if (this._index == -1)
        this._log.warn("binding could not get an index", this._name);

      this._cgp.on("deviceChange", () => {
        // this.reInit();
      });
    }

    isStruct() {
      if (this.uniforms.length == 0) return false;

      if (this.uniforms.length == 1) {
        if (this.uniforms[0].type == "t" || this.uniforms[0].type == "sampler")
          return false;
        if (this.bindingType != "uniform") return false;
      }

      return true;
    }

    copy(newShader) {
      console.log("copy binding...");
      const options = {};

      for (const i in this._options) options[i] = this._options[i];

      options.shader = newShader;

      let binding = new Binding(this._cgp, this._name, options);

      for (let i = 0; i < this.uniforms.length; i++) {
        binding.addUniform(newShader.getUniform(this.uniforms[i].name)); // .copy(newShader)
      }

      return binding;
    }

    addUniform(uni) {
      this.uniforms.push(uni);
    }

    getSizeBytes() {
      let size = 0;
      for (let i = 0; i < this.uniforms.length; i++) {
        // console.log("UNIFORM!!!", i, this.uniforms[i], this.uniforms[i].getSizeBytes());
        // console.log("getSizeBytes", this.uniforms[i], this.uniforms[i].getSizeBytes);
        size += this.uniforms[i].getSizeBytes();
      }
      // if (this.uniforms.length == 0)console.log("NO UNIFORMS!!!");
      return size;
    }

    getShaderHeaderCode() {
      let str = "";

      let typeStr = "strct_" + this._name;
      let name = this._name;

      if (this.uniforms.length === 0)
        return "// no uniforms in bindinggroup...?\n";

      str += "// " + this.uniforms.length + " uniforms\n";

      if (this.isStruct()) {
        str += "struct " + typeStr + "\n";
        str += "{\n";
        for (let i = 0; i < this.uniforms.length; i++) {
          str +=
            "    " +
            this.uniforms[i].name +
            ": " +
            this.uniforms[i].getWgslTypeStr();
          if (i != this.uniforms.length - 1) str += ",";
          str += "\n";
        }
        str += "};\n";
      } else {
        typeStr = this.uniforms[0].getWgslTypeStr();
        name = this.uniforms[0].name;
      }

      str += "@group(0) ";
      str += "@binding(" + this._index + ") ";

      if (this.isStruct()) {
        str += "var<" + this.bindingType + "> ";
      } else if (this.bindingType == "read-only-storage")
        str += "var<storage,read> ";
      else str += "var ";

      str += name + ": " + typeStr + ";\n";

      return str;
    }

    getBindingGroupLayoutEntry() {
      let label = "layout " + this._name + " [";
      for (let i = 0; i < this.uniforms.length; i++)
        label += this.uniforms[i].getName() + ",";
      label += "]";

      const o = {
        label: label,
        binding: this._index,
        visibility: this.stage,
        size: this.getSizeBytes(),
      };

      if (this.uniforms.length == 1 && this.uniforms[0].getType() == "t") {
        o.texture = {};
      } else if (
        this.uniforms.length == 1 &&
        this.uniforms[0].getType() == "sampler"
      ) {
        o.sampler = {};
      } else {
        o.buffer = {};
        o.buffer.type = this.bindingType;
      }

      return o;
    }

    getBindingGroupEntry(gpuDevice, inst) {
      this.isValid = false;

      const o = {
        label: this._name + " binding",
        binding: this._index,
        size: this.getSizeBytes(),
        visibility: this.stage,
      };

      if (this.uniforms.length == 0) {
        console.log("binding uniforms length 0");
        return;
      }

      if (this.uniforms.length == 1 && this.uniforms[0].getType() == "t") {
        if (
          this.uniforms[0].getValue() &&
          this.uniforms[0].getValue().gpuTexture
        )
          o.resource = this.uniforms[0].getValue().gpuTexture.createView();
        else o.resource = this._cgp.getEmptyTexture().createView(); // CABLES.emptyCglTexture.createView();
      } else if (
        this.uniforms.length == 1 &&
        this.uniforms[0].getType() == "sampler"
      ) {
        let smplDesc = {
          addressModeU: "mirror-repeat",
          addressModeV: "mirror-repeat",
          magFilter: "linear",
          minFilter: "linear",
          mipmapFilter: "linear",
        };

        if (this.uniforms[0].getValue())
          smplDesc = this.uniforms[0].getValue().getSampler();

        const sampler = this.uniforms[0]._cgp.device.createSampler(smplDesc);
        o.resource = sampler;
      } else {
        this._createCgpuBuffer(inst);

        o.resource = {
          buffer: this.cGpuBuffers[inst].gpuBuffer,
          minBindingSize: this.getSizeBytes(),
          hasDynamicOffset: 0,
        };
      }

      this.isValid = true;
      this.bindingInstances[inst] = o;

      return o;
    }

    _createCgpuBuffer(inst) {
      let buffCfg = {
        label: this._name,
        size: this.getSizeBytes(),
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
      };

      if (
        this.bindingType == "read-only-storage" ||
        this.bindingType == "storage"
      )
        buffCfg.usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;

      if (this.cGpuBuffers[inst]) this.cGpuBuffers[inst].dispose();
      this.cGpuBuffers[inst] = new GPUBuffer(
        this._cgp,
        this._name + " buff",
        null,
        { buffCfg: buffCfg }
      );

      if (this.uniforms.length > 0 && this.uniforms[0].gpuBuffer)
        this.cGpuBuffers[inst] = this.uniforms[0].gpuBuffer;
    }

    update(cgp, inst) {
      let b = this.bindingInstances[inst];
      if (!b) b = this.getBindingGroupEntry(cgp.device, inst);

      if (this.uniforms.length == 1 && this.uniforms[0].gpuBuffer) {
        if (this.uniforms[0].gpuBuffer != this.cGpuBuffers[inst]) {
          console.log("changed?!");
          this.shader._needsRecompile = true; // TODO this should actually just rebuild the bindinggroup i guess ?
        }

        if (this._cgp.frameStore.branchProfiler)
          this._cgp.frameStore.branchStack.push("extern uni bind", [
            this.uniforms[0].getName(),
            this.cGpuBuffers[inst].floatArr,
          ]);
        if (this._cgp.frameStore.branchProfiler)
          this._cgp.frameStore.branchStack.pop();
      } else if (
        this.uniforms.length == 1 &&
        this.uniforms[0].getType() == "t"
      ) {
        if (this._cgp.frameStore.branchProfiler)
          this._cgp.frameStore.branchStack.push("uni texture");
        if (this.uniforms[0].getValue())
          if (this.uniforms[0].getValue().gpuTexture) {
            this.bindingInstances[inst] = this.getBindingGroupEntry(
              this.uniforms[0]._cgp.device,
              inst
            );
          } else {
            console.log("uni t has no gputexture");
            b.resource = this._cgp.getErrorTexture().createView();
          }

        if (this._cgp.frameStore.branchProfiler)
          this._cgp.frameStore.branchStack.pop();
      } else if (
        this.uniforms.length == 1 &&
        this.uniforms[0].getType() == "sampler"
      ) {
        if (this._cgp.frameStore.branchProfiler)
          this._cgp.frameStore.branchStack.push("uni sampler");
        b.resource = this.uniforms[0].getValue();
        if (this._cgp.frameStore.branchProfiler)
          this._cgp.frameStore.branchStack.pop();
      } else {
        let info = ["stage " + this.stageStr + " / inst " + inst];

        // console.log("B",this.);
        // update uniform values to buffer
        const s = this.getSizeBytes() / 4;

        // if (!this.cGpuBuffers[inst])
        // this._createCgpuBuffer(inst);
        // this.cGpuBuffers[inst] = new GPUBuffer(this._cgp, "buff", null, { "buffCfg": buffCfg });

        this.cGpuBuffers[inst].setLength(s);

        let off = 0;
        for (let i = 0; i < this.uniforms.length; i++) {
          info.push(
            this.uniforms[i].getName() + " " + this.uniforms[i].getValue()
          );
          this.uniforms[i].copyToBuffer(this.cGpuBuffers[inst].floatArr, off); // todo: check if uniform changed?

          // if (isNaN(this.cGpuBuffers[inst].floatArr[0]))
          // {
          // console.log("shitttttttt", this.cGpuBuffers[inst].floatArr[0], this.uniforms[i].getName(), this.cGpuBuffers[inst].name, this.uniforms[i]);
          // }

          off += this.uniforms[i].getSizeBytes() / 4;
        }
        if (this._cgp.frameStore.branchProfiler)
          this._cgp.frameStore.branchStack.push("uni buff", info);

        // console.log("upodate", inst);

        this.cGpuBuffers[inst].updateGpuBuffer();
        // todo: only if changed...
        // cgp.device.queue.writeBuffer(
        //     b.resource.buffer,
        //     0,
        //     this._buffer.buffer,
        //     this._buffer.byteOffset,
        //     this._buffer.byteLength
        // );

        if (this._cgp.frameStore.branchProfiler)
          this._cgp.frameStore.branchStack.pop();
      }
    }
  } // CONCATENATED MODULE: ./src/core/cgp/cgp_shader.js

  class cgp_shader_Shader extends CgShader {
    constructor(_cgp, _name, options = {}) {
      super();
      if (!_cgp) throw new Error("shader constructed without cgp " + _name);
      this._log = new Logger("cgp_shader");
      this._cgp = _cgp;
      this._name = _name;
      this._uniforms = [];
      this.compute = options.compute || false;

      if (!_name) this._log.stack("no shader name given");
      this._name = _name || "unknown";
      this._compileReason = "";
      this.gpuShaderModule = null;
      this._needsRecompile = true;
      this.bindingCounter = 0;
      this.bindCountlastFrame = -1;
      this._bindingIndexCount = 0;

      this.defaultBindingVert = new Binding(_cgp, "vsUniforms", {
        stage: "vert",
        bindingType: "uniform",
        index: this._bindingIndexCount++,
      });
      this.defaultBindingFrag = new Binding(_cgp, "fsUniforms", {
        stage: "frag",
        bindingType: "uniform",
        index: this._bindingIndexCount++,
      });
      this.defaultBindingComp = new Binding(_cgp, "computeUniforms", {
        bindingType: "uniform",
        index: this._bindingIndexCount++,
      });
      this.bindingsFrag = [this.defaultBindingFrag];
      this.bindingsVert = [this.defaultBindingVert];
      this.bindingsComp = [this.defaultBindingComp];

      if (!this.compute) {
        this.uniModelMatrix = this.addUniformVert("m4", "modelMatrix");
        this.uniViewMatrix = this.addUniformVert("m4", "viewMatrix");
        this.uniProjMatrix = this.addUniformVert("m4", "projMatrix");
        this.uniNormalMatrix = this.addUniformVert("m4", "normalMatrix");
        this.uniModelViewMatrix = this.addUniformVert("m4", "modelViewMatrix");
        this._tempNormalMatrix = mat4.create();
        this._tempModelViewMatrix = mat4.create();
      }

      this._src = "";

      this._cgp.on("deviceChange", () => {
        this.gpuShaderModule = null;
        this._needsRecompile = "device changed";
      });
    }

    incBindingCounter() {
      if (this.bindCountlastFrame != this._cgp.frame) this.bindingCounter = 0;
      else this.bindingCounter++;
      this.bindCountlastFrame = this._cgp.frame;
    }

    reInit() {}

    get isValid() {
      return this._isValid;
    }

    get uniforms() {
      return this._uniforms;
    }

    getName() {
      return this._name;
    }

    setWhyCompile(why) {
      this._compileReason = why;
    }

    getNewBindingIndex() {
      return ++this._bindingIndexCount;
    }

    setSource(src) {
      this._src = src;
      this.setWhyCompile("Source changed");
      this._needsRecompile = true;
    }

    _replaceMods(vs) {
      let srcHeadVert = "";
      for (let i = 0; i < this._moduleNames.length; i++) {
        let srcVert = "";

        for (let j = 0; j < this._modules.length; j++) {
          const mod = this._modules[j];
          if (mod.name == this._moduleNames[i]) {
            srcHeadVert +=
              "\n//---- MOD: group:" +
              mod.group +
              ": idx:" +
              j +
              " - prfx:" +
              mod.prefix +
              " - " +
              mod.title +
              " ------\n";

            srcVert +=
              "\n\n//---- MOD: " +
              mod.title +
              " / " +
              mod.priority +
              " ------\n";

            if (mod.attributes)
              for (let k = 0; k < mod.attributes.length; k++) {
                const r = this._getAttrSrc(mod.attributes[k], false);
                if (r.srcHeadVert) srcHeadVert += r.srcHeadVert;
                if (r.srcVert) srcVert += r.srcVert;
              }

            srcHeadVert += mod.srcHead || "";
            srcVert += mod.srcBody || "";

            srcHeadVert += "\n//---- end mod ------\n";

            srcVert += "\n//---- end mod ------\n";

            srcVert = srcVert.replace(/{{mod}}/g, mod.prefix);
            srcHeadVert = srcHeadVert.replace(/{{mod}}/g, mod.prefix);

            srcVert = srcVert.replace(/MOD_/g, mod.prefix);
            srcHeadVert = srcHeadVert.replace(/MOD_/g, mod.prefix);
          }
        }

        vs = vs.replace("{{" + this._moduleNames[i] + "}}", srcVert);
      }

      vs = vs.replace("{{MODULES_HEAD}}", srcHeadVert);
      return vs;
    }

    getProcessedSource() {
      const defs = {};
      for (let i = 0; i < this._defines.length; i++)
        defs[this._defines[i][0]] = this._defines[i][1] || true;

      let src = preproc(this._src, defs);

      let bindingsHeadVert = "";
      for (let i = 0; i < this.bindingsFrag.length; i++)
        bindingsHeadVert += this.bindingsFrag[i].getShaderHeaderCode();

      let bindingsHeadFrag = "";
      for (let i = 0; i < this.bindingsVert.length; i++)
        bindingsHeadFrag += this.bindingsVert[i].getShaderHeaderCode();

      src =
        bindingsHeadFrag +
        "\n\n////////////////\n\n" +
        bindingsHeadVert +
        "\n\n////////////////\n\n" +
        src;
      src = this._replaceMods(src);

      return src;
      // console.log("----------------\n", src, "\n----------------------------");
    }

    compile() {
      console.log("compile", this._compileReason);
      this._isValid = true;
      this._cgp.pushErrorScope("cgp_shader " + this._name);
      // console.log(this.getProcessedSource());
      this.gpuShaderModule = this._cgp.device.createShaderModule({
        code: this.getProcessedSource(),
        label: this._name,
      });
      this._cgp.popErrorScope(this.error.bind(this));
      this._needsRecompile = false;

      this.emitEvent("compiled");
    }

    error(e) {
      this._isValid = false;
    }

    bind() {
      if (!this.compute) {
        this.uniModelMatrix.setValue(this._cgp.mMatrix);
        this.uniViewMatrix.setValue(this._cgp.vMatrix);
        this.uniProjMatrix.setValue(this._cgp.pMatrix);

        // mat4.invert(this._tempNormalMatrix, this._cgp.mMatrix);
        // mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix);
        mat4.mul(
          this._tempModelViewMatrix,
          this._cgp.vMatrix,
          this._cgp.mMatrix
        );

        // mat4.set(this._tempNormalMatrix, this._tempModelViewMatrix);
        mat4.invert(this._tempNormalMatrix, this._tempModelViewMatrix);
        mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix);

        // cpu billboarding?
        // this._tempModelViewMatrix[0 * 4 + 0] = 1.0;
        // this._tempModelViewMatrix[0 * 4 + 1] = 0.0;
        // this._tempModelViewMatrix[0 * 4 + 2] = 0.0;

        // // #ifndef BILLBOARDING_CYLINDRIC
        // this._tempModelViewMatrix[1 * 4 + 0] = 0.0;
        // this._tempModelViewMatrix[1 * 4 + 1] = 1.0;
        // this._tempModelViewMatrix[1 * 4 + 2] = 0.0;
        // // #endif

        // this._tempModelViewMatrix[2 * 4 + 0] = 0.0;
        // this._tempModelViewMatrix[2 * 4 + 1] = 0.0;
        // this._tempModelViewMatrix[2 * 4 + 2] = 1.0;

        this.uniModelViewMatrix.setValue(this._tempModelViewMatrix);
        this.uniNormalMatrix.setValue(this._tempNormalMatrix);
      }

      if (this._needsRecompile) this.compile();
    }

    /**
     * add a uniform to the fragment shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniformFrag
     * @returns {Uniform}
     */
    addUniformFrag(type, name, valueOrPort, p2, p3, p4) {
      const uni = new cgp_uniform_Uniform(
        this,
        type,
        name,
        valueOrPort,
        p2,
        p3,
        p4
      );
      uni.shaderType = "frag";

      this.defaultBindingFrag.addUniform(uni);
      this.needsPipelineUpdate = "add frag uniform";

      return uni;
    }

    /**
     * add a uniform to the vertex shader
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniformVert
     * @returns {Uniform}
     */
    addUniformVert(type, name, valueOrPort, p2, p3, p4) {
      const uni = new cgp_uniform_Uniform(
        this,
        type,
        name,
        valueOrPort,
        p2,
        p3,
        p4
      );
      uni.shaderType = "vert";

      this.defaultBindingVert.addUniform(uni);
      this.needsPipelineUpdate = "add ver uniform";

      return uni;
    }

    /**
     * add a uniform to all shader programs
     * @param {String} type ['f','t', etc]
     * @param {String} name
     * @param {any} valueOrPort value or port
     * @param p2
     * @param p3
     * @param p4
     * @memberof Shader
     * @instance
     * @function addUniform
     * @returns {Uniform}
     */
    addUniform(type, name, valueOrPort, p2, p3, p4) {
      const uni = new cgp_uniform_Uniform(
        this,
        type,
        name,
        valueOrPort,
        p2,
        p3,
        p4
      );
      uni.shaderType = "both";
      return uni;
    }

    _addUniform(uni) {
      this._uniforms.push(uni);
      this.setWhyCompile("add uniform " + name);
      this._needsRecompile = true;
    }

    getUniform(name) {
      for (let i = 0; i < this._uniforms.length; i++) {
        if (this._uniforms[i].getName() == name) return this._uniforms[i];
      }
    }

    /**
     * copy current shader
     * @function copy
     * @memberof Shader
     * @instance
     * @returns newShader
     */
    copy() {
      const shader = new cgp_shader_Shader(this._cgp, this._name + " copy");
      shader.setSource(this._src);

      shader._modules = JSON.parse(JSON.stringify(this._modules));
      shader._defines = JSON.parse(JSON.stringify(this._defines));

      shader._modGroupCount = this._modGroupCount;
      shader._moduleNames = this._moduleNames;

      // shader.glPrimitive = this.glPrimitive;
      // shader.offScreenPass = this.offScreenPass;
      // shader._extensions = this._extensions;
      // shader.wireframe = this.wireframe;
      // shader._attributes = this._attributes;

      for (let i = 0; i < this._uniforms.length; i++)
        this._uniforms[i].copy(shader);

      shader.bindingsFrag = [];
      for (let i = 0; i < this.bindingsFrag.length; i++)
        this.bindingsFrag[i].copy(shader);
      shader.defaultBindingFrag = this.bindingsFrag[0];

      shader.bindingsVert = [];
      for (let i = 0; i < this.bindingsVert.length; i++)
        this.bindingsVert[i].copy(shader);
      shader.defaultBindingVert = this.bindingsVert[0];

      shader.bindingsComp = [];
      for (let i = 0; i < this.bindingsComp.length; i++)
        this.bindingsComp[i].copy(shader);
      shader.defaultBindingComp = this.bindingsComp[0];

      console.log("copyyyyyyyyyy", shader.bindingsVert, this.bindingsVert);

      this.setWhyCompile("copy");
      shader._needsRecompile = true;
      return shader;
    }

    /**
     * copy all uniform values from another shader
     * @function copyUniforms
     * @memberof Shader
     * @instance
     * @param origShader uniform values will be copied from this shader
     */
    copyUniformValues(origShader) {
      for (let i = 0; i < origShader._uniforms.length; i++) {
        if (!this._uniforms[i]) {
          this._log.log("unknown uniform?!");
          continue;
        }
        this.getUniform(origShader._uniforms[i].getName()).set(
          origShader._uniforms[i].getValue()
        );
      }

      // this.popTextures();
      // for (let i = 0; i < origShader._textureStackUni.length; i++)
      // {
      //     this._textureStackUni[i] = origShader._textureStackUni[i];
      //     this._textureStackTex[i] = origShader._textureStackTex[i];
      //     this._textureStackType[i] = origShader._textureStackType[i];
      //     this._textureStackTexCgl[i] = origShader._textureStackTexCgl[i];
      // }
    }
  } // CONCATENATED MODULE: ./src/core/cgp/cgl_shader_default.wgsl

  /* harmony default export */ const cgl_shader_default =
    "\nstruct MyVSInput\n{\n    @location(0) position: vec3<f32>,\n    @location(1) normal: vec3<f32>,\n    @location(2) texcoord: vec2<f32>,\n};\n\nstruct MyVSOutput\n{\n    @builtin(position) position: vec4<f32>,\n    @location(0) normal: vec3<f32>,\n    @location(1) texcoord: vec2<f32>,\n};\n\n@vertex\nfn myVSMain(v: MyVSInput) -> MyVSOutput\n{\n    var vsOut: MyVSOutput;\n    var pos =vec4<f32>(v.position, 1.0);\n\n    var mvMatrix=vsUniforms.viewMatrix * vsUniforms.modelMatrix;\n    vsOut.position = vsUniforms.projMatrix * mvMatrix * pos;\n\n    vsOut.normal = v.normal;\n    vsOut.texcoord = v.texcoord;\n    return vsOut;\n}\n\n@fragment\nfn myFSMain(v: MyVSOutput) -> @location(0) vec4<f32>\n{\n    return fsUniforms.color+vec4<f32>(.5,.5,.5,1.0);\n}\n\n"; // CONCATENATED MODULE: ./src/core/cgp/cgp_texture.js
  class cgp_texture_Texture extends CgTexture {
    constructor(_cgp, options = {}) {
      super(options);
      if (!_cgp) throw new Error("no cgp");
      this._log = new Logger("cgp_texture");
      this._cgp = _cgp;
      // this.id = CABLES.uuid();
      this.gpuTexture = null;
      this.gpuTextureDescriptor = null;

      options = options || {};

      this.name = options.name || "unknown";

      this.samplerDesc = {
        addressModeU: options.wrap || options.addressModeU || "clamp-to-edge",
        addressModeV: options.wrap || options.addressModeV || "clamp-to-edge",
        magFilter: options.magFilter || options.filter || "linear",
        minFilter: options.minFilter || options.filter || "linear",
      };

      this._cgp.on("deviceChange", () => {
        // this.reInit();
      });
    }

    /**
     * set texture data from an image/canvas object
     * @function initTexture
     * @memberof Texture
     * @instance
     * @param {Object} img image
     * @param {Number} filter
     */
    initTexture(img, filter) {
      this.width = img.width;
      this.height = img.height;

      const textureType = "rgba8unorm";

      this._cgp.pushErrorScope("inittexture", { logger: this._log });

      this.gpuTextureDescriptor = {
        size: { width: img.width, height: img.height },
        format: textureType,
        usage:
          GPUTextureUsage.TEXTURE_BINDING |
          GPUTextureUsage.COPY_DST |
          GPUTextureUsage.RENDER_ATTACHMENT,
      };

      this.gpuTexture = this._cgp.device.createTexture(
        this.gpuTextureDescriptor
      );
      this._cgp.device.queue.copyExternalImageToTexture(
        { source: img },
        { texture: this.gpuTexture },
        this.gpuTextureDescriptor.size
      );

      this._cgp.popErrorScope();

      return this.gpuTexture;
    }

    dispose() {
      console.log("todo dispose");
    }

    getInfo() {
      const tex = this;
      const obj = {};

      obj.name = tex.name;
      obj.size = tex.width + " x " + tex.height;

      obj.textureType = tex.textureType;

      return obj;
    }

    createView() {
      if (!this.gpuTexture) {
        console.log("no gputexture...");
        return null;
      }
      return this.gpuTexture.createView();
    }

    getSampler() {
      // "clamp-to-edge"
      // "repeat"
      // "mirror-repeat"

      return this.samplerDesc;
    }

    /**
     * @function initFromData
     * @memberof Texture
     * @instance
     * @description create texturem from rgb data
     * @param {Array<Number>} data rgb color array [r,g,b,a,r,g,b,a,...]
     * @param {Number} w width
     * @param {Number} h height
     * @param {Number} filter
     * @param {Number} wrap
     */
    initFromData(data, w, h, filter, wrap) {
      if (!w || !h) this._log.error("texture size is 0");
      this.width = w;
      this.height = h;
      this.gpuTexture = this._cgp.device.createTexture({
        size: [w, h],
        format: "rgba8unorm",
        usage:
          GPUTextureUsage.TEXTURE_BINDING |
          GPUTextureUsage.COPY_DST |
          GPUTextureUsage.RENDER_ATTACHMENT,
      });

      this._cgp.device.queue.writeTexture(
        { texture: this.gpuTexture },
        data,
        { bytesPerRow: w * 4 },
        { width: w, height: h }
      );
    }

    setWrap(v) {
      this.samplerDesc.addressModeU = this.samplerDesc.addressModeV = v;
    }

    setFilter(v) {
      this.samplerDesc.minFilter = this.samplerDesc.magFilter = v;
    }
  }

  /**
   * @function load
   * @static
   * @memberof Texture
   * @description load an image from an url
   * @param {Context} cgp
   * @param {String} url
   * @param {Function} onFinished
   * @param {Object} settings
   * @return {Texture}
   */
  cgp_texture_Texture.load = function (cgp, url, onFinished, settings) {
    fetch(url).then((response) => {
      const texture = new cgp_texture_Texture(cgp, { name: url });

      response.blob().then((blob) => {
        createImageBitmap(blob)
          .then((imgBitmap) => {
            texture.initTexture(imgBitmap);
            if (onFinished) onFinished(texture);
            else console.log("Texture.load no onFinished callback");
          })
          .catch((err) => {
            if (onFinished) onFinished(cgp.getErrorTexture());
          });
      });
    });
  }; // CONCATENATED MODULE: ./src/core/cgp/cgp_state.js

  // https://github.com/greggman/webgpu-utils
  // https://developer.chrome.com/blog/from-webgl-to-webgpu/
  // https://gpuweb.github.io/gpuweb/explainer/

  /**
   * cables webgpu context/state manager
   * @class
   * @namespace external:CGP
   * @hideconstructor
   */
  // const Context = function (_patch)
  class WebGpuContext extends CGState {
    constructor(_patch) {
      super();

      this.patch = _patch;

      this.lastErrorMsg = "";

      this._log = new Logger("WebGpuContext");
      this.gApi = CG.GAPI_WEBGPU;
      this._viewport = [0, 0, 256, 256];
      this._shaderStack = [];
      this._simpleShader = null;
      this.frame = 0;
      this.catchErrors = false;

      this._stackCullFaceFacing = [];
      this._stackDepthTest = [];
      this._stackCullFace = [];
      this._stackDepthFunc = [];
      this._stackDepthWrite = [];
      this._stackErrorScope = [];
      this._stackBlend = [];
      this._stackErrorScopeLogs = [];

      this._defaultBlend = {
        color: {
          operation: "add",
          srcFactor: "one",
          dstFactor: "zero",
        },
        alpha: {
          operation: "add",
          srcFactor: "one",
          dstFactor: "zero",
        },
      };

      this.DEPTH_FUNCS = [
        "never",
        "always",
        "less",
        "less-equal",
        "greater",
        "greater-equal",
        "equal",
        "not-equal",
      ];

      this.CULL_MODES = [
        "none",
        "back",
        "front",
        "none", // both does not exist in webgpu
      ];
    }

    /// ////////////////////

    // getViewPort()
    // {
    //     return [0, 0, this.canvasWidth, this.canvasHeight];
    // }

    renderStart(cgp, identTranslate, identTranslateView) {
      this.frame++;
      this.pushErrorScope("cgpstate internal", "internal");
      this.pushErrorScope("cgpstate out-of-memory", "out-of-memory");

      if (!this._simpleShader) {
        this._simpleShader = new cgp_shader_Shader(
          this,
          "simple default shader"
        );
        this._simpleShader.setSource(cgl_shader_default);
        this._simpleShader.addUniformFrag("4f", "color", [1, 1, 0, 1]);
      }

      this.fpsCounter.startFrame();

      this._startMatrixStacks(identTranslate, identTranslateView);
      this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);

      this.pushShader(this._simpleShader);
      this.pushDepthTest(true);
      this.pushDepthWrite(true);
      this.pushDepthFunc("less-equal");

      this.pushBlend(this._defaultBlend);

      this.emitEvent("beginFrame");
    }

    renderEnd() {
      this._endMatrixStacks();

      this.popShader();
      this.popDepthFunc();
      this.popDepthWrite();
      this.popDepthTest();

      this.popErrorScope();
      this.popErrorScope();

      if (this._stackErrorScope.length > 0)
        console.log("scope stack length invalid...");

      this.emitEvent("endFrame");
      this.fpsCounter.endFrame();
    }

    setViewPort(x, y, w, h) {
      this._viewport = [x, y, w, h];
    }

    /**
     * @function getViewPort
     * @memberof Context
     * @instance
     * @description get current gl viewport
     * @returns {Array} array [x,y,w,h]
     */
    getViewPort() {
      return this._viewPort;
    }

    createMesh(geom, glPrimitive) {
      return new CGP.Mesh(this, geom, glPrimitive);
    }

    /**
     * push a shader to the shader stack
     * @function pushShader
     * @memberof Context
     * @instance
     * @param {Object} shader
     * @function
     */
    pushShader(shader) {
      this._shaderStack.push(shader);
      // currentShader = shader;
    }

    /**
     * pop current used shader from shader stack
     * @function popShader
     * @memberof Context
     * @instance
     * @function
     */
    popShader() {
      if (this._shaderStack.length === 0)
        throw new Error("Invalid shader stack pop!");
      this._shaderStack.pop();
      // currentShader = this._shaderStack[this._shaderStack.length - 1];
    }

    getShader() {
      return this._shaderStack[this._shaderStack.length - 1];
      // if (currentShader) if (!this.frameStore || ((this.frameStore.renderOffscreen === true) == currentShader.offScreenPass) === true) return currentShader;
      // for (let i = this._shaderStack.length - 1; i >= 0; i--) if (this._shaderStack[i]) if (this.frameStore.renderOffscreen == this._shaderStack[i].offScreenPass) return this._shaderStack[i];
    }

    setDevice(device) {
      this.device = device;

      if (this._emptyTexture) this._emptyTexture = this._emptyTexture.dispose();
      if (this._defaultTexture)
        this._defaultTexture = this._defaultTexture.dispose();
      if (this._errorTexture) this._errorTexture = this._errorTexture.dispose();

      this.emitEvent("deviceChange");
    }

    pushErrorScope(name, options = {}) {
      if (this.catchErrors) {
        this._stackErrorScope.push(name);
        this._stackErrorScopeLogs.push(options.logger || null);
        this.device.pushErrorScope(options.scope || "validation");
      }
    }

    popErrorScope(cb) {
      if (this.catchErrors) {
        const name = this._stackErrorScope.pop();
        const logger = this._stackErrorScopeLogs.pop();
        this.device.popErrorScope().then((error) => {
          if (error) {
            if (this.lastErrorMsg == error.message) {
              // this._log.warn("last error once more...");
            } else {
              (logger || this._log).error(error.constructor.name, "in", name);
              (logger || this._log).error(error.message);
            }
            this.lastErrorMsg = error.message;

            if (cb) cb(error);
          }
        });
      }
    }

    /**
     * push depth testing enabled state
     * @function pushDepthTest
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushDepthTest(b) {
      this._stackDepthTest.push(b);
    }

    /**
     * current state of depth testing
     * @function stateDepthTest
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthTest() {
      return this._stackDepthTest[this._stackDepthTest.length - 1];
    }

    /**
     * pop depth testing state
     * @function popDepthTest
     * @memberof Context
     * @instance
     */
    popDepthTest() {
      this._stackDepthTest.pop();
    }

    // --------------------------------------
    // state depthwrite

    /**
     * push depth write enabled state
     * @function pushDepthWrite
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushDepthWrite(b) {
      b = b || false;
      this._stackDepthWrite.push(b);
    }

    /**
     * current state of depth writing
     * @function stateCullFace
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateDepthWrite() {
      return this._stackDepthWrite[this._stackDepthWrite.length - 1];
    }

    /**
     * pop depth writing state
     * @function popCullFace
     * @memberof Context
     * @instance
     */
    popDepthWrite() {
      this._stackDepthWrite.pop();
    }

    // --------------------------------------
    // state depthfunc

    /**
     * @function pushDepthFunc
     * @memberof Context
     * @instance
     * @param {string} f depth compare func
     */
    pushDepthFunc(f) {
      this._stackDepthFunc.push(f);
    }

    /**
     * @function stateDepthFunc
     * @memberof Context
     * @instance
     * @returns {string}
     */
    stateDepthFunc() {
      if (this._stackDepthFunc.length > 0)
        return this._stackDepthFunc[this._stackDepthFunc.length - 1];
      return false;
    }

    /**
     * pop depth compare func
     * @function popDepthFunc
     * @memberof Context
     * @instance
     */
    popDepthFunc() {
      this._stackDepthFunc.pop();
    }

    // --------------------------------------
    // state CullFace

    /**
     * push face culling face enabled state
     * @function pushCullFace
     * @param {Boolean} b enabled
     * @memberof Context
     * @instance
     */
    pushCullFace(b) {
      this._stackCullFace.push(b);
    }

    /**
     * current state of face culling
     * @function stateCullFace
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateCullFace() {
      return this._stackCullFace[this._stackCullFace.length - 1];
    }

    /**
     * pop face culling enabled state
     * @function popCullFace
     * @memberof Context
     * @instance
     */
    popCullFace() {
      this._stackCullFace.pop();
    }

    // --------------------------------------
    // state CullFace Facing

    /**
     * push face culling face side
     * @function pushCullFaceFacing
     * @memberof Context
     * @param b
     * @instance
     */
    pushCullFaceFacing(b) {
      this._stackCullFaceFacing.push(b);
    }

    /**
     * current state of face culling side
     * @function stateCullFaceFacing
     * @returns {Boolean} enabled
     * @memberof Context
     * @instance
     */
    stateCullFaceFacing() {
      return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];
    }

    /**
     * pop face culling face side
     * @function popCullFaceFacing
     * @memberof Context
     * @instance
     */
    popCullFaceFacing() {
      this._stackCullFaceFacing.pop();
    }

    pushBlend(b) {
      this._stackBlend.push(b);
    }

    popBlend() {
      this._stackBlend.pop();
    }

    stateBlend() {
      return this._stackBlend[this._stackBlend.length - 1];
    }

    getEmptyTexture() {
      if (this._emptyTexture) return this._emptyTexture;
      const size = 8;
      this._emptyTexture = new cgp_texture_Texture(this, {});
      this._emptyTexture.initFromData(
        CgTexture.getDefaultTextureData("empty", size),
        size,
        size
      );
      return this._emptyTexture;
    }

    getErrorTexture() {
      // if (this._errorTexture) return this._errorTexture;
      const size = 256;
      this._errorTexture = new cgp_texture_Texture(this, {});
      this._errorTexture.initFromData(
        CgTexture.getDefaultTextureData("stripes", size, { r: 1, g: 0, b: 0 }),
        size,
        size
      );
      return this._errorTexture;
    }

    getDefaultTexture() {
      if (this._defaultTexture) return this._defaultTexture;
      const size = 256;
      this._defaultTexture = new cgp_texture_Texture(this, {});
      this._defaultTexture.initFromData(
        CgTexture.getDefaultTextureData("stripes", size),
        size,
        size
      );
      return this._defaultTexture;
    }
  } // CONCATENATED MODULE: ./src/core/cgp/cgp_pipeline.js

  class Pipeline {
    constructor(_cgp, name) {
      if (!_cgp) throw new Error("Pipeline constructed without cgp " + name);
      this._name = name;
      this._cgp = _cgp;
      this._isValid = true;
      this._log = new Logger("pipeline");

      this._pipeCfg = null;
      this._renderPipeline = null;

      this._bindGroups = [];

      this._shaderListeners = [];
      this.shaderNeedsPipelineUpdate = false;

      this._old = {};

      this.DEPTH_COMPARE_FUNCS_STRINGS = [
        "never",
        "less",
        "equal",
        "lessequal",
        "greater",
        "notequal",
        "greaterequal",
        "always",
      ];

      this._cgp.on("deviceChange", () => {
        this._renderPipeline = null;
      });
    }

    get isValid() {
      return this._isValid;
    }

    setName(name) {
      this._name = name;
    }

    setShaderListener(oldShader, newShader) {
      for (let i = 0; i < this._shaderListeners.length; i++)
        oldShader.off(this._shaderListeners[i]);

      this._shaderListeners.push(
        newShader.on("compiled", () => {
          // console.log("pipe update shader compileeeeeee");
          // this.needsRebuildReason = "shader changed";
          this.shaderNeedsPipelineUpdate = "shader compiled";
        })
      );
    }

    getInfo() {
      // console.log(this.bindingGroupLayoutEntries);

      const arr = [
        "name: " + this._name,
        "bindgroups: " + this._bindGroups.length,
      ];

      if (this.bindingGroupLayoutEntries)
        arr.push("layouts: " + this.bindingGroupLayoutEntries.length);

      // if (this.bindingGroupLayoutEntries)
      //     for (let i = 0; i < this.bindingGroupLayoutEntries.length; i++)
      //     {
      //         // const lines = JSON.stringify(this.bindingGroupLayoutEntries, 4, true).split(",");
      //         arr.push(...lines);
      //     }

      return arr;
    }

    setPipeline(shader, mesh) {
      if (!mesh || !shader) {
        console.log("pipeline unknown shader/mesh");
        return;
      }

      if (this._cgp.frameStore.branchProfiler)
        this._cgp.frameStore.branchStack.push("setPipeline", this.getInfo());

      let needsRebuildReason = "";
      if (!this._renderPipeline) needsRebuildReason = "no renderpipeline";
      if (!this._pipeCfg) needsRebuildReason = "no pipecfg";
      if (this._old.mesh != mesh) needsRebuildReason = "no mesh";
      if (this._old.shader != shader) {
        this.setShaderListener(this._old.shader, shader);
        needsRebuildReason = "shader changed";
      }

      if (shader.needsPipelineUpdate) {
        needsRebuildReason = "mesh needs update: " + shader.needsPipelineUpdate;
        shader.needsPipelineUpdate = false;
      }
      if (mesh.needsPipelineUpdate) needsRebuildReason = "mesh needs update";
      if (this.shaderNeedsPipelineUpdate)
        needsRebuildReason =
          "shader was recompiled: " + this.shaderNeedsPipelineUpdate;

      if (this._pipeCfg) {
        if (
          this._pipeCfg.depthStencil.depthWriteEnabled !=
          this._cgp.stateDepthWrite()
        ) {
          needsRebuildReason = "depth changed";
          this._pipeCfg.depthStencil.depthWriteEnabled =
            this._cgp.stateDepthWrite();
        }

        if (this._pipeCfg.fragment.targets[0].blend != this._cgp.stateBlend()) {
          needsRebuildReason = "blend changed";
          this._pipeCfg.fragment.targets[0].blend = this._cgp.stateBlend();
        }

        // "fragment": {
        //     "module": shader.gpuShaderModule,
        //     "entryPoint": "myFSMain",
        //     "targets": [
        //         {
        //             "format": this._cgp.presentationFormat,
        //             "blend":
        //         },

        if (this._cgp.stateDepthTest() === false) {
          if (this._pipeCfg.depthStencil.depthCompare != "never") {
            this._pipeCfg.depthStencil.depthCompare = "never";
            needsRebuildReason = "depth compare changed";
          }
        } else if (
          this._pipeCfg.depthStencil.depthCompare != this._cgp.stateDepthFunc()
        ) {
          needsRebuildReason = "depth state ";
          this._pipeCfg.depthStencil.depthCompare =
            this._cgp.stateDepththis._cgp.stateDepthFunc();
        }

        // console.log(this._pipeCfg.primitive.cullMode, this._cgp.stateCullFaceFacing());
        if (
          this._pipeCfg.primitive.cullMode != this._cgp.stateCullFaceFacing()
        ) {
          needsRebuildReason = "cullmode change";
          this._pipeCfg.primitive.cullMode = this._cgp.stateCullFaceFacing();
        }
      }

      this._cgp.currentPipeDebug = {
        cfg: this._pipeCfg,
        bindingGroupEntries: this.bindingGroupEntries,
        bindingGroupLayoutEntries: this.bindingGroupLayoutEntries,
      };

      if (needsRebuildReason != "") {
        console.log("rebuild pipe", needsRebuildReason);
        this._cgp.pushErrorScope("createPipeline", { logger: this._log });

        this._bindGroups = [];

        this._pipeCfg = this.getPipelineObject(shader, mesh);
        this._old.device = this._cgp.device;
        this._old.shader = shader;
        this._old.mesh = mesh;
        this._renderPipeline = this._cgp.device.createRenderPipeline(
          this._pipeCfg
        );

        this._cgp.popErrorScope();
      }

      if (this._renderPipeline && this._isValid) {
        this._cgp.pushErrorScope("setpipeline", { logger: this._log });

        this._cgp.passEncoder.setPipeline(this._renderPipeline);

        if (this._cgp.frameStore.branchProfiler)
          this._cgp.frameStore.branchStack.push("updateUniforms");

        shader.incBindingCounter();

        if (!this._bindGroups[shader.bindingCounter]) {
          const bindingGroupEntries = [];

          for (let i = 0; i < shader.bindingsVert.length; i++) {
            if (shader.bindingsVert[i].getSizeBytes() > 0) {
              bindingGroupEntries.push(
                shader.bindingsVert[i].getBindingGroupEntry(
                  this._cgp.device,
                  shader.bindingCounter
                )
              );
            } else console.log("shader defaultBindingVert size 0");
          }
          for (let i = 0; i < shader.bindingsFrag.length; i++) {
            if (shader.bindingsFrag[i].getSizeBytes() > 0) {
              bindingGroupEntries.push(
                shader.bindingsFrag[i].getBindingGroupEntry(
                  this._cgp.device,
                  shader.bindingCounter
                )
              );
            } else console.log("shader defaultBindingFrag size 0");
          }

          const bg = {
            label: "label2",
            layout: this.bindGroupLayout,
            entries: bindingGroupEntries,
          };

          this._bindGroups[shader.bindingCounter] =
            this._cgp.device.createBindGroup(bg);
        }

        this._bindUniforms(shader, shader.bindingCounter);

        if (this._bindGroups[shader.bindingCounter])
          this._cgp.passEncoder.setBindGroup(
            0,
            this._bindGroups[shader.bindingCounter]
          );

        // shader.bindingCounter++;

        if (this._cgp.frameStore.branchProfiler)
          this._cgp.frameStore.branchStack.pop();

        this._cgp.popErrorScope();
      }
      if (this._cgp.frameStore.branchProfiler)
        this._cgp.frameStore.branchStack.pop();

      this.shaderNeedsPipelineUpdate = false;
    }

    getPipelineObject(shader, mesh) {
      this.bindingGroupLayoutEntries = [];

      for (let i = 0; i < shader.bindingsVert.length; i++) {
        if (shader.bindingsVert[i].getSizeBytes() > 0) {
          this.bindingGroupLayoutEntries.push(
            shader.bindingsVert[i].getBindingGroupLayoutEntry()
          );
        } else console.log("shader defaultBindingVert size 0");
      }

      for (let i = 0; i < shader.bindingsFrag.length; i++) {
        if (shader.bindingsFrag[i].getSizeBytes() > 0) {
          this.bindingGroupLayoutEntries.push(
            shader.bindingsFrag[i].getBindingGroupLayoutEntry()
          );
        } else console.log("shader defaultBindingFrag size 0");
      }
      // //////////

      this.bindGroupLayout = this._cgp.device.createBindGroupLayout({
        label: "bg layout " + this._name,
        entries: this.bindingGroupLayoutEntries,
      });

      const pipelineLayout = this._cgp.device.createPipelineLayout({
        label: "pipe layout " + this._name,
        bindGroupLayouts: [this.bindGroupLayout],
      });

      let buffers = [
        // position
        {
          arrayStride: 3 * 4, // 3 floats, 4 bytes each
          attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }],
        },
        // texcoords
        {
          arrayStride: 2 * 4, // 2 floats, 4 bytes each
          attributes: [{ shaderLocation: 2, offset: 0, format: "float32x2" }],
        },
        // normals
        {
          arrayStride: 3 * 4, // 3 floats, 4 bytes each
          attributes: [{ shaderLocation: 1, offset: 0, format: "float32x3" }],
        },
      ];

      const pipeCfg = {
        // "layout": "auto",
        label: this._name,
        layout: pipelineLayout,
        vertex: {
          module: shader.gpuShaderModule,
          entryPoint: "myVSMain",
          buffers: buffers,
        },
        fragment: {
          module: shader.gpuShaderModule,
          entryPoint: "myFSMain",
          targets: [
            {
              format: this._cgp.presentationFormat,
              blend: this._cgp.stateBlend(),
            },
          ],
        },
        primitive: {
          topology: "triangle-list",
          cullMode: this._cgp.stateCullFaceFacing(), // back/none/front

          // "point-list",
          // "line-list",
          // "line-strip",
          // "triangle-list",
          // "triangle-strip"
        },
        depthStencil: {
          depthWriteEnabled: this._cgp.stateDepthTest(),
          depthCompare: this._cgp.stateDepthFunc(),
          format: "depth24plus",
        },
      };

      return pipeCfg;
    }

    _bindUniforms(shader, inst) {
      // this._cgp.pushErrorScope("pipeline bind uniforms", { "logger": this._log });

      shader.bind();

      if (this._cgp.frameStore.branchProfiler)
        this._cgp.frameStore.branchStack.push("bind uniforms vert", [
          "num:" + shader.bindingsVert.length,
        ]);
      for (let i = 0; i < shader.bindingsVert.length; i++)
        shader.bindingsVert[i].update(this._cgp, inst);
      if (this._cgp.frameStore.branchProfiler)
        this._cgp.frameStore.branchStack.pop();

      if (this._cgp.frameStore.branchProfiler)
        this._cgp.frameStore.branchStack.push("bind uniforms frag", [
          "num:" + shader.bindingsFrag.length,
        ]);
      for (let i = 0; i < shader.bindingsFrag.length; i++)
        shader.bindingsFrag[i].update(this._cgp, inst);
      if (this._cgp.frameStore.branchProfiler)
        this._cgp.frameStore.branchStack.pop();

      // shader.defaultBindingVert.update(this._cgp);

      // this._cgp.popErrorScope((e) =>
      // {
      //     this._isValid = false;
      // });
    }
  } // CONCATENATED MODULE: ./src/core/cgp/cgp_mesh.js

  class cgp_mesh_Mesh {
    constructor(_cgp, __geom) {
      this._log = new Logger("cgl_mesh");
      this._cgp = _cgp;
      this._geom = null;
      this.numIndex = 0;
      this.instances = 1;

      this._pipe = new Pipeline(this._cgp, "new mesh");
      this._numNonIndexed = 0;
      this._positionBuffer = null;
      this._bufVerticesIndizes = null;
      this._attributes = [];
      this._needsPipelineUpdate = false;

      if (__geom) this.setGeom(__geom);
    }

    _createBuffer(device, data, usage) {
      let bo = {
        size: data.byteLength,
        usage: usage,
        mappedAtCreation: true,
      };
      // ifbo.stepMode = "instance";
      const buffer = device.createBuffer(bo);
      const dst = new data.constructor(buffer.getMappedRange());
      dst.set(data);
      buffer.unmap();
      return buffer;
    }

    /**
     * @function setGeom
     * @memberof Mesh
     * @instance
     * @description set geometry for mesh
     * @param {Geometry} geom geometry
     * @param {boolean} removeRef
     */
    setGeom(geom, removeRef) {
      this._needsPipelineUpdate = true;
      this._geom = geom;
      this._disposeAttributes();

      this._positionBuffer = this._createBuffer(
        this._cgp.device,
        new Float32Array(geom.vertices),
        GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
      );

      let vi = geom.verticesIndices;
      if (!geom.isIndexed())
        vi = Array.from(Array(geom.vertices.length / 3).keys());
      this._numIndices = vi.length;
      this._indicesBuffer = this._createBuffer(
        this._cgp.device,
        new Uint32Array(vi),
        GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
      );

      if (geom.texCoords && geom.texCoords.length)
        this.setAttribute("texCoords", geom.texCoords, 2);
      if (geom.vertexNormals && geom.vertexNormals.length)
        this.setAttribute("normals", geom.vertexNormals, 3);

      this.setAttribute("normals", geom.vertexNormals, 3);
    }

    _disposeAttributes() {
      this._needsPipelineUpdate = true;
      for (let i = 0; i < this._attributes.length; i++) {
        this._attributes[i].buffer.destroy();
      }
      this._attributes.length = 0;
    }

    dispose() {
      this._disposeAttributes();
    }

    /**
     * @function setAttribute
     * @description update attribute
     * @memberof Mesh
     * @instance
     * @param {String} name attribute name
     * @param {Array} array data
     * @param {Number} itemSize
     * @param {Object} options
     */
    setAttribute(name, array, itemSize, options = {}) {
      if (!array) {
        this._log.error("mesh addAttribute - no array given! " + name);
        throw new Error();
      }

      let instanced = false;
      if (options.instanced) instanced = options.instanced;

      const buffer = this._createBuffer(
        this._cgp.device,
        new Float32Array(array),
        GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
      );

      const attr = {
        buffer: buffer,
        name: name,
        instanced: instanced,
      };
      this._attributes.push(attr);

      return attr;
    }

    render() {
      if (!this._positionBuffer) return;
      if (this.instances <= 0) return;

      const shader = this._cgp.getShader();
      if (shader) shader.bind();

      if (!this._cgp.getShader() || !this._cgp.getShader().isValid) {
        // this.status = "shader invalid";
        return;
      }

      if (this._cgp.frameStore.branchProfiler)
        this._cgp.frameStore.branchStack.push("mesh", [
          "geom " + this._geom.name,
          "shader " + this._cgp.getShader().getName(),
        ]);

      this._pipe.setName(
        "mesh " + this._geom.name + " " + this._cgp.getShader().getName()
      );
      this._pipe.setPipeline(this._cgp.getShader(), this);

      if (this._pipe.isValid) {
        this._cgp.passEncoder.setVertexBuffer(0, this._positionBuffer);
        for (let i = 0; i < this._attributes.length; i++) {
          this._cgp.passEncoder.setVertexBuffer(
            i + 1,
            this._attributes[i].buffer
          );
        }

        this._cgp.passEncoder.setIndexBuffer(this._indicesBuffer, "uint32");

        if (this._numNonIndexed)
          this._cgp.passEncoder.draw(this._numIndices, this.instances);
        else
          this._cgp.passEncoder.drawIndexed(this._numIndices, this.instances);
      }

      if (this._cgp.frameStore.branchProfiler)
        this._cgp.frameStore.branchStack.pop();

      // if (shader)shader.unbind();
    }
  } // CONCATENATED MODULE: ./src/core/cgp/index.js

  const cgp_CGP = {
    Context: WebGpuContext,
    Shader: cgp_shader_Shader,
    Mesh: cgp_mesh_Mesh,
    Pipeline: Pipeline,
    Texture: cgp_texture_Texture,
    Binding: Binding,
    Uniform: cgp_uniform_Uniform,
    MESHES: MESHES,
    GPUBuffer: GPUBuffer,
  };

  window.CABLES = window.CABLES || {};
  window.CABLES.CGP = cgp_CGP;
  window.CGP = cgp_CGP; // CONCATENATED MODULE: ./src/core/cgl/cgl_framebuffer.js

  // todo: convert to prototyped...

  /**
   * a framebuffer
   * @constructor
   * @class
   * @constructs Framebuffer
   * @param {Context} _cgl cgl
   * @param {Number} _w width
   * @param {Number} _h height
   * @param {Object} options
   */
  const Framebuffer = function (_cgl, _w, _h, options) {
    const cgl = _cgl;
    this._log = new Logger("Framebuffer");
    this.valid = true;

    let depthTextureExt = cgl.gl.DEPTH_TEXTURE;
    if (!depthTextureExt)
      depthTextureExt = cgl.enableExtension("WEBGL_depth_texture");
    if (!depthTextureExt)
      depthTextureExt = cgl.enableExtension("WEBKIT_WEBGL_depth_texture");
    if (!depthTextureExt)
      depthTextureExt = cgl.enableExtension("MOZ_WEBGL_depth_texture");

    if (!depthTextureExt) {
      this._log.error("NO_DEPTH_TEXTURE", "no depth texture support");
      return;
    }

    let width = _w || 512;
    let height = _h || 512;

    options = options || {
      isFloatingPointTexture: false,
    };

    if (!options.hasOwnProperty("clear")) options.clear = true;
    if (!options.hasOwnProperty("filter"))
      options.filter = Texture.FILTER_LINEAR;

    const texture = new Texture(cgl, {
      isFloatingPointTexture: options.isFloatingPointTexture,
      filter: options.filter,
      wrap: options.wrap || Texture.CLAMP_TO_EDGE,
    });

    let textureDepth = null;
    if (depthTextureExt) {
      textureDepth = new Texture(cgl, {
        isDepthTexture: true,
      });
    }
    this._options = options;

    const frameBuf = cgl.gl.createFramebuffer();
    const depthBuffer = cgl.gl.createRenderbuffer();

    this.getWidth = function () {
      return width;
    };
    this.getHeight = function () {
      return height;
    };

    /**
     * get native gl framebuffer
     * @function getGlFrameBuffer
     * @memberof Framebuffer
     * @returns {Object} framebuffer
     */
    this.getGlFrameBuffer = function () {
      return frameBuf;
    };

    /**
     * get depth renderbuffer
     * @function getDepthRenderBuffer
     * @memberof Framebuffer
     * @returns {Object} renderbuffer
     */
    this.getDepthRenderBuffer = function () {
      return depthBuffer;
    };

    /**
     * get color texture
     * @function getTextureColor
     * @memberof Framebuffer
     * @returns {Texture} rgba texture
     */
    this.getTextureColor = function () {
      return texture;
    };

    /**
     * get depth texture
     * @function getTextureDepth
     * @memberof Framebuffer
     * @returns {Texture} depth texture
     */
    this.getTextureDepth = function () {
      return textureDepth;
    };

    this.setFilter = function (f) {
      texture.filter = f;
      texture.setSize(width, height);
    };

    this.setSize = function (w, h) {
      if (w < 2) w = 2;
      if (h < 2) h = 2;

      width = Math.ceil(w);
      height = Math.ceil(h);

      cgl.profileData.profileFrameBuffercreate++;

      cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, frameBuf);
      cgl.gl.bindRenderbuffer(cgl.gl.RENDERBUFFER, depthBuffer);

      texture.setSize(width, height);
      if (textureDepth) textureDepth.setSize(width, height);

      // if(depthTextureExt) cgl.gl.renderbufferStorage(cgl.gl.RENDERBUFFER, cgl.gl.DEPTH_COMPONENT16, width,height);
      if (depthTextureExt)
        cgl.gl.renderbufferStorage(
          cgl.gl.RENDERBUFFER,
          cgl.gl.DEPTH_COMPONENT16,
          width,
          height
        );

      cgl.gl.framebufferTexture2D(
        cgl.gl.FRAMEBUFFER,
        cgl.gl.COLOR_ATTACHMENT0,
        cgl.gl.TEXTURE_2D,
        texture.tex,
        0
      );

      if (depthTextureExt) {
        cgl.gl.framebufferRenderbuffer(
          cgl.gl.FRAMEBUFFER,
          cgl.gl.DEPTH_ATTACHMENT,
          cgl.gl.RENDERBUFFER,
          depthBuffer
        );
        cgl.gl.framebufferTexture2D(
          cgl.gl.FRAMEBUFFER,
          cgl.gl.DEPTH_ATTACHMENT, // safari needs DEPTH_ATTACHMENT NOT DEPTH_ATTACHMENT16
          // cgl.gl.DEPTH_COMPONENT16,
          cgl.gl.TEXTURE_2D,
          textureDepth.tex,
          0
        );
      }

      if (!cgl.gl.isFramebuffer(frameBuf))
        throw new Error("Invalid framebuffer");
      const status = cgl.gl.checkFramebufferStatus(cgl.gl.FRAMEBUFFER);

      switch (status) {
        case cgl.gl.FRAMEBUFFER_COMPLETE:
          break;
        case cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          this._log.warn(
            "FRAMEBUFFER_INCOMPLETE_ATTACHMENT...",
            width,
            height,
            texture.tex,
            depthBuffer
          );
          this.valid = false;
          throw new Error(
            "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT"
          );
        case cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          this._log.warn("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
          this.valid = false;
          throw new Error(
            "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"
          );
        case cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          this._log.warn("FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
          this.valid = false;
          throw new Error(
            "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS"
          );
        case cgl.gl.FRAMEBUFFER_UNSUPPORTED:
          this._log.warn("FRAMEBUFFER_UNSUPPORTED");
          this.valid = false;
          this._log.warn(width, height, options);

          throw new Error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
        case 0x8cdb:
          this._log.warn(
            "Incomplete: FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER from ext. Or Safari/iOS undefined behaviour."
          );
          this.valid = false;
          break;
        default:
          this._log.warn("incomplete framebuffer", status);
          this.valid = false;
          throw new Error("Incomplete framebuffer: " + status);
      }

      cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, null);
      cgl.gl.bindRenderbuffer(cgl.gl.RENDERBUFFER, null);
      cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, null);
    };

    this.renderStart = function () {
      cgl.pushModelMatrix();
      cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, frameBuf);
      cgl.pushGlFrameBuffer(frameBuf);
      cgl.pushFrameBuffer(this);

      cgl.pushPMatrix();
      cgl.gl.viewport(0, 0, width, height);

      if (this._options.clear) {
        cgl.gl.clearColor(0, 0, 0, 0);
        cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
      }
    };

    this.renderEnd = function () {
      cgl.popPMatrix();
      cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, cgl.popGlFrameBuffer());
      cgl.popFrameBuffer();

      cgl.popModelMatrix();
      cgl.resetViewPort();
    };

    this.delete = function () {
      texture.delete();
      this.valid = false;
      if (textureDepth) textureDepth.delete();
      cgl.gl.deleteRenderbuffer(depthBuffer);
      cgl.gl.deleteFramebuffer(frameBuf);
    };

    this.dispose = this.delete;

    this.setSize(width, height);
  }; // CONCATENATED MODULE: ./src/core/cgl/cgl_framebuffer2.js

  // * see framebuffer1

  const Framebuffer2 = function (cgl, w, h, options) {
    this._log = new Logger("cgl_framebuffer2");
    if (cgl.glVersion == 1)
      return this._log.error("framebuffer2 used on webgl1");
    this.Framebuffer2DrawTargetsDefault = null;
    this.Framebuffer2BlittingFramebuffer = null;
    this.Framebuffer2FinalFramebuffer = null;
    this._cgl = cgl;

    this._cgl.printError("before framebuffer2 constructor");

    this._width = 0;
    this._height = 0;
    this.valid = true;

    this._depthRenderbuffer = null;
    this._frameBuffer = null;
    this._textureFrameBuffer = null;
    this._colorRenderbuffers = [];
    this._drawTargetArray = [];
    this._disposed = false;

    if (!this.Framebuffer2BlittingFramebuffer)
      this.Framebuffer2BlittingFramebuffer = cgl.gl.createFramebuffer();
    if (!this.Framebuffer2FinalFramebuffer)
      this.Framebuffer2FinalFramebuffer = cgl.gl.createFramebuffer();

    if (!this.Framebuffer2DrawTargetsDefault)
      this.Framebuffer2DrawTargetsDefault = [cgl.gl.COLOR_ATTACHMENT0];

    this._options = options || {
      isFloatingPointTexture: false,
    };

    // this._cgl.printError("fb2 before");

    this.name = this._options.name || "unknown";

    this._cgl.profileData.addHeavyEvent("framebuffer create", this.name);

    if (!this._options.hasOwnProperty("numRenderBuffers"))
      this._options.numRenderBuffers = 1;
    if (!this._options.hasOwnProperty("depth")) this._options.depth = true;
    if (!this._options.hasOwnProperty("clear")) this._options.clear = true;
    if (!this._options.hasOwnProperty("multisampling")) {
      this._options.multisampling = false;
      this._options.multisamplingSamples = 0;
    }

    if (this._options.multisamplingSamples) {
      if (this._cgl.glSlowRenderer) this._options.multisamplingSamples = 0;
      if (!this._cgl.gl.MAX_SAMPLES) this._options.multisamplingSamples = 0;
      else
        this._options.multisamplingSamples = Math.min(
          this._cgl.maxSamples,
          this._options.multisamplingSamples
        );
    }

    if (!this._options.hasOwnProperty("filter"))
      this._options.filter = Texture.FILTER_LINEAR;
    if (!this._options.hasOwnProperty("wrap"))
      this._options.wrap = Texture.WRAP_REPEAT;

    this._numRenderBuffers = this._options.numRenderBuffers;
    this._colorTextures = [];

    this.clearColors = [];
    for (let i = 0; i < this._numRenderBuffers; i++)
      this.clearColors.push([0, 0, 0, 1]);

    if (!options.pixelFormat) {
      if (options.isFloatingPointTexture)
        this._options.pixelFormat = Texture.PFORMATSTR_RGBA32F;
      else this._options.pixelFormat = Texture.PFORMATSTR_RGBA8UB;
    }

    for (let i = 0; i < this._numRenderBuffers; i++) {
      this._colorTextures[i] = new Texture(cgl, {
        name: "fb2 " + this.name + " " + i,
        isFloatingPointTexture: this._options.isFloatingPointTexture,
        anisotropic: this._options.anisotropic || 0,
        pixelFormat: this._options.pixelFormat,
        filter: this._options.filter,
        wrap: this._options.wrap,
      });
    }

    let fil = Texture.FILTER_NEAREST;
    if (this._options.shadowMap) fil = Texture.FILTER_LINEAR;

    const defaultTexSize = 512;

    if (this._options.depth) {
      this._textureDepth = new Texture(cgl, {
        name: "fb2 depth " + this.name,
        isDepthTexture: true,
        filter: fil,
        shadowMap: this._options.shadowMap || false,
        width: w || defaultTexSize,
        height: h || defaultTexSize,
      });
    }

    if (cgl.aborted) return;

    this.setSize(w || defaultTexSize, h || defaultTexSize);

    this._cgl.printError("framebuffer2 constructor");
  };

  Framebuffer2.prototype.getWidth = function () {
    return this._width;
  };
  Framebuffer2.prototype.getHeight = function () {
    return this._height;
  };

  Framebuffer2.prototype.getGlFrameBuffer = function () {
    return this._frameBuffer;
  };

  Framebuffer2.prototype.getDepthRenderBuffer = function () {
    return this._depthRenderbuffer;
  };

  Framebuffer2.prototype.getTextureColor = function () {
    return this._colorTextures[0];
  };

  Framebuffer2.prototype.getTextureColorNum = function (i) {
    return this._colorTextures[i];
  };

  Framebuffer2.prototype.getTextureDepth = function () {
    return this._textureDepth;
  };

  Framebuffer2.prototype.setFilter = function (f) {
    for (let i = 0; i < this._numRenderBuffers; i++) {
      this._colorTextures[i].filter = f;
      this._colorTextures[i].setSize(this._width, this._height);
    }
  };

  Framebuffer2.prototype.delete = Framebuffer2.prototype.dispose = function () {
    this._disposed = true;
    let i = 0;
    for (i = 0; i < this._numRenderBuffers; i++)
      this._colorTextures[i].delete();
    // this._texture.delete();
    if (this._textureDepth) this._textureDepth.delete();
    for (i = 0; i < this._numRenderBuffers; i++)
      this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);
    this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);
    this._cgl.gl.deleteFramebuffer(this._frameBuffer);
    this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);
  };

  Framebuffer2.prototype.setSize = function (w, h) {
    if (this._disposed)
      return this._log.warn("disposed framebuffer setsize...");
    this._cgl.profileData.addHeavyEvent("framebuffer resize", this.name);

    let i = 0;

    this._width = this._cgl.checkTextureSize(w);
    this._height = this._cgl.checkTextureSize(h);

    this._cgl.profileData.profileFrameBuffercreate++;

    if (this._frameBuffer) {
      for (i = 0; i < this._numRenderBuffers; i++)
        this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);
      // this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffer);
      this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);
      this._cgl.gl.deleteFramebuffer(this._frameBuffer);
      this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);
    }

    this._frameBuffer = this._cgl.gl.createFramebuffer();
    this._textureFrameBuffer = this._cgl.gl.createFramebuffer();

    const depth = this._options.depth;

    for (i = 0; i < this._numRenderBuffers; i++) {
      this._colorTextures[i].setSize(this._width, this._height);
    }

    for (i = 0; i < this._numRenderBuffers; i++) {
      const renderBuffer = this._cgl.gl.createRenderbuffer();

      // color renderbuffer

      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
      this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, renderBuffer);

      const info = Texture.setUpGlPixelFormat(
        this._cgl,
        this._options.pixelFormat
      );
      let internFormat = info.glInternalFormat;

      // if (this._options.isFloatingPointTexture)
      // {
      if (CGL.Texture.isPixelFormatHalfFloat(info.pixelFormat)) {
        if (!this._cgl.enableExtension("OES_texture_float_linear")) {
          this._options.filter = Texture.FILTER_NEAREST;
          this.setFilter(this._options.filter);
        }
      } else if (CGL.Texture.isPixelFormatFloat(info.pixelFormat)) {
        if (!this._cgl.enableExtension("OES_texture_float_linear")) {
          this._log.warn("no linear pixelformat,using nearest");
          this._options.filter = Texture.FILTER_NEAREST;
          this.setFilter(this._options.filter);
        }
      }
      // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F
      // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F
      // else if (info.pixelFormat == Texture.PFORMATSTR_RG16F)
      // {
      //     const extcb = this._cgl.enableExtension("EXT_color_buffer_float");

      //     if (!this._cgl.enableExtension("OES_texture_float_linear"))
      //     {
      //         console.log("no linear pixelformat,switching to nearest");
      //         this._options.filter = Texture.FILTER_NEAREST;
      //         this.setFilter(this._options.filter);
      //     }
      // }
      // }

      if (this._options.multisampling && this._options.multisamplingSamples) {
        this._cgl.gl.renderbufferStorageMultisample(
          this._cgl.gl.RENDERBUFFER,
          this._options.multisamplingSamples,
          internFormat,
          this._width,
          this._height
        );
      } else {
        this._cgl.gl.renderbufferStorage(
          this._cgl.gl.RENDERBUFFER,
          internFormat,
          this._width,
          this._height
        );
      }

      this._cgl.gl.framebufferRenderbuffer(
        this._cgl.gl.FRAMEBUFFER,
        this._cgl.gl.COLOR_ATTACHMENT0 + i,
        this._cgl.gl.RENDERBUFFER,
        renderBuffer
      );
      this._colorRenderbuffers[i] = renderBuffer;
    }

    // this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);
    this._cgl.gl.bindFramebuffer(
      this._cgl.gl.FRAMEBUFFER,
      this._textureFrameBuffer
    );

    for (i = 0; i < this._numRenderBuffers; i++) {
      this._cgl.gl.framebufferTexture2D(
        this._cgl.gl.FRAMEBUFFER,
        this._cgl.gl.COLOR_ATTACHMENT0 + i,
        this._cgl.gl.TEXTURE_2D,
        this._colorTextures[i].tex,
        0
      );
    }

    if (this._options.depth) {
      this._cgl.gl.framebufferTexture2D(
        this._cgl.gl.FRAMEBUFFER,
        this._cgl.gl.DEPTH_ATTACHMENT,
        this._cgl.gl.TEXTURE_2D,
        this._textureDepth.tex,
        0
      );
    }

    // depth renderbuffer

    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);

    let depthType = this._cgl.gl.DEPTH_COMPONENT32F;

    if (this._cgl.glSlowRenderer) depthType = this._cgl.gl.DEPTH_COMPONENT16;
    if (depth) {
      this._textureDepth.setSize(this._width, this._height);
      this._depthRenderbuffer = this._cgl.gl.createRenderbuffer();

      this._cgl.gl.bindRenderbuffer(
        this._cgl.gl.RENDERBUFFER,
        this._depthRenderbuffer
      );
      if (this._options.isFloatingPointTexture) {
        if (this._options.multisampling)
          this._cgl.gl.renderbufferStorageMultisample(
            this._cgl.gl.RENDERBUFFER,
            this._options.multisamplingSamples,
            depthType,
            this._width,
            this._height
          );
        else
          this._cgl.gl.renderbufferStorage(
            this._cgl.gl.RENDERBUFFER,
            depthType,
            this._width,
            this._height
          );
      } else if (this._options.multisampling) {
        this._cgl.gl.renderbufferStorageMultisample(
          this._cgl.gl.RENDERBUFFER,
          this._options.multisamplingSamples,
          depthType,
          this._width,
          this._height
        );
        // this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,depthType, this._width, this._height);
      } else {
        this._cgl.gl.renderbufferStorage(
          this._cgl.gl.RENDERBUFFER,
          depthType,
          this._width,
          this._height
        );
      }

      this._cgl.gl.framebufferRenderbuffer(
        this._cgl.gl.FRAMEBUFFER,
        this._cgl.gl.DEPTH_ATTACHMENT,
        this._cgl.gl.RENDERBUFFER,
        this._depthRenderbuffer
      );
    }

    // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
    // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer);

    this._drawTargetArray.length = 0;
    for (i = 0; i < this._numRenderBuffers; i++)
      this._drawTargetArray.push(this._cgl.gl.COLOR_ATTACHMENT0 + i);

    // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

    if (!this._cgl.gl.isFramebuffer(this._textureFrameBuffer))
      this._log.warn("invalid framebuffer"); // throw new Error("Invalid framebuffer");
    const status = this._cgl.gl.checkFramebufferStatus(
      this._cgl.gl.FRAMEBUFFER
    );

    if (status != this._cgl.gl.FRAMEBUFFER_COMPLETE) {
      this._log.error("framebuffer incomplete: " + this.name, this);
      this._log.log("options", this._options);
      this._log.log("options pixelformat", this._options.pixelFormat);

      switch (status) {
        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          this._log.warn("FRAMEBUFFER_INCOMPLETE_ATTACHMENT...", this);
          throw new Error(
            "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT"
          );
        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          this._log.warn("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
          throw new Error(
            "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"
          );
        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          this._log.warn("FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
          throw new Error(
            "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS"
          );
        case this._cgl.gl.FRAMEBUFFER_UNSUPPORTED:
          this._log.warn("FRAMEBUFFER_UNSUPPORTED");
          throw new Error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
        default:
          this.valid = false;
          this._log.error("incomplete framebuffer", status, this._frameBuffer);
          this._cgl.printError();

          this._frameBuffer = null;
          // debugger;
          throw new Error("Incomplete framebuffer: " + status);

        // throw("Incomplete framebuffer: " + status);
      }
    }

    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
    this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);

    // this._cgl.printError("fb setsize");
  };

  Framebuffer2.prototype.renderStart = function () {
    if (this._disposed)
      return this._log.warn("disposed framebuffer renderStart...");
    this._cgl.checkFrameStarted("fb2 renderstart");
    this._cgl.pushModelMatrix(); // needed ??

    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);
    this._cgl.pushGlFrameBuffer(this._frameBuffer);
    this._cgl.pushFrameBuffer(this);

    this._cgl.pushPMatrix();
    this._cgl.pushViewPort(0, 0, this._width, this._height);

    this._cgl.gl.drawBuffers(this._drawTargetArray);

    if (this._options.clear) {
      this._cgl.gl.clearColor(0, 0, 0, 0);
      this._cgl.gl.clear(
        this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT
      );
    }
  };

  Framebuffer2.prototype.clear = function () {
    if (this._numRenderBuffers <= 1) {
      this._cgl.gl.bindFramebuffer(
        this._cgl.gl.READ_FRAMEBUFFER,
        this._frameBuffer
      );
      this._cgl.gl.bindFramebuffer(
        this._cgl.gl.DRAW_FRAMEBUFFER,
        this._textureFrameBuffer
      );
    } else
      this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);

    this._cgl.gl.drawBuffers(this._drawTargetArray);

    for (let i = 0; i < this._numRenderBuffers; i++) {
      this._cgl.gl.framebufferTexture2D(
        this._cgl.gl.FRAMEBUFFER,
        this._cgl.gl.COLOR_ATTACHMENT0 + i,
        this._cgl.gl.TEXTURE_2D,
        this._colorTextures[i].tex,
        0
      );
      this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, this.clearColors[i]);
    }
    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);
  };

  Framebuffer2.prototype.renderEnd = function () {
    if (this._disposed)
      return this._log.warn("disposed framebuffer renderEnd...");
    this._cgl.popPMatrix();

    this._cgl.profileData.profileFramebuffer++;

    if (this._numRenderBuffers <= 1) {
      this._cgl.gl.bindFramebuffer(
        this._cgl.gl.READ_FRAMEBUFFER,
        this._frameBuffer
      );
      this._cgl.gl.bindFramebuffer(
        this._cgl.gl.DRAW_FRAMEBUFFER,
        this._textureFrameBuffer
      );

      this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
      this._cgl.gl.blitFramebuffer(
        0,
        0,
        this._width,
        this._height,
        0,
        0,
        this._width,
        this._height,
        this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT,
        this._cgl.gl.NEAREST
      );
    } else {
      this._cgl.gl.bindFramebuffer(
        this._cgl.gl.FRAMEBUFFER,
        this.Framebuffer2BlittingFramebuffer
      );
      this._cgl.gl.framebufferRenderbuffer(
        this._cgl.gl.FRAMEBUFFER,
        this._cgl.gl.DEPTH_ATTACHMENT,
        this._cgl.gl.RENDERBUFFER,
        this._depthRenderbuffer
      );

      this._cgl.gl.bindFramebuffer(
        this._cgl.gl.FRAMEBUFFER,
        this.Framebuffer2FinalFramebuffer
      );
      this._cgl.gl.framebufferTexture2D(
        this._cgl.gl.FRAMEBUFFER,
        this._cgl.gl.DEPTH_ATTACHMENT,
        this._cgl.gl.TEXTURE_2D,
        this._textureDepth.tex,
        0
      );

      for (let i = 0; i < this._numRenderBuffers; i++) {
        this._cgl.gl.bindFramebuffer(
          this._cgl.gl.FRAMEBUFFER,
          this.Framebuffer2BlittingFramebuffer
        );
        this._cgl.gl.framebufferRenderbuffer(
          this._cgl.gl.FRAMEBUFFER,
          this._cgl.gl.COLOR_ATTACHMENT0,
          this._cgl.gl.RENDERBUFFER,
          this._colorRenderbuffers[i]
        );

        this._cgl.gl.bindFramebuffer(
          this._cgl.gl.FRAMEBUFFER,
          this.Framebuffer2FinalFramebuffer
        );
        this._cgl.gl.framebufferTexture2D(
          this._cgl.gl.FRAMEBUFFER,
          this._cgl.gl.COLOR_ATTACHMENT0,
          this._cgl.gl.TEXTURE_2D,
          this._colorTextures[i].tex,
          0
        );

        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);

        this._cgl.gl.bindFramebuffer(
          this._cgl.gl.READ_FRAMEBUFFER,
          this.Framebuffer2BlittingFramebuffer
        );
        this._cgl.gl.bindFramebuffer(
          this._cgl.gl.DRAW_FRAMEBUFFER,
          this.Framebuffer2FinalFramebuffer
        );

        // this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, [0.0, 0.0, 0.0, 1.0]);

        let flags = this._cgl.gl.COLOR_BUFFER_BIT;
        if (i == 0) flags |= this._cgl.gl.DEPTH_BUFFER_BIT;

        this._cgl.gl.blitFramebuffer(
          0,
          0,
          this._width,
          this._height,
          0,
          0,
          this._width,
          this._height,
          flags,
          this._cgl.gl.NEAREST
        );
      }
    }

    this._cgl.gl.bindFramebuffer(
      this._cgl.gl.FRAMEBUFFER,
      this._cgl.popGlFrameBuffer()
    );
    this._cgl.popFrameBuffer();

    this._cgl.popModelMatrix();
    // this._cgl.resetViewPort();
    this._cgl.popViewPort();

    if (this._colorTextures[0].filter == Texture.FILTER_MIPMAP) {
      for (let i = 0; i < this._numRenderBuffers; i++) {
        this._cgl.gl.bindTexture(
          this._cgl.gl.TEXTURE_2D,
          this._colorTextures[i].tex
        );
        this._colorTextures[i].updateMipMap();
        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);
      }
    }
  }; // CONCATENATED MODULE: ./src/core/cgl/cgl_marker.js

  /// ///////

  const Marker = function (
    _cgl // deprecated...
  ) {
    this.draw = function (cgl, _size, depthTest) {};
  };

  const WirePoint = function (
    cgl // deprecated...
  ) {
    this.render = function (_cgl, _size) {};
  };

  const WireCube = function (
    cgl // deprecated...
  ) {
    this.render = function (_cgl, sizeX, sizeY, sizeZ) {};
  }; // CONCATENATED MODULE: ./src/core/cgl/cgl_unicolorshader.js

  class UniColorShader {
    constructor(_cgl) {
      this.shader = new CGL.Shader(_cgl, "markermaterial");

      const frag =
        "".endl() +
        "void main()".endl() +
        "{".endl() +
        "    outColor = vec4(color.rgb,1.0);".endl() +
        "}";

      const vert =
        "".endl() +
        "IN vec3 vPosition;".endl() +
        "UNI mat4 projMatrix;".endl() +
        "UNI mat4 mvMatrix;".endl() +
        "void main()".endl() +
        "{".endl() +
        "   gl_Position = projMatrix * mvMatrix * vec4(vPosition,1.0);".endl() +
        "}";

      this.shader.setSource(vert, frag);
      this.coloruni = this.shader.addUniformFrag(
        "4f",
        "color",
        [1, 0.777, 1, 1]
      );
    }

    setColor(r, g, b, a) {
      this.coloruni.set(r, g, b, a);
    }
  } // CONCATENATED MODULE: ./src/core/cgl/index.js

  const cgl_CGL = {
    Framebuffer: Framebuffer,
    Framebuffer2: Framebuffer2,
    Geometry: Geometry,
    BoundingBox: BoundingBox,
    Marker: Marker,
    WirePoint: WirePoint,
    WireCube: WireCube,
    MatrixStack: MatrixStack,
    Mesh: Mesh,
    MESH: MESH,
    ShaderLibMods: ShaderLibMods,
    Shader: Shader,
    Uniform: Uniform,
    MESHES: MESHES,
    Context: Context,
    Texture: Texture,
    TextureEffect: TextureEffect,
    isWindows: isWindows,
    getWheelSpeed: getWheelSpeed,
    getWheelDelta: getWheelDelta,
    onLoadingAssetsFinished: onLoadingAssetsFinished,
    ProfileData: ProfileData,
    UniColorShader: UniColorShader,
    ...constants_CONSTANTS.BLEND_MODES,
    ...constants_CONSTANTS.SHADER,
    ...constants_CONSTANTS.MATH,
    ...constants_CONSTANTS.BLEND_MODES,
  };

  window.CGL = cgl_CGL; // CONCATENATED MODULE: ./src/core/index.js

  window.CABLES = window.CABLES || {};

  CABLES.CGL = cgl_CGL;
  CABLES.CG = CG;
  CABLES.CGP = cgp_CGP;
  CABLES.EMBED = EMBED;
  CABLES.Link = Link;
  CABLES.Port = Port;
  CABLES.Op = Op;
  CABLES.Profiler = Profiler;
  CABLES.Patch = core_patch;
  CABLES.Timer = Timer;
  CABLES.WEBAUDIO = WEBAUDIO;
  CABLES.Variable = Variable;
  CABLES.LoadingStatus = LoadingStatus;
  CABLES.now = now;
  CABLES.internalNow = internalNow;

  CABLES = Object.assign(
    CABLES,
    utils_namespaceObject,
    anim_namespaceObject,
    CONSTANTS.PORT,
    CONSTANTS.PACO,
    CONSTANTS.ANIM,
    CONSTANTS.OP
  );

  /* harmony default export */ const core = CABLES;

  if (
    !(function () {
      return !this;
    })()
  )
    console.warn("not in strict mode: index core"); // eslint-disable-line

  CABLES = __webpack_exports__["default"];
  /******/
})();

var CABLES = CABLES || {};
CABLES.build = {
  timestamp: 1734525262407,
  created: "2024-12-18T12:34:22.407Z",
  git: {
    branch: "master",
    commit: "20b730583e0a440aa00951d2b66a7e8f3d7db458",
    date: "1734433453",
    message: "docs",
  },
};
(() => {
  "use strict";
  var t = {
      d: (n, a) => {
        for (var r in a)
          t.o(a, r) &&
            !t.o(n, r) &&
            Object.defineProperty(n, r, { enumerable: !0, get: a[r] });
      },
      o: (t, n) => Object.prototype.hasOwnProperty.call(t, n),
      r: (t) => {
        "undefined" != typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
          Object.defineProperty(t, "__esModule", { value: !0 });
      },
    },
    n = {};
  t.r(n),
    t.d(n, {
      ARRAY_TYPE: () => f,
      EPSILON: () => M,
      RANDOM: () => l,
      equals: () => d,
      setMatrixArrayType: () => v,
      toRadian: () => m,
    });
  var a = {};
  t.r(a),
    t.d(a, {
      LDU: () => j,
      add: () => z,
      adjoint: () => S,
      clone: () => y,
      copy: () => p,
      create: () => x,
      determinant: () => R,
      equals: () => Y,
      exactEquals: () => Q,
      frob: () => V,
      fromRotation: () => D,
      fromScaling: () => F,
      fromValues: () => w,
      identity: () => q,
      invert: () => P,
      mul: () => _,
      multiply: () => T,
      multiplyScalar: () => X,
      multiplyScalarAndAdd: () => Z,
      rotate: () => I,
      scale: () => E,
      set: () => g,
      str: () => L,
      sub: () => B,
      subtract: () => O,
      transpose: () => A,
    });
  var r = {};
  t.r(r),
    t.d(r, {
      add: () => it,
      clone: () => k,
      copy: () => U,
      create: () => N,
      determinant: () => J,
      equals: () => ft,
      exactEquals: () => Mt,
      frob: () => ot,
      fromRotation: () => at,
      fromScaling: () => rt,
      fromTranslation: () => ut,
      fromValues: () => C,
      identity: () => W,
      invert: () => H,
      mul: () => lt,
      multiply: () => K,
      multiplyScalar: () => ct,
      multiplyScalarAndAdd: () => st,
      rotate: () => $,
      scale: () => tt,
      set: () => G,
      str: () => et,
      sub: () => vt,
      subtract: () => ht,
      translate: () => nt,
    });
  var u = {};
  t.r(u),
    t.d(u, {
      add: () => Yt,
      adjoint: () => At,
      clone: () => dt,
      copy: () => xt,
      create: () => bt,
      determinant: () => Pt,
      equals: () => Nt,
      exactEquals: () => Bt,
      frob: () => Qt,
      fromMat2d: () => Lt,
      fromMat4: () => mt,
      fromQuat: () => Vt,
      fromRotation: () => Dt,
      fromScaling: () => Ft,
      fromTranslation: () => Et,
      fromValues: () => yt,
      identity: () => qt,
      invert: () => gt,
      mul: () => kt,
      multiply: () => St,
      multiplyScalar: () => Zt,
      multiplyScalarAndAdd: () => _t,
      normalFromMat4: () => jt,
      projection: () => zt,
      rotate: () => Tt,
      scale: () => It,
      set: () => pt,
      str: () => Ot,
      sub: () => Ut,
      subtract: () => Xt,
      translate: () => Rt,
      transpose: () => wt,
    });
  var e = {};
  t.r(e),
    t.d(e, {
      add: () => Ln,
      adjoint: () => nn,
      clone: () => Ct,
      copy: () => Gt,
      create: () => Wt,
      determinant: () => an,
      equals: () => Qn,
      exactEquals: () => On,
      frob: () => Fn,
      fromQuat: () => An,
      fromQuat2: () => xn,
      fromRotation: () => ln,
      fromRotationTranslation: () => dn,
      fromRotationTranslationScale: () => wn,
      fromRotationTranslationScaleOrigin: () => gn,
      fromScaling: () => fn,
      fromTranslation: () => Mn,
      fromValues: () => Ht,
      fromXRotation: () => vn,
      fromYRotation: () => bn,
      fromZRotation: () => mn,
      frustum: () => Pn,
      getRotation: () => qn,
      getScaling: () => pn,
      getTranslation: () => yn,
      identity: () => Kt,
      invert: () => tn,
      lookAt: () => In,
      mul: () => Yn,
      multiply: () => rn,
      multiplyScalar: () => jn,
      multiplyScalarAndAdd: () => zn,
      ortho: () => Tn,
      perspective: () => Sn,
      perspectiveFromFieldOfView: () => Rn,
      rotate: () => on,
      rotateX: () => hn,
      rotateY: () => cn,
      rotateZ: () => sn,
      scale: () => en,
      set: () => Jt,
      str: () => Dn,
      sub: () => Xn,
      subtract: () => Vn,
      targetTo: () => En,
      translate: () => un,
      transpose: () => $t,
    });
  var o = {};
  t.r(o),
    t.d(o, {
      add: () => Wn,
      angle: () => wa,
      bezier: () => va,
      ceil: () => Jn,
      clone: () => _n,
      copy: () => kn,
      create: () => Zn,
      cross: () => Ma,
      dist: () => Da,
      distance: () => ua,
      div: () => Ea,
      divide: () => Hn,
      dot: () => sa,
      equals: () => Sa,
      exactEquals: () => Pa,
      floor: () => Kn,
      forEach: () => ja,
      fromValues: () => Nn,
      hermite: () => la,
      inverse: () => ha,
      len: () => La,
      length: () => Bn,
      lerp: () => fa,
      max: () => ta,
      min: () => $n,
      mul: () => Ia,
      multiply: () => Gn,
      negate: () => ia,
      normalize: () => ca,
      random: () => ba,
      rotateX: () => ya,
      rotateY: () => pa,
      rotateZ: () => qa,
      round: () => na,
      scale: () => aa,
      scaleAndAdd: () => ra,
      set: () => Un,
      sqrDist: () => Fa,
      sqrLen: () => Va,
      squaredDistance: () => ea,
      squaredLength: () => oa,
      str: () => Aa,
      sub: () => Ta,
      subtract: () => Cn,
      transformMat3: () => da,
      transformMat4: () => ma,
      transformQuat: () => xa,
      zero: () => ga,
    });
  var i = {};
  t.r(i),
    t.d(i, {
      add: () => Za,
      ceil: () => ka,
      clone: () => Oa,
      copy: () => Ya,
      create: () => za,
      cross: () => or,
      dist: () => xr,
      distance: () => Ka,
      div: () => dr,
      divide: () => Na,
      dot: () => er,
      equals: () => vr,
      exactEquals: () => lr,
      floor: () => Ua,
      forEach: () => wr,
      fromValues: () => Qa,
      inverse: () => rr,
      len: () => pr,
      length: () => tr,
      lerp: () => ir,
      max: () => Ca,
      min: () => Wa,
      mul: () => mr,
      multiply: () => Ba,
      negate: () => ar,
      normalize: () => ur,
      random: () => hr,
      round: () => Ga,
      scale: () => Ha,
      scaleAndAdd: () => Ja,
      set: () => Xa,
      sqrDist: () => yr,
      sqrLen: () => qr,
      squaredDistance: () => $a,
      squaredLength: () => nr,
      str: () => fr,
      sub: () => br,
      subtract: () => _a,
      transformMat4: () => cr,
      transformQuat: () => sr,
      zero: () => Mr,
    });
  var h = {};
  t.r(h),
    t.d(h, {
      add: () => $r,
      calculateW: () => Fr,
      clone: () => Gr,
      conjugate: () => Yr,
      copy: () => Jr,
      create: () => gr,
      dot: () => au,
      equals: () => su,
      exactEquals: () => cu,
      exp: () => Lr,
      fromEuler: () => Zr,
      fromMat3: () => Xr,
      fromValues: () => Hr,
      getAngle: () => Rr,
      getAxisAngle: () => Sr,
      identity: () => Ar,
      invert: () => Qr,
      len: () => eu,
      length: () => uu,
      lerp: () => ru,
      ln: () => Vr,
      mul: () => tu,
      multiply: () => Tr,
      normalize: () => hu,
      pow: () => jr,
      random: () => Or,
      rotateX: () => Ir,
      rotateY: () => Er,
      rotateZ: () => Dr,
      rotationTo: () => Mu,
      scale: () => nu,
      set: () => Kr,
      setAxes: () => lu,
      setAxisAngle: () => Pr,
      slerp: () => zr,
      sqlerp: () => fu,
      sqrLen: () => iu,
      squaredLength: () => ou,
      str: () => _r,
    });
  var c = {};
  t.r(c),
    t.d(c, {
      add: () => Ou,
      clone: () => bu,
      conjugate: () => Nu,
      copy: () => wu,
      create: () => vu,
      dot: () => Zu,
      equals: () => Ku,
      exactEquals: () => Ju,
      fromMat4: () => qu,
      fromRotation: () => pu,
      fromRotationTranslation: () => xu,
      fromRotationTranslationValues: () => du,
      fromTranslation: () => yu,
      fromValues: () => mu,
      getDual: () => Su,
      getReal: () => Pu,
      getTranslation: () => Iu,
      identity: () => gu,
      invert: () => Bu,
      len: () => Uu,
      length: () => ku,
      lerp: () => _u,
      mul: () => Yu,
      multiply: () => Qu,
      normalize: () => Gu,
      rotateAroundAxis: () => zu,
      rotateByQuatAppend: () => Vu,
      rotateByQuatPrepend: () => ju,
      rotateX: () => Du,
      rotateY: () => Fu,
      rotateZ: () => Lu,
      scale: () => Xu,
      set: () => Au,
      setDual: () => Tu,
      setReal: () => Ru,
      sqrLen: () => Cu,
      squaredLength: () => Wu,
      str: () => Hu,
      translate: () => Eu,
    });
  var s = {};
  t.r(s),
    t.d(s, {
      add: () => ue,
      angle: () => De,
      ceil: () => he,
      clone: () => te,
      copy: () => ae,
      create: () => $u,
      cross: () => ge,
      dist: () => Xe,
      distance: () => be,
      div: () => Ye,
      divide: () => ie,
      dot: () => we,
      equals: () => je,
      exactEquals: () => Ve,
      floor: () => ce,
      forEach: () => Be,
      fromValues: () => ne,
      inverse: () => pe,
      len: () => ze,
      length: () => de,
      lerp: () => Ae,
      max: () => Me,
      min: () => se,
      mul: () => Qe,
      multiply: () => oe,
      negate: () => ye,
      normalize: () => qe,
      random: () => Pe,
      rotate: () => Ee,
      round: () => fe,
      scale: () => le,
      scaleAndAdd: () => ve,
      set: () => re,
      sqrDist: () => Ze,
      sqrLen: () => _e,
      squaredDistance: () => me,
      squaredLength: () => xe,
      str: () => Le,
      sub: () => Oe,
      subtract: () => ee,
      transformMat2: () => Se,
      transformMat2d: () => Re,
      transformMat3: () => Te,
      transformMat4: () => Ie,
      zero: () => Fe,
    });
  var M = 1e-6,
    f = "undefined" != typeof Float32Array ? Float32Array : Array,
    l = Math.random;
  function v(t) {
    f = t;
  }
  var b = Math.PI / 180;
  function m(t) {
    return t * b;
  }
  function d(t, n) {
    return Math.abs(t - n) <= M * Math.max(1, Math.abs(t), Math.abs(n));
  }
  function x() {
    var t = new f(4);
    return (
      f != Float32Array && ((t[1] = 0), (t[2] = 0)), (t[0] = 1), (t[3] = 1), t
    );
  }
  function y(t) {
    var n = new f(4);
    return (n[0] = t[0]), (n[1] = t[1]), (n[2] = t[2]), (n[3] = t[3]), n;
  }
  function p(t, n) {
    return (t[0] = n[0]), (t[1] = n[1]), (t[2] = n[2]), (t[3] = n[3]), t;
  }
  function q(t) {
    return (t[0] = 1), (t[1] = 0), (t[2] = 0), (t[3] = 1), t;
  }
  function w(t, n, a, r) {
    var u = new f(4);
    return (u[0] = t), (u[1] = n), (u[2] = a), (u[3] = r), u;
  }
  function g(t, n, a, r, u) {
    return (t[0] = n), (t[1] = a), (t[2] = r), (t[3] = u), t;
  }
  function A(t, n) {
    if (t === n) {
      var a = n[1];
      (t[1] = n[2]), (t[2] = a);
    } else (t[0] = n[0]), (t[1] = n[2]), (t[2] = n[1]), (t[3] = n[3]);
    return t;
  }
  function P(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[3],
      o = a * e - u * r;
    return o
      ? ((o = 1 / o),
        (t[0] = e * o),
        (t[1] = -r * o),
        (t[2] = -u * o),
        (t[3] = a * o),
        t)
      : null;
  }
  function S(t, n) {
    var a = n[0];
    return (t[0] = n[3]), (t[1] = -n[1]), (t[2] = -n[2]), (t[3] = a), t;
  }
  function R(t) {
    return t[0] * t[3] - t[2] * t[1];
  }
  function T(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = a[0],
      h = a[1],
      c = a[2],
      s = a[3];
    return (
      (t[0] = r * i + e * h),
      (t[1] = u * i + o * h),
      (t[2] = r * c + e * s),
      (t[3] = u * c + o * s),
      t
    );
  }
  function I(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = Math.sin(a),
      h = Math.cos(a);
    return (
      (t[0] = r * h + e * i),
      (t[1] = u * h + o * i),
      (t[2] = r * -i + e * h),
      (t[3] = u * -i + o * h),
      t
    );
  }
  function E(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = a[0],
      h = a[1];
    return (t[0] = r * i), (t[1] = u * i), (t[2] = e * h), (t[3] = o * h), t;
  }
  function D(t, n) {
    var a = Math.sin(n),
      r = Math.cos(n);
    return (t[0] = r), (t[1] = a), (t[2] = -a), (t[3] = r), t;
  }
  function F(t, n) {
    return (t[0] = n[0]), (t[1] = 0), (t[2] = 0), (t[3] = n[1]), t;
  }
  function L(t) {
    return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
  }
  function V(t) {
    return Math.hypot(t[0], t[1], t[2], t[3]);
  }
  function j(t, n, a, r) {
    return (
      (t[2] = r[2] / r[0]),
      (a[0] = r[0]),
      (a[1] = r[1]),
      (a[3] = r[3] - t[2] * a[1]),
      [t, n, a]
    );
  }
  function z(t, n, a) {
    return (
      (t[0] = n[0] + a[0]),
      (t[1] = n[1] + a[1]),
      (t[2] = n[2] + a[2]),
      (t[3] = n[3] + a[3]),
      t
    );
  }
  function O(t, n, a) {
    return (
      (t[0] = n[0] - a[0]),
      (t[1] = n[1] - a[1]),
      (t[2] = n[2] - a[2]),
      (t[3] = n[3] - a[3]),
      t
    );
  }
  function Q(t, n) {
    return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3];
  }
  function Y(t, n) {
    var a = t[0],
      r = t[1],
      u = t[2],
      e = t[3],
      o = n[0],
      i = n[1],
      h = n[2],
      c = n[3];
    return (
      Math.abs(a - o) <= M * Math.max(1, Math.abs(a), Math.abs(o)) &&
      Math.abs(r - i) <= M * Math.max(1, Math.abs(r), Math.abs(i)) &&
      Math.abs(u - h) <= M * Math.max(1, Math.abs(u), Math.abs(h)) &&
      Math.abs(e - c) <= M * Math.max(1, Math.abs(e), Math.abs(c))
    );
  }
  function X(t, n, a) {
    return (
      (t[0] = n[0] * a),
      (t[1] = n[1] * a),
      (t[2] = n[2] * a),
      (t[3] = n[3] * a),
      t
    );
  }
  function Z(t, n, a, r) {
    return (
      (t[0] = n[0] + a[0] * r),
      (t[1] = n[1] + a[1] * r),
      (t[2] = n[2] + a[2] * r),
      (t[3] = n[3] + a[3] * r),
      t
    );
  }
  Math.hypot ||
    (Math.hypot = function () {
      for (var t = 0, n = arguments.length; n--; )
        t += arguments[n] * arguments[n];
      return Math.sqrt(t);
    });
  var _ = T,
    B = O;
  function N() {
    var t = new f(6);
    return (
      f != Float32Array && ((t[1] = 0), (t[2] = 0), (t[4] = 0), (t[5] = 0)),
      (t[0] = 1),
      (t[3] = 1),
      t
    );
  }
  function k(t) {
    var n = new f(6);
    return (
      (n[0] = t[0]),
      (n[1] = t[1]),
      (n[2] = t[2]),
      (n[3] = t[3]),
      (n[4] = t[4]),
      (n[5] = t[5]),
      n
    );
  }
  function U(t, n) {
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      t
    );
  }
  function W(t) {
    return (
      (t[0] = 1), (t[1] = 0), (t[2] = 0), (t[3] = 1), (t[4] = 0), (t[5] = 0), t
    );
  }
  function C(t, n, a, r, u, e) {
    var o = new f(6);
    return (
      (o[0] = t), (o[1] = n), (o[2] = a), (o[3] = r), (o[4] = u), (o[5] = e), o
    );
  }
  function G(t, n, a, r, u, e, o) {
    return (
      (t[0] = n), (t[1] = a), (t[2] = r), (t[3] = u), (t[4] = e), (t[5] = o), t
    );
  }
  function H(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[3],
      o = n[4],
      i = n[5],
      h = a * e - r * u;
    return h
      ? ((h = 1 / h),
        (t[0] = e * h),
        (t[1] = -r * h),
        (t[2] = -u * h),
        (t[3] = a * h),
        (t[4] = (u * i - e * o) * h),
        (t[5] = (r * o - a * i) * h),
        t)
      : null;
  }
  function J(t) {
    return t[0] * t[3] - t[1] * t[2];
  }
  function K(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = n[4],
      h = n[5],
      c = a[0],
      s = a[1],
      M = a[2],
      f = a[3],
      l = a[4],
      v = a[5];
    return (
      (t[0] = r * c + e * s),
      (t[1] = u * c + o * s),
      (t[2] = r * M + e * f),
      (t[3] = u * M + o * f),
      (t[4] = r * l + e * v + i),
      (t[5] = u * l + o * v + h),
      t
    );
  }
  function $(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = n[4],
      h = n[5],
      c = Math.sin(a),
      s = Math.cos(a);
    return (
      (t[0] = r * s + e * c),
      (t[1] = u * s + o * c),
      (t[2] = r * -c + e * s),
      (t[3] = u * -c + o * s),
      (t[4] = i),
      (t[5] = h),
      t
    );
  }
  function tt(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = n[4],
      h = n[5],
      c = a[0],
      s = a[1];
    return (
      (t[0] = r * c),
      (t[1] = u * c),
      (t[2] = e * s),
      (t[3] = o * s),
      (t[4] = i),
      (t[5] = h),
      t
    );
  }
  function nt(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = n[4],
      h = n[5],
      c = a[0],
      s = a[1];
    return (
      (t[0] = r),
      (t[1] = u),
      (t[2] = e),
      (t[3] = o),
      (t[4] = r * c + e * s + i),
      (t[5] = u * c + o * s + h),
      t
    );
  }
  function at(t, n) {
    var a = Math.sin(n),
      r = Math.cos(n);
    return (
      (t[0] = r), (t[1] = a), (t[2] = -a), (t[3] = r), (t[4] = 0), (t[5] = 0), t
    );
  }
  function rt(t, n) {
    return (
      (t[0] = n[0]),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = n[1]),
      (t[4] = 0),
      (t[5] = 0),
      t
    );
  }
  function ut(t, n) {
    return (
      (t[0] = 1),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 1),
      (t[4] = n[0]),
      (t[5] = n[1]),
      t
    );
  }
  function et(t) {
    return (
      "mat2d(" +
      t[0] +
      ", " +
      t[1] +
      ", " +
      t[2] +
      ", " +
      t[3] +
      ", " +
      t[4] +
      ", " +
      t[5] +
      ")"
    );
  }
  function ot(t) {
    return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1);
  }
  function it(t, n, a) {
    return (
      (t[0] = n[0] + a[0]),
      (t[1] = n[1] + a[1]),
      (t[2] = n[2] + a[2]),
      (t[3] = n[3] + a[3]),
      (t[4] = n[4] + a[4]),
      (t[5] = n[5] + a[5]),
      t
    );
  }
  function ht(t, n, a) {
    return (
      (t[0] = n[0] - a[0]),
      (t[1] = n[1] - a[1]),
      (t[2] = n[2] - a[2]),
      (t[3] = n[3] - a[3]),
      (t[4] = n[4] - a[4]),
      (t[5] = n[5] - a[5]),
      t
    );
  }
  function ct(t, n, a) {
    return (
      (t[0] = n[0] * a),
      (t[1] = n[1] * a),
      (t[2] = n[2] * a),
      (t[3] = n[3] * a),
      (t[4] = n[4] * a),
      (t[5] = n[5] * a),
      t
    );
  }
  function st(t, n, a, r) {
    return (
      (t[0] = n[0] + a[0] * r),
      (t[1] = n[1] + a[1] * r),
      (t[2] = n[2] + a[2] * r),
      (t[3] = n[3] + a[3] * r),
      (t[4] = n[4] + a[4] * r),
      (t[5] = n[5] + a[5] * r),
      t
    );
  }
  function Mt(t, n) {
    return (
      t[0] === n[0] &&
      t[1] === n[1] &&
      t[2] === n[2] &&
      t[3] === n[3] &&
      t[4] === n[4] &&
      t[5] === n[5]
    );
  }
  function ft(t, n) {
    var a = t[0],
      r = t[1],
      u = t[2],
      e = t[3],
      o = t[4],
      i = t[5],
      h = n[0],
      c = n[1],
      s = n[2],
      f = n[3],
      l = n[4],
      v = n[5];
    return (
      Math.abs(a - h) <= M * Math.max(1, Math.abs(a), Math.abs(h)) &&
      Math.abs(r - c) <= M * Math.max(1, Math.abs(r), Math.abs(c)) &&
      Math.abs(u - s) <= M * Math.max(1, Math.abs(u), Math.abs(s)) &&
      Math.abs(e - f) <= M * Math.max(1, Math.abs(e), Math.abs(f)) &&
      Math.abs(o - l) <= M * Math.max(1, Math.abs(o), Math.abs(l)) &&
      Math.abs(i - v) <= M * Math.max(1, Math.abs(i), Math.abs(v))
    );
  }
  var lt = K,
    vt = ht;
  function bt() {
    var t = new f(9);
    return (
      f != Float32Array &&
        ((t[1] = 0),
        (t[2] = 0),
        (t[3] = 0),
        (t[5] = 0),
        (t[6] = 0),
        (t[7] = 0)),
      (t[0] = 1),
      (t[4] = 1),
      (t[8] = 1),
      t
    );
  }
  function mt(t, n) {
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[4]),
      (t[4] = n[5]),
      (t[5] = n[6]),
      (t[6] = n[8]),
      (t[7] = n[9]),
      (t[8] = n[10]),
      t
    );
  }
  function dt(t) {
    var n = new f(9);
    return (
      (n[0] = t[0]),
      (n[1] = t[1]),
      (n[2] = t[2]),
      (n[3] = t[3]),
      (n[4] = t[4]),
      (n[5] = t[5]),
      (n[6] = t[6]),
      (n[7] = t[7]),
      (n[8] = t[8]),
      n
    );
  }
  function xt(t, n) {
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      t
    );
  }
  function yt(t, n, a, r, u, e, o, i, h) {
    var c = new f(9);
    return (
      (c[0] = t),
      (c[1] = n),
      (c[2] = a),
      (c[3] = r),
      (c[4] = u),
      (c[5] = e),
      (c[6] = o),
      (c[7] = i),
      (c[8] = h),
      c
    );
  }
  function pt(t, n, a, r, u, e, o, i, h, c) {
    return (
      (t[0] = n),
      (t[1] = a),
      (t[2] = r),
      (t[3] = u),
      (t[4] = e),
      (t[5] = o),
      (t[6] = i),
      (t[7] = h),
      (t[8] = c),
      t
    );
  }
  function qt(t) {
    return (
      (t[0] = 1),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = 1),
      (t[5] = 0),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = 1),
      t
    );
  }
  function wt(t, n) {
    if (t === n) {
      var a = n[1],
        r = n[2],
        u = n[5];
      (t[1] = n[3]),
        (t[2] = n[6]),
        (t[3] = a),
        (t[5] = n[7]),
        (t[6] = r),
        (t[7] = u);
    } else
      (t[0] = n[0]),
        (t[1] = n[3]),
        (t[2] = n[6]),
        (t[3] = n[1]),
        (t[4] = n[4]),
        (t[5] = n[7]),
        (t[6] = n[2]),
        (t[7] = n[5]),
        (t[8] = n[8]);
    return t;
  }
  function gt(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[3],
      o = n[4],
      i = n[5],
      h = n[6],
      c = n[7],
      s = n[8],
      M = s * o - i * c,
      f = -s * e + i * h,
      l = c * e - o * h,
      v = a * M + r * f + u * l;
    return v
      ? ((v = 1 / v),
        (t[0] = M * v),
        (t[1] = (-s * r + u * c) * v),
        (t[2] = (i * r - u * o) * v),
        (t[3] = f * v),
        (t[4] = (s * a - u * h) * v),
        (t[5] = (-i * a + u * e) * v),
        (t[6] = l * v),
        (t[7] = (-c * a + r * h) * v),
        (t[8] = (o * a - r * e) * v),
        t)
      : null;
  }
  function At(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[3],
      o = n[4],
      i = n[5],
      h = n[6],
      c = n[7],
      s = n[8];
    return (
      (t[0] = o * s - i * c),
      (t[1] = u * c - r * s),
      (t[2] = r * i - u * o),
      (t[3] = i * h - e * s),
      (t[4] = a * s - u * h),
      (t[5] = u * e - a * i),
      (t[6] = e * c - o * h),
      (t[7] = r * h - a * c),
      (t[8] = a * o - r * e),
      t
    );
  }
  function Pt(t) {
    var n = t[0],
      a = t[1],
      r = t[2],
      u = t[3],
      e = t[4],
      o = t[5],
      i = t[6],
      h = t[7],
      c = t[8];
    return n * (c * e - o * h) + a * (-c * u + o * i) + r * (h * u - e * i);
  }
  function St(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = n[4],
      h = n[5],
      c = n[6],
      s = n[7],
      M = n[8],
      f = a[0],
      l = a[1],
      v = a[2],
      b = a[3],
      m = a[4],
      d = a[5],
      x = a[6],
      y = a[7],
      p = a[8];
    return (
      (t[0] = f * r + l * o + v * c),
      (t[1] = f * u + l * i + v * s),
      (t[2] = f * e + l * h + v * M),
      (t[3] = b * r + m * o + d * c),
      (t[4] = b * u + m * i + d * s),
      (t[5] = b * e + m * h + d * M),
      (t[6] = x * r + y * o + p * c),
      (t[7] = x * u + y * i + p * s),
      (t[8] = x * e + y * h + p * M),
      t
    );
  }
  function Rt(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = n[4],
      h = n[5],
      c = n[6],
      s = n[7],
      M = n[8],
      f = a[0],
      l = a[1];
    return (
      (t[0] = r),
      (t[1] = u),
      (t[2] = e),
      (t[3] = o),
      (t[4] = i),
      (t[5] = h),
      (t[6] = f * r + l * o + c),
      (t[7] = f * u + l * i + s),
      (t[8] = f * e + l * h + M),
      t
    );
  }
  function Tt(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = n[4],
      h = n[5],
      c = n[6],
      s = n[7],
      M = n[8],
      f = Math.sin(a),
      l = Math.cos(a);
    return (
      (t[0] = l * r + f * o),
      (t[1] = l * u + f * i),
      (t[2] = l * e + f * h),
      (t[3] = l * o - f * r),
      (t[4] = l * i - f * u),
      (t[5] = l * h - f * e),
      (t[6] = c),
      (t[7] = s),
      (t[8] = M),
      t
    );
  }
  function It(t, n, a) {
    var r = a[0],
      u = a[1];
    return (
      (t[0] = r * n[0]),
      (t[1] = r * n[1]),
      (t[2] = r * n[2]),
      (t[3] = u * n[3]),
      (t[4] = u * n[4]),
      (t[5] = u * n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      t
    );
  }
  function Et(t, n) {
    return (
      (t[0] = 1),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = 1),
      (t[5] = 0),
      (t[6] = n[0]),
      (t[7] = n[1]),
      (t[8] = 1),
      t
    );
  }
  function Dt(t, n) {
    var a = Math.sin(n),
      r = Math.cos(n);
    return (
      (t[0] = r),
      (t[1] = a),
      (t[2] = 0),
      (t[3] = -a),
      (t[4] = r),
      (t[5] = 0),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = 1),
      t
    );
  }
  function Ft(t, n) {
    return (
      (t[0] = n[0]),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = n[1]),
      (t[5] = 0),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = 1),
      t
    );
  }
  function Lt(t, n) {
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = 0),
      (t[3] = n[2]),
      (t[4] = n[3]),
      (t[5] = 0),
      (t[6] = n[4]),
      (t[7] = n[5]),
      (t[8] = 1),
      t
    );
  }
  function Vt(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[3],
      o = a + a,
      i = r + r,
      h = u + u,
      c = a * o,
      s = r * o,
      M = r * i,
      f = u * o,
      l = u * i,
      v = u * h,
      b = e * o,
      m = e * i,
      d = e * h;
    return (
      (t[0] = 1 - M - v),
      (t[3] = s - d),
      (t[6] = f + m),
      (t[1] = s + d),
      (t[4] = 1 - c - v),
      (t[7] = l - b),
      (t[2] = f - m),
      (t[5] = l + b),
      (t[8] = 1 - c - M),
      t
    );
  }
  function jt(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[3],
      o = n[4],
      i = n[5],
      h = n[6],
      c = n[7],
      s = n[8],
      M = n[9],
      f = n[10],
      l = n[11],
      v = n[12],
      b = n[13],
      m = n[14],
      d = n[15],
      x = a * i - r * o,
      y = a * h - u * o,
      p = a * c - e * o,
      q = r * h - u * i,
      w = r * c - e * i,
      g = u * c - e * h,
      A = s * b - M * v,
      P = s * m - f * v,
      S = s * d - l * v,
      R = M * m - f * b,
      T = M * d - l * b,
      I = f * d - l * m,
      E = x * I - y * T + p * R + q * S - w * P + g * A;
    return E
      ? ((E = 1 / E),
        (t[0] = (i * I - h * T + c * R) * E),
        (t[1] = (h * S - o * I - c * P) * E),
        (t[2] = (o * T - i * S + c * A) * E),
        (t[3] = (u * T - r * I - e * R) * E),
        (t[4] = (a * I - u * S + e * P) * E),
        (t[5] = (r * S - a * T - e * A) * E),
        (t[6] = (b * g - m * w + d * q) * E),
        (t[7] = (m * p - v * g - d * y) * E),
        (t[8] = (v * w - b * p + d * x) * E),
        t)
      : null;
  }
  function zt(t, n, a) {
    return (
      (t[0] = 2 / n),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = -2 / a),
      (t[5] = 0),
      (t[6] = -1),
      (t[7] = 1),
      (t[8] = 1),
      t
    );
  }
  function Ot(t) {
    return (
      "mat3(" +
      t[0] +
      ", " +
      t[1] +
      ", " +
      t[2] +
      ", " +
      t[3] +
      ", " +
      t[4] +
      ", " +
      t[5] +
      ", " +
      t[6] +
      ", " +
      t[7] +
      ", " +
      t[8] +
      ")"
    );
  }
  function Qt(t) {
    return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
  }
  function Yt(t, n, a) {
    return (
      (t[0] = n[0] + a[0]),
      (t[1] = n[1] + a[1]),
      (t[2] = n[2] + a[2]),
      (t[3] = n[3] + a[3]),
      (t[4] = n[4] + a[4]),
      (t[5] = n[5] + a[5]),
      (t[6] = n[6] + a[6]),
      (t[7] = n[7] + a[7]),
      (t[8] = n[8] + a[8]),
      t
    );
  }
  function Xt(t, n, a) {
    return (
      (t[0] = n[0] - a[0]),
      (t[1] = n[1] - a[1]),
      (t[2] = n[2] - a[2]),
      (t[3] = n[3] - a[3]),
      (t[4] = n[4] - a[4]),
      (t[5] = n[5] - a[5]),
      (t[6] = n[6] - a[6]),
      (t[7] = n[7] - a[7]),
      (t[8] = n[8] - a[8]),
      t
    );
  }
  function Zt(t, n, a) {
    return (
      (t[0] = n[0] * a),
      (t[1] = n[1] * a),
      (t[2] = n[2] * a),
      (t[3] = n[3] * a),
      (t[4] = n[4] * a),
      (t[5] = n[5] * a),
      (t[6] = n[6] * a),
      (t[7] = n[7] * a),
      (t[8] = n[8] * a),
      t
    );
  }
  function _t(t, n, a, r) {
    return (
      (t[0] = n[0] + a[0] * r),
      (t[1] = n[1] + a[1] * r),
      (t[2] = n[2] + a[2] * r),
      (t[3] = n[3] + a[3] * r),
      (t[4] = n[4] + a[4] * r),
      (t[5] = n[5] + a[5] * r),
      (t[6] = n[6] + a[6] * r),
      (t[7] = n[7] + a[7] * r),
      (t[8] = n[8] + a[8] * r),
      t
    );
  }
  function Bt(t, n) {
    return (
      t[0] === n[0] &&
      t[1] === n[1] &&
      t[2] === n[2] &&
      t[3] === n[3] &&
      t[4] === n[4] &&
      t[5] === n[5] &&
      t[6] === n[6] &&
      t[7] === n[7] &&
      t[8] === n[8]
    );
  }
  function Nt(t, n) {
    var a = t[0],
      r = t[1],
      u = t[2],
      e = t[3],
      o = t[4],
      i = t[5],
      h = t[6],
      c = t[7],
      s = t[8],
      f = n[0],
      l = n[1],
      v = n[2],
      b = n[3],
      m = n[4],
      d = n[5],
      x = n[6],
      y = n[7],
      p = n[8];
    return (
      Math.abs(a - f) <= M * Math.max(1, Math.abs(a), Math.abs(f)) &&
      Math.abs(r - l) <= M * Math.max(1, Math.abs(r), Math.abs(l)) &&
      Math.abs(u - v) <= M * Math.max(1, Math.abs(u), Math.abs(v)) &&
      Math.abs(e - b) <= M * Math.max(1, Math.abs(e), Math.abs(b)) &&
      Math.abs(o - m) <= M * Math.max(1, Math.abs(o), Math.abs(m)) &&
      Math.abs(i - d) <= M * Math.max(1, Math.abs(i), Math.abs(d)) &&
      Math.abs(h - x) <= M * Math.max(1, Math.abs(h), Math.abs(x)) &&
      Math.abs(c - y) <= M * Math.max(1, Math.abs(c), Math.abs(y)) &&
      Math.abs(s - p) <= M * Math.max(1, Math.abs(s), Math.abs(p))
    );
  }
  var kt = St,
    Ut = Xt;
  function Wt() {
    var t = new f(16);
    return (
      f != Float32Array &&
        ((t[1] = 0),
        (t[2] = 0),
        (t[3] = 0),
        (t[4] = 0),
        (t[6] = 0),
        (t[7] = 0),
        (t[8] = 0),
        (t[9] = 0),
        (t[11] = 0),
        (t[12] = 0),
        (t[13] = 0),
        (t[14] = 0)),
      (t[0] = 1),
      (t[5] = 1),
      (t[10] = 1),
      (t[15] = 1),
      t
    );
  }
  function Ct(t) {
    var n = new f(16);
    return (
      (n[0] = t[0]),
      (n[1] = t[1]),
      (n[2] = t[2]),
      (n[3] = t[3]),
      (n[4] = t[4]),
      (n[5] = t[5]),
      (n[6] = t[6]),
      (n[7] = t[7]),
      (n[8] = t[8]),
      (n[9] = t[9]),
      (n[10] = t[10]),
      (n[11] = t[11]),
      (n[12] = t[12]),
      (n[13] = t[13]),
      (n[14] = t[14]),
      (n[15] = t[15]),
      n
    );
  }
  function Gt(t, n) {
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      (t[9] = n[9]),
      (t[10] = n[10]),
      (t[11] = n[11]),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      t
    );
  }
  function Ht(t, n, a, r, u, e, o, i, h, c, s, M, l, v, b, m) {
    var d = new f(16);
    return (
      (d[0] = t),
      (d[1] = n),
      (d[2] = a),
      (d[3] = r),
      (d[4] = u),
      (d[5] = e),
      (d[6] = o),
      (d[7] = i),
      (d[8] = h),
      (d[9] = c),
      (d[10] = s),
      (d[11] = M),
      (d[12] = l),
      (d[13] = v),
      (d[14] = b),
      (d[15] = m),
      d
    );
  }
  function Jt(t, n, a, r, u, e, o, i, h, c, s, M, f, l, v, b, m) {
    return (
      (t[0] = n),
      (t[1] = a),
      (t[2] = r),
      (t[3] = u),
      (t[4] = e),
      (t[5] = o),
      (t[6] = i),
      (t[7] = h),
      (t[8] = c),
      (t[9] = s),
      (t[10] = M),
      (t[11] = f),
      (t[12] = l),
      (t[13] = v),
      (t[14] = b),
      (t[15] = m),
      t
    );
  }
  function Kt(t) {
    return (
      (t[0] = 1),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = 0),
      (t[5] = 1),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = 0),
      (t[9] = 0),
      (t[10] = 1),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      t
    );
  }
  function $t(t, n) {
    if (t === n) {
      var a = n[1],
        r = n[2],
        u = n[3],
        e = n[6],
        o = n[7],
        i = n[11];
      (t[1] = n[4]),
        (t[2] = n[8]),
        (t[3] = n[12]),
        (t[4] = a),
        (t[6] = n[9]),
        (t[7] = n[13]),
        (t[8] = r),
        (t[9] = e),
        (t[11] = n[14]),
        (t[12] = u),
        (t[13] = o),
        (t[14] = i);
    } else
      (t[0] = n[0]),
        (t[1] = n[4]),
        (t[2] = n[8]),
        (t[3] = n[12]),
        (t[4] = n[1]),
        (t[5] = n[5]),
        (t[6] = n[9]),
        (t[7] = n[13]),
        (t[8] = n[2]),
        (t[9] = n[6]),
        (t[10] = n[10]),
        (t[11] = n[14]),
        (t[12] = n[3]),
        (t[13] = n[7]),
        (t[14] = n[11]),
        (t[15] = n[15]);
    return t;
  }
  function tn(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[3],
      o = n[4],
      i = n[5],
      h = n[6],
      c = n[7],
      s = n[8],
      M = n[9],
      f = n[10],
      l = n[11],
      v = n[12],
      b = n[13],
      m = n[14],
      d = n[15],
      x = a * i - r * o,
      y = a * h - u * o,
      p = a * c - e * o,
      q = r * h - u * i,
      w = r * c - e * i,
      g = u * c - e * h,
      A = s * b - M * v,
      P = s * m - f * v,
      S = s * d - l * v,
      R = M * m - f * b,
      T = M * d - l * b,
      I = f * d - l * m,
      E = x * I - y * T + p * R + q * S - w * P + g * A;
    return E
      ? ((E = 1 / E),
        (t[0] = (i * I - h * T + c * R) * E),
        (t[1] = (u * T - r * I - e * R) * E),
        (t[2] = (b * g - m * w + d * q) * E),
        (t[3] = (f * w - M * g - l * q) * E),
        (t[4] = (h * S - o * I - c * P) * E),
        (t[5] = (a * I - u * S + e * P) * E),
        (t[6] = (m * p - v * g - d * y) * E),
        (t[7] = (s * g - f * p + l * y) * E),
        (t[8] = (o * T - i * S + c * A) * E),
        (t[9] = (r * S - a * T - e * A) * E),
        (t[10] = (v * w - b * p + d * x) * E),
        (t[11] = (M * p - s * w - l * x) * E),
        (t[12] = (i * P - o * R - h * A) * E),
        (t[13] = (a * R - r * P + u * A) * E),
        (t[14] = (b * y - v * q - m * x) * E),
        (t[15] = (s * q - M * y + f * x) * E),
        t)
      : null;
  }
  function nn(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[3],
      o = n[4],
      i = n[5],
      h = n[6],
      c = n[7],
      s = n[8],
      M = n[9],
      f = n[10],
      l = n[11],
      v = n[12],
      b = n[13],
      m = n[14],
      d = n[15];
    return (
      (t[0] = i * (f * d - l * m) - M * (h * d - c * m) + b * (h * l - c * f)),
      (t[1] = -(
        r * (f * d - l * m) -
        M * (u * d - e * m) +
        b * (u * l - e * f)
      )),
      (t[2] = r * (h * d - c * m) - i * (u * d - e * m) + b * (u * c - e * h)),
      (t[3] = -(
        r * (h * l - c * f) -
        i * (u * l - e * f) +
        M * (u * c - e * h)
      )),
      (t[4] = -(
        o * (f * d - l * m) -
        s * (h * d - c * m) +
        v * (h * l - c * f)
      )),
      (t[5] = a * (f * d - l * m) - s * (u * d - e * m) + v * (u * l - e * f)),
      (t[6] = -(
        a * (h * d - c * m) -
        o * (u * d - e * m) +
        v * (u * c - e * h)
      )),
      (t[7] = a * (h * l - c * f) - o * (u * l - e * f) + s * (u * c - e * h)),
      (t[8] = o * (M * d - l * b) - s * (i * d - c * b) + v * (i * l - c * M)),
      (t[9] = -(
        a * (M * d - l * b) -
        s * (r * d - e * b) +
        v * (r * l - e * M)
      )),
      (t[10] = a * (i * d - c * b) - o * (r * d - e * b) + v * (r * c - e * i)),
      (t[11] = -(
        a * (i * l - c * M) -
        o * (r * l - e * M) +
        s * (r * c - e * i)
      )),
      (t[12] = -(
        o * (M * m - f * b) -
        s * (i * m - h * b) +
        v * (i * f - h * M)
      )),
      (t[13] = a * (M * m - f * b) - s * (r * m - u * b) + v * (r * f - u * M)),
      (t[14] = -(
        a * (i * m - h * b) -
        o * (r * m - u * b) +
        v * (r * h - u * i)
      )),
      (t[15] = a * (i * f - h * M) - o * (r * f - u * M) + s * (r * h - u * i)),
      t
    );
  }
  function an(t) {
    var n = t[0],
      a = t[1],
      r = t[2],
      u = t[3],
      e = t[4],
      o = t[5],
      i = t[6],
      h = t[7],
      c = t[8],
      s = t[9],
      M = t[10],
      f = t[11],
      l = t[12],
      v = t[13],
      b = t[14],
      m = t[15];
    return (
      (n * o - a * e) * (M * m - f * b) -
      (n * i - r * e) * (s * m - f * v) +
      (n * h - u * e) * (s * b - M * v) +
      (a * i - r * o) * (c * m - f * l) -
      (a * h - u * o) * (c * b - M * l) +
      (r * h - u * i) * (c * v - s * l)
    );
  }
  function rn(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = n[4],
      h = n[5],
      c = n[6],
      s = n[7],
      M = n[8],
      f = n[9],
      l = n[10],
      v = n[11],
      b = n[12],
      m = n[13],
      d = n[14],
      x = n[15],
      y = a[0],
      p = a[1],
      q = a[2],
      w = a[3];
    return (
      (t[0] = y * r + p * i + q * M + w * b),
      (t[1] = y * u + p * h + q * f + w * m),
      (t[2] = y * e + p * c + q * l + w * d),
      (t[3] = y * o + p * s + q * v + w * x),
      (y = a[4]),
      (p = a[5]),
      (q = a[6]),
      (w = a[7]),
      (t[4] = y * r + p * i + q * M + w * b),
      (t[5] = y * u + p * h + q * f + w * m),
      (t[6] = y * e + p * c + q * l + w * d),
      (t[7] = y * o + p * s + q * v + w * x),
      (y = a[8]),
      (p = a[9]),
      (q = a[10]),
      (w = a[11]),
      (t[8] = y * r + p * i + q * M + w * b),
      (t[9] = y * u + p * h + q * f + w * m),
      (t[10] = y * e + p * c + q * l + w * d),
      (t[11] = y * o + p * s + q * v + w * x),
      (y = a[12]),
      (p = a[13]),
      (q = a[14]),
      (w = a[15]),
      (t[12] = y * r + p * i + q * M + w * b),
      (t[13] = y * u + p * h + q * f + w * m),
      (t[14] = y * e + p * c + q * l + w * d),
      (t[15] = y * o + p * s + q * v + w * x),
      t
    );
  }
  function un(t, n, a) {
    var r,
      u,
      e,
      o,
      i,
      h,
      c,
      s,
      M,
      f,
      l,
      v,
      b = a[0],
      m = a[1],
      d = a[2];
    return (
      n === t
        ? ((t[12] = n[0] * b + n[4] * m + n[8] * d + n[12]),
          (t[13] = n[1] * b + n[5] * m + n[9] * d + n[13]),
          (t[14] = n[2] * b + n[6] * m + n[10] * d + n[14]),
          (t[15] = n[3] * b + n[7] * m + n[11] * d + n[15]))
        : ((r = n[0]),
          (u = n[1]),
          (e = n[2]),
          (o = n[3]),
          (i = n[4]),
          (h = n[5]),
          (c = n[6]),
          (s = n[7]),
          (M = n[8]),
          (f = n[9]),
          (l = n[10]),
          (v = n[11]),
          (t[0] = r),
          (t[1] = u),
          (t[2] = e),
          (t[3] = o),
          (t[4] = i),
          (t[5] = h),
          (t[6] = c),
          (t[7] = s),
          (t[8] = M),
          (t[9] = f),
          (t[10] = l),
          (t[11] = v),
          (t[12] = r * b + i * m + M * d + n[12]),
          (t[13] = u * b + h * m + f * d + n[13]),
          (t[14] = e * b + c * m + l * d + n[14]),
          (t[15] = o * b + s * m + v * d + n[15])),
      t
    );
  }
  function en(t, n, a) {
    var r = a[0],
      u = a[1],
      e = a[2];
    return (
      (t[0] = n[0] * r),
      (t[1] = n[1] * r),
      (t[2] = n[2] * r),
      (t[3] = n[3] * r),
      (t[4] = n[4] * u),
      (t[5] = n[5] * u),
      (t[6] = n[6] * u),
      (t[7] = n[7] * u),
      (t[8] = n[8] * e),
      (t[9] = n[9] * e),
      (t[10] = n[10] * e),
      (t[11] = n[11] * e),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      t
    );
  }
  function on(t, n, a, r) {
    var u,
      e,
      o,
      i,
      h,
      c,
      s,
      f,
      l,
      v,
      b,
      m,
      d,
      x,
      y,
      p,
      q,
      w,
      g,
      A,
      P,
      S,
      R,
      T,
      I = r[0],
      E = r[1],
      D = r[2],
      F = Math.hypot(I, E, D);
    return F < M
      ? null
      : ((I *= F = 1 / F),
        (E *= F),
        (D *= F),
        (u = Math.sin(a)),
        (o = 1 - (e = Math.cos(a))),
        (i = n[0]),
        (h = n[1]),
        (c = n[2]),
        (s = n[3]),
        (f = n[4]),
        (l = n[5]),
        (v = n[6]),
        (b = n[7]),
        (m = n[8]),
        (d = n[9]),
        (x = n[10]),
        (y = n[11]),
        (p = I * I * o + e),
        (q = E * I * o + D * u),
        (w = D * I * o - E * u),
        (g = I * E * o - D * u),
        (A = E * E * o + e),
        (P = D * E * o + I * u),
        (S = I * D * o + E * u),
        (R = E * D * o - I * u),
        (T = D * D * o + e),
        (t[0] = i * p + f * q + m * w),
        (t[1] = h * p + l * q + d * w),
        (t[2] = c * p + v * q + x * w),
        (t[3] = s * p + b * q + y * w),
        (t[4] = i * g + f * A + m * P),
        (t[5] = h * g + l * A + d * P),
        (t[6] = c * g + v * A + x * P),
        (t[7] = s * g + b * A + y * P),
        (t[8] = i * S + f * R + m * T),
        (t[9] = h * S + l * R + d * T),
        (t[10] = c * S + v * R + x * T),
        (t[11] = s * S + b * R + y * T),
        n !== t &&
          ((t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), (t[15] = n[15])),
        t);
  }
  function hn(t, n, a) {
    var r = Math.sin(a),
      u = Math.cos(a),
      e = n[4],
      o = n[5],
      i = n[6],
      h = n[7],
      c = n[8],
      s = n[9],
      M = n[10],
      f = n[11];
    return (
      n !== t &&
        ((t[0] = n[0]),
        (t[1] = n[1]),
        (t[2] = n[2]),
        (t[3] = n[3]),
        (t[12] = n[12]),
        (t[13] = n[13]),
        (t[14] = n[14]),
        (t[15] = n[15])),
      (t[4] = e * u + c * r),
      (t[5] = o * u + s * r),
      (t[6] = i * u + M * r),
      (t[7] = h * u + f * r),
      (t[8] = c * u - e * r),
      (t[9] = s * u - o * r),
      (t[10] = M * u - i * r),
      (t[11] = f * u - h * r),
      t
    );
  }
  function cn(t, n, a) {
    var r = Math.sin(a),
      u = Math.cos(a),
      e = n[0],
      o = n[1],
      i = n[2],
      h = n[3],
      c = n[8],
      s = n[9],
      M = n[10],
      f = n[11];
    return (
      n !== t &&
        ((t[4] = n[4]),
        (t[5] = n[5]),
        (t[6] = n[6]),
        (t[7] = n[7]),
        (t[12] = n[12]),
        (t[13] = n[13]),
        (t[14] = n[14]),
        (t[15] = n[15])),
      (t[0] = e * u - c * r),
      (t[1] = o * u - s * r),
      (t[2] = i * u - M * r),
      (t[3] = h * u - f * r),
      (t[8] = e * r + c * u),
      (t[9] = o * r + s * u),
      (t[10] = i * r + M * u),
      (t[11] = h * r + f * u),
      t
    );
  }
  function sn(t, n, a) {
    var r = Math.sin(a),
      u = Math.cos(a),
      e = n[0],
      o = n[1],
      i = n[2],
      h = n[3],
      c = n[4],
      s = n[5],
      M = n[6],
      f = n[7];
    return (
      n !== t &&
        ((t[8] = n[8]),
        (t[9] = n[9]),
        (t[10] = n[10]),
        (t[11] = n[11]),
        (t[12] = n[12]),
        (t[13] = n[13]),
        (t[14] = n[14]),
        (t[15] = n[15])),
      (t[0] = e * u + c * r),
      (t[1] = o * u + s * r),
      (t[2] = i * u + M * r),
      (t[3] = h * u + f * r),
      (t[4] = c * u - e * r),
      (t[5] = s * u - o * r),
      (t[6] = M * u - i * r),
      (t[7] = f * u - h * r),
      t
    );
  }
  function Mn(t, n) {
    return (
      (t[0] = 1),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = 0),
      (t[5] = 1),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = 0),
      (t[9] = 0),
      (t[10] = 1),
      (t[11] = 0),
      (t[12] = n[0]),
      (t[13] = n[1]),
      (t[14] = n[2]),
      (t[15] = 1),
      t
    );
  }
  function fn(t, n) {
    return (
      (t[0] = n[0]),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = 0),
      (t[5] = n[1]),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = 0),
      (t[9] = 0),
      (t[10] = n[2]),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      t
    );
  }
  function ln(t, n, a) {
    var r,
      u,
      e,
      o = a[0],
      i = a[1],
      h = a[2],
      c = Math.hypot(o, i, h);
    return c < M
      ? null
      : ((o *= c = 1 / c),
        (i *= c),
        (h *= c),
        (r = Math.sin(n)),
        (e = 1 - (u = Math.cos(n))),
        (t[0] = o * o * e + u),
        (t[1] = i * o * e + h * r),
        (t[2] = h * o * e - i * r),
        (t[3] = 0),
        (t[4] = o * i * e - h * r),
        (t[5] = i * i * e + u),
        (t[6] = h * i * e + o * r),
        (t[7] = 0),
        (t[8] = o * h * e + i * r),
        (t[9] = i * h * e - o * r),
        (t[10] = h * h * e + u),
        (t[11] = 0),
        (t[12] = 0),
        (t[13] = 0),
        (t[14] = 0),
        (t[15] = 1),
        t);
  }
  function vn(t, n) {
    var a = Math.sin(n),
      r = Math.cos(n);
    return (
      (t[0] = 1),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = 0),
      (t[5] = r),
      (t[6] = a),
      (t[7] = 0),
      (t[8] = 0),
      (t[9] = -a),
      (t[10] = r),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      t
    );
  }
  function bn(t, n) {
    var a = Math.sin(n),
      r = Math.cos(n);
    return (
      (t[0] = r),
      (t[1] = 0),
      (t[2] = -a),
      (t[3] = 0),
      (t[4] = 0),
      (t[5] = 1),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = a),
      (t[9] = 0),
      (t[10] = r),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      t
    );
  }
  function mn(t, n) {
    var a = Math.sin(n),
      r = Math.cos(n);
    return (
      (t[0] = r),
      (t[1] = a),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = -a),
      (t[5] = r),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = 0),
      (t[9] = 0),
      (t[10] = 1),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      t
    );
  }
  function dn(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = r + r,
      h = u + u,
      c = e + e,
      s = r * i,
      M = r * h,
      f = r * c,
      l = u * h,
      v = u * c,
      b = e * c,
      m = o * i,
      d = o * h,
      x = o * c;
    return (
      (t[0] = 1 - (l + b)),
      (t[1] = M + x),
      (t[2] = f - d),
      (t[3] = 0),
      (t[4] = M - x),
      (t[5] = 1 - (s + b)),
      (t[6] = v + m),
      (t[7] = 0),
      (t[8] = f + d),
      (t[9] = v - m),
      (t[10] = 1 - (s + l)),
      (t[11] = 0),
      (t[12] = a[0]),
      (t[13] = a[1]),
      (t[14] = a[2]),
      (t[15] = 1),
      t
    );
  }
  function xn(t, n) {
    var a = new f(3),
      r = -n[0],
      u = -n[1],
      e = -n[2],
      o = n[3],
      i = n[4],
      h = n[5],
      c = n[6],
      s = n[7],
      M = r * r + u * u + e * e + o * o;
    return (
      M > 0
        ? ((a[0] = (2 * (i * o + s * r + h * e - c * u)) / M),
          (a[1] = (2 * (h * o + s * u + c * r - i * e)) / M),
          (a[2] = (2 * (c * o + s * e + i * u - h * r)) / M))
        : ((a[0] = 2 * (i * o + s * r + h * e - c * u)),
          (a[1] = 2 * (h * o + s * u + c * r - i * e)),
          (a[2] = 2 * (c * o + s * e + i * u - h * r))),
      dn(t, n, a),
      t
    );
  }
  function yn(t, n) {
    return (t[0] = n[12]), (t[1] = n[13]), (t[2] = n[14]), t;
  }
  function pn(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[4],
      o = n[5],
      i = n[6],
      h = n[8],
      c = n[9],
      s = n[10];
    return (
      (t[0] = Math.hypot(a, r, u)),
      (t[1] = Math.hypot(e, o, i)),
      (t[2] = Math.hypot(h, c, s)),
      t
    );
  }
  function qn(t, n) {
    var a = new f(3);
    pn(a, n);
    var r = 1 / a[0],
      u = 1 / a[1],
      e = 1 / a[2],
      o = n[0] * r,
      i = n[1] * u,
      h = n[2] * e,
      c = n[4] * r,
      s = n[5] * u,
      M = n[6] * e,
      l = n[8] * r,
      v = n[9] * u,
      b = n[10] * e,
      m = o + s + b,
      d = 0;
    return (
      m > 0
        ? ((d = 2 * Math.sqrt(m + 1)),
          (t[3] = 0.25 * d),
          (t[0] = (M - v) / d),
          (t[1] = (l - h) / d),
          (t[2] = (i - c) / d))
        : o > s && o > b
        ? ((d = 2 * Math.sqrt(1 + o - s - b)),
          (t[3] = (M - v) / d),
          (t[0] = 0.25 * d),
          (t[1] = (i + c) / d),
          (t[2] = (l + h) / d))
        : s > b
        ? ((d = 2 * Math.sqrt(1 + s - o - b)),
          (t[3] = (l - h) / d),
          (t[0] = (i + c) / d),
          (t[1] = 0.25 * d),
          (t[2] = (M + v) / d))
        : ((d = 2 * Math.sqrt(1 + b - o - s)),
          (t[3] = (i - c) / d),
          (t[0] = (l + h) / d),
          (t[1] = (M + v) / d),
          (t[2] = 0.25 * d)),
      t
    );
  }
  function wn(t, n, a, r) {
    var u = n[0],
      e = n[1],
      o = n[2],
      i = n[3],
      h = u + u,
      c = e + e,
      s = o + o,
      M = u * h,
      f = u * c,
      l = u * s,
      v = e * c,
      b = e * s,
      m = o * s,
      d = i * h,
      x = i * c,
      y = i * s,
      p = r[0],
      q = r[1],
      w = r[2];
    return (
      (t[0] = (1 - (v + m)) * p),
      (t[1] = (f + y) * p),
      (t[2] = (l - x) * p),
      (t[3] = 0),
      (t[4] = (f - y) * q),
      (t[5] = (1 - (M + m)) * q),
      (t[6] = (b + d) * q),
      (t[7] = 0),
      (t[8] = (l + x) * w),
      (t[9] = (b - d) * w),
      (t[10] = (1 - (M + v)) * w),
      (t[11] = 0),
      (t[12] = a[0]),
      (t[13] = a[1]),
      (t[14] = a[2]),
      (t[15] = 1),
      t
    );
  }
  function gn(t, n, a, r, u) {
    var e = n[0],
      o = n[1],
      i = n[2],
      h = n[3],
      c = e + e,
      s = o + o,
      M = i + i,
      f = e * c,
      l = e * s,
      v = e * M,
      b = o * s,
      m = o * M,
      d = i * M,
      x = h * c,
      y = h * s,
      p = h * M,
      q = r[0],
      w = r[1],
      g = r[2],
      A = u[0],
      P = u[1],
      S = u[2],
      R = (1 - (b + d)) * q,
      T = (l + p) * q,
      I = (v - y) * q,
      E = (l - p) * w,
      D = (1 - (f + d)) * w,
      F = (m + x) * w,
      L = (v + y) * g,
      V = (m - x) * g,
      j = (1 - (f + b)) * g;
    return (
      (t[0] = R),
      (t[1] = T),
      (t[2] = I),
      (t[3] = 0),
      (t[4] = E),
      (t[5] = D),
      (t[6] = F),
      (t[7] = 0),
      (t[8] = L),
      (t[9] = V),
      (t[10] = j),
      (t[11] = 0),
      (t[12] = a[0] + A - (R * A + E * P + L * S)),
      (t[13] = a[1] + P - (T * A + D * P + V * S)),
      (t[14] = a[2] + S - (I * A + F * P + j * S)),
      (t[15] = 1),
      t
    );
  }
  function An(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[3],
      o = a + a,
      i = r + r,
      h = u + u,
      c = a * o,
      s = r * o,
      M = r * i,
      f = u * o,
      l = u * i,
      v = u * h,
      b = e * o,
      m = e * i,
      d = e * h;
    return (
      (t[0] = 1 - M - v),
      (t[1] = s + d),
      (t[2] = f - m),
      (t[3] = 0),
      (t[4] = s - d),
      (t[5] = 1 - c - v),
      (t[6] = l + b),
      (t[7] = 0),
      (t[8] = f + m),
      (t[9] = l - b),
      (t[10] = 1 - c - M),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      t
    );
  }
  function Pn(t, n, a, r, u, e, o) {
    var i = 1 / (a - n),
      h = 1 / (u - r),
      c = 1 / (e - o);
    return (
      (t[0] = 2 * e * i),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = 0),
      (t[5] = 2 * e * h),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = (a + n) * i),
      (t[9] = (u + r) * h),
      (t[10] = (o + e) * c),
      (t[11] = -1),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = o * e * 2 * c),
      (t[15] = 0),
      t
    );
  }
  function Sn(t, n, a, r, u) {
    var e,
      o = 1 / Math.tan(n / 2);
    return (
      (t[0] = o / a),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = 0),
      (t[5] = o),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = 0),
      (t[9] = 0),
      (t[11] = -1),
      (t[12] = 0),
      (t[13] = 0),
      (t[15] = 0),
      null != u && u !== 1 / 0
        ? ((e = 1 / (r - u)), (t[10] = (u + r) * e), (t[14] = 2 * u * r * e))
        : ((t[10] = -1), (t[14] = -2 * r)),
      t
    );
  }
  function Rn(t, n, a, r) {
    var u = Math.tan((n.upDegrees * Math.PI) / 180),
      e = Math.tan((n.downDegrees * Math.PI) / 180),
      o = Math.tan((n.leftDegrees * Math.PI) / 180),
      i = Math.tan((n.rightDegrees * Math.PI) / 180),
      h = 2 / (o + i),
      c = 2 / (u + e);
    return (
      (t[0] = h),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = 0),
      (t[5] = c),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = -(o - i) * h * 0.5),
      (t[9] = (u - e) * c * 0.5),
      (t[10] = r / (a - r)),
      (t[11] = -1),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = (r * a) / (a - r)),
      (t[15] = 0),
      t
    );
  }
  function Tn(t, n, a, r, u, e, o) {
    var i = 1 / (n - a),
      h = 1 / (r - u),
      c = 1 / (e - o);
    return (
      (t[0] = -2 * i),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 0),
      (t[4] = 0),
      (t[5] = -2 * h),
      (t[6] = 0),
      (t[7] = 0),
      (t[8] = 0),
      (t[9] = 0),
      (t[10] = 2 * c),
      (t[11] = 0),
      (t[12] = (n + a) * i),
      (t[13] = (u + r) * h),
      (t[14] = (o + e) * c),
      (t[15] = 1),
      t
    );
  }
  function In(t, n, a, r) {
    var u,
      e,
      o,
      i,
      h,
      c,
      s,
      f,
      l,
      v,
      b = n[0],
      m = n[1],
      d = n[2],
      x = r[0],
      y = r[1],
      p = r[2],
      q = a[0],
      w = a[1],
      g = a[2];
    return Math.abs(b - q) < M && Math.abs(m - w) < M && Math.abs(d - g) < M
      ? Kt(t)
      : ((s = b - q),
        (f = m - w),
        (l = d - g),
        (u = y * (l *= v = 1 / Math.hypot(s, f, l)) - p * (f *= v)),
        (e = p * (s *= v) - x * l),
        (o = x * f - y * s),
        (v = Math.hypot(u, e, o))
          ? ((u *= v = 1 / v), (e *= v), (o *= v))
          : ((u = 0), (e = 0), (o = 0)),
        (i = f * o - l * e),
        (h = l * u - s * o),
        (c = s * e - f * u),
        (v = Math.hypot(i, h, c))
          ? ((i *= v = 1 / v), (h *= v), (c *= v))
          : ((i = 0), (h = 0), (c = 0)),
        (t[0] = u),
        (t[1] = i),
        (t[2] = s),
        (t[3] = 0),
        (t[4] = e),
        (t[5] = h),
        (t[6] = f),
        (t[7] = 0),
        (t[8] = o),
        (t[9] = c),
        (t[10] = l),
        (t[11] = 0),
        (t[12] = -(u * b + e * m + o * d)),
        (t[13] = -(i * b + h * m + c * d)),
        (t[14] = -(s * b + f * m + l * d)),
        (t[15] = 1),
        t);
  }
  function En(t, n, a, r) {
    var u = n[0],
      e = n[1],
      o = n[2],
      i = r[0],
      h = r[1],
      c = r[2],
      s = u - a[0],
      M = e - a[1],
      f = o - a[2],
      l = s * s + M * M + f * f;
    l > 0 && ((s *= l = 1 / Math.sqrt(l)), (M *= l), (f *= l));
    var v = h * f - c * M,
      b = c * s - i * f,
      m = i * M - h * s;
    return (
      (l = v * v + b * b + m * m) > 0 &&
        ((v *= l = 1 / Math.sqrt(l)), (b *= l), (m *= l)),
      (t[0] = v),
      (t[1] = b),
      (t[2] = m),
      (t[3] = 0),
      (t[4] = M * m - f * b),
      (t[5] = f * v - s * m),
      (t[6] = s * b - M * v),
      (t[7] = 0),
      (t[8] = s),
      (t[9] = M),
      (t[10] = f),
      (t[11] = 0),
      (t[12] = u),
      (t[13] = e),
      (t[14] = o),
      (t[15] = 1),
      t
    );
  }
  function Dn(t) {
    return (
      "mat4(" +
      t[0] +
      ", " +
      t[1] +
      ", " +
      t[2] +
      ", " +
      t[3] +
      ", " +
      t[4] +
      ", " +
      t[5] +
      ", " +
      t[6] +
      ", " +
      t[7] +
      ", " +
      t[8] +
      ", " +
      t[9] +
      ", " +
      t[10] +
      ", " +
      t[11] +
      ", " +
      t[12] +
      ", " +
      t[13] +
      ", " +
      t[14] +
      ", " +
      t[15] +
      ")"
    );
  }
  function Fn(t) {
    return Math.hypot(
      t[0],
      t[1],
      t[3],
      t[4],
      t[5],
      t[6],
      t[7],
      t[8],
      t[9],
      t[10],
      t[11],
      t[12],
      t[13],
      t[14],
      t[15]
    );
  }
  function Ln(t, n, a) {
    return (
      (t[0] = n[0] + a[0]),
      (t[1] = n[1] + a[1]),
      (t[2] = n[2] + a[2]),
      (t[3] = n[3] + a[3]),
      (t[4] = n[4] + a[4]),
      (t[5] = n[5] + a[5]),
      (t[6] = n[6] + a[6]),
      (t[7] = n[7] + a[7]),
      (t[8] = n[8] + a[8]),
      (t[9] = n[9] + a[9]),
      (t[10] = n[10] + a[10]),
      (t[11] = n[11] + a[11]),
      (t[12] = n[12] + a[12]),
      (t[13] = n[13] + a[13]),
      (t[14] = n[14] + a[14]),
      (t[15] = n[15] + a[15]),
      t
    );
  }
  function Vn(t, n, a) {
    return (
      (t[0] = n[0] - a[0]),
      (t[1] = n[1] - a[1]),
      (t[2] = n[2] - a[2]),
      (t[3] = n[3] - a[3]),
      (t[4] = n[4] - a[4]),
      (t[5] = n[5] - a[5]),
      (t[6] = n[6] - a[6]),
      (t[7] = n[7] - a[7]),
      (t[8] = n[8] - a[8]),
      (t[9] = n[9] - a[9]),
      (t[10] = n[10] - a[10]),
      (t[11] = n[11] - a[11]),
      (t[12] = n[12] - a[12]),
      (t[13] = n[13] - a[13]),
      (t[14] = n[14] - a[14]),
      (t[15] = n[15] - a[15]),
      t
    );
  }
  function jn(t, n, a) {
    return (
      (t[0] = n[0] * a),
      (t[1] = n[1] * a),
      (t[2] = n[2] * a),
      (t[3] = n[3] * a),
      (t[4] = n[4] * a),
      (t[5] = n[5] * a),
      (t[6] = n[6] * a),
      (t[7] = n[7] * a),
      (t[8] = n[8] * a),
      (t[9] = n[9] * a),
      (t[10] = n[10] * a),
      (t[11] = n[11] * a),
      (t[12] = n[12] * a),
      (t[13] = n[13] * a),
      (t[14] = n[14] * a),
      (t[15] = n[15] * a),
      t
    );
  }
  function zn(t, n, a, r) {
    return (
      (t[0] = n[0] + a[0] * r),
      (t[1] = n[1] + a[1] * r),
      (t[2] = n[2] + a[2] * r),
      (t[3] = n[3] + a[3] * r),
      (t[4] = n[4] + a[4] * r),
      (t[5] = n[5] + a[5] * r),
      (t[6] = n[6] + a[6] * r),
      (t[7] = n[7] + a[7] * r),
      (t[8] = n[8] + a[8] * r),
      (t[9] = n[9] + a[9] * r),
      (t[10] = n[10] + a[10] * r),
      (t[11] = n[11] + a[11] * r),
      (t[12] = n[12] + a[12] * r),
      (t[13] = n[13] + a[13] * r),
      (t[14] = n[14] + a[14] * r),
      (t[15] = n[15] + a[15] * r),
      t
    );
  }
  function On(t, n) {
    return (
      t[0] === n[0] &&
      t[1] === n[1] &&
      t[2] === n[2] &&
      t[3] === n[3] &&
      t[4] === n[4] &&
      t[5] === n[5] &&
      t[6] === n[6] &&
      t[7] === n[7] &&
      t[8] === n[8] &&
      t[9] === n[9] &&
      t[10] === n[10] &&
      t[11] === n[11] &&
      t[12] === n[12] &&
      t[13] === n[13] &&
      t[14] === n[14] &&
      t[15] === n[15]
    );
  }
  function Qn(t, n) {
    var a = t[0],
      r = t[1],
      u = t[2],
      e = t[3],
      o = t[4],
      i = t[5],
      h = t[6],
      c = t[7],
      s = t[8],
      f = t[9],
      l = t[10],
      v = t[11],
      b = t[12],
      m = t[13],
      d = t[14],
      x = t[15],
      y = n[0],
      p = n[1],
      q = n[2],
      w = n[3],
      g = n[4],
      A = n[5],
      P = n[6],
      S = n[7],
      R = n[8],
      T = n[9],
      I = n[10],
      E = n[11],
      D = n[12],
      F = n[13],
      L = n[14],
      V = n[15];
    return (
      Math.abs(a - y) <= M * Math.max(1, Math.abs(a), Math.abs(y)) &&
      Math.abs(r - p) <= M * Math.max(1, Math.abs(r), Math.abs(p)) &&
      Math.abs(u - q) <= M * Math.max(1, Math.abs(u), Math.abs(q)) &&
      Math.abs(e - w) <= M * Math.max(1, Math.abs(e), Math.abs(w)) &&
      Math.abs(o - g) <= M * Math.max(1, Math.abs(o), Math.abs(g)) &&
      Math.abs(i - A) <= M * Math.max(1, Math.abs(i), Math.abs(A)) &&
      Math.abs(h - P) <= M * Math.max(1, Math.abs(h), Math.abs(P)) &&
      Math.abs(c - S) <= M * Math.max(1, Math.abs(c), Math.abs(S)) &&
      Math.abs(s - R) <= M * Math.max(1, Math.abs(s), Math.abs(R)) &&
      Math.abs(f - T) <= M * Math.max(1, Math.abs(f), Math.abs(T)) &&
      Math.abs(l - I) <= M * Math.max(1, Math.abs(l), Math.abs(I)) &&
      Math.abs(v - E) <= M * Math.max(1, Math.abs(v), Math.abs(E)) &&
      Math.abs(b - D) <= M * Math.max(1, Math.abs(b), Math.abs(D)) &&
      Math.abs(m - F) <= M * Math.max(1, Math.abs(m), Math.abs(F)) &&
      Math.abs(d - L) <= M * Math.max(1, Math.abs(d), Math.abs(L)) &&
      Math.abs(x - V) <= M * Math.max(1, Math.abs(x), Math.abs(V))
    );
  }
  var Yn = rn,
    Xn = Vn;
  function Zn() {
    var t = new f(3);
    return f != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)), t;
  }
  function _n(t) {
    var n = new f(3);
    return (n[0] = t[0]), (n[1] = t[1]), (n[2] = t[2]), n;
  }
  function Bn(t) {
    var n = t[0],
      a = t[1],
      r = t[2];
    return Math.hypot(n, a, r);
  }
  function Nn(t, n, a) {
    var r = new f(3);
    return (r[0] = t), (r[1] = n), (r[2] = a), r;
  }
  function kn(t, n) {
    return (t[0] = n[0]), (t[1] = n[1]), (t[2] = n[2]), t;
  }
  function Un(t, n, a, r) {
    return (t[0] = n), (t[1] = a), (t[2] = r), t;
  }
  function Wn(t, n, a) {
    return (t[0] = n[0] + a[0]), (t[1] = n[1] + a[1]), (t[2] = n[2] + a[2]), t;
  }
  function Cn(t, n, a) {
    return (t[0] = n[0] - a[0]), (t[1] = n[1] - a[1]), (t[2] = n[2] - a[2]), t;
  }
  function Gn(t, n, a) {
    return (t[0] = n[0] * a[0]), (t[1] = n[1] * a[1]), (t[2] = n[2] * a[2]), t;
  }
  function Hn(t, n, a) {
    return (t[0] = n[0] / a[0]), (t[1] = n[1] / a[1]), (t[2] = n[2] / a[2]), t;
  }
  function Jn(t, n) {
    return (
      (t[0] = Math.ceil(n[0])),
      (t[1] = Math.ceil(n[1])),
      (t[2] = Math.ceil(n[2])),
      t
    );
  }
  function Kn(t, n) {
    return (
      (t[0] = Math.floor(n[0])),
      (t[1] = Math.floor(n[1])),
      (t[2] = Math.floor(n[2])),
      t
    );
  }
  function $n(t, n, a) {
    return (
      (t[0] = Math.min(n[0], a[0])),
      (t[1] = Math.min(n[1], a[1])),
      (t[2] = Math.min(n[2], a[2])),
      t
    );
  }
  function ta(t, n, a) {
    return (
      (t[0] = Math.max(n[0], a[0])),
      (t[1] = Math.max(n[1], a[1])),
      (t[2] = Math.max(n[2], a[2])),
      t
    );
  }
  function na(t, n) {
    return (
      (t[0] = Math.round(n[0])),
      (t[1] = Math.round(n[1])),
      (t[2] = Math.round(n[2])),
      t
    );
  }
  function aa(t, n, a) {
    return (t[0] = n[0] * a), (t[1] = n[1] * a), (t[2] = n[2] * a), t;
  }
  function ra(t, n, a, r) {
    return (
      (t[0] = n[0] + a[0] * r),
      (t[1] = n[1] + a[1] * r),
      (t[2] = n[2] + a[2] * r),
      t
    );
  }
  function ua(t, n) {
    var a = n[0] - t[0],
      r = n[1] - t[1],
      u = n[2] - t[2];
    return Math.hypot(a, r, u);
  }
  function ea(t, n) {
    var a = n[0] - t[0],
      r = n[1] - t[1],
      u = n[2] - t[2];
    return a * a + r * r + u * u;
  }
  function oa(t) {
    var n = t[0],
      a = t[1],
      r = t[2];
    return n * n + a * a + r * r;
  }
  function ia(t, n) {
    return (t[0] = -n[0]), (t[1] = -n[1]), (t[2] = -n[2]), t;
  }
  function ha(t, n) {
    return (t[0] = 1 / n[0]), (t[1] = 1 / n[1]), (t[2] = 1 / n[2]), t;
  }
  function ca(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = a * a + r * r + u * u;
    return (
      e > 0 && (e = 1 / Math.sqrt(e)),
      (t[0] = n[0] * e),
      (t[1] = n[1] * e),
      (t[2] = n[2] * e),
      t
    );
  }
  function sa(t, n) {
    return t[0] * n[0] + t[1] * n[1] + t[2] * n[2];
  }
  function Ma(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = a[0],
      i = a[1],
      h = a[2];
    return (
      (t[0] = u * h - e * i), (t[1] = e * o - r * h), (t[2] = r * i - u * o), t
    );
  }
  function fa(t, n, a, r) {
    var u = n[0],
      e = n[1],
      o = n[2];
    return (
      (t[0] = u + r * (a[0] - u)),
      (t[1] = e + r * (a[1] - e)),
      (t[2] = o + r * (a[2] - o)),
      t
    );
  }
  function la(t, n, a, r, u, e) {
    var o = e * e,
      i = o * (2 * e - 3) + 1,
      h = o * (e - 2) + e,
      c = o * (e - 1),
      s = o * (3 - 2 * e);
    return (
      (t[0] = n[0] * i + a[0] * h + r[0] * c + u[0] * s),
      (t[1] = n[1] * i + a[1] * h + r[1] * c + u[1] * s),
      (t[2] = n[2] * i + a[2] * h + r[2] * c + u[2] * s),
      t
    );
  }
  function va(t, n, a, r, u, e) {
    var o = 1 - e,
      i = o * o,
      h = e * e,
      c = i * o,
      s = 3 * e * i,
      M = 3 * h * o,
      f = h * e;
    return (
      (t[0] = n[0] * c + a[0] * s + r[0] * M + u[0] * f),
      (t[1] = n[1] * c + a[1] * s + r[1] * M + u[1] * f),
      (t[2] = n[2] * c + a[2] * s + r[2] * M + u[2] * f),
      t
    );
  }
  function ba(t, n) {
    n = n || 1;
    var a = 2 * l() * Math.PI,
      r = 2 * l() - 1,
      u = Math.sqrt(1 - r * r) * n;
    return (
      (t[0] = Math.cos(a) * u), (t[1] = Math.sin(a) * u), (t[2] = r * n), t
    );
  }
  function ma(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = a[3] * r + a[7] * u + a[11] * e + a[15];
    return (
      (o = o || 1),
      (t[0] = (a[0] * r + a[4] * u + a[8] * e + a[12]) / o),
      (t[1] = (a[1] * r + a[5] * u + a[9] * e + a[13]) / o),
      (t[2] = (a[2] * r + a[6] * u + a[10] * e + a[14]) / o),
      t
    );
  }
  function da(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2];
    return (
      (t[0] = r * a[0] + u * a[3] + e * a[6]),
      (t[1] = r * a[1] + u * a[4] + e * a[7]),
      (t[2] = r * a[2] + u * a[5] + e * a[8]),
      t
    );
  }
  function xa(t, n, a) {
    var r = a[0],
      u = a[1],
      e = a[2],
      o = a[3],
      i = n[0],
      h = n[1],
      c = n[2],
      s = u * c - e * h,
      M = e * i - r * c,
      f = r * h - u * i,
      l = u * f - e * M,
      v = e * s - r * f,
      b = r * M - u * s,
      m = 2 * o;
    return (
      (s *= m),
      (M *= m),
      (f *= m),
      (l *= 2),
      (v *= 2),
      (b *= 2),
      (t[0] = i + s + l),
      (t[1] = h + M + v),
      (t[2] = c + f + b),
      t
    );
  }
  function ya(t, n, a, r) {
    var u = [],
      e = [];
    return (
      (u[0] = n[0] - a[0]),
      (u[1] = n[1] - a[1]),
      (u[2] = n[2] - a[2]),
      (e[0] = u[0]),
      (e[1] = u[1] * Math.cos(r) - u[2] * Math.sin(r)),
      (e[2] = u[1] * Math.sin(r) + u[2] * Math.cos(r)),
      (t[0] = e[0] + a[0]),
      (t[1] = e[1] + a[1]),
      (t[2] = e[2] + a[2]),
      t
    );
  }
  function pa(t, n, a, r) {
    var u = [],
      e = [];
    return (
      (u[0] = n[0] - a[0]),
      (u[1] = n[1] - a[1]),
      (u[2] = n[2] - a[2]),
      (e[0] = u[2] * Math.sin(r) + u[0] * Math.cos(r)),
      (e[1] = u[1]),
      (e[2] = u[2] * Math.cos(r) - u[0] * Math.sin(r)),
      (t[0] = e[0] + a[0]),
      (t[1] = e[1] + a[1]),
      (t[2] = e[2] + a[2]),
      t
    );
  }
  function qa(t, n, a, r) {
    var u = [],
      e = [];
    return (
      (u[0] = n[0] - a[0]),
      (u[1] = n[1] - a[1]),
      (u[2] = n[2] - a[2]),
      (e[0] = u[0] * Math.cos(r) - u[1] * Math.sin(r)),
      (e[1] = u[0] * Math.sin(r) + u[1] * Math.cos(r)),
      (e[2] = u[2]),
      (t[0] = e[0] + a[0]),
      (t[1] = e[1] + a[1]),
      (t[2] = e[2] + a[2]),
      t
    );
  }
  function wa(t, n) {
    var a = Nn(t[0], t[1], t[2]),
      r = Nn(n[0], n[1], n[2]);
    ca(a, a), ca(r, r);
    var u = sa(a, r);
    return u > 1 ? 0 : u < -1 ? Math.PI : Math.acos(u);
  }
  function ga(t) {
    return (t[0] = 0), (t[1] = 0), (t[2] = 0), t;
  }
  function Aa(t) {
    return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
  }
  function Pa(t, n) {
    return t[0] === n[0] && t[1] === n[1] && t[2] === n[2];
  }
  function Sa(t, n) {
    var a = t[0],
      r = t[1],
      u = t[2],
      e = n[0],
      o = n[1],
      i = n[2];
    return (
      Math.abs(a - e) <= M * Math.max(1, Math.abs(a), Math.abs(e)) &&
      Math.abs(r - o) <= M * Math.max(1, Math.abs(r), Math.abs(o)) &&
      Math.abs(u - i) <= M * Math.max(1, Math.abs(u), Math.abs(i))
    );
  }
  var Ra,
    Ta = Cn,
    Ia = Gn,
    Ea = Hn,
    Da = ua,
    Fa = ea,
    La = Bn,
    Va = oa,
    ja =
      ((Ra = Zn()),
      function (t, n, a, r, u, e) {
        var o, i;
        for (
          n || (n = 3),
            a || (a = 0),
            i = r ? Math.min(r * n + a, t.length) : t.length,
            o = a;
          o < i;
          o += n
        )
          (Ra[0] = t[o]),
            (Ra[1] = t[o + 1]),
            (Ra[2] = t[o + 2]),
            u(Ra, Ra, e),
            (t[o] = Ra[0]),
            (t[o + 1] = Ra[1]),
            (t[o + 2] = Ra[2]);
        return t;
      });
  function za() {
    var t = new f(4);
    return (
      f != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0), (t[3] = 0)), t
    );
  }
  function Oa(t) {
    var n = new f(4);
    return (n[0] = t[0]), (n[1] = t[1]), (n[2] = t[2]), (n[3] = t[3]), n;
  }
  function Qa(t, n, a, r) {
    var u = new f(4);
    return (u[0] = t), (u[1] = n), (u[2] = a), (u[3] = r), u;
  }
  function Ya(t, n) {
    return (t[0] = n[0]), (t[1] = n[1]), (t[2] = n[2]), (t[3] = n[3]), t;
  }
  function Xa(t, n, a, r, u) {
    return (t[0] = n), (t[1] = a), (t[2] = r), (t[3] = u), t;
  }
  function Za(t, n, a) {
    return (
      (t[0] = n[0] + a[0]),
      (t[1] = n[1] + a[1]),
      (t[2] = n[2] + a[2]),
      (t[3] = n[3] + a[3]),
      t
    );
  }
  function _a(t, n, a) {
    return (
      (t[0] = n[0] - a[0]),
      (t[1] = n[1] - a[1]),
      (t[2] = n[2] - a[2]),
      (t[3] = n[3] - a[3]),
      t
    );
  }
  function Ba(t, n, a) {
    return (
      (t[0] = n[0] * a[0]),
      (t[1] = n[1] * a[1]),
      (t[2] = n[2] * a[2]),
      (t[3] = n[3] * a[3]),
      t
    );
  }
  function Na(t, n, a) {
    return (
      (t[0] = n[0] / a[0]),
      (t[1] = n[1] / a[1]),
      (t[2] = n[2] / a[2]),
      (t[3] = n[3] / a[3]),
      t
    );
  }
  function ka(t, n) {
    return (
      (t[0] = Math.ceil(n[0])),
      (t[1] = Math.ceil(n[1])),
      (t[2] = Math.ceil(n[2])),
      (t[3] = Math.ceil(n[3])),
      t
    );
  }
  function Ua(t, n) {
    return (
      (t[0] = Math.floor(n[0])),
      (t[1] = Math.floor(n[1])),
      (t[2] = Math.floor(n[2])),
      (t[3] = Math.floor(n[3])),
      t
    );
  }
  function Wa(t, n, a) {
    return (
      (t[0] = Math.min(n[0], a[0])),
      (t[1] = Math.min(n[1], a[1])),
      (t[2] = Math.min(n[2], a[2])),
      (t[3] = Math.min(n[3], a[3])),
      t
    );
  }
  function Ca(t, n, a) {
    return (
      (t[0] = Math.max(n[0], a[0])),
      (t[1] = Math.max(n[1], a[1])),
      (t[2] = Math.max(n[2], a[2])),
      (t[3] = Math.max(n[3], a[3])),
      t
    );
  }
  function Ga(t, n) {
    return (
      (t[0] = Math.round(n[0])),
      (t[1] = Math.round(n[1])),
      (t[2] = Math.round(n[2])),
      (t[3] = Math.round(n[3])),
      t
    );
  }
  function Ha(t, n, a) {
    return (
      (t[0] = n[0] * a),
      (t[1] = n[1] * a),
      (t[2] = n[2] * a),
      (t[3] = n[3] * a),
      t
    );
  }
  function Ja(t, n, a, r) {
    return (
      (t[0] = n[0] + a[0] * r),
      (t[1] = n[1] + a[1] * r),
      (t[2] = n[2] + a[2] * r),
      (t[3] = n[3] + a[3] * r),
      t
    );
  }
  function Ka(t, n) {
    var a = n[0] - t[0],
      r = n[1] - t[1],
      u = n[2] - t[2],
      e = n[3] - t[3];
    return Math.hypot(a, r, u, e);
  }
  function $a(t, n) {
    var a = n[0] - t[0],
      r = n[1] - t[1],
      u = n[2] - t[2],
      e = n[3] - t[3];
    return a * a + r * r + u * u + e * e;
  }
  function tr(t) {
    var n = t[0],
      a = t[1],
      r = t[2],
      u = t[3];
    return Math.hypot(n, a, r, u);
  }
  function nr(t) {
    var n = t[0],
      a = t[1],
      r = t[2],
      u = t[3];
    return n * n + a * a + r * r + u * u;
  }
  function ar(t, n) {
    return (t[0] = -n[0]), (t[1] = -n[1]), (t[2] = -n[2]), (t[3] = -n[3]), t;
  }
  function rr(t, n) {
    return (
      (t[0] = 1 / n[0]),
      (t[1] = 1 / n[1]),
      (t[2] = 1 / n[2]),
      (t[3] = 1 / n[3]),
      t
    );
  }
  function ur(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[3],
      o = a * a + r * r + u * u + e * e;
    return (
      o > 0 && (o = 1 / Math.sqrt(o)),
      (t[0] = a * o),
      (t[1] = r * o),
      (t[2] = u * o),
      (t[3] = e * o),
      t
    );
  }
  function er(t, n) {
    return t[0] * n[0] + t[1] * n[1] + t[2] * n[2] + t[3] * n[3];
  }
  function or(t, n, a, r) {
    var u = a[0] * r[1] - a[1] * r[0],
      e = a[0] * r[2] - a[2] * r[0],
      o = a[0] * r[3] - a[3] * r[0],
      i = a[1] * r[2] - a[2] * r[1],
      h = a[1] * r[3] - a[3] * r[1],
      c = a[2] * r[3] - a[3] * r[2],
      s = n[0],
      M = n[1],
      f = n[2],
      l = n[3];
    return (
      (t[0] = M * c - f * h + l * i),
      (t[1] = -s * c + f * o - l * e),
      (t[2] = s * h - M * o + l * u),
      (t[3] = -s * i + M * e - f * u),
      t
    );
  }
  function ir(t, n, a, r) {
    var u = n[0],
      e = n[1],
      o = n[2],
      i = n[3];
    return (
      (t[0] = u + r * (a[0] - u)),
      (t[1] = e + r * (a[1] - e)),
      (t[2] = o + r * (a[2] - o)),
      (t[3] = i + r * (a[3] - i)),
      t
    );
  }
  function hr(t, n) {
    var a, r, u, e, o, i;
    n = n || 1;
    do {
      o = (a = 2 * l() - 1) * a + (r = 2 * l() - 1) * r;
    } while (o >= 1);
    do {
      i = (u = 2 * l() - 1) * u + (e = 2 * l() - 1) * e;
    } while (i >= 1);
    var h = Math.sqrt((1 - o) / i);
    return (
      (t[0] = n * a), (t[1] = n * r), (t[2] = n * u * h), (t[3] = n * e * h), t
    );
  }
  function cr(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3];
    return (
      (t[0] = a[0] * r + a[4] * u + a[8] * e + a[12] * o),
      (t[1] = a[1] * r + a[5] * u + a[9] * e + a[13] * o),
      (t[2] = a[2] * r + a[6] * u + a[10] * e + a[14] * o),
      (t[3] = a[3] * r + a[7] * u + a[11] * e + a[15] * o),
      t
    );
  }
  function sr(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = a[0],
      i = a[1],
      h = a[2],
      c = a[3],
      s = c * r + i * e - h * u,
      M = c * u + h * r - o * e,
      f = c * e + o * u - i * r,
      l = -o * r - i * u - h * e;
    return (
      (t[0] = s * c + l * -o + M * -h - f * -i),
      (t[1] = M * c + l * -i + f * -o - s * -h),
      (t[2] = f * c + l * -h + s * -i - M * -o),
      (t[3] = n[3]),
      t
    );
  }
  function Mr(t) {
    return (t[0] = 0), (t[1] = 0), (t[2] = 0), (t[3] = 0), t;
  }
  function fr(t) {
    return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
  }
  function lr(t, n) {
    return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3];
  }
  function vr(t, n) {
    var a = t[0],
      r = t[1],
      u = t[2],
      e = t[3],
      o = n[0],
      i = n[1],
      h = n[2],
      c = n[3];
    return (
      Math.abs(a - o) <= M * Math.max(1, Math.abs(a), Math.abs(o)) &&
      Math.abs(r - i) <= M * Math.max(1, Math.abs(r), Math.abs(i)) &&
      Math.abs(u - h) <= M * Math.max(1, Math.abs(u), Math.abs(h)) &&
      Math.abs(e - c) <= M * Math.max(1, Math.abs(e), Math.abs(c))
    );
  }
  var br = _a,
    mr = Ba,
    dr = Na,
    xr = Ka,
    yr = $a,
    pr = tr,
    qr = nr,
    wr = (function () {
      var t = za();
      return function (n, a, r, u, e, o) {
        var i, h;
        for (
          a || (a = 4),
            r || (r = 0),
            h = u ? Math.min(u * a + r, n.length) : n.length,
            i = r;
          i < h;
          i += a
        )
          (t[0] = n[i]),
            (t[1] = n[i + 1]),
            (t[2] = n[i + 2]),
            (t[3] = n[i + 3]),
            e(t, t, o),
            (n[i] = t[0]),
            (n[i + 1] = t[1]),
            (n[i + 2] = t[2]),
            (n[i + 3] = t[3]);
        return n;
      };
    })();
  function gr() {
    var t = new f(4);
    return (
      f != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)), (t[3] = 1), t
    );
  }
  function Ar(t) {
    return (t[0] = 0), (t[1] = 0), (t[2] = 0), (t[3] = 1), t;
  }
  function Pr(t, n, a) {
    a *= 0.5;
    var r = Math.sin(a);
    return (
      (t[0] = r * n[0]),
      (t[1] = r * n[1]),
      (t[2] = r * n[2]),
      (t[3] = Math.cos(a)),
      t
    );
  }
  function Sr(t, n) {
    var a = 2 * Math.acos(n[3]),
      r = Math.sin(a / 2);
    return (
      r > M
        ? ((t[0] = n[0] / r), (t[1] = n[1] / r), (t[2] = n[2] / r))
        : ((t[0] = 1), (t[1] = 0), (t[2] = 0)),
      a
    );
  }
  function Rr(t, n) {
    var a = au(t, n);
    return Math.acos(2 * a * a - 1);
  }
  function Tr(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = a[0],
      h = a[1],
      c = a[2],
      s = a[3];
    return (
      (t[0] = r * s + o * i + u * c - e * h),
      (t[1] = u * s + o * h + e * i - r * c),
      (t[2] = e * s + o * c + r * h - u * i),
      (t[3] = o * s - r * i - u * h - e * c),
      t
    );
  }
  function Ir(t, n, a) {
    a *= 0.5;
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = Math.sin(a),
      h = Math.cos(a);
    return (
      (t[0] = r * h + o * i),
      (t[1] = u * h + e * i),
      (t[2] = e * h - u * i),
      (t[3] = o * h - r * i),
      t
    );
  }
  function Er(t, n, a) {
    a *= 0.5;
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = Math.sin(a),
      h = Math.cos(a);
    return (
      (t[0] = r * h - e * i),
      (t[1] = u * h + o * i),
      (t[2] = e * h + r * i),
      (t[3] = o * h - u * i),
      t
    );
  }
  function Dr(t, n, a) {
    a *= 0.5;
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = Math.sin(a),
      h = Math.cos(a);
    return (
      (t[0] = r * h + u * i),
      (t[1] = u * h - r * i),
      (t[2] = e * h + o * i),
      (t[3] = o * h - e * i),
      t
    );
  }
  function Fr(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2];
    return (
      (t[0] = a),
      (t[1] = r),
      (t[2] = u),
      (t[3] = Math.sqrt(Math.abs(1 - a * a - r * r - u * u))),
      t
    );
  }
  function Lr(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[3],
      o = Math.sqrt(a * a + r * r + u * u),
      i = Math.exp(e),
      h = o > 0 ? (i * Math.sin(o)) / o : 0;
    return (
      (t[0] = a * h),
      (t[1] = r * h),
      (t[2] = u * h),
      (t[3] = i * Math.cos(o)),
      t
    );
  }
  function Vr(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[3],
      o = Math.sqrt(a * a + r * r + u * u),
      i = o > 0 ? Math.atan2(o, e) / o : 0;
    return (
      (t[0] = a * i),
      (t[1] = r * i),
      (t[2] = u * i),
      (t[3] = 0.5 * Math.log(a * a + r * r + u * u + e * e)),
      t
    );
  }
  function jr(t, n, a) {
    return Vr(t, n), nu(t, t, a), Lr(t, t), t;
  }
  function zr(t, n, a, r) {
    var u,
      e,
      o,
      i,
      h,
      c = n[0],
      s = n[1],
      f = n[2],
      l = n[3],
      v = a[0],
      b = a[1],
      m = a[2],
      d = a[3];
    return (
      (e = c * v + s * b + f * m + l * d) < 0 &&
        ((e = -e), (v = -v), (b = -b), (m = -m), (d = -d)),
      1 - e > M
        ? ((u = Math.acos(e)),
          (o = Math.sin(u)),
          (i = Math.sin((1 - r) * u) / o),
          (h = Math.sin(r * u) / o))
        : ((i = 1 - r), (h = r)),
      (t[0] = i * c + h * v),
      (t[1] = i * s + h * b),
      (t[2] = i * f + h * m),
      (t[3] = i * l + h * d),
      t
    );
  }
  function Or(t) {
    var n = l(),
      a = l(),
      r = l(),
      u = Math.sqrt(1 - n),
      e = Math.sqrt(n);
    return (
      (t[0] = u * Math.sin(2 * Math.PI * a)),
      (t[1] = u * Math.cos(2 * Math.PI * a)),
      (t[2] = e * Math.sin(2 * Math.PI * r)),
      (t[3] = e * Math.cos(2 * Math.PI * r)),
      t
    );
  }
  function Qr(t, n) {
    var a = n[0],
      r = n[1],
      u = n[2],
      e = n[3],
      o = a * a + r * r + u * u + e * e,
      i = o ? 1 / o : 0;
    return (t[0] = -a * i), (t[1] = -r * i), (t[2] = -u * i), (t[3] = e * i), t;
  }
  function Yr(t, n) {
    return (t[0] = -n[0]), (t[1] = -n[1]), (t[2] = -n[2]), (t[3] = n[3]), t;
  }
  function Xr(t, n) {
    var a,
      r = n[0] + n[4] + n[8];
    if (r > 0)
      (a = Math.sqrt(r + 1)),
        (t[3] = 0.5 * a),
        (a = 0.5 / a),
        (t[0] = (n[5] - n[7]) * a),
        (t[1] = (n[6] - n[2]) * a),
        (t[2] = (n[1] - n[3]) * a);
    else {
      var u = 0;
      n[4] > n[0] && (u = 1), n[8] > n[3 * u + u] && (u = 2);
      var e = (u + 1) % 3,
        o = (u + 2) % 3;
      (a = Math.sqrt(n[3 * u + u] - n[3 * e + e] - n[3 * o + o] + 1)),
        (t[u] = 0.5 * a),
        (a = 0.5 / a),
        (t[3] = (n[3 * e + o] - n[3 * o + e]) * a),
        (t[e] = (n[3 * e + u] + n[3 * u + e]) * a),
        (t[o] = (n[3 * o + u] + n[3 * u + o]) * a);
    }
    return t;
  }
  function Zr(t, n, a, r) {
    var u = (0.5 * Math.PI) / 180;
    (n *= u), (a *= u), (r *= u);
    var e = Math.sin(n),
      o = Math.cos(n),
      i = Math.sin(a),
      h = Math.cos(a),
      c = Math.sin(r),
      s = Math.cos(r);
    return (
      (t[0] = e * h * s - o * i * c),
      (t[1] = o * i * s + e * h * c),
      (t[2] = o * h * c - e * i * s),
      (t[3] = o * h * s + e * i * c),
      t
    );
  }
  function _r(t) {
    return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
  }
  var Br,
    Nr,
    kr,
    Ur,
    Wr,
    Cr,
    Gr = Oa,
    Hr = Qa,
    Jr = Ya,
    Kr = Xa,
    $r = Za,
    tu = Tr,
    nu = Ha,
    au = er,
    ru = ir,
    uu = tr,
    eu = uu,
    ou = nr,
    iu = ou,
    hu = ur,
    cu = lr,
    su = vr,
    Mu =
      ((Br = Zn()),
      (Nr = Nn(1, 0, 0)),
      (kr = Nn(0, 1, 0)),
      function (t, n, a) {
        var r = sa(n, a);
        return r < -0.999999
          ? (Ma(Br, Nr, n),
            La(Br) < 1e-6 && Ma(Br, kr, n),
            ca(Br, Br),
            Pr(t, Br, Math.PI),
            t)
          : r > 0.999999
          ? ((t[0] = 0), (t[1] = 0), (t[2] = 0), (t[3] = 1), t)
          : (Ma(Br, n, a),
            (t[0] = Br[0]),
            (t[1] = Br[1]),
            (t[2] = Br[2]),
            (t[3] = 1 + r),
            hu(t, t));
      }),
    fu =
      ((Ur = gr()),
      (Wr = gr()),
      function (t, n, a, r, u, e) {
        return (
          zr(Ur, n, u, e), zr(Wr, a, r, e), zr(t, Ur, Wr, 2 * e * (1 - e)), t
        );
      }),
    lu =
      ((Cr = bt()),
      function (t, n, a, r) {
        return (
          (Cr[0] = a[0]),
          (Cr[3] = a[1]),
          (Cr[6] = a[2]),
          (Cr[1] = r[0]),
          (Cr[4] = r[1]),
          (Cr[7] = r[2]),
          (Cr[2] = -n[0]),
          (Cr[5] = -n[1]),
          (Cr[8] = -n[2]),
          hu(t, Xr(t, Cr))
        );
      });
  function vu() {
    var t = new f(8);
    return (
      f != Float32Array &&
        ((t[0] = 0),
        (t[1] = 0),
        (t[2] = 0),
        (t[4] = 0),
        (t[5] = 0),
        (t[6] = 0),
        (t[7] = 0)),
      (t[3] = 1),
      t
    );
  }
  function bu(t) {
    var n = new f(8);
    return (
      (n[0] = t[0]),
      (n[1] = t[1]),
      (n[2] = t[2]),
      (n[3] = t[3]),
      (n[4] = t[4]),
      (n[5] = t[5]),
      (n[6] = t[6]),
      (n[7] = t[7]),
      n
    );
  }
  function mu(t, n, a, r, u, e, o, i) {
    var h = new f(8);
    return (
      (h[0] = t),
      (h[1] = n),
      (h[2] = a),
      (h[3] = r),
      (h[4] = u),
      (h[5] = e),
      (h[6] = o),
      (h[7] = i),
      h
    );
  }
  function du(t, n, a, r, u, e, o) {
    var i = new f(8);
    (i[0] = t), (i[1] = n), (i[2] = a), (i[3] = r);
    var h = 0.5 * u,
      c = 0.5 * e,
      s = 0.5 * o;
    return (
      (i[4] = h * r + c * a - s * n),
      (i[5] = c * r + s * t - h * a),
      (i[6] = s * r + h * n - c * t),
      (i[7] = -h * t - c * n - s * a),
      i
    );
  }
  function xu(t, n, a) {
    var r = 0.5 * a[0],
      u = 0.5 * a[1],
      e = 0.5 * a[2],
      o = n[0],
      i = n[1],
      h = n[2],
      c = n[3];
    return (
      (t[0] = o),
      (t[1] = i),
      (t[2] = h),
      (t[3] = c),
      (t[4] = r * c + u * h - e * i),
      (t[5] = u * c + e * o - r * h),
      (t[6] = e * c + r * i - u * o),
      (t[7] = -r * o - u * i - e * h),
      t
    );
  }
  function yu(t, n) {
    return (
      (t[0] = 0),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 1),
      (t[4] = 0.5 * n[0]),
      (t[5] = 0.5 * n[1]),
      (t[6] = 0.5 * n[2]),
      (t[7] = 0),
      t
    );
  }
  function pu(t, n) {
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = 0),
      (t[5] = 0),
      (t[6] = 0),
      (t[7] = 0),
      t
    );
  }
  function qu(t, n) {
    var a = gr();
    qn(a, n);
    var r = new f(3);
    return yn(r, n), xu(t, a, r), t;
  }
  function wu(t, n) {
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      t
    );
  }
  function gu(t) {
    return (
      (t[0] = 0),
      (t[1] = 0),
      (t[2] = 0),
      (t[3] = 1),
      (t[4] = 0),
      (t[5] = 0),
      (t[6] = 0),
      (t[7] = 0),
      t
    );
  }
  function Au(t, n, a, r, u, e, o, i, h) {
    return (
      (t[0] = n),
      (t[1] = a),
      (t[2] = r),
      (t[3] = u),
      (t[4] = e),
      (t[5] = o),
      (t[6] = i),
      (t[7] = h),
      t
    );
  }
  var Pu = Jr;
  function Su(t, n) {
    return (t[0] = n[4]), (t[1] = n[5]), (t[2] = n[6]), (t[3] = n[7]), t;
  }
  var Ru = Jr;
  function Tu(t, n) {
    return (t[4] = n[0]), (t[5] = n[1]), (t[6] = n[2]), (t[7] = n[3]), t;
  }
  function Iu(t, n) {
    var a = n[4],
      r = n[5],
      u = n[6],
      e = n[7],
      o = -n[0],
      i = -n[1],
      h = -n[2],
      c = n[3];
    return (
      (t[0] = 2 * (a * c + e * o + r * h - u * i)),
      (t[1] = 2 * (r * c + e * i + u * o - a * h)),
      (t[2] = 2 * (u * c + e * h + a * i - r * o)),
      t
    );
  }
  function Eu(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = 0.5 * a[0],
      h = 0.5 * a[1],
      c = 0.5 * a[2],
      s = n[4],
      M = n[5],
      f = n[6],
      l = n[7];
    return (
      (t[0] = r),
      (t[1] = u),
      (t[2] = e),
      (t[3] = o),
      (t[4] = o * i + u * c - e * h + s),
      (t[5] = o * h + e * i - r * c + M),
      (t[6] = o * c + r * h - u * i + f),
      (t[7] = -r * i - u * h - e * c + l),
      t
    );
  }
  function Du(t, n, a) {
    var r = -n[0],
      u = -n[1],
      e = -n[2],
      o = n[3],
      i = n[4],
      h = n[5],
      c = n[6],
      s = n[7],
      M = i * o + s * r + h * e - c * u,
      f = h * o + s * u + c * r - i * e,
      l = c * o + s * e + i * u - h * r,
      v = s * o - i * r - h * u - c * e;
    return (
      Ir(t, n, a),
      (r = t[0]),
      (u = t[1]),
      (e = t[2]),
      (o = t[3]),
      (t[4] = M * o + v * r + f * e - l * u),
      (t[5] = f * o + v * u + l * r - M * e),
      (t[6] = l * o + v * e + M * u - f * r),
      (t[7] = v * o - M * r - f * u - l * e),
      t
    );
  }
  function Fu(t, n, a) {
    var r = -n[0],
      u = -n[1],
      e = -n[2],
      o = n[3],
      i = n[4],
      h = n[5],
      c = n[6],
      s = n[7],
      M = i * o + s * r + h * e - c * u,
      f = h * o + s * u + c * r - i * e,
      l = c * o + s * e + i * u - h * r,
      v = s * o - i * r - h * u - c * e;
    return (
      Er(t, n, a),
      (r = t[0]),
      (u = t[1]),
      (e = t[2]),
      (o = t[3]),
      (t[4] = M * o + v * r + f * e - l * u),
      (t[5] = f * o + v * u + l * r - M * e),
      (t[6] = l * o + v * e + M * u - f * r),
      (t[7] = v * o - M * r - f * u - l * e),
      t
    );
  }
  function Lu(t, n, a) {
    var r = -n[0],
      u = -n[1],
      e = -n[2],
      o = n[3],
      i = n[4],
      h = n[5],
      c = n[6],
      s = n[7],
      M = i * o + s * r + h * e - c * u,
      f = h * o + s * u + c * r - i * e,
      l = c * o + s * e + i * u - h * r,
      v = s * o - i * r - h * u - c * e;
    return (
      Dr(t, n, a),
      (r = t[0]),
      (u = t[1]),
      (e = t[2]),
      (o = t[3]),
      (t[4] = M * o + v * r + f * e - l * u),
      (t[5] = f * o + v * u + l * r - M * e),
      (t[6] = l * o + v * e + M * u - f * r),
      (t[7] = v * o - M * r - f * u - l * e),
      t
    );
  }
  function Vu(t, n, a) {
    var r = a[0],
      u = a[1],
      e = a[2],
      o = a[3],
      i = n[0],
      h = n[1],
      c = n[2],
      s = n[3];
    return (
      (t[0] = i * o + s * r + h * e - c * u),
      (t[1] = h * o + s * u + c * r - i * e),
      (t[2] = c * o + s * e + i * u - h * r),
      (t[3] = s * o - i * r - h * u - c * e),
      (i = n[4]),
      (h = n[5]),
      (c = n[6]),
      (s = n[7]),
      (t[4] = i * o + s * r + h * e - c * u),
      (t[5] = h * o + s * u + c * r - i * e),
      (t[6] = c * o + s * e + i * u - h * r),
      (t[7] = s * o - i * r - h * u - c * e),
      t
    );
  }
  function ju(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = a[0],
      h = a[1],
      c = a[2],
      s = a[3];
    return (
      (t[0] = r * s + o * i + u * c - e * h),
      (t[1] = u * s + o * h + e * i - r * c),
      (t[2] = e * s + o * c + r * h - u * i),
      (t[3] = o * s - r * i - u * h - e * c),
      (i = a[4]),
      (h = a[5]),
      (c = a[6]),
      (s = a[7]),
      (t[4] = r * s + o * i + u * c - e * h),
      (t[5] = u * s + o * h + e * i - r * c),
      (t[6] = e * s + o * c + r * h - u * i),
      (t[7] = o * s - r * i - u * h - e * c),
      t
    );
  }
  function zu(t, n, a, r) {
    if (Math.abs(r) < M) return wu(t, n);
    var u = Math.hypot(a[0], a[1], a[2]);
    r *= 0.5;
    var e = Math.sin(r),
      o = (e * a[0]) / u,
      i = (e * a[1]) / u,
      h = (e * a[2]) / u,
      c = Math.cos(r),
      s = n[0],
      f = n[1],
      l = n[2],
      v = n[3];
    (t[0] = s * c + v * o + f * h - l * i),
      (t[1] = f * c + v * i + l * o - s * h),
      (t[2] = l * c + v * h + s * i - f * o),
      (t[3] = v * c - s * o - f * i - l * h);
    var b = n[4],
      m = n[5],
      d = n[6],
      x = n[7];
    return (
      (t[4] = b * c + x * o + m * h - d * i),
      (t[5] = m * c + x * i + d * o - b * h),
      (t[6] = d * c + x * h + b * i - m * o),
      (t[7] = x * c - b * o - m * i - d * h),
      t
    );
  }
  function Ou(t, n, a) {
    return (
      (t[0] = n[0] + a[0]),
      (t[1] = n[1] + a[1]),
      (t[2] = n[2] + a[2]),
      (t[3] = n[3] + a[3]),
      (t[4] = n[4] + a[4]),
      (t[5] = n[5] + a[5]),
      (t[6] = n[6] + a[6]),
      (t[7] = n[7] + a[7]),
      t
    );
  }
  function Qu(t, n, a) {
    var r = n[0],
      u = n[1],
      e = n[2],
      o = n[3],
      i = a[4],
      h = a[5],
      c = a[6],
      s = a[7],
      M = n[4],
      f = n[5],
      l = n[6],
      v = n[7],
      b = a[0],
      m = a[1],
      d = a[2],
      x = a[3];
    return (
      (t[0] = r * x + o * b + u * d - e * m),
      (t[1] = u * x + o * m + e * b - r * d),
      (t[2] = e * x + o * d + r * m - u * b),
      (t[3] = o * x - r * b - u * m - e * d),
      (t[4] = r * s + o * i + u * c - e * h + M * x + v * b + f * d - l * m),
      (t[5] = u * s + o * h + e * i - r * c + f * x + v * m + l * b - M * d),
      (t[6] = e * s + o * c + r * h - u * i + l * x + v * d + M * m - f * b),
      (t[7] = o * s - r * i - u * h - e * c + v * x - M * b - f * m - l * d),
      t
    );
  }
  var Yu = Qu;
  function Xu(t, n, a) {
    return (
      (t[0] = n[0] * a),
      (t[1] = n[1] * a),
      (t[2] = n[2] * a),
      (t[3] = n[3] * a),
      (t[4] = n[4] * a),
      (t[5] = n[5] * a),
      (t[6] = n[6] * a),
      (t[7] = n[7] * a),
      t
    );
  }
  var Zu = au;
  function _u(t, n, a, r) {
    var u = 1 - r;
    return (
      Zu(n, a) < 0 && (r = -r),
      (t[0] = n[0] * u + a[0] * r),
      (t[1] = n[1] * u + a[1] * r),
      (t[2] = n[2] * u + a[2] * r),
      (t[3] = n[3] * u + a[3] * r),
      (t[4] = n[4] * u + a[4] * r),
      (t[5] = n[5] * u + a[5] * r),
      (t[6] = n[6] * u + a[6] * r),
      (t[7] = n[7] * u + a[7] * r),
      t
    );
  }
  function Bu(t, n) {
    var a = Wu(n);
    return (
      (t[0] = -n[0] / a),
      (t[1] = -n[1] / a),
      (t[2] = -n[2] / a),
      (t[3] = n[3] / a),
      (t[4] = -n[4] / a),
      (t[5] = -n[5] / a),
      (t[6] = -n[6] / a),
      (t[7] = n[7] / a),
      t
    );
  }
  function Nu(t, n) {
    return (
      (t[0] = -n[0]),
      (t[1] = -n[1]),
      (t[2] = -n[2]),
      (t[3] = n[3]),
      (t[4] = -n[4]),
      (t[5] = -n[5]),
      (t[6] = -n[6]),
      (t[7] = n[7]),
      t
    );
  }
  var ku = uu,
    Uu = ku,
    Wu = ou,
    Cu = Wu;
  function Gu(t, n) {
    var a = Wu(n);
    if (a > 0) {
      a = Math.sqrt(a);
      var r = n[0] / a,
        u = n[1] / a,
        e = n[2] / a,
        o = n[3] / a,
        i = n[4],
        h = n[5],
        c = n[6],
        s = n[7],
        M = r * i + u * h + e * c + o * s;
      (t[0] = r),
        (t[1] = u),
        (t[2] = e),
        (t[3] = o),
        (t[4] = (i - r * M) / a),
        (t[5] = (h - u * M) / a),
        (t[6] = (c - e * M) / a),
        (t[7] = (s - o * M) / a);
    }
    return t;
  }
  function Hu(t) {
    return (
      "quat2(" +
      t[0] +
      ", " +
      t[1] +
      ", " +
      t[2] +
      ", " +
      t[3] +
      ", " +
      t[4] +
      ", " +
      t[5] +
      ", " +
      t[6] +
      ", " +
      t[7] +
      ")"
    );
  }
  function Ju(t, n) {
    return (
      t[0] === n[0] &&
      t[1] === n[1] &&
      t[2] === n[2] &&
      t[3] === n[3] &&
      t[4] === n[4] &&
      t[5] === n[5] &&
      t[6] === n[6] &&
      t[7] === n[7]
    );
  }
  function Ku(t, n) {
    var a = t[0],
      r = t[1],
      u = t[2],
      e = t[3],
      o = t[4],
      i = t[5],
      h = t[6],
      c = t[7],
      s = n[0],
      f = n[1],
      l = n[2],
      v = n[3],
      b = n[4],
      m = n[5],
      d = n[6],
      x = n[7];
    return (
      Math.abs(a - s) <= M * Math.max(1, Math.abs(a), Math.abs(s)) &&
      Math.abs(r - f) <= M * Math.max(1, Math.abs(r), Math.abs(f)) &&
      Math.abs(u - l) <= M * Math.max(1, Math.abs(u), Math.abs(l)) &&
      Math.abs(e - v) <= M * Math.max(1, Math.abs(e), Math.abs(v)) &&
      Math.abs(o - b) <= M * Math.max(1, Math.abs(o), Math.abs(b)) &&
      Math.abs(i - m) <= M * Math.max(1, Math.abs(i), Math.abs(m)) &&
      Math.abs(h - d) <= M * Math.max(1, Math.abs(h), Math.abs(d)) &&
      Math.abs(c - x) <= M * Math.max(1, Math.abs(c), Math.abs(x))
    );
  }
  function $u() {
    var t = new f(2);
    return f != Float32Array && ((t[0] = 0), (t[1] = 0)), t;
  }
  function te(t) {
    var n = new f(2);
    return (n[0] = t[0]), (n[1] = t[1]), n;
  }
  function ne(t, n) {
    var a = new f(2);
    return (a[0] = t), (a[1] = n), a;
  }
  function ae(t, n) {
    return (t[0] = n[0]), (t[1] = n[1]), t;
  }
  function re(t, n, a) {
    return (t[0] = n), (t[1] = a), t;
  }
  function ue(t, n, a) {
    return (t[0] = n[0] + a[0]), (t[1] = n[1] + a[1]), t;
  }
  function ee(t, n, a) {
    return (t[0] = n[0] - a[0]), (t[1] = n[1] - a[1]), t;
  }
  function oe(t, n, a) {
    return (t[0] = n[0] * a[0]), (t[1] = n[1] * a[1]), t;
  }
  function ie(t, n, a) {
    return (t[0] = n[0] / a[0]), (t[1] = n[1] / a[1]), t;
  }
  function he(t, n) {
    return (t[0] = Math.ceil(n[0])), (t[1] = Math.ceil(n[1])), t;
  }
  function ce(t, n) {
    return (t[0] = Math.floor(n[0])), (t[1] = Math.floor(n[1])), t;
  }
  function se(t, n, a) {
    return (t[0] = Math.min(n[0], a[0])), (t[1] = Math.min(n[1], a[1])), t;
  }
  function Me(t, n, a) {
    return (t[0] = Math.max(n[0], a[0])), (t[1] = Math.max(n[1], a[1])), t;
  }
  function fe(t, n) {
    return (t[0] = Math.round(n[0])), (t[1] = Math.round(n[1])), t;
  }
  function le(t, n, a) {
    return (t[0] = n[0] * a), (t[1] = n[1] * a), t;
  }
  function ve(t, n, a, r) {
    return (t[0] = n[0] + a[0] * r), (t[1] = n[1] + a[1] * r), t;
  }
  function be(t, n) {
    var a = n[0] - t[0],
      r = n[1] - t[1];
    return Math.hypot(a, r);
  }
  function me(t, n) {
    var a = n[0] - t[0],
      r = n[1] - t[1];
    return a * a + r * r;
  }
  function de(t) {
    var n = t[0],
      a = t[1];
    return Math.hypot(n, a);
  }
  function xe(t) {
    var n = t[0],
      a = t[1];
    return n * n + a * a;
  }
  function ye(t, n) {
    return (t[0] = -n[0]), (t[1] = -n[1]), t;
  }
  function pe(t, n) {
    return (t[0] = 1 / n[0]), (t[1] = 1 / n[1]), t;
  }
  function qe(t, n) {
    var a = n[0],
      r = n[1],
      u = a * a + r * r;
    return (
      u > 0 && (u = 1 / Math.sqrt(u)), (t[0] = n[0] * u), (t[1] = n[1] * u), t
    );
  }
  function we(t, n) {
    return t[0] * n[0] + t[1] * n[1];
  }
  function ge(t, n, a) {
    var r = n[0] * a[1] - n[1] * a[0];
    return (t[0] = t[1] = 0), (t[2] = r), t;
  }
  function Ae(t, n, a, r) {
    var u = n[0],
      e = n[1];
    return (t[0] = u + r * (a[0] - u)), (t[1] = e + r * (a[1] - e)), t;
  }
  function Pe(t, n) {
    n = n || 1;
    var a = 2 * l() * Math.PI;
    return (t[0] = Math.cos(a) * n), (t[1] = Math.sin(a) * n), t;
  }
  function Se(t, n, a) {
    var r = n[0],
      u = n[1];
    return (t[0] = a[0] * r + a[2] * u), (t[1] = a[1] * r + a[3] * u), t;
  }
  function Re(t, n, a) {
    var r = n[0],
      u = n[1];
    return (
      (t[0] = a[0] * r + a[2] * u + a[4]),
      (t[1] = a[1] * r + a[3] * u + a[5]),
      t
    );
  }
  function Te(t, n, a) {
    var r = n[0],
      u = n[1];
    return (
      (t[0] = a[0] * r + a[3] * u + a[6]),
      (t[1] = a[1] * r + a[4] * u + a[7]),
      t
    );
  }
  function Ie(t, n, a) {
    var r = n[0],
      u = n[1];
    return (
      (t[0] = a[0] * r + a[4] * u + a[12]),
      (t[1] = a[1] * r + a[5] * u + a[13]),
      t
    );
  }
  function Ee(t, n, a, r) {
    var u = n[0] - a[0],
      e = n[1] - a[1],
      o = Math.sin(r),
      i = Math.cos(r);
    return (t[0] = u * i - e * o + a[0]), (t[1] = u * o + e * i + a[1]), t;
  }
  function De(t, n) {
    var a = t[0],
      r = t[1],
      u = n[0],
      e = n[1],
      o = a * a + r * r;
    o > 0 && (o = 1 / Math.sqrt(o));
    var i = u * u + e * e;
    i > 0 && (i = 1 / Math.sqrt(i));
    var h = (a * u + r * e) * o * i;
    return h > 1 ? 0 : h < -1 ? Math.PI : Math.acos(h);
  }
  function Fe(t) {
    return (t[0] = 0), (t[1] = 0), t;
  }
  function Le(t) {
    return "vec2(" + t[0] + ", " + t[1] + ")";
  }
  function Ve(t, n) {
    return t[0] === n[0] && t[1] === n[1];
  }
  function je(t, n) {
    var a = t[0],
      r = t[1],
      u = n[0],
      e = n[1];
    return (
      Math.abs(a - u) <= M * Math.max(1, Math.abs(a), Math.abs(u)) &&
      Math.abs(r - e) <= M * Math.max(1, Math.abs(r), Math.abs(e))
    );
  }
  var ze = de,
    Oe = ee,
    Qe = oe,
    Ye = ie,
    Xe = be,
    Ze = me,
    _e = xe,
    Be = (function () {
      var t = $u();
      return function (n, a, r, u, e, o) {
        var i, h;
        for (
          a || (a = 2),
            r || (r = 0),
            h = u ? Math.min(u * a + r, n.length) : n.length,
            i = r;
          i < h;
          i += a
        )
          (t[0] = n[i]),
            (t[1] = n[i + 1]),
            e(t, t, o),
            (n[i] = t[0]),
            (n[i + 1] = t[1]);
        return n;
      };
    })();
  (window.glMatrix = n),
    (window.mat2 = a),
    (window.mat2d = r),
    (window.mat3 = u),
    (window.mat4 = e),
    (window.quat = h),
    (window.quat2 = c),
    (window.vec2 = s),
    (window.vec3 = o),
    (window.vec4 = i);
})();
//# sourceMappingURL=libs.core.js.map
if (!CABLES.exportedPatches) CABLES.exportedPatches = {};
CABLES.exportedPatches["GgjVeu"] = {
  _id: "6737d25bb91f6fc8379ea12e",
  ops: [
    {
      id: "c4nbn4unw",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [
        { name: "Coordinates index", value: 0 },
        { name: "Coordinates", value: "-1 to 1" },
        { name: "Area index", value: 0 },
        { name: "Area", value: "Canvas" },
        { name: "flip y", value: 1 },
        { name: "right click prevent default", value: 0 },
        { name: "Touch support", value: 0 },
        { name: "Passive Events", value: 0 },
        { name: "Active", value: 1 },
      ],
      portsOut: [
        {
          name: "x",
          links: [
            {
              portIn: "value",
              portOut: "x",
              objIn: "7b39eacc-6305-4549-9220-f95f570c738d",
              objOut: "c4nbn4unw",
            },
          ],
        },
        {
          name: "y",
          links: [
            {
              portIn: "value",
              portOut: "y",
              objIn: "7ripfb4hq",
              objOut: "c4nbn4unw",
            },
          ],
        },
        { name: "Button is down", value: 0 },
        { name: "Mouse is hovering", value: 0 },
        { name: "Movement X", value: -17 },
        { name: "Movement Y", value: 8 },
      ],
      objName: "Ops.Devices.Mouse.Mouse_v3",
    },
    {
      id: "7b39eacc-6305-4549-9220-f95f570c738d",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [
        { name: "old min", value: -1 },
        { name: "old max", value: 1 },
        { name: "new min", value: 0 },
        { name: "new max", value: 20 },
        { name: "Easing index", value: 0 },
        { name: "Easing", value: "Linear" },
        { name: "Clamp", value: 1 },
      ],
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "number1",
              portOut: "result",
              objIn: "658cc009-6a0c-43ac-a52b-8dd5cdc024a1",
              objOut: "7b39eacc-6305-4549-9220-f95f570c738d",
            },
          ],
        },
      ],
      objName: "Ops.Math.MapRange",
    },
    {
      id: "7ripfb4hq",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [
        { name: "old min", value: -1 },
        { name: "old max", value: 1 },
        { name: "new min", value: 0 },
        { name: "new max", value: 20 },
        { name: "Easing index", value: 0 },
        { name: "Easing", value: "Linear" },
        { name: "Clamp", value: 1 },
      ],
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "number1",
              portOut: "result",
              objIn: "a53ce4a5-fe8a-4e4a-ae88-bb7bd84648d9",
              objOut: "7ripfb4hq",
            },
          ],
        },
      ],
      objName: "Ops.Math.MapRange",
    },
    {
      id: "658cc009-6a0c-43ac-a52b-8dd5cdc024a1",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [{ name: "number2", value: 20.22 }],
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "number1",
              portOut: "result",
              objIn: "sead3j9rf",
              objOut: "658cc009-6a0c-43ac-a52b-8dd5cdc024a1",
            },
          ],
        },
      ],
      objName: "Ops.Math.Sum",
    },
    {
      id: "a53ce4a5-fe8a-4e4a-ae88-bb7bd84648d9",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [{ name: "number2", value: -22.06 }],
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "number1",
              portOut: "result",
              objIn: "xd1ax0y1d",
              objOut: "a53ce4a5-fe8a-4e4a-ae88-bb7bd84648d9",
            },
          ],
        },
      ],
      objName: "Ops.Math.Sum",
    },
    {
      id: "g135m25tl",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [
        { name: "Separate inc/dec", value: 0 },
        { name: "Inc factor", value: 100, title: "Inc/Dec factor" },
        { name: "Dec factor", value: 4 },
      ],
      portsOut: [{ name: "Result", value: 0 }],
      objName: "Ops.Anim.Smooth",
    },
    {
      id: "dk000ttew",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [
        { name: "Separate inc/dec", value: 0 },
        { name: "Inc factor", value: 100, title: "Inc/Dec factor" },
        { name: "Dec factor", value: 4 },
      ],
      portsOut: [{ name: "Result", value: 0 }],
      objName: "Ops.Anim.Smooth",
    },
    {
      id: "d7520180-d502-4253-b524-862489fa03ae",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsOut: [
        {
          name: "Changed",
          links: [
            {
              portIn: "Trigger",
              portOut: "Changed",
              objIn: "e451ab65-a112-47be-b831-d3048cf11326",
              objOut: "d7520180-d502-4253-b524-862489fa03ae",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.TriggerOnChangeString",
    },
    {
      id: "7ec3bd86-a299-42e3-beae-59256abd844f",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [
        { name: "min", value: -10 },
        { name: "max", value: 10 },
        { name: "Integer", value: 0 },
        { name: "No consecutive duplicates", value: 1 },
      ],
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "number2",
              portOut: "result",
              objIn: "sead3j9rf",
              objOut: "7ec3bd86-a299-42e3-beae-59256abd844f",
            },
          ],
        },
      ],
      objName: "Ops.Math.TriggerRandomNumber_v2",
    },
    {
      id: "e451ab65-a112-47be-b831-d3048cf11326",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsOut: [
        {
          name: "Next",
          links: [
            {
              portIn: "Generate",
              portOut: "Next",
              objIn: "7ec3bd86-a299-42e3-beae-59256abd844f",
              objOut: "e451ab65-a112-47be-b831-d3048cf11326",
            },
            {
              portIn: "Generate",
              portOut: "Next",
              objIn: "6c2tkdtx2",
              objOut: "e451ab65-a112-47be-b831-d3048cf11326",
            },
            {
              portIn: "Generate",
              portOut: "Next",
              objIn: "wf8or6sx5",
              objOut: "e451ab65-a112-47be-b831-d3048cf11326",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.TriggerButton",
    },
    {
      id: "sead3j9rf",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "Value",
              portOut: "result",
              objIn: "g135m25tl",
              objOut: "sead3j9rf",
            },
          ],
        },
      ],
      objName: "Ops.Math.Sum",
    },
    {
      id: "6c2tkdtx2",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [
        { name: "min", value: -10 },
        { name: "max", value: 10 },
        { name: "Integer", value: 0 },
        { name: "No consecutive duplicates", value: 1 },
      ],
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "number2",
              portOut: "result",
              objIn: "xd1ax0y1d",
              objOut: "6c2tkdtx2",
            },
          ],
        },
      ],
      objName: "Ops.Math.TriggerRandomNumber_v2",
    },
    {
      id: "xd1ax0y1d",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "Value",
              portOut: "result",
              objIn: "dk000ttew",
              objOut: "xd1ax0y1d",
            },
          ],
        },
      ],
      objName: "Ops.Math.Sum",
    },
    {
      id: "wf8or6sx5",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [
        { name: "min", value: -10 },
        { name: "max", value: 10 },
        { name: "Integer", value: 0 },
        { name: "No consecutive duplicates", value: 1 },
      ],
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "number1",
              portOut: "result",
              objIn: "2nwqj122c",
              objOut: "wf8or6sx5",
            },
          ],
        },
      ],
      objName: "Ops.Math.TriggerRandomNumber_v2",
    },
    {
      id: "vwgc5nyev",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [
        { name: "Separate inc/dec", value: 0 },
        { name: "Inc factor", value: 100, title: "Inc/Dec factor" },
        { name: "Dec factor", value: 4 },
      ],
      portsOut: [{ name: "Result", value: 0 }],
      objName: "Ops.Anim.Smooth",
    },
    {
      id: "2nwqj122c",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [{ name: "number2", value: -51.27 }],
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "Value",
              portOut: "result",
              objIn: "vwgc5nyev",
              objOut: "2nwqj122c",
            },
          ],
        },
      ],
      objName: "Ops.Math.Sum",
    },
    {
      id: "otdiewxu8",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [{ name: "Variable", value: "imageUrl" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "String",
              portOut: "Value",
              objIn: "d7520180-d502-4253-b524-862489fa03ae",
              objOut: "otdiewxu8",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetString",
    },
    {
      id: "1912e32f-b447-4384-adf0-44cc04b0dec7",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsOut: [{ name: "create port", value: 0 }],
      objName: "Ops.Ui.PatchInput",
    },
    {
      id: "38674664-f35b-40fc-9232-f3343d361ea9",
      uiAttribs: { subPatch: "d9d56413-14d4-4bc4-aa2c-67e1f8fe2dbf" },
      portsIn: [{ name: "create port", value: 0 }],
      objName: "Ops.Ui.PatchOutput",
    },
    {
      id: "3e9jbf60v",
      uiAttribs: {},
      portsOut: [
        {
          name: "trigger",
          links: [
            {
              portIn: "in0 Ops.Gl.Matrix.TransformView trigger",
              portOut: "trigger",
              objIn: "hmrwm30er",
              objOut: "3e9jbf60v",
            },
          ],
        },
      ],
      objName: "Ops.Gl.Matrix.TransformView",
    },
    {
      id: "pymi5dwfn",
      uiAttribs: {},
      portsIn: [
        { name: "Value", value: 0 },
        { name: "Variable", value: "workScroll" },
      ],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "idb5vni1j",
      uiAttribs: {},
      portsIn: [
        { name: "Value", value: 0 },
        { name: "Variable", value: "aboutScroll" },
      ],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "h36xf2f52",
      uiAttribs: {},
      portsIn: [
        { name: "Value", value: "index" },
        { name: "Variable", value: "pageContext" },
      ],
      objName: "Ops.Vars.VarSetString_v2",
    },
    {
      id: "cfmh16c3b",
      uiAttribs: {},
      portsIn: [{ name: "Play Timeline", value: 0 }],
      portsOut: [
        {
          name: "Next",
          links: [
            {
              portIn: "Trigger",
              portOut: "Next",
              objIn: "99nt7axny",
              objOut: "cfmh16c3b",
            },
            {
              portIn: "Execute",
              portOut: "Next",
              objIn: "o6iq01n0j",
              objOut: "cfmh16c3b",
            },
          ],
        },
        { name: "Finished Initial Loading", value: 1 },
        { name: "Loading", value: 0 },
        {
          name: "Progress",
          links: [
            {
              portIn: "Value",
              portOut: "Progress",
              objIn: "cb0k3nn3a",
              objOut: "cfmh16c3b",
            },
          ],
        },
        {
          name: "Trigger Loading Finished ",
          links: [
            {
              portIn: "Trigger",
              portOut: "Trigger Loading Finished ",
              objIn: "fy34a0ima",
              objOut: "cfmh16c3b",
            },
          ],
        },
      ],
      objName: "Ops.Cables.LoadingStatus_v2",
    },
    {
      id: "yycpxv7b2",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "pageContext" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Switch Value",
              portOut: "Value",
              objIn: "o6iq01n0j",
              objOut: "yycpxv7b2",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetString",
    },
    {
      id: "5cuc5vqu0",
      uiAttribs: {},
      portsIn: [
        { name: "r", value: 0 },
        { name: "g", value: 0 },
        { name: "b", value: 0 },
        { name: "a", value: 0 },
      ],
      portsOut: [
        {
          name: "trigger",
          links: [
            {
              portIn: "Render",
              portOut: "trigger",
              objIn: "fvntb6ykt",
              objOut: "5cuc5vqu0",
            },
            {
              portIn: "render",
              portOut: "trigger",
              objIn: "5m0nxxnjx",
              objOut: "5cuc5vqu0",
            },
          ],
        },
      ],
      objName: "Ops.Gl.ClearColor",
    },
    {
      id: "7e4ey2fi4",
      uiAttribs: {},
      portsIn: [
        { name: "r", value: 0 },
        { name: "g", value: 0 },
        { name: "b", value: 0 },
        { name: "a", value: 0 },
      ],
      portsOut: [
        {
          name: "trigger",
          links: [
            {
              portIn: "in0 Ops.Trigger.RouteTriggerString_v2 Trigger 1",
              portOut: "trigger",
              objIn: "c3020432-d72e-41bb-8274-dbd55ba98235",
              objOut: "7e4ey2fi4",
            },
          ],
        },
      ],
      objName: "Ops.Gl.ClearColor",
    },
    {
      id: "dwq5osdkj",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "nContext" }],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "fy34a0ima",
      uiAttribs: {},
      portsIn: [{ name: "Named Trigger", value: "loaded" }],
      objName: "Ops.Trigger.TriggerSend",
    },
    {
      id: "cb0k3nn3a",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "loadingStatus" }],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "99nt7axny",
      uiAttribs: {},
      portsIn: [{ name: "Named Trigger", value: "mainLoop" }],
      objName: "Ops.Trigger.TriggerSend",
    },
    {
      id: "703egzgtr",
      uiAttribs: {},
      portsIn: [
        { name: "Value", value: "New String" },
        { name: "Variable", value: "imageUrl" },
      ],
      objName: "Ops.Vars.VarSetString_v2",
    },
    {
      id: "whp28n8pi",
      uiAttribs: {},
      portsOut: [
        { name: "Switched Value", value: 0 },
        {
          name: "Trigger 0",
          links: [
            {
              portIn: "Execute",
              portOut: "Trigger 0",
              objIn: "uqyteclc3",
              objOut: "whp28n8pi",
            },
          ],
        },
        {
          name: "Trigger 1",
          links: [
            {
              portIn: "Execute",
              portOut: "Trigger 1",
              objIn: "val0mhtoj",
              objOut: "whp28n8pi",
            },
          ],
        },
        { name: "Highest Index", value: 1 },
      ],
      objName: "Ops.Trigger.RouteTrigger",
    },
    {
      id: "rdi6zanod",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "nContext" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Switch Value",
              portOut: "Value",
              objIn: "whp28n8pi",
              objOut: "rdi6zanod",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "jvioe1871",
      uiAttribs: {},
      portsIn: [
        { name: "Value", value: "Media Design" },
        { name: "Variable", value: "stringTexture" },
      ],
      objName: "Ops.Vars.VarSetString_v2",
    },
    {
      id: "bw5x42j1o",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "imageTexture" }],
      objName: "Ops.Vars.VarSetTexture_v2",
    },
    {
      id: "hdbfyi4so",
      uiAttribs: {},
      portsIn: [
        { name: "Active", value: 1 },
        { name: "Visible", value: 0 },
        { name: "Measure GPU", value: 0 },
        { name: "Position index", value: 1 },
        { name: "Position", value: "bottom" },
        { name: "Open", value: 0 },
        { name: "Smooth Graph", value: 0 },
        { name: "Scale", value: 3 },
        { name: "Size", value: 128 },
      ],
      portsOut: [
        {
          name: "childs",
          links: [
            {
              portIn: "exe",
              portOut: "childs",
              objIn: "cfmh16c3b",
              objOut: "hdbfyi4so",
            },
          ],
        },
        { name: "FPS", value: 61 },
      ],
      objName: "Ops.Gl.Performance",
    },
    {
      id: "wuo33hidd",
      uiAttribs: {},
      portsIn: [
        { name: "Value", value: "mq3" },
        { name: "Variable", value: "mediaQuery" },
      ],
      objName: "Ops.Vars.VarSetString_v2",
    },
    {
      id: "e0embtgzv",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "videoUrl" }],
      objName: "Ops.Vars.VarSetString_v2",
    },
    {
      id: "h042fj5j0",
      uiAttribs: {},
      portsOut: [
        { name: "has focus", value: 1 },
        {
          name: "Tab Visible",
          links: [
            {
              portIn: "Active",
              portOut: "Tab Visible",
              objIn: "pa2y9tgmx",
              objOut: "h042fj5j0",
            },
          ],
        },
      ],
      objName: "Ops.Html.WindowHasFocus",
    },
    {
      id: "jh3l549w8",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "mediaQuery" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Switch Value",
              portOut: "Value",
              objIn: "val0mhtoj",
              objOut: "jh3l549w8",
            },
            {
              portIn: "Switch Value",
              portOut: "Value",
              objIn: "uqyteclc3",
              objOut: "jh3l549w8",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetString",
    },
    {
      id: "isiuxw17x",
      uiAttribs: {},
      portsIn: [
        {
          name: "value",
          value:
            "https://vz-2feef9b1-637.b-cdn.net/8860ee99-33f1-4f92-ace7-04044ace1592/playlist.m3u8",
        },
      ],
      portsOut: [
        {
          name: "String",
          links: [
            {
              portIn: "Value",
              portOut: "String",
              objIn: "e0embtgzv",
              objOut: "isiuxw17x",
            },
          ],
        },
      ],
      objName: "Ops.String.String_v2",
    },
    {
      id: "gm13f4zcc",
      uiAttribs: {},
      portsIn: [{ name: "a", value: 1 }],
      portsOut: [
        { name: "outr", value: 0 },
        { name: "outg", value: 0.00392156862745098 },
        { name: "outb", value: 1 },
        { name: "outa", value: 1 },
        { name: "Hex", value: "0001FF" },
        {
          name: "Array",
          links: [
            {
              portIn: "Array In",
              portOut: "Array",
              objIn: "t8wj0g1fm",
              objOut: "gm13f4zcc",
            },
          ],
        },
      ],
      objName: "Ops.Color.ColorValue",
    },
    {
      id: "val0mhtoj",
      uiAttribs: {},
      portsIn: [
        { name: "String 0", value: "mq1" },
        { name: "String 1", value: "mq2" },
        { name: "String 2", value: "mq3" },
        { name: "String 3", value: "" },
        { name: "String 4", value: "" },
        { name: "String 5", value: "" },
        { name: "String 6", value: "" },
        { name: "String 7", value: "" },
        { name: "String 8", value: "" },
        { name: "String 9", value: "" },
        { name: "String 10", value: "" },
        { name: "String 11", value: "" },
        { name: "String 12", value: "" },
        { name: "String 13", value: "" },
        { name: "String 14", value: "" },
        { name: "String 15", value: "" },
        { name: "String 16", value: "" },
        { name: "String 17", value: "" },
        { name: "String 18", value: "" },
        { name: "String 19", value: "" },
        { name: "String 20", value: "" },
        { name: "String 21", value: "" },
        { name: "String 22", value: "" },
        { name: "String 23", value: "" },
      ],
      portsOut: [
        { name: "Switched Index", value: 2 },
        {
          name: "Trigger 0",
          links: [
            {
              portIn: "9mnoq6ams",
              portOut: "Trigger 0",
              objIn: "64opcwacl",
              objOut: "val0mhtoj",
            },
          ],
        },
        {
          name: "Trigger 1",
          links: [
            {
              portIn: "9mnoq6ams",
              portOut: "Trigger 1",
              objIn: "3sodhmqvs",
              objOut: "val0mhtoj",
            },
          ],
        },
        {
          name: "Trigger 2",
          links: [
            {
              portIn: "d7g5c0h5b",
              portOut: "Trigger 2",
              objIn: "8jjtil0jj",
              objOut: "val0mhtoj",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.RouteTriggerString_v2",
    },
    {
      id: "uqyteclc3",
      uiAttribs: {},
      portsIn: [
        { name: "String 0", value: "mq1" },
        { name: "String 1", value: "mq2" },
        { name: "String 2", value: "mq3" },
        { name: "String 3", value: "" },
        { name: "String 4", value: "" },
        { name: "String 5", value: "" },
        { name: "String 6", value: "" },
        { name: "String 7", value: "" },
        { name: "String 8", value: "" },
        { name: "String 9", value: "" },
        { name: "String 10", value: "" },
        { name: "String 11", value: "" },
        { name: "String 12", value: "" },
        { name: "String 13", value: "" },
        { name: "String 14", value: "" },
        { name: "String 15", value: "" },
        { name: "String 16", value: "" },
        { name: "String 17", value: "" },
        { name: "String 18", value: "" },
        { name: "String 19", value: "" },
        { name: "String 20", value: "" },
        { name: "String 21", value: "" },
        { name: "String 22", value: "" },
        { name: "String 23", value: "" },
      ],
      portsOut: [
        {
          name: "Next Trigger",
          links: [
            {
              portIn: "Exe",
              portOut: "Next Trigger",
              objIn: "0co9dzwpn",
              objOut: "uqyteclc3",
            },
          ],
        },
        {
          name: "Switched Index",
          links: [
            {
              portIn: "Value",
              portOut: "Switched Index",
              objIn: "400e715b-2702-4f99-acf3-b545cbb099f7",
              objOut: "uqyteclc3",
            },
          ],
        },
        {
          name: "Trigger 2",
          links: [
            {
              portIn: "d7g5c0h5b",
              portOut: "Trigger 2",
              objIn: "buwa4ywbx",
              objOut: "uqyteclc3",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.RouteTriggerString_v2",
    },
    {
      id: "o6iq01n0j",
      uiAttribs: {},
      portsIn: [
        { name: "String 0", value: "index" },
        { name: "String 1", value: "works" },
        { name: "String 2", value: "" },
        { name: "String 3", value: "" },
        { name: "String 4", value: "" },
        { name: "String 5", value: "" },
        { name: "String 6", value: "" },
        { name: "String 7", value: "" },
        { name: "String 8", value: "" },
        { name: "String 9", value: "" },
        { name: "String 10", value: "" },
        { name: "String 11", value: "" },
        { name: "String 12", value: "" },
        { name: "String 13", value: "" },
        { name: "String 14", value: "" },
        { name: "String 15", value: "" },
        { name: "String 16", value: "" },
        { name: "String 17", value: "" },
        { name: "String 18", value: "" },
        { name: "String 19", value: "" },
        { name: "String 20", value: "" },
        { name: "String 21", value: "" },
        { name: "String 22", value: "" },
        { name: "String 23", value: "" },
      ],
      portsOut: [
        {
          name: "Switched Index",
          links: [
            {
              portIn: "Value",
              portOut: "Switched Index",
              objIn: "dwq5osdkj",
              objOut: "o6iq01n0j",
            },
          ],
        },
        {
          name: "Trigger 0",
          links: [
            {
              portIn: "render",
              portOut: "Trigger 0",
              objIn: "5cuc5vqu0",
              objOut: "o6iq01n0j",
            },
            {
              portIn: "Generate",
              portOut: "Trigger 0",
              objIn: "xvrxo414c",
              objOut: "o6iq01n0j",
            },
          ],
        },
        {
          name: "Trigger 1",
          links: [
            {
              portIn: "render",
              portOut: "Trigger 1",
              objIn: "7e4ey2fi4",
              objOut: "o6iq01n0j",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.RouteTriggerString_v2",
    },
    {
      id: "o9o1lvbn5",
      uiAttribs: {},
      portsIn: [{ name: "Index", value: 0 }],
      portsOut: [
        {
          name: "X",
          links: [
            {
              portIn: "posX",
              portOut: "X",
              objIn: "3e9jbf60v",
              objOut: "o9o1lvbn5",
            },
          ],
        },
        {
          name: "Y",
          links: [
            {
              portIn: "posY",
              portOut: "Y",
              objIn: "3e9jbf60v",
              objOut: "o9o1lvbn5",
            },
          ],
        },
        {
          name: "Z",
          links: [
            {
              portIn: "posZ",
              portOut: "Z",
              objIn: "3e9jbf60v",
              objOut: "o9o1lvbn5",
            },
          ],
        },
      ],
      objName: "Ops.Array.Array3GetNumbers",
    },
    {
      id: "cqjowcwqt",
      uiAttribs: {},
      portsIn: [
        { name: "index", value: 3 },
        { name: "Value Invalid Index", value: 0 },
      ],
      portsOut: [
        {
          name: "value",
          links: [
            {
              portIn: "scale",
              portOut: "value",
              objIn: "3e9jbf60v",
              objOut: "cqjowcwqt",
            },
          ],
        },
        { name: "Valid Index", value: 1 },
      ],
      objName: "Ops.Array.ArrayGetNumber",
    },
    {
      id: "e6ylr7btl",
      uiAttribs: {},
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "rotZ",
              portOut: "result",
              objIn: "3e9jbf60v",
              objOut: "e6ylr7btl",
            },
          ],
        },
      ],
      objName: "Ops.Math.Sum",
    },
    {
      id: "ub6p4urcu",
      uiAttribs: {},
      portsIn: [{ name: "Index", value: 4 }],
      portsOut: [
        {
          name: "X",
          links: [
            {
              portIn: "number2",
              portOut: "X",
              objIn: "zpdk4s7hr",
              objOut: "ub6p4urcu",
            },
          ],
        },
        {
          name: "Y",
          links: [
            {
              portIn: "number2",
              portOut: "Y",
              objIn: "sd5jtt6y5",
              objOut: "ub6p4urcu",
            },
          ],
        },
        {
          name: "Z",
          links: [
            {
              portIn: "number2",
              portOut: "Z",
              objIn: "e6ylr7btl",
              objOut: "ub6p4urcu",
            },
          ],
        },
      ],
      objName: "Ops.Array.Array3GetNumbers",
    },
    {
      id: "zpdk4s7hr",
      uiAttribs: {},
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "rotX",
              portOut: "result",
              objIn: "3e9jbf60v",
              objOut: "zpdk4s7hr",
            },
          ],
        },
      ],
      objName: "Ops.Math.Sum",
    },
    {
      id: "sd5jtt6y5",
      uiAttribs: {},
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "rotY",
              portOut: "result",
              objIn: "3e9jbf60v",
              objOut: "sd5jtt6y5",
            },
          ],
        },
      ],
      objName: "Ops.Math.Sum",
    },
    {
      id: "d6dfe00c-a333-4385-a551-7ca5093b463e",
      uiAttribs: {},
      portsIn: [
        { name: "file", display: "file" },
        { name: "family", value: "everettLight" },
        { name: "Active", value: 1 },
      ],
      portsOut: [{ name: "Loaded", value: 1 }],
      objName: "Ops.Html.FontFile_v2",
    },
    {
      id: "fe53c691-9587-4d39-9499-356538b54e80",
      uiAttribs: {},
      portsIn: [
        { name: "file", display: "file" },
        { name: "family", value: "everettBold" },
        { name: "Active", value: 1 },
      ],
      portsOut: [{ name: "Loaded", value: 1 }],
      objName: "Ops.Html.FontFile_v2",
    },
    {
      id: "56ab535f-13e7-4255-a15c-46783459d78f",
      uiAttribs: {},
      portsIn: [
        {
          name: "value",
          value:
            "https://uploads-ssl.webflow.com/630ca11296e48c2b70f1013e/652bc291b62af154c444c7f5_TWKEverett-Bold.otf",
        },
      ],
      portsOut: [
        {
          name: "String",
          links: [
            {
              portIn: "file",
              portOut: "String",
              objIn: "fe53c691-9587-4d39-9499-356538b54e80",
              objOut: "56ab535f-13e7-4255-a15c-46783459d78f",
            },
          ],
        },
      ],
      objName: "Ops.String.String_v2",
    },
    {
      id: "j64yb3d3e",
      uiAttribs: {},
      portsIn: [
        {
          name: "value",
          value:
            "https://uploads-ssl.webflow.com/630ca11296e48c2b70f1013e/652bc29129f6f7d9d2e6a5e7_TWKEverett-Light.otf",
        },
      ],
      portsOut: [
        {
          name: "String",
          links: [
            {
              portIn: "file",
              portOut: "String",
              objIn: "d6dfe00c-a333-4385-a551-7ca5093b463e",
              objOut: "j64yb3d3e",
            },
          ],
        },
      ],
      objName: "Ops.String.String_v2",
    },
    {
      id: "ck7se7ko6",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [
        { name: "File", display: "file" },
        { name: "Filter index", value: 2 },
        { name: "Filter", value: "mipmap" },
        { name: "Wrap index", value: 0 },
        { name: "Wrap", value: "repeat" },
        { name: "Anisotropic index", value: 0 },
        { name: "Anisotropic", value: "0" },
        { name: "Data Format index", value: 2 },
        { name: "Data Format", value: "RGB" },
        { name: "Flip", value: 0 },
        { name: "Pre Multiplied Alpha", value: 0 },
        { name: "Save Memory", value: 1 },
        { name: "Add Cachebuster", value: 0 },
      ],
      portsOut: [
        {
          name: "Texture",
          links: [
            {
              portIn: "texture1",
              portOut: "Texture",
              objIn: "wm3l5lbrt",
              objOut: "ck7se7ko6",
            },
          ],
        },
        { name: "Width", value: 8 },
        { name: "Height", value: 8 },
        {
          name: "Aspect Ratio",
          links: [
            {
              portIn: "Value 1",
              portOut: "Aspect Ratio",
              objIn: "728bc2af-66ca-4c6f-a6d4-2b51f809033d",
              objOut: "ck7se7ko6",
            },
          ],
        },
        { name: "Loaded", value: 1 },
        { name: "Loading", value: 0 },
      ],
      objName: "Ops.Gl.Texture_v2",
    },
    {
      id: "1vm54l2e2",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "imageUrl" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "File",
              portOut: "Value",
              objIn: "ck7se7ko6",
              objOut: "1vm54l2e2",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetString",
    },
    {
      id: "wm3l5lbrt",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Default Texture Transparent", value: 1 }],
      portsOut: [
        {
          name: "Next",
          links: [
            {
              portIn: "Execute",
              portOut: "Next",
              objIn: "b0hk8u9bi",
              objOut: "wm3l5lbrt",
            },
          ],
        },
        {
          name: "texture",
          links: [
            {
              portIn: "textureInput",
              portOut: "texture",
              objIn: "v38pi7nzw",
              objOut: "wm3l5lbrt",
            },
            {
              portIn: "in2 SwitchTextures texture",
              portOut: "texture",
              objIn: "gpxi4rlmc",
              objOut: "wm3l5lbrt",
            },
            {
              portIn: "textureInput",
              portOut: "texture",
              objIn: "r3u33h3hs",
              objOut: "wm3l5lbrt",
            },
          ],
        },
      ],
      objName: "Ops.Gl.Textures.SwitchTextures_v2",
    },
    {
      id: "3czynyjwm",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "num",
              portOut: "result",
              objIn: "wm3l5lbrt",
              objOut: "3czynyjwm",
            },
          ],
        },
      ],
      objName: "Ops.Number.Number",
    },
    {
      id: "b4tefn2a1",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "Value",
              portOut: "result",
              objIn: "o2rjjfyi8",
              objOut: "b4tefn2a1",
            },
          ],
        },
      ],
      objName: "Ops.Number.Number",
    },
    {
      id: "9sekcc5gw",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [
        { name: "Coordinates index", value: 0 },
        { name: "Coordinates", value: "-1 to 1" },
        { name: "Area index", value: 0 },
        { name: "Area", value: "Canvas" },
        { name: "flip y", value: 1 },
        { name: "right click prevent default", value: 1 },
        { name: "Touch support", value: 1 },
        { name: "Passive Events", value: 0 },
      ],
      portsOut: [
        { name: "x", value: -0.9904610492845787 },
        { name: "y", value: -0.18248175182481752 },
        {
          name: "click",
          links: [
            {
              portIn: "Execute",
              portOut: "click",
              objIn: "3j7vi0s9v",
              objOut: "9sekcc5gw",
            },
          ],
        },
        { name: "Button is down", value: 0 },
        { name: "Mouse is hovering", value: 0 },
        { name: "Movement X", value: -17 },
        { name: "Movement Y", value: 8 },
      ],
      objName: "Ops.Devices.Mouse.Mouse_v3",
    },
    {
      id: "wo3yxin4e",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Default", value: 0 }],
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "value",
              portOut: "result",
              objIn: "b4tefn2a1",
              objOut: "wo3yxin4e",
            },
          ],
        },
      ],
      objName: "Ops.Boolean.ToggleBool_v2",
    },
    {
      id: "3j7vi0s9v",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Pass Through", value: 1 }],
      portsOut: [
        {
          name: "Trigger out",
          links: [
            {
              portIn: "trigger",
              portOut: "Trigger out",
              objIn: "wo3yxin4e",
              objOut: "3j7vi0s9v",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.GateTrigger",
    },
    {
      id: "7b956q2sq",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "SearchValue", value: ".png" }],
      portsOut: [
        {
          name: "Found",
          links: [
            {
              portIn: "bool 1",
              portOut: "Found",
              objIn: "dvlao3w4r",
              objOut: "7b956q2sq",
            },
          ],
        },
        { name: "Index", value: -1 },
      ],
      objName: "Ops.String.StringContains_v2",
    },
    {
      id: "dvlao3w4r",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [
        { name: "bool 4", value: 0 },
        { name: "bool 5", value: 0 },
        { name: "bool 6", value: 0 },
        { name: "bool 7", value: 0 },
        { name: "bool 8", value: 0 },
        { name: "bool 9", value: 0 },
        { name: "bool 10", value: 0 },
      ],
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "value",
              portOut: "result",
              objIn: "3czynyjwm",
              objOut: "dvlao3w4r",
            },
            {
              portIn: "Value",
              portOut: "result",
              objIn: "jg54smpee",
              objOut: "dvlao3w4r",
            },
            {
              portIn: "Active",
              portOut: "result",
              objIn: "ck7se7ko6",
              objOut: "dvlao3w4r",
            },
          ],
        },
      ],
      objName: "Ops.Boolean.Or",
    },
    {
      id: "wer07k5pg",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "imageUrl" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "String",
              portOut: "Value",
              objIn: "7b956q2sq",
              objOut: "wer07k5pg",
            },
            {
              portIn: "String",
              portOut: "Value",
              objIn: "oqal79lge",
              objOut: "wer07k5pg",
            },
            {
              portIn: "String",
              portOut: "Value",
              objIn: "s00nrdmzx",
              objOut: "wer07k5pg",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetString",
    },
    {
      id: "oqal79lge",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "SearchValue", value: ".jpg" }],
      portsOut: [
        {
          name: "Found",
          links: [
            {
              portIn: "bool 2",
              portOut: "Found",
              objIn: "dvlao3w4r",
              objOut: "oqal79lge",
            },
          ],
        },
        { name: "Index", value: -1 },
      ],
      objName: "Ops.String.StringContains_v2",
    },
    {
      id: "s00nrdmzx",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "SearchValue", value: ".jpeg" }],
      portsOut: [
        {
          name: "Found",
          links: [
            {
              portIn: "bool 3",
              portOut: "Found",
              objIn: "dvlao3w4r",
              objOut: "s00nrdmzx",
            },
          ],
        },
        { name: "Index", value: -1 },
      ],
      objName: "Ops.String.StringContains_v2",
    },
    {
      id: "jg54smpee",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "isImage" }],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "zl9l016gb",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "isImage" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "in bool",
              portOut: "Value",
              objIn: "xwiak10cy",
              objOut: "zl9l016gb",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "xwiak10cy",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsOut: [
        {
          name: "out bool",
          links: [
            {
              portIn: "Active",
              portOut: "out bool",
              objIn: "9sekcc5gw",
              objOut: "xwiak10cy",
            },
          ],
        },
      ],
      objName: "Ops.Extension.Deprecated.ToggleBoolValue",
    },
    {
      id: "8o9m36la4",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "videoUrl" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "String",
              portOut: "Value",
              objIn: "r4kfaaige",
              objOut: "8o9m36la4",
            },
            {
              portIn: "file",
              portOut: "Value",
              objIn: "lcig881l8",
              objOut: "8o9m36la4",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetString",
    },
    {
      id: "r4kfaaige",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsOut: [
        {
          name: "Changed",
          links: [
            {
              portIn: "exe",
              portOut: "Changed",
              objIn: "8tjrih3pf",
              objOut: "r4kfaaige",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.TriggerOnChangeString",
    },
    {
      id: "ldn5adez0",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "isImage" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Value",
              portOut: "Value",
              objIn: "oaq4sw0ce",
              objOut: "ldn5adez0",
            },
            {
              portIn: "Value",
              portOut: "Value",
              objIn: "55vyxi8a2",
              objOut: "ldn5adez0",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "oaq4sw0ce",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsOut: [
        {
          name: "Next",
          links: [
            {
              portIn: "trigger",
              portOut: "Next",
              objIn: "wo3yxin4e",
              objOut: "oaq4sw0ce",
            },
          ],
        },
      ],
      objName: "Ops.Boolean.TriggerChangedFalse",
    },
    {
      id: "55vyxi8a2",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsOut: [
        {
          name: "Next",
          links: [
            {
              portIn: "reset",
              portOut: "Next",
              objIn: "wo3yxin4e",
              objOut: "55vyxi8a2",
            },
          ],
        },
      ],
      objName: "Ops.Boolean.TriggerChangedTrue",
    },
    {
      id: "8tjrih3pf",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "delay", value: 0.1 }],
      portsOut: [
        {
          name: "next",
          links: [
            {
              portIn: "Rewind",
              portOut: "next",
              objIn: "lcig881l8",
              objOut: "8tjrih3pf",
            },
          ],
        },
        { name: "Delaying", value: false },
      ],
      objName: "Ops.Trigger.DelayedTrigger",
    },
    {
      id: "z1jnexqjf",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "videoAspectRatio" }],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "axrb9y4f6",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "videoLoaded" }],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "k66hq3ihz",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsOut: [
        {
          name: "out bool",
          links: [
            {
              portIn: "Value",
              portOut: "out bool",
              objIn: "axrb9y4f6",
              objOut: "k66hq3ihz",
            },
          ],
        },
      ],
      objName: "Ops.Extension.Deprecated.ToggleBoolValue",
    },
    {
      id: "axv61bs99",
      uiAttribs: { subPatch: "2154fd20-4fef-42fd-bef2-ef39e6975cdf" },
      portsIn: [{ name: "Variable", value: "videoAspectRatio" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "number1",
              portOut: "Value",
              objIn: "gwlsewuc3",
              objOut: "axv61bs99",
            },
            {
              portIn: "number2",
              portOut: "Value",
              objIn: "snccy8bvu",
              objOut: "axv61bs99",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "snccy8bvu",
      uiAttribs: { subPatch: "2154fd20-4fef-42fd-bef2-ef39e6975cdf" },
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn:
                "out0 Ops.Gl.ShaderEffects.TransformTextureCoordinates Repeat X",
              portOut: "result",
              objIn: "ltmbqybsn",
              objOut: "snccy8bvu",
            },
          ],
        },
      ],
      objName: "Ops.Math.Divide",
    },
    {
      id: "gwlsewuc3",
      uiAttribs: { subPatch: "2154fd20-4fef-42fd-bef2-ef39e6975cdf" },
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "number1",
              portOut: "result",
              objIn: "l7yax5e5f",
              objOut: "gwlsewuc3",
            },
          ],
        },
      ],
      objName: "Ops.Math.Subtract",
    },
    {
      id: "l7yax5e5f",
      uiAttribs: { subPatch: "2154fd20-4fef-42fd-bef2-ef39e6975cdf" },
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn:
                "out1 Ops.Gl.ShaderEffects.TransformTextureCoordinates Translate X",
              portOut: "result",
              objIn: "ltmbqybsn",
              objOut: "l7yax5e5f",
            },
          ],
        },
      ],
      objName: "Ops.Math.Sum",
    },
    {
      id: "or292emfj",
      uiAttribs: { subPatch: "2154fd20-4fef-42fd-bef2-ef39e6975cdf" },
      portsOut: [
        { name: "create port", value: 0 },
        {
          name: "in0 + number2",
          links: [
            {
              portIn: "number2",
              portOut: "in0 + number2",
              objIn: "l7yax5e5f",
              objOut: "or292emfj",
            },
          ],
        },
        {
          name: "in1 SwitchTextures Next",
          links: [
            {
              portIn: "out2 CustomShader render",
              portOut: "in1 SwitchTextures Next",
              objIn: "ltmbqybsn",
              objOut: "or292emfj",
            },
          ],
        },
      ],
      objName: "Ops.Ui.PatchInput",
    },
    {
      id: "ltmbqybsn",
      uiAttribs: { subPatch: "2154fd20-4fef-42fd-bef2-ef39e6975cdf" },
      portsIn: [
        { name: "create port", value: 0 },
        { name: "out4 CustomShader textureInput", value: 0 },
      ],
      objName: "Ops.Ui.PatchOutput",
    },
    {
      id: "gpxi4rlmc",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      storage: { subPatchVer: 1 },
      portsIn: [
        { name: "create port", value: 0 },
        {
          name: "dataStr",
          value:
            '{"ports":[{"name":"in0 + number2","type":0,"value":0},{"name":"in1 SwitchTextures Next","type":1},{"name":"in2 SwitchTextures texture","type":2,"objType":"texture"}],"portsOut":[{"name":"out0 Ops.Gl.ShaderEffects.TransformTextureCoordinates Repeat X","type":0},{"name":"out1 Ops.Gl.ShaderEffects.TransformTextureCoordinates Translate X","type":0},{"name":"out2 CustomShader render","type":1},{"name":"out3 CanvasInfo Aspect Ratio","type":0},{"name":"out4 CustomShader textureInput","type":2}]}',
        },
        { name: "patchId", value: "2154fd20-4fef-42fd-bef2-ef39e6975cdf" },
      ],
      portsOut: [
        { name: "create port out", value: 0 },
        {
          name: "out0 Ops.Gl.ShaderEffects.TransformTextureCoordinates Repeat X",
          links: [
            {
              portIn: "repeat X",
              portOut:
                "out0 Ops.Gl.ShaderEffects.TransformTextureCoordinates Repeat X",
              objIn: "v38pi7nzw",
              objOut: "gpxi4rlmc",
            },
          ],
        },
        {
          name: "out1 Ops.Gl.ShaderEffects.TransformTextureCoordinates Translate X",
          links: [
            {
              portIn: "offset X",
              portOut:
                "out1 Ops.Gl.ShaderEffects.TransformTextureCoordinates Translate X",
              objIn: "v38pi7nzw",
              objOut: "gpxi4rlmc",
            },
          ],
        },
        {
          name: "out3 CanvasInfo Aspect Ratio",
          links: [
            {
              portIn: "number2",
              portOut: "out3 CanvasInfo Aspect Ratio",
              objIn: "exw5m949c",
              objOut: "gpxi4rlmc",
            },
          ],
        },
      ],
      objName: "Ops.Ui.SubPatch",
    },
    {
      id: "xm013etp7",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsOut: [
        {
          name: "number",
          links: [
            {
              portIn: "play",
              portOut: "number",
              objIn: "lcig881l8",
              objOut: "xm013etp7",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.NumberByTrigger",
    },
    {
      id: "b2sqi3l7g",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Named Trigger", value: "loaded" }],
      portsOut: [
        {
          name: "Triggered",
          links: [
            {
              portIn: "exe",
              portOut: "Triggered",
              objIn: "a4u8a1x4q",
              objOut: "b2sqi3l7g",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.TriggerReceive",
    },
    {
      id: "a4u8a1x4q",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "delay", value: 0.1 }],
      portsOut: [
        {
          name: "next",
          links: [
            {
              portIn: "1",
              portOut: "next",
              objIn: "xm013etp7",
              objOut: "a4u8a1x4q",
            },
            {
              portIn: "trigger",
              portOut: "next",
              objIn: "wo3yxin4e",
              objOut: "a4u8a1x4q",
            },
          ],
        },
        { name: "Delaying", value: false },
      ],
      objName: "Ops.Trigger.DelayedTrigger",
    },
    {
      id: "3fessdj9o",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Named Trigger", value: "controlPlay" }],
      portsOut: [
        {
          name: "Triggered",
          links: [
            {
              portIn: "trigger",
              portOut: "Triggered",
              objIn: "wo3yxin4e",
              objOut: "3fessdj9o",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.TriggerReceive",
    },
    {
      id: "o2rjjfyi8",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "playerStatus" }],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "v38pi7nzw",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [
        {
          name: "Fragment Code",
          value:
            "IN vec2 texCoord;\r\nUNI vec2 offset;  // Offset in X and Y directions\r\nUNI vec2 repeat;  // Repeat in X and Y directions\r\nUNI sampler2D textureInput;\r\n{{MODULES_HEAD}}\r\nvoid main()\r\n{\r\n    vec2 uv = texCoord * repeat + offset; // Apply offset and repeat\r\n    // Wrap UV coordinates to ensure they stay within the [0, 1] range\r\n    uv = fract(uv);\r\n    {{MODULE_COLOR}}\r\n    outColor = texture(textureInput, uv); // Sample the texture using modified coordinates\r\n}",
        },
        {
          name: "Vertex Code",
          value:
            "{{MODULES_HEAD}}\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN vec3 attrTangent,attrBiTangent;\n\nIN float attrVertIndex;\n\nOUT vec2 texCoord;\nOUT vec3 norm;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n    texCoord=attrTexCoord;\n    norm=attrVertNormal;\n    vec4 pos=vec4(vPosition,  1.0);\n    vec3 tangent=attrTangent;\n    vec3 bitangent=attrBiTangent;\n    mat4 mMatrix=modelMatrix;\n    gl_PointSize=10.0;\n\n    {{MODULE_VERTEX_POSITION}}\n    gl_Position = projMatrix * (viewMatrix*mMatrix) * pos;\n}\n",
        },
        { name: "Use As Material", value: 0 },
        { name: "repeat Y", value: 1 },
      ],
      portsOut: [
        {
          name: "trigger",
          links: [
            {
              portIn: "Render",
              portOut: "trigger",
              objIn: "z1150e2ur",
              objOut: "v38pi7nzw",
            },
          ],
        },
        {
          name: "Shader",
          links: [
            {
              portIn: "object port 2",
              portOut: "Shader",
              objIn: "vyl1eomnh",
              objOut: "v38pi7nzw",
            },
          ],
        },
        { name: "Has Errors", value: false },
      ],
      objName: "Ops.Gl.Shader.CustomShader_v2",
    },
    {
      id: "ece3100d-56f4-40e1-bd04-711aba30c988",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsOut: [
        { name: "create port", value: 0 },
        {
          name: "in0 Ops.Trigger.RouteTriggerString_v2 Trigger 1",
          links: [
            {
              portIn: "Update",
              portOut: "in0 Ops.Trigger.RouteTriggerString_v2 Trigger 1",
              objIn: "lcig881l8",
              objOut: "ece3100d-56f4-40e1-bd04-711aba30c988",
            },
          ],
        },
      ],
      objName: "Ops.Ui.PatchInput",
    },
    {
      id: "c2dfdfab-f08f-46c6-8599-9c62d64da7c1",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "create port", value: 0 }],
      objName: "Ops.Ui.PatchOutput",
    },
    {
      id: "c3020432-d72e-41bb-8274-dbd55ba98235",
      uiAttribs: {},
      storage: { subPatchVer: 1 },
      portsIn: [
        { name: "create port", value: 0 },
        {
          name: "dataStr",
          value:
            '{"ports":[{"name":"in0 Ops.Trigger.RouteTriggerString_v2 Trigger 1","type":1}],"portsOut":[{"name":"out0 ImageCompose texture_out","type":2,"objType":"texture"},{"name":"out1 ShaderToTexture Next","type":1}]}',
        },
        { name: "patchId", value: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      ],
      portsOut: [
        { name: "create port out", value: 0 },
        {
          name: "out0 ImageCompose texture_out",
          links: [
            {
              portIn: "object port 1",
              portOut: "out0 ImageCompose texture_out",
              objIn: "8ejjb9tja",
              objOut: "c3020432-d72e-41bb-8274-dbd55ba98235",
            },
          ],
        },
        {
          name: "out1 ShaderToTexture Next",
          links: [
            {
              portIn: "render",
              portOut: "out1 ShaderToTexture Next",
              objIn: "5m0nxxnjx",
              objOut: "c3020432-d72e-41bb-8274-dbd55ba98235",
            },
          ],
        },
      ],
      objName: "Ops.Ui.SubPatch",
    },
    {
      id: "728bc2af-66ca-4c6f-a6d4-2b51f809033d",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [
        { name: "Value 2", value: 0 },
        { name: "Value 3", value: 0 },
        { name: "Value 4", value: 0 },
        { name: "Value 5", value: 0 },
        { name: "Value 6", value: 0 },
        { name: "Value 7", value: 0 },
        { name: "Value 8", value: 0 },
        { name: "Value 9", value: 0 },
        { name: "Value 10", value: 0 },
        { name: "Value 11", value: 0 },
        { name: "Value 12", value: 0 },
        { name: "Value 13", value: 0 },
        { name: "Value 14", value: 0 },
        { name: "Value 15", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "z1jnexqjf",
              objOut: "728bc2af-66ca-4c6f-a6d4-2b51f809033d",
            },
          ],
        },
      ],
      objName: "Ops.Number.SwitchNumber",
    },
    {
      id: "73996b48-d3cb-4a6f-8009-ad1df84c1427",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "isImage" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Index",
              portOut: "Value",
              objIn: "728bc2af-66ca-4c6f-a6d4-2b51f809033d",
              objOut: "73996b48-d3cb-4a6f-8009-ad1df84c1427",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "mmolwn8pn",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "aboutScroll" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "perc",
              portOut: "Value",
              objIn: "dbus6zao0",
              objOut: "mmolwn8pn",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "y53d604uk",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "workScroll" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "perc",
              portOut: "Value",
              objIn: "0co9dzwpn",
              objOut: "y53d604uk",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "0co9dzwpn",
      uiAttribs: {},
      portsOut: [
        {
          name: "Next",
          links: [
            {
              portIn: "Exe",
              portOut: "Next",
              objIn: "dbus6zao0",
              objOut: "0co9dzwpn",
            },
          ],
        },
        {
          name: "Result",
          links: [
            {
              portIn: "Array 1",
              portOut: "Result",
              objIn: "dbus6zao0",
              objOut: "0co9dzwpn",
            },
          ],
        },
      ],
      objName: "Ops.Array.InterpolateArrays",
    },
    {
      id: "ddsl6t6bk",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 0.6 },
        { name: "Y", value: 1.12 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 0",
              portOut: "Array",
              objIn: "01spwg00b",
              objOut: "ddsl6t6bk",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "01spwg00b",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "2kmdmhz3p",
              objOut: "01spwg00b",
            },
          ],
        },
        { name: "Array length", value: 7 },
      ],
      objName: "Ops.Array.ArrayMerge_v3",
    },
    {
      id: "dbus6zao0",
      uiAttribs: {},
      portsOut: [
        {
          name: "Next",
          links: [
            {
              portIn: "Execute",
              portOut: "Next",
              objIn: "lywnyv9o4",
              objOut: "dbus6zao0",
            },
          ],
        },
        {
          name: "Result",
          links: [
            {
              portIn: "Array In",
              portOut: "Result",
              objIn: "lywnyv9o4",
              objOut: "dbus6zao0",
            },
          ],
        },
      ],
      objName: "Ops.Array.InterpolateArrays",
    },
    {
      id: "lywnyv9o4",
      uiAttribs: {},
      portsIn: [
        { name: "Separate inc/dec", value: 0 },
        { name: "Inc factor", value: 30, title: "Inc/Dec factor" },
        { name: "Dec factor", value: 4 },
      ],
      portsOut: [
        {
          name: "Next",
          links: [
            {
              portIn: "render",
              portOut: "Next",
              objIn: "3e9jbf60v",
              objOut: "lywnyv9o4",
            },
          ],
        },
        {
          name: "Array Out",
          links: [
            {
              portIn: "Array",
              portOut: "Array Out",
              objIn: "ub6p4urcu",
              objOut: "lywnyv9o4",
            },
            {
              portIn: "array",
              portOut: "Array Out",
              objIn: "cqjowcwqt",
              objOut: "lywnyv9o4",
            },
            {
              portIn: "Array",
              portOut: "Array Out",
              objIn: "o9o1lvbn5",
              objOut: "lywnyv9o4",
            },
          ],
        },
      ],
      objName: "Ops.Array.SmoothArray",
    },
    {
      id: "mgvdxuuuc",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: 3.7 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "01spwg00b",
              objOut: "mgvdxuuuc",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "gnz3lfvnx",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 148.35 },
        { name: "Y", value: -67.71 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 2",
              portOut: "Array",
              objIn: "01spwg00b",
              objOut: "gnz3lfvnx",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "9ab09c55-a9f4-45b3-91f7-1438b3975417",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
        { name: "Array 8", value: 0 },
        { name: "Array 9", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Array 1",
              portOut: "Result",
              objIn: "0co9dzwpn",
              objOut: "9ab09c55-a9f4-45b3-91f7-1438b3975417",
            },
          ],
        },
      ],
      objName: "Ops.Array.SwitchArray",
    },
    {
      id: "400e715b-2702-4f99-acf3-b545cbb099f7",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "mediaQueryIndex" }],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "25dac18d-a406-44cb-a11e-6770fc5fe1e3",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "mediaQueryIndex" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Index",
              portOut: "Value",
              objIn: "9ab09c55-a9f4-45b3-91f7-1438b3975417",
              objOut: "25dac18d-a406-44cb-a11e-6770fc5fe1e3",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "xunvxt053",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
        { name: "Array 8", value: 0 },
        { name: "Array 9", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Array 2",
              portOut: "Result",
              objIn: "0co9dzwpn",
              objOut: "xunvxt053",
            },
          ],
        },
      ],
      objName: "Ops.Array.SwitchArray",
    },
    {
      id: "zazzu6gav",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
        { name: "Array 8", value: 0 },
        { name: "Array 9", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Array 2",
              portOut: "Result",
              objIn: "dbus6zao0",
              objOut: "zazzu6gav",
            },
          ],
        },
      ],
      objName: "Ops.Array.SwitchArray",
    },
    {
      id: "lcig881l8",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [
        { name: "file", display: "file" },
        { name: "loop", value: 1 },
        { name: "Volume", value: 1 },
        { name: "Update FPS", value: 30 },
        { name: "Filter index", value: 1 },
        { name: "Filter", value: "linear" },
        { name: "Wrap index", value: 2 },
        { name: "Wrap", value: "clamp to edge" },
        { name: "flip", value: 1 },
        { name: "set time", value: 0 },
        { name: "Preload", value: 1 },
        { name: "Show Interaction needed Button", value: 0 },
      ],
      portsOut: [
        {
          name: "Next",
          links: [
            {
              portIn: "exec",
              portOut: "Next",
              objIn: "wm3l5lbrt",
              objOut: "lcig881l8",
            },
          ],
        },
        {
          name: "texture",
          links: [
            {
              portIn: "texture0",
              portOut: "texture",
              objIn: "wm3l5lbrt",
              objOut: "lcig881l8",
            },
          ],
        },
        { name: "duration", value: 119.933333 },
        { name: "progress", value: 0.8527424459711845 },
        { name: "Interaction Needed", value: 0 },
        { name: "CurrentTime", value: 102.274518 },
        {
          name: "Loading",
          links: [
            {
              portIn: "in bool",
              portOut: "Loading",
              objIn: "k66hq3ihz",
              objOut: "lcig881l8",
            },
          ],
        },
        { name: "Playing", value: 1 },
        { name: "Can Play Through", value: 1 },
        { name: "Width", value: 1440 },
        { name: "Height", value: 1440 },
        {
          name: "Aspect Ratio",
          links: [
            {
              portIn: "Value 0",
              portOut: "Aspect Ratio",
              objIn: "728bc2af-66ca-4c6f-a6d4-2b51f809033d",
              objOut: "lcig881l8",
            },
          ],
        },
        { name: "Has Error", value: 0 },
        { name: "Auto FPS", value: 1 },
        { name: "Error Message", value: "" },
      ],
      objName: "Ops.User.srcphag.VideoJS",
    },
    {
      id: "sokw138q9",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "mainColor" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "cretzkq7p",
      uiAttribs: {},
      portsIn: [{ name: "Bytes", value: 0 }],
      portsOut: [
        {
          name: "R",
          links: [
            {
              portIn: "r",
              portOut: "R",
              objIn: "gm13f4zcc",
              objOut: "cretzkq7p",
            },
          ],
        },
        {
          name: "G",
          links: [
            {
              portIn: "g",
              portOut: "G",
              objIn: "gm13f4zcc",
              objOut: "cretzkq7p",
            },
          ],
        },
        {
          name: "B",
          links: [
            {
              portIn: "b",
              portOut: "B",
              objIn: "gm13f4zcc",
              objOut: "cretzkq7p",
            },
          ],
        },
      ],
      objName: "Ops.Color.HexToRGB_v2",
    },
    {
      id: "eus15y61d",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "mainColorHex" }],
      objName: "Ops.Vars.VarSetString_v2",
    },
    {
      id: "p2hdsw9tg",
      uiAttribs: {},
      portsIn: [{ name: "value", value: "#0001ff" }],
      portsOut: [
        {
          name: "String",
          links: [
            {
              portIn: "Value",
              portOut: "String",
              objIn: "eus15y61d",
              objOut: "p2hdsw9tg",
            },
          ],
        },
      ],
      objName: "Ops.String.String_v2",
    },
    {
      id: "kf52yxg3c",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "mainColorHex" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Hex",
              portOut: "Value",
              objIn: "cretzkq7p",
              objOut: "kf52yxg3c",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetString",
    },
    {
      id: "t8wj0g1fm",
      uiAttribs: {},
      portsIn: [
        { name: "Separate inc/dec", value: 0 },
        { name: "Inc factor", value: 3, title: "Inc/Dec factor" },
        { name: "Dec factor", value: 4 },
      ],
      portsOut: [
        {
          name: "Array Out",
          links: [
            {
              portIn: "Value",
              portOut: "Array Out",
              objIn: "sokw138q9",
              objOut: "t8wj0g1fm",
            },
          ],
        },
      ],
      objName: "Ops.Array.SmoothArray",
    },
    {
      id: "0dsqix305",
      uiAttribs: {},
      portsIn: [{ name: "Named Trigger", value: "mainLoop" }],
      portsOut: [
        {
          name: "Triggered",
          links: [
            {
              portIn: "Execute",
              portOut: "Triggered",
              objIn: "t8wj0g1fm",
              objOut: "0dsqix305",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.TriggerReceive",
    },
    {
      id: "69ih8zk1e",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "mediaQueryIndex" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Index",
              portOut: "Value",
              objIn: "zazzu6gav",
              objOut: "69ih8zk1e",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "hargq3qo8",
      uiAttribs: {},
      portsIn: [
        { name: "Value", value: 1 },
        { name: "Variable", value: "videoPlay" },
      ],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "qnjs57c8o",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "videoPlay" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "speed",
              portOut: "Value",
              objIn: "lcig881l8",
              objOut: "qnjs57c8o",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "c850knda1",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "videoMuted" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "mute",
              portOut: "Value",
              objIn: "lcig881l8",
              objOut: "c850knda1",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "oen4upux4",
      uiAttribs: {},
      portsIn: [
        { name: "Value", value: 1 },
        { name: "Variable", value: "videoMuted" },
      ],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "plo7uwjmn",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [
        { name: "Array 2", value: 0 },
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
        { name: "Array 8", value: 0 },
        { name: "Array 9", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "array",
              portOut: "Result",
              objIn: "ls1owm8vb",
              objOut: "plo7uwjmn",
            },
            {
              portIn: "array",
              portOut: "Result",
              objIn: "gyjsxc17k",
              objOut: "plo7uwjmn",
            },
            {
              portIn: "array",
              portOut: "Result",
              objIn: "hnxcvkeen",
              objOut: "plo7uwjmn",
            },
          ],
        },
      ],
      objName: "Ops.Array.SwitchArray",
    },
    {
      id: "dck8p93pm",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [{ name: "a", value: 1 }],
      portsOut: [
        { name: "outr", value: 0 },
        { name: "outg", value: 0.00392156862745098 },
        { name: "outb", value: 1 },
        { name: "outa", value: 1 },
        { name: "Hex", value: "0001FF" },
        {
          name: "Array",
          links: [
            {
              portIn: "Array 0",
              portOut: "Array",
              objIn: "plo7uwjmn",
              objOut: "dck8p93pm",
            },
          ],
        },
      ],
      objName: "Ops.Color.ColorValue",
    },
    {
      id: "3hjppckvj",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [
        { name: "r", value: 0 },
        { name: "g", value: 0 },
        { name: "b", value: 0 },
        { name: "a", value: 0 },
      ],
      portsOut: [
        { name: "outr", value: 0 },
        { name: "outg", value: 0 },
        { name: "outb", value: 0 },
        { name: "outa", value: 0 },
        { name: "Hex", value: "000000" },
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "plo7uwjmn",
              objOut: "3hjppckvj",
            },
          ],
        },
      ],
      objName: "Ops.Color.ColorValue",
    },
    {
      id: "ls1owm8vb",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [
        { name: "index", value: 0 },
        { name: "Value Invalid Index", value: 0 },
      ],
      portsOut: [
        {
          name: "value",
          links: [
            {
              portIn: "r",
              portOut: "value",
              objIn: "x1nx2ee3j",
              objOut: "ls1owm8vb",
            },
          ],
        },
        { name: "Valid Index", value: 1 },
      ],
      objName: "Ops.Array.ArrayGetNumber",
    },
    {
      id: "gyjsxc17k",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [
        { name: "index", value: 1 },
        { name: "Value Invalid Index", value: 0 },
      ],
      portsOut: [
        {
          name: "value",
          links: [
            {
              portIn: "g",
              portOut: "value",
              objIn: "x1nx2ee3j",
              objOut: "gyjsxc17k",
            },
          ],
        },
        { name: "Valid Index", value: 1 },
      ],
      objName: "Ops.Array.ArrayGetNumber",
    },
    {
      id: "hnxcvkeen",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [
        { name: "index", value: 2 },
        { name: "Value Invalid Index", value: 0 },
      ],
      portsOut: [
        {
          name: "value",
          links: [
            {
              portIn: "b",
              portOut: "value",
              objIn: "x1nx2ee3j",
              objOut: "hnxcvkeen",
            },
          ],
        },
        { name: "Valid Index", value: 1 },
      ],
      objName: "Ops.Array.ArrayGetNumber",
    },
    {
      id: "q5hgcc873",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsOut: [
        { name: "create port", value: 0 },
        {
          name: "in0 Ops.Gl.Matrix.TransformView trigger",
          links: [
            {
              portIn: "Execute",
              portOut: "in0 Ops.Gl.Matrix.TransformView trigger",
              objIn: "3ms5xb3ej",
              objOut: "q5hgcc873",
            },
          ],
        },
        { name: "in1 Ops.Json.ObjectToArray Array", value: 0 },
        { name: "in2 var get  Value", value: 0 },
      ],
      objName: "Ops.Ui.PatchInput",
    },
    {
      id: "hmrwm30er",
      uiAttribs: {},
      storage: { subPatchVer: 1 },
      portsIn: [
        { name: "create port", value: 0 },
        {
          name: "dataStr",
          value:
            '{"ports":[{"name":"in0 Ops.Gl.Matrix.TransformView trigger","type":1},{"name":"in1 Ops.Json.ObjectToArray Array","type":3,"value":null},{"name":"in2 var get  Value","type":5,"value":null}],"portsOut":[{"name":"out0 Ops.Ui.VizArrayTable Start Row","type":0},{"name":"out1 Ops.Trigger.RouteTrigger Next Trigger","type":1}]}',
        },
        { name: "patchId", value: "oq0mm5hrc" },
      ],
      portsOut: [{ name: "create port out", value: 0 }],
      objName: "Ops.Ui.SubPatch",
    },
    {
      id: "m9hzg1ife",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [
        { name: "create port", value: 0 },
        { name: "out0 Ops.Ui.VizArrayTable Start Row", value: 0 },
      ],
      objName: "Ops.Ui.PatchOutput",
    },
    {
      id: "99lxruhzw",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [
        { name: "blendMode index", value: 0 },
        { name: "blendMode", value: "normal" },
        { name: "Amount", value: 1 },
        { name: "Target index", value: 0 },
        { name: "Target", value: "Color" },
        { name: "Scale", value: 1 },
        { name: "Use Texture Alpha", value: 0 },
        { name: "Pos X", value: 0 },
        { name: "Pos Y", value: 0 },
        { name: "Rot X", value: 0 },
        { name: "Rot Y", value: 0 },
        { name: "Rot Z", value: 0 },
        { name: "Mapping index", value: 4 },
        { name: "Mapping", value: "Screen" },
        { name: "Discard", value: 0 },
        { name: "WorldSpace", value: 0 },
      ],
      portsOut: [
        {
          name: "trigger",
          links: [
            {
              portIn: "Render",
              portOut: "trigger",
              objIn: "hjdeu0zr1",
              objOut: "99lxruhzw",
            },
          ],
        },
      ],
      objName: "Ops.Gl.ShaderEffects.TextureProjection_v2",
    },
    {
      id: "e50oqab02",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [{ name: "Variable", value: "textTexture" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Texture",
              portOut: "Value",
              objIn: "23spdnjhn",
              objOut: "e50oqab02",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetTexture_v2",
    },
    {
      id: "23spdnjhn",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [
        { name: "blendMode index", value: 6 },
        { name: "blendMode", value: "add" },
        { name: "Amount", value: 1 },
        { name: "Target index", value: 0 },
        { name: "Target", value: "Color" },
        { name: "Scale", value: 1 },
        { name: "Use Texture Alpha", value: 0 },
        { name: "Pos X", value: 0 },
        { name: "Pos Y", value: 0 },
        { name: "Rot X", value: 0 },
        { name: "Rot Y", value: 0 },
        { name: "Rot Z", value: 0 },
        { name: "Mapping index", value: 5 },
        { name: "Mapping", value: "TexCoords 1" },
        { name: "Discard", value: 0 },
        { name: "WorldSpace", value: 1 },
      ],
      portsOut: [
        {
          name: "trigger",
          links: [
            {
              portIn: "Render",
              portOut: "trigger",
              objIn: "hjdeu0zr1",
              objOut: "23spdnjhn",
            },
          ],
        },
      ],
      objName: "Ops.Gl.ShaderEffects.TextureProjection_v2",
    },
    {
      id: "x1nx2ee3j",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [
        { name: "a", value: 1 },
        { name: "colorizeTexture", value: 0 },
        { name: "Vertex Colors", value: 0 },
        { name: "Alpha Mask Source index", value: 0 },
        { name: "Alpha Mask Source", value: "Luminance" },
        { name: "Opacity TexCoords Transform", value: 0 },
        { name: "Discard Transparent Pixels", value: 0 },
        { name: "diffuseRepeatX", value: 1 },
        { name: "diffuseRepeatY", value: 1 },
        { name: "Tex Offset X", value: 0 },
        { name: "Tex Offset Y", value: 0 },
        { name: "Crop TexCoords", value: 0 },
        { name: "billboard", value: 0 },
      ],
      portsOut: [
        {
          name: "trigger",
          links: [
            {
              portIn: "render",
              portOut: "trigger",
              objIn: "23spdnjhn",
              objOut: "x1nx2ee3j",
            },
          ],
        },
      ],
      objName: "Ops.Gl.Shader.BasicMaterial_v3",
    },
    {
      id: "6szyoriwg",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [{ name: "Variable", value: "imageTexture" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Texture",
              portOut: "Value",
              objIn: "99lxruhzw",
              objOut: "6szyoriwg",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetTexture_v2",
    },
    {
      id: "aghifmi60",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [{ name: "Variable", value: "mainColor" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Array",
              portOut: "Value",
              objIn: "nkc7m4mpo",
              objOut: "aghifmi60",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "nkc7m4mpo",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [{ name: "Index", value: 0 }],
      portsOut: [
        {
          name: "X",
          links: [
            {
              portIn: "r",
              portOut: "X",
              objIn: "dck8p93pm",
              objOut: "nkc7m4mpo",
            },
          ],
        },
        {
          name: "Y",
          links: [
            {
              portIn: "g",
              portOut: "Y",
              objIn: "dck8p93pm",
              objOut: "nkc7m4mpo",
            },
          ],
        },
        {
          name: "Z",
          links: [
            {
              portIn: "b",
              portOut: "Z",
              objIn: "dck8p93pm",
              objOut: "nkc7m4mpo",
            },
          ],
        },
      ],
      objName: "Ops.Array.Array3GetNumbers",
    },
    {
      id: "hjdeu0zr1",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [
        { name: "data", value: "" },
        {
          name: "glb File",
          value:
            "./651a88bdc6d98bfb822e8d4a_000002045050001042130030000_cubic2UV.glb",
          display: "file",
        },
        { name: "Draw", value: 1 },
        { name: "Camera index", value: 0 },
        { name: "Camera", value: "None" },
        { name: "Animation", value: "" },
        { name: "Center index", value: 0 },
        { name: "Center", value: "None" },
        { name: "Rescale", value: 1 },
        { name: "Rescale Size", value: 1.5 },
        { name: "Time", value: 0 },
        { name: "Sync to timeline", value: 0 },
        { name: "Loop", value: 1 },
        { name: "Normals Format index", value: 0 },
        { name: "Normals Format", value: "XYZ" },
        { name: "Vertices Format index", value: 0 },
        { name: "Vertices Format", value: "XYZ" },
        { name: "Calc Normals index", value: 0 },
        { name: "Calc Normals", value: "Auto" },
        { name: "Hide Nodes", value: 0 },
        { name: "Use Material Properties", value: 0 },
        { name: "Active", value: 1 },
      ],
      portsOut: [
        {
          name: "Render Before",
          links: [
            {
              portIn: "out1 Ops.Trigger.RouteTrigger Next Trigger",
              portOut: "Render Before",
              objIn: "m9hzg1ife",
              objOut: "hjdeu0zr1",
            },
          ],
        },
        { name: "Generator", value: "" },
        { name: "GLTF Version", value: 2 },
        { name: "Anim Length", value: 0 },
        { name: "Anim Time", value: 0 },
        { name: "Loading", value: false },
      ],
      objName: "Ops.Gl.GLTF.GltfScene_v4",
    },
    {
      id: "2kmdmhz3p",
      uiAttribs: {},
      portsIn: [
        { name: "Value", useVariable: "unknown" },
        { name: "Variable", value: "indexPSR_mq3" },
      ],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "jwfjtazmg",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexPSR_mq3" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Array 2",
              portOut: "Value",
              objIn: "9ab09c55-a9f4-45b3-91f7-1438b3975417",
              objOut: "jwfjtazmg",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "p70hvwc6c",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "mediaQueryIndex" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Index",
              portOut: "Value",
              objIn: "xunvxt053",
              objOut: "p70hvwc6c",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "2i8gsui6v",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "workPSR_mq3" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "exnbfhfos",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 0 },
        { name: "Y", value: 0 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 0",
              portOut: "Array",
              objIn: "2hezwqori",
              objOut: "exnbfhfos",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "2hezwqori",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "2i8gsui6v",
              objOut: "2hezwqori",
            },
          ],
        },
        { name: "Array length", value: 7 },
      ],
      objName: "Ops.Array.ArrayMerge_v3",
    },
    {
      id: "i4cd58a1f",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: 5.44 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "2hezwqori",
              objOut: "i4cd58a1f",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "6bkqlotoh",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 138.85 },
        { name: "Y", value: -28.8 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 2",
              portOut: "Array",
              objIn: "2hezwqori",
              objOut: "6bkqlotoh",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "chc44agoc",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "workPSR_mq3" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "byk06hys1",
              portOut: "Value",
              objIn: "t94xojk09",
              objOut: "chc44agoc",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "pccmrol86",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "yf0cqputf",
              objOut: "pccmrol86",
            },
          ],
        },
        { name: "Array length", value: 7 },
      ],
      objName: "Ops.Array.ArrayMerge_v3",
    },
    {
      id: "ggf2ud9x6",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: 7.92 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "pccmrol86",
              objOut: "ggf2ud9x6",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "h4ozzfizw",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 2 },
        { name: "Y", value: 0 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 0",
              portOut: "Array",
              objIn: "pccmrol86",
              objOut: "h4ozzfizw",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "y0g4lw34g",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 51.5 },
        { name: "Y", value: -29.22 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 2",
              portOut: "Array",
              objIn: "pccmrol86",
              objOut: "y0g4lw34g",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "yf0cqputf",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexWorkPSR_mq3" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "ellnqv315",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexWorkPSR_mq3" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Array 2",
              portOut: "Value",
              objIn: "xunvxt053",
              objOut: "ellnqv315",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "mcbcfh35i",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 3.04 },
        { name: "Y", value: -1.89 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 0",
              portOut: "Array",
              objIn: "bvm6d55bb",
              objOut: "mcbcfh35i",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "bvm6d55bb",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "c656yrjan",
              objOut: "bvm6d55bb",
            },
          ],
        },
        { name: "Array length", value: 7 },
      ],
      objName: "Ops.Array.ArrayMerge_v3",
    },
    {
      id: "w7wharqei",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: 7.11 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "bvm6d55bb",
              objOut: "w7wharqei",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "frq6m3yxr",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 33.93 },
        { name: "Y", value: -18.54 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 2",
              portOut: "Array",
              objIn: "bvm6d55bb",
              objOut: "frq6m3yxr",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "c656yrjan",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexAboutPSR_mq3" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "uzyavlylt",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexAboutPSR_mq3" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Array 2",
              portOut: "Value",
              objIn: "zazzu6gav",
              objOut: "uzyavlylt",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "l36s3jlsl",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 1.62 },
        { name: "Y", value: 0 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 0",
              portOut: "Array",
              objIn: "4dksq1abi",
              objOut: "l36s3jlsl",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "4dksq1abi",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "h7mhzibj4",
              objOut: "4dksq1abi",
            },
          ],
        },
        { name: "Array length", value: 7 },
      ],
      objName: "Ops.Array.ArrayMerge_v3",
    },
    {
      id: "zg8hsww2r",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: 8.68 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "4dksq1abi",
              objOut: "zg8hsww2r",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "pf4ebu45x",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 332.62 },
        { name: "Y", value: -88.18 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 2",
              portOut: "Array",
              objIn: "4dksq1abi",
              objOut: "pf4ebu45x",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "h7mhzibj4",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexPSR_mq1" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "n2q1jok6z",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "tu8296wau",
              objOut: "n2q1jok6z",
            },
          ],
        },
        { name: "Array length", value: 7 },
      ],
      objName: "Ops.Array.ArrayMerge_v3",
    },
    {
      id: "vgphyej1w",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: -3.52 },
        { name: "Y", value: -1.67 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 0",
              portOut: "Array",
              objIn: "n2q1jok6z",
              objOut: "vgphyej1w",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "mqpqb4eo4",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: 15 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "n2q1jok6z",
              objOut: "mqpqb4eo4",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "vszs6x49d",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 333 },
        { name: "Y", value: 0 },
        { name: "Z", value: -8.39 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 2",
              portOut: "Array",
              objIn: "n2q1jok6z",
              objOut: "vszs6x49d",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "3sqb5827s",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "workPSR_mq1" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "byk06hys1",
              portOut: "Value",
              objIn: "6aubf72ju",
              objOut: "3sqb5827s",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "tu8296wau",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "workPSR_mq1" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "py33q58zb",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexPSR_mq1" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Array 0",
              portOut: "Value",
              objIn: "9ab09c55-a9f4-45b3-91f7-1438b3975417",
              objOut: "py33q58zb",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "5r7i5h20c",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "91pq98h5z",
              objOut: "5r7i5h20c",
            },
          ],
        },
        { name: "Array length", value: 7 },
      ],
      objName: "Ops.Array.ArrayMerge_v3",
    },
    {
      id: "ala5ig2bi",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 2.5 },
        { name: "Y", value: -10.94 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 0",
              portOut: "Array",
              objIn: "5r7i5h20c",
              objOut: "ala5ig2bi",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "upcxohqe5",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: 8.68 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "5r7i5h20c",
              objOut: "upcxohqe5",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "9r254ayc4",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 332.62 },
        { name: "Y", value: -88.68 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 2",
              portOut: "Array",
              objIn: "5r7i5h20c",
              objOut: "9r254ayc4",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "41cjp8rgl",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexWorkPSR_mq1" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Array 0",
              portOut: "Value",
              objIn: "xunvxt053",
              objOut: "41cjp8rgl",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "91pq98h5z",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexWorkPSR_mq1" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "yqjbwaeqk",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: -3.09 },
        { name: "Y", value: 4.9 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 0",
              portOut: "Array",
              objIn: "5uk9wosps",
              objOut: "yqjbwaeqk",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "5uk9wosps",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "lm4og22cv",
              objOut: "5uk9wosps",
            },
          ],
        },
        { name: "Array length", value: 7 },
      ],
      objName: "Ops.Array.ArrayMerge_v3",
    },
    {
      id: "5bpyu9pzr",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: 11.08 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "5uk9wosps",
              objOut: "5bpyu9pzr",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "6v2w0ex5l",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 222.34 },
        { name: "Y", value: -123.39 },
        { name: "Z", value: 11.62 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 2",
              portOut: "Array",
              objIn: "5uk9wosps",
              objOut: "6v2w0ex5l",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "lm4og22cv",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexAboutPSR_mq1" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "764ftab6t",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexAboutPSR_mq1" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Array 0",
              portOut: "Value",
              objIn: "zazzu6gav",
              objOut: "764ftab6t",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "r3u33h3hs",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [
        {
          name: "Fragment Code",
          value:
            "IN vec2 texCoord;\r\nUNI vec2 offset;\r\nUNI vec2 repeat;\r\nUNI bool wrapMode;  // Add this uniform\r\nUNI sampler2D textureInput;\r\n{{MODULES_HEAD}}\r\nvoid main()\r\n{\r\n    // Start with original texture coordinates\r\n    vec2 uv = texCoord;\r\n    \r\n    // Flip Y before repetition so pattern starts from top\r\n    uv.y = 1.0 - uv.y;\r\n    \r\n    // Create vertical repetition\r\n    uv.y *= repeat.y;\r\n    \r\n    // Apply offset\r\n    uv += offset;\r\n    \r\n    // Switch between wrap and clamp modes\r\n    uv = wrapMode ? fract(uv) : clamp(uv, 0.0, 1.0);\r\n    \r\n    // Flip Y again to maintain correct image orientation\r\n    uv.y = 1.0 - uv.y;\r\n    \r\n    {{MODULE_COLOR}}\r\n    outColor = texture(textureInput, uv);\r\n}",
        },
        {
          name: "Vertex Code",
          value:
            "{{MODULES_HEAD}}\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN vec3 attrTangent,attrBiTangent;\n\nIN float attrVertIndex;\n\nOUT vec2 texCoord;\nOUT vec3 norm;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\nvoid main()\n{\n    texCoord=attrTexCoord;\n    norm=attrVertNormal;\n    vec4 pos=vec4(vPosition,  1.0);\n    vec3 tangent=attrTangent;\n    vec3 bitangent=attrBiTangent;\n    mat4 mMatrix=modelMatrix;\n    gl_PointSize=10.0;\n\n    {{MODULE_VERTEX_POSITION}}\n    gl_Position = projMatrix * (viewMatrix*mMatrix) * pos;\n}\n",
        },
        { name: "Use As Material", value: 0 },
        { name: "repeat X", value: 1 },
        { name: "wrapMode", value: 0 },
      ],
      portsOut: [
        {
          name: "trigger",
          links: [
            {
              portIn: "Render",
              portOut: "trigger",
              objIn: "z1150e2ur",
              objOut: "r3u33h3hs",
            },
          ],
        },
        {
          name: "Shader",
          links: [
            {
              portIn: "object port 0",
              portOut: "Shader",
              objIn: "vyl1eomnh",
              objOut: "r3u33h3hs",
            },
            {
              portIn: "object port 1",
              portOut: "Shader",
              objIn: "vyl1eomnh",
              objOut: "r3u33h3hs",
            },
          ],
        },
        { name: "Has Errors", value: false },
      ],
      objName: "Ops.Gl.Shader.CustomShader_v2",
    },
    {
      id: "6fpmfnjy1",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "mediaQuery" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Switch Value",
              portOut: "Value",
              objIn: "b0hk8u9bi",
              objOut: "6fpmfnjy1",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetString",
    },
    {
      id: "b0hk8u9bi",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [
        { name: "String 0", value: "mq1" },
        { name: "String 1", value: "mq2" },
        { name: "String 2", value: "mq3" },
        { name: "String 3", value: "" },
        { name: "String 4", value: "" },
        { name: "String 5", value: "" },
        { name: "String 6", value: "" },
        { name: "String 7", value: "" },
        { name: "String 8", value: "" },
        { name: "String 9", value: "" },
        { name: "String 10", value: "" },
        { name: "String 11", value: "" },
        { name: "String 12", value: "" },
        { name: "String 13", value: "" },
        { name: "String 14", value: "" },
        { name: "String 15", value: "" },
        { name: "String 16", value: "" },
        { name: "String 17", value: "" },
        { name: "String 18", value: "" },
        { name: "String 19", value: "" },
        { name: "String 20", value: "" },
        { name: "String 21", value: "" },
        { name: "String 22", value: "" },
        { name: "String 23", value: "" },
      ],
      portsOut: [
        {
          name: "Next Trigger",
          links: [
            {
              portIn: "in1 SwitchTextures Next",
              portOut: "Next Trigger",
              objIn: "gpxi4rlmc",
              objOut: "b0hk8u9bi",
            },
          ],
        },
        {
          name: "Switched Index",
          links: [
            {
              portIn: "Object Index",
              portOut: "Switched Index",
              objIn: "vyl1eomnh",
              objOut: "b0hk8u9bi",
            },
          ],
        },
        {
          name: "Trigger 0",
          links: [
            {
              portIn: "render",
              portOut: "Trigger 0",
              objIn: "r3u33h3hs",
              objOut: "b0hk8u9bi",
            },
          ],
        },
        {
          name: "Trigger 1",
          links: [
            {
              portIn: "render",
              portOut: "Trigger 1",
              objIn: "r3u33h3hs",
              objOut: "b0hk8u9bi",
            },
          ],
        },
        {
          name: "Trigger 2",
          links: [
            {
              portIn: "render",
              portOut: "Trigger 2",
              objIn: "v38pi7nzw",
              objOut: "b0hk8u9bi",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.RouteTriggerString_v2",
    },
    {
      id: "exw5m949c",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "repeat Y",
              portOut: "result",
              objIn: "r3u33h3hs",
              objOut: "exw5m949c",
            },
          ],
        },
      ],
      objName: "Ops.Math.Divide",
    },
    {
      id: "imr8zljmp",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 0.41 },
        { name: "Y", value: 6.17 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 0",
              portOut: "Array",
              objIn: "bpyykpwd5",
              objOut: "imr8zljmp",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "bpyykpwd5",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "w8rz76p68",
              objOut: "bpyykpwd5",
            },
          ],
        },
        { name: "Array length", value: 7 },
      ],
      objName: "Ops.Array.ArrayMerge_v3",
    },
    {
      id: "2p5xzcx54",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: 12.37 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "bpyykpwd5",
              objOut: "2p5xzcx54",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "0zhl4oyyh",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 233.71 },
        { name: "Y", value: -64.86 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 2",
              portOut: "Array",
              objIn: "bpyykpwd5",
              objOut: "0zhl4oyyh",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "w8rz76p68",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "workPSR_mq2" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "gv5wydpvw",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 3.88 },
        { name: "Y", value: 0.89 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 0",
              portOut: "Array",
              objIn: "0aldyxi0a",
              objOut: "gv5wydpvw",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "0aldyxi0a",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "z9j7nqtoi",
              objOut: "0aldyxi0a",
            },
          ],
        },
        { name: "Array length", value: 7 },
      ],
      objName: "Ops.Array.ArrayMerge_v3",
    },
    {
      id: "rz2flkkiq",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: 5.95 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "0aldyxi0a",
              objOut: "rz2flkkiq",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "1ohqdvker",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 248.87 },
        { name: "Y", value: -40.95 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 2",
              portOut: "Array",
              objIn: "0aldyxi0a",
              objOut: "1ohqdvker",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "z9j7nqtoi",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexPSR_mq2" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "zauhxljs1",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexPSR_mq2" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Array 1",
              portOut: "Value",
              objIn: "9ab09c55-a9f4-45b3-91f7-1438b3975417",
              objOut: "zauhxljs1",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "wktp2kjaz",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "workPSR_mq2" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "byk06hys1",
              portOut: "Value",
              objIn: "5l8gkfndg",
              objOut: "wktp2kjaz",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "sgxfp2dh9",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 0.17 },
        { name: "Y", value: -3.43 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 0",
              portOut: "Array",
              objIn: "nbbh25gsp",
              objOut: "sgxfp2dh9",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "nbbh25gsp",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "hpl4pfw6d",
              objOut: "nbbh25gsp",
            },
          ],
        },
        { name: "Array length", value: 7 },
      ],
      objName: "Ops.Array.ArrayMerge_v3",
    },
    {
      id: "0gbr5e0jd",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: 9.08 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "nbbh25gsp",
              objOut: "0gbr5e0jd",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "obpbg4umr",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 340.51 },
        { name: "Y", value: 8.92 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 2",
              portOut: "Array",
              objIn: "nbbh25gsp",
              objOut: "obpbg4umr",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "hpl4pfw6d",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexAboutPSR_mq2" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "j5bnp2pah",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexAboutPSR_mq2" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Array 1",
              portOut: "Value",
              objIn: "zazzu6gav",
              objOut: "j5bnp2pah",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "lz04ulvsv",
      uiAttribs: {},
      portsIn: [{ name: "Title", value: "" }],
      objName: "Ops.Ui.Area",
    },
    {
      id: "74ixjif61",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 0.41 },
        { name: "Y", value: -6.73 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 0",
              portOut: "Array",
              objIn: "tts0z2501",
              objOut: "74ixjif61",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "tts0z2501",
      uiAttribs: {},
      portsIn: [
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "5weur9rlg",
              objOut: "tts0z2501",
            },
          ],
        },
        { name: "Array length", value: 7 },
      ],
      objName: "Ops.Array.ArrayMerge_v3",
    },
    {
      id: "1glgv73qv",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: 8.88 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "tts0z2501",
              objOut: "1glgv73qv",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "zky6tth8a",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 1 },
        { name: "X", value: 250.28 },
        { name: "Y", value: -45.93 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 2",
              portOut: "Array",
              objIn: "tts0z2501",
              objOut: "zky6tth8a",
            },
          ],
        },
        { name: "Total points", value: 1 },
        { name: "Array length", value: 3 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "5weur9rlg",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexWorkPSR_mq2" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "bvk5q8iei",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "indexWorkPSR_mq2" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Array 1",
              portOut: "Value",
              objIn: "xunvxt053",
              objOut: "bvk5q8iei",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "j2v7lizv8",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "textTexture" }],
      objName: "Ops.Vars.VarSetTexture_v2",
    },
    {
      id: "3ms5xb3ej",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [
        { name: "String 0", value: "index" },
        { name: "String 1", value: "works" },
        { name: "String 2", value: "" },
        { name: "String 3", value: "" },
        { name: "String 4", value: "" },
        { name: "String 5", value: "" },
        { name: "String 6", value: "" },
        { name: "String 7", value: "" },
        { name: "String 8", value: "" },
        { name: "String 9", value: "" },
        { name: "String 10", value: "" },
        { name: "String 11", value: "" },
        { name: "String 12", value: "" },
        { name: "String 13", value: "" },
        { name: "String 14", value: "" },
        { name: "String 15", value: "" },
        { name: "String 16", value: "" },
        { name: "String 17", value: "" },
        { name: "String 18", value: "" },
        { name: "String 19", value: "" },
        { name: "String 20", value: "" },
        { name: "String 21", value: "" },
        { name: "String 22", value: "" },
        { name: "String 23", value: "" },
      ],
      portsOut: [
        {
          name: "Switched Index",
          links: [
            {
              portIn: "Index",
              portOut: "Switched Index",
              objIn: "plo7uwjmn",
              objOut: "3ms5xb3ej",
            },
          ],
        },
        {
          name: "Trigger 0",
          links: [
            {
              portIn: "render",
              portOut: "Trigger 0",
              objIn: "x1nx2ee3j",
              objOut: "3ms5xb3ej",
            },
          ],
        },
        {
          name: "Trigger 1",
          links: [
            {
              portIn: "render",
              portOut: "Trigger 1",
              objIn: "99lxruhzw",
              objOut: "3ms5xb3ej",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.RouteTriggerString_v2",
    },
    {
      id: "f31jfdtdj",
      uiAttribs: { subPatch: "oq0mm5hrc" },
      portsIn: [{ name: "Variable", value: "pageContext" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Switch Value",
              portOut: "Value",
              objIn: "3ms5xb3ej",
              objOut: "f31jfdtdj",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetString",
    },
    {
      id: "vyl1eomnh",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsOut: [
        {
          name: "object out",
          links: [
            {
              portIn: "Shader",
              portOut: "object out",
              objIn: "z1150e2ur",
              objOut: "vyl1eomnh",
            },
          ],
        },
      ],
      objName: "Ops.Json.SwitchObject",
    },
    {
      id: "1rkhd6ijv",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "videoAspectRatio" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "number1",
              portOut: "Value",
              objIn: "exw5m949c",
              objOut: "1rkhd6ijv",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "233hz90n3",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "imageTextureOffset" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "rad5pr04g",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: 0 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 1",
              portOut: "Array",
              objIn: "kh45ej5sc",
              objOut: "rad5pr04g",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "x17czuoyb",
      uiAttribs: {},
      portsIn: [
        { name: "Array length", value: 1 },
        { name: "Mode select index", value: 0 },
        { name: "Mode select", value: "Number" },
        { name: "Default Value", value: -0.28 },
        { name: "Reverse", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Array 2",
              portOut: "Array",
              objIn: "kh45ej5sc",
              objOut: "x17czuoyb",
            },
          ],
        },
        { name: "Array length out", value: 1 },
      ],
      objName: "Ops.Array.Array_v3",
    },
    {
      id: "kh45ej5sc",
      uiAttribs: {},
      portsIn: [
        { name: "Array 0", value: 0 },
        { name: "Array 3", value: 0 },
        { name: "Array 4", value: 0 },
        { name: "Array 5", value: 0 },
        { name: "Array 6", value: 0 },
        { name: "Array 7", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Value",
              portOut: "Result",
              objIn: "233hz90n3",
              objOut: "kh45ej5sc",
            },
          ],
        },
      ],
      objName: "Ops.Array.ArrayPack",
    },
    {
      id: "i0q70ilkb",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [{ name: "Variable", value: "imageTextureOffset" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "array",
              portOut: "Value",
              objIn: "69llqqm87",
              objOut: "i0q70ilkb",
            },
            {
              portIn: "array",
              portOut: "Value",
              objIn: "y97ci5q96",
              objOut: "i0q70ilkb",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetArray_v2",
    },
    {
      id: "69llqqm87",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [
        { name: "index", value: 0 },
        { name: "Value Invalid Index", value: 0 },
      ],
      portsOut: [
        {
          name: "value",
          links: [
            {
              portIn: "offset X",
              portOut: "value",
              objIn: "r3u33h3hs",
              objOut: "69llqqm87",
            },
          ],
        },
        { name: "Valid Index", value: 1 },
      ],
      objName: "Ops.Array.ArrayGetNumber",
    },
    {
      id: "y97ci5q96",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [
        { name: "index", value: 1 },
        { name: "Value Invalid Index", value: 0 },
      ],
      portsOut: [
        {
          name: "value",
          links: [
            {
              portIn: "offset Y",
              portOut: "value",
              objIn: "r3u33h3hs",
              objOut: "y97ci5q96",
            },
            {
              portIn: "offset Y",
              portOut: "value",
              objIn: "v38pi7nzw",
              objOut: "y97ci5q96",
            },
          ],
        },
        { name: "Valid Index", value: 1 },
      ],
      objName: "Ops.Array.ArrayGetNumber",
    },
    {
      id: "8gblxjhc4",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "imageTextureWrap" }],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "gadc7j33d",
      uiAttribs: {},
      portsIn: [{ name: "value", value: 0 }],
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "Value",
              portOut: "result",
              objIn: "8gblxjhc4",
              objOut: "gadc7j33d",
            },
          ],
        },
      ],
      objName: "Ops.Boolean.Boolean",
    },
    {
      id: "vplbf7t31",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "stringTexture" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "text",
              portOut: "Value",
              objIn: "fvntb6ykt",
              objOut: "vplbf7t31",
            },
            {
              portIn: "String",
              portOut: "Value",
              objIn: "pokh8f7mm",
              objOut: "vplbf7t31",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetString",
    },
    {
      id: "fvntb6ykt",
      uiAttribs: {},
      portsIn: [
        { name: "Draw Mesh", value: 0 },
        { name: "Scale Mesh", value: 0.5 },
        { name: "Size index", value: 1 },
        { name: "Size", value: "Manual" },
        { name: "Width", value: 2048 },
        { name: "Height", value: 2048 },
        { name: "Auto Height", value: 0 },
        { name: "Auto Line Breaks", value: 0 },
        { name: "font", value: "everettLight" },
        { name: "weight", value: "bold" },
        { name: "fontSize", value: 300 },
        { name: "align index", value: 1 },
        { name: "align", value: "center" },
        { name: "Vertical align index", value: 1 },
        { name: "Vertical align", value: "Middle" },
        { name: "Letter Spacing", value: 0 },
        { name: "Line Height Add", value: 0 },
        { name: "Padding Y Top", value: 3 },
        { name: "Padding Y Bottom", value: 3 },
        { name: "Padding X", value: 0 },
        { name: "filter index", value: 1 },
        { name: "filter", value: "linear" },
        { name: "Wrap index", value: 0 },
        { name: "Wrap", value: "repeat" },
        { name: "Anisotropic index", value: 0 },
        { name: "Anisotropic", value: 0 },
        { name: "Reuse Texture", value: 1 },
        { name: "Show Debug", value: 0 },
        { name: "Redraw On Font Load", value: 1 },
        { name: "r", value: 1 },
        { name: "g", value: 1 },
        { name: "b", value: 1 },
        { name: "background R", value: 0 },
        { name: "background G", value: 0 },
        { name: "background B", value: 0 },
        { name: "background A", value: 1 },
      ],
      portsOut: [
        { name: "Ratio", value: 1.0029296875 },
        {
          name: "texture",
          links: [
            {
              portIn: "object port 0",
              portOut: "texture",
              objIn: "mosg1lz53",
              objOut: "fvntb6ykt",
            },
          ],
        },
        { name: "Aspect", value: 0.997078870496592 },
        { name: "Num Lines", value: 1 },
      ],
      objName: "Ops.Gl.Textures.TextTexture_v6",
    },
    {
      id: "zgn2xh9jp",
      uiAttribs: {},
      portsIn: [
        { name: "Value", value: 1 },
        { name: "Variable", value: "mouseTransformSpeed" },
      ],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "pokh8f7mm",
      uiAttribs: {},
      portsOut: [
        {
          name: "Changed",
          links: [
            {
              portIn: "Reset",
              portOut: "Changed",
              objIn: "2z4excx7g",
              objOut: "pokh8f7mm",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.TriggerOnChangeString",
    },
    {
      id: "3jdhde75y",
      uiAttribs: {},
      portsOut: [
        {
          name: "Next",
          links: [
            {
              portIn: "Reset",
              portOut: "Next",
              objIn: "2z4excx7g",
              objOut: "3jdhde75y",
            },
          ],
        },
      ],
      objName: "Ops.Trigger.TriggerButton",
    },
    {
      id: "xvrxo414c",
      uiAttribs: {},
      portsIn: [
        { name: "min", value: 0 },
        { name: "max", value: 1 },
        { name: "Integer", value: 1 },
        { name: "No consecutive duplicates", value: 0 },
      ],
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "Value 1",
              portOut: "result",
              objIn: "jubvms29d",
              objOut: "xvrxo414c",
            },
          ],
        },
      ],
      objName: "Ops.Math.TriggerRandomNumber_v2",
    },
    {
      id: "2z4excx7g",
      uiAttribs: {},
      portsIn: [
        { name: "Speed", value: 1 },
        { name: "Play", value: 1 },
        { name: "Sync to timeline", value: 0 },
      ],
      portsOut: [
        {
          name: "Time",
          links: [
            {
              portIn: "number1",
              portOut: "Time",
              objIn: "k8772j0ch",
              objOut: "2z4excx7g",
            },
          ],
        },
      ],
      objName: "Ops.Anim.Timer_v2",
    },
    {
      id: "k8772j0ch",
      uiAttribs: {},
      portsIn: [{ name: "number2", value: 0.2 }],
      portsOut: [
        {
          name: "result",
          links: [
            {
              portIn: "Index",
              portOut: "result",
              objIn: "jubvms29d",
              objOut: "k8772j0ch",
            },
          ],
        },
      ],
      objName: "Ops.Math.Compare.LessThan",
    },
    {
      id: "jubvms29d",
      uiAttribs: {},
      portsIn: [
        { name: "Value 0", value: 1 },
        { name: "Value 2", value: 0 },
        { name: "Value 3", value: 0 },
        { name: "Value 4", value: 0 },
        { name: "Value 5", value: 0 },
        { name: "Value 6", value: 0 },
        { name: "Value 7", value: 0 },
        { name: "Value 8", value: 0 },
        { name: "Value 9", value: 0 },
        { name: "Value 10", value: 0 },
        { name: "Value 11", value: 0 },
        { name: "Value 12", value: 0 },
        { name: "Value 13", value: 0 },
        { name: "Value 14", value: 0 },
        { name: "Value 15", value: 0 },
      ],
      portsOut: [
        {
          name: "Result",
          links: [
            {
              portIn: "Opacity",
              portOut: "Result",
              objIn: "fvntb6ykt",
              objOut: "jubvms29d",
            },
          ],
        },
      ],
      objName: "Ops.Number.SwitchNumber",
    },
    {
      id: "p6hjo3g1c",
      uiAttribs: {},
      portsIn: [{ name: "Title", value: "" }],
      objName: "Ops.Ui.Area",
    },
    {
      id: "mm8u7lfgw",
      uiAttribs: {},
      portsIn: [{ name: "Title", value: "" }],
      objName: "Ops.Ui.Area",
    },
    {
      id: "3sodhmqvs",
      uiAttribs: {},
      storage: { blueprintVer: 2, subPatchVer: 2 },
      portsIn: [
        { name: "9mnoq6ams", title: "Reset" },
        { name: "x51l5mx3z", value: 0.5, title: "number1" },
        { name: "via20ae2r", value: 0, title: "number1" },
        { name: "eq3wcir2y", value: 0, title: "number1" },
        { name: "x0ic0h4fm", title: "number1" },
        { name: "patchId", value: "bp2sub_3sodhmqvs" },
      ],
      portsOut: [
        { name: "fei1jpjm5", value: 0, title: "Result" },
        { name: "o1i9iyfw1", value: 0, title: "Result" },
        { name: "arp1806j4", value: 0, title: "result" },
        {
          name: "scw0zze34",
          title: "Next",
          links: [
            {
              portIn: "2uzay3xk0",
              portOut: "scw0zze34",
              objIn: "5l8gkfndg",
              objOut: "3sodhmqvs",
            },
          ],
        },
      ],
      objName: "Ops.Patch.PGgjVeu.AutoTransform",
    },
    {
      id: "64opcwacl",
      uiAttribs: {},
      storage: { blueprintVer: 2, subPatchVer: 2 },
      portsIn: [
        { name: "9mnoq6ams", title: "Reset" },
        { name: "x51l5mx3z", value: 0.5, title: "number1" },
        { name: "via20ae2r", value: 0, title: "number1" },
        { name: "eq3wcir2y", value: 0, title: "number1" },
        { name: "x0ic0h4fm", title: "number1" },
        { name: "patchId", value: "bp2sub_64opcwacl" },
      ],
      portsOut: [
        { name: "fei1jpjm5", value: 17.281836431257368, title: "Result" },
        { name: "o1i9iyfw1", value: 0, title: "Result" },
        { name: "arp1806j4", value: 0, title: "result" },
        {
          name: "scw0zze34",
          title: "Next",
          links: [
            {
              portIn: "2uzay3xk0",
              portOut: "scw0zze34",
              objIn: "6aubf72ju",
              objOut: "64opcwacl",
            },
          ],
        },
      ],
      objName: "Ops.Patch.PGgjVeu.AutoTransform",
    },
    {
      id: "ovzv6maxr",
      uiAttribs: {},
      portsIn: [
        { name: "Value", value: 0.1 },
        { name: "Variable", value: "autoTransformSpeed" },
      ],
      objName: "Ops.Vars.VarSetNumber_v2",
    },
    {
      id: "onyu94me7",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "autoTransformSpeed" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "x0ic0h4fm",
              portOut: "Value",
              objIn: "3sodhmqvs",
              objOut: "onyu94me7",
            },
            {
              portIn: "x0ic0h4fm",
              portOut: "Value",
              objIn: "64opcwacl",
              objOut: "onyu94me7",
            },
            {
              portIn: "ieb1lbewd",
              portOut: "Value",
              objIn: "8jjtil0jj",
              objOut: "onyu94me7",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "mosg1lz53",
      uiAttribs: {},
      portsOut: [
        {
          name: "object out",
          links: [
            {
              portIn: "Value",
              portOut: "object out",
              objIn: "j2v7lizv8",
              objOut: "mosg1lz53",
            },
          ],
        },
      ],
      objName: "Ops.Json.SwitchObject",
    },
    {
      id: "dblvyr861",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "nContext" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Object Index",
              portOut: "Value",
              objIn: "mosg1lz53",
              objOut: "dblvyr861",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "8ejjb9tja",
      uiAttribs: {},
      portsOut: [
        {
          name: "object out",
          links: [
            {
              portIn: "Value",
              portOut: "object out",
              objIn: "bw5x42j1o",
              objOut: "8ejjb9tja",
            },
          ],
        },
      ],
      objName: "Ops.Json.SwitchObject",
    },
    {
      id: "hldkm0li0",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "nContext" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "Object Index",
              portOut: "Value",
              objIn: "8ejjb9tja",
              objOut: "hldkm0li0",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "ya5hiple7",
      uiAttribs: {},
      portsIn: [
        { name: "width", value: 8 },
        { name: "height", value: 8 },
      ],
      portsOut: [
        {
          name: "texture",
          links: [
            {
              portIn: "object port 0",
              portOut: "texture",
              objIn: "8ejjb9tja",
              objOut: "ya5hiple7",
            },
          ],
        },
      ],
      objName: "Ops.Gl.Textures.EmptyTexture",
    },
    {
      id: "i8rjnteob",
      uiAttribs: {},
      portsIn: [
        { name: "width", value: 8 },
        { name: "height", value: 8 },
      ],
      portsOut: [
        {
          name: "texture",
          links: [
            {
              portIn: "object port 1",
              portOut: "texture",
              objIn: "mosg1lz53",
              objOut: "i8rjnteob",
            },
          ],
        },
      ],
      objName: "Ops.Gl.Textures.EmptyTexture",
    },
    {
      id: "e37ngwrk6",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "autoTransformSpeed" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "ieb1lbewd",
              portOut: "Value",
              objIn: "buwa4ywbx",
              objOut: "e37ngwrk6",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "1qfvv6m0r",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "mouseTransformSpeed" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "83lvt4w8p",
              portOut: "Value",
              objIn: "buwa4ywbx",
              objOut: "1qfvv6m0r",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "s8pdb81a8",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "mouseTransformSpeed" }],
      portsOut: [
        {
          name: "Value",
          links: [
            {
              portIn: "83lvt4w8p",
              portOut: "Value",
              objIn: "8jjtil0jj",
              objOut: "s8pdb81a8",
            },
          ],
        },
      ],
      objName: "Ops.Vars.VarGetNumber_v2",
    },
    {
      id: "t94xojk09",
      uiAttribs: {},
      storage: { blueprintVer: 2, subPatchVer: 2 },
      portsIn: [
        { name: "2uzay3xk0", title: "render" },
        { name: "byk06hys1", title: "Array" },
        { name: "icoiczvtv", title: "number2" },
        { name: "6lhmsuqvg", title: "number2" },
        { name: "09lct6z2t", title: "number2" },
        { name: "patchId", value: "bp2sub_t94xojk09" },
      ],
      portsOut: [
        {
          name: "driq8l4om",
          title: "trigger",
          links: [
            {
              portIn: "in0 Ops.Gl.Matrix.TransformView trigger",
              portOut: "driq8l4om",
              objIn: "hmrwm30er",
              objOut: "t94xojk09",
            },
          ],
        },
      ],
      objName: "Ops.Patch.PGgjVeu.TransfromFromArray",
    },
    {
      id: "5l8gkfndg",
      uiAttribs: {},
      storage: { blueprintVer: 2, subPatchVer: 2 },
      portsIn: [
        { name: "2uzay3xk0", title: "render" },
        { name: "byk06hys1", title: "Array" },
        { name: "icoiczvtv", value: 0, title: "number2" },
        { name: "6lhmsuqvg", value: 0, title: "number2" },
        { name: "09lct6z2t", value: 0, title: "number2" },
        { name: "patchId", value: "bp2sub_5l8gkfndg" },
      ],
      portsOut: [
        {
          name: "driq8l4om",
          title: "trigger",
          links: [
            {
              portIn: "in0 Ops.Gl.Matrix.TransformView trigger",
              portOut: "driq8l4om",
              objIn: "hmrwm30er",
              objOut: "5l8gkfndg",
            },
          ],
        },
      ],
      objName: "Ops.Patch.PGgjVeu.TransfromFromArray",
    },
    {
      id: "6aubf72ju",
      uiAttribs: {},
      storage: { blueprintVer: 2, subPatchVer: 2 },
      portsIn: [
        { name: "2uzay3xk0", title: "render" },
        { name: "byk06hys1", title: "Array" },
        { name: "icoiczvtv", value: 0, title: "number2" },
        { name: "6lhmsuqvg", value: 0, title: "number2" },
        { name: "09lct6z2t", value: 0, title: "number2" },
        { name: "patchId", value: "bp2sub_6aubf72ju" },
      ],
      portsOut: [
        {
          name: "driq8l4om",
          title: "trigger",
          links: [
            {
              portIn: "in0 Ops.Gl.Matrix.TransformView trigger",
              portOut: "driq8l4om",
              objIn: "hmrwm30er",
              objOut: "6aubf72ju",
            },
          ],
        },
      ],
      objName: "Ops.Patch.PGgjVeu.TransfromFromArray",
    },
    {
      id: "z1150e2ur",
      uiAttribs: { subPatch: "0ff66c6c-0dc3-43ce-bbac-906b76f3f60b" },
      portsIn: [
        { name: "Size index", value: 1 },
        { name: "Size", value: "Manual" },
        { name: "Width", value: 629 },
        { name: "Height", value: 822 },
        { name: "filter index", value: 1 },
        { name: "filter", value: "linear" },
        { name: "Anisotropic index", value: 0 },
        { name: "Anisotropic", value: "0" },
        { name: "wrap index", value: 0 },
        { name: "wrap", value: "clamp to edge" },
        { name: "Pixel Format index", value: 4 },
        { name: "Pixel Format", value: "RGBA 8bit ubyte" },
        { name: "Num Textures index", value: 0 },
        { name: "Num Textures", value: "1" },
      ],
      portsOut: [
        {
          name: "Next",
          links: [
            {
              portIn: "out1 ShaderToTexture Next",
              portOut: "Next",
              objIn: "c2dfdfab-f08f-46c6-8599-9c62d64da7c1",
              objOut: "z1150e2ur",
            },
          ],
        },
        {
          name: "Texture",
          links: [
            {
              portIn: "out0 ImageCompose texture_out",
              portOut: "Texture",
              objIn: "c2dfdfab-f08f-46c6-8599-9c62d64da7c1",
              objOut: "z1150e2ur",
            },
          ],
        },
      ],
      objName: "Ops.Gl.Shader.ShaderToTexture_v2",
    },
    {
      id: "5m0nxxnjx",
      uiAttribs: {},
      portsIn: [
        { name: "Identity", value: 1 },
        { name: "projection mode index", value: 1 },
        { name: "projection mode", value: "ortogonal" },
        { name: "frustum near", value: 0.01 },
        { name: "frustum far", value: 5e3 },
        { name: "fov", value: 45 },
        { name: "Auto Aspect Ratio", value: 1 },
        { name: "Aspect Ratio", value: 1 },
        { name: "eye X", value: 0 },
        { name: "eye Y", value: 0 },
        { name: "eye Z", value: 5 },
        { name: "center X", value: 0 },
        { name: "center Y", value: 0 },
        { name: "center Z", value: 0 },
        { name: "truck", value: 0 },
        { name: "boom", value: 0 },
        { name: "dolly", value: 0 },
        { name: "tilt", value: 0 },
        { name: "pan", value: 0 },
        { name: "roll", value: 0 },
      ],
      portsOut: [
        {
          name: "trigger",
          links: [
            {
              portIn: "Execute",
              portOut: "trigger",
              objIn: "whp28n8pi",
              objOut: "5m0nxxnjx",
            },
          ],
        },
        { name: "Aspect", value: 0.7652068126520681 },
      ],
      objName: "Ops.Gl.Matrix.Camera_v2",
    },
    {
      id: "pa2y9tgmx",
      uiAttribs: {},
      portsIn: [
        { name: "Max Pixel Density (DPR)", value: 2 },
        { name: "FPS Limit", value: 60 },
        { name: "Reduce FPS unfocussed", value: 0 },
        { name: "Transparent", value: 1 },
      ],
      portsOut: [
        {
          name: "trigger",
          links: [
            {
              portIn: "exe",
              portOut: "trigger",
              objIn: "hdbfyi4so",
              objOut: "pa2y9tgmx",
            },
          ],
        },
        { name: "width", value: 629 },
        { name: "height", value: 822 },
        { name: "Pixel Density", value: 1 },
      ],
      objName: "Ops.Gl.MainLoop_v2",
    },
    {
      id: "f6lhh1vgq",
      uiAttribs: { subPatch: "2154fd20-4fef-42fd-bef2-ef39e6975cdf" },
      portsOut: [
        { name: "CSS Width", value: 629 },
        { name: "CSS Height", value: 822 },
        { name: "Pixel Ratio", value: 1 },
        { name: "Pixel Width", value: 629 },
        { name: "Pixel Height", value: 822 },
        {
          name: "Aspect Ratio",
          links: [
            {
              portIn: "number1",
              portOut: "Aspect Ratio",
              objIn: "snccy8bvu",
              objOut: "f6lhh1vgq",
            },
            {
              portIn: "number2",
              portOut: "Aspect Ratio",
              objIn: "gwlsewuc3",
              objOut: "f6lhh1vgq",
            },
            {
              portIn: "out3 CanvasInfo Aspect Ratio",
              portOut: "Aspect Ratio",
              objIn: "ltmbqybsn",
              objOut: "f6lhh1vgq",
            },
          ],
        },
        { name: "Landscape", value: 0 },
      ],
      objName: "Ops.Gl.CanvasInfo_v3",
    },
    {
      id: "qxg4n5ydb",
      uiAttribs: {},
      portsIn: [{ name: "Variable", value: "mousePosition" }],
      objName: "Ops.Vars.VarSetArray_v2",
    },
    {
      id: "tfqqg918w",
      uiAttribs: {},
      portsIn: [
        { name: "Coordinates index", value: 0 },
        { name: "Coordinates", value: "-1 to 1" },
        { name: "Area index", value: 1 },
        { name: "Area", value: "Document" },
        { name: "flip y", value: 1 },
        { name: "right click prevent default", value: 1 },
        { name: "Touch support", value: 1 },
        { name: "Passive Events", value: 0 },
        { name: "Active", value: 1 },
      ],
      portsOut: [
        {
          name: "x",
          links: [
            {
              portIn: "X",
              portOut: "x",
              objIn: "hrvqoi58d",
              objOut: "tfqqg918w",
            },
          ],
        },
        {
          name: "y",
          links: [
            {
              portIn: "Y",
              portOut: "y",
              objIn: "hrvqoi58d",
              objOut: "tfqqg918w",
            },
          ],
        },
        { name: "Button is down", value: 0 },
        { name: "Mouse is hovering", value: 1 },
        { name: "Movement X", value: 0 },
        { name: "Movement Y", value: -1 },
      ],
      objName: "Ops.Devices.Mouse.Mouse_v3",
    },
    {
      id: "hrvqoi58d",
      uiAttribs: {},
      portsIn: [
        { name: "Num Triplets", value: 100 },
        { name: "Z", value: 0 },
      ],
      portsOut: [
        {
          name: "Array",
          links: [
            {
              portIn: "Value",
              portOut: "Array",
              objIn: "qxg4n5ydb",
              objOut: "hrvqoi58d",
            },
          ],
        },
        { name: "Total points", value: 100 },
        { name: "Array length", value: 300 },
      ],
      objName: "Ops.Array.Array3",
    },
    {
      id: "buwa4ywbx",
      uiAttribs: {},
      storage: { blueprintVer: 2, subPatchVer: 2 },
      portsIn: [
        { name: "d7g5c0h5b", title: "Trigger 2" },
        { name: "ieb1lbewd", title: "Value" },
        { name: "83lvt4w8p", title: "Value" },
        { name: "patchId", value: "bp2sub_buwa4ywbx" },
      ],
      portsOut: [
        {
          name: "d58ks5o1j",
          title: "Result",
          links: [
            {
              portIn: "number1",
              portOut: "d58ks5o1j",
              objIn: "zpdk4s7hr",
              objOut: "buwa4ywbx",
            },
          ],
        },
        {
          name: "eqbeofk6o",
          title: "Result",
          links: [
            {
              portIn: "number1",
              portOut: "eqbeofk6o",
              objIn: "sd5jtt6y5",
              objOut: "buwa4ywbx",
            },
          ],
        },
        {
          name: "vy0njf6dp",
          title: "Result",
          links: [
            {
              portIn: "number1",
              portOut: "vy0njf6dp",
              objIn: "e6ylr7btl",
              objOut: "buwa4ywbx",
            },
          ],
        },
      ],
      objName: "Ops.Patch.PGgjVeu.MouseInteract",
    },
    {
      id: "8jjtil0jj",
      uiAttribs: {},
      storage: { blueprintVer: 2, subPatchVer: 2 },
      portsIn: [
        { name: "d7g5c0h5b", title: "Trigger 2" },
        { name: "ieb1lbewd", title: "Value" },
        { name: "83lvt4w8p", title: "Value" },
        { name: "patchId", value: "bp2sub_8jjtil0jj" },
      ],
      portsOut: [
        {
          name: "d58ks5o1j",
          title: "Result",
          links: [
            {
              portIn: "icoiczvtv",
              portOut: "d58ks5o1j",
              objIn: "t94xojk09",
              objOut: "8jjtil0jj",
            },
          ],
        },
        {
          name: "eqbeofk6o",
          title: "Result",
          links: [
            {
              portIn: "6lhmsuqvg",
              portOut: "eqbeofk6o",
              objIn: "t94xojk09",
              objOut: "8jjtil0jj",
            },
          ],
        },
        {
          name: "vy0njf6dp",
          title: "Result",
          links: [
            {
              portIn: "09lct6z2t",
              portOut: "vy0njf6dp",
              objIn: "t94xojk09",
              objOut: "8jjtil0jj",
            },
          ],
        },
        {
          name: "cq7ouht1r",
          title: "Next",
          links: [
            {
              portIn: "2uzay3xk0",
              portOut: "cq7ouht1r",
              objIn: "t94xojk09",
              objOut: "8jjtil0jj",
            },
          ],
        },
      ],
      objName: "Ops.Patch.PGgjVeu.MouseInteract",
    },
  ],
  export: { time: "2025-01-06 21:00", service: "html", exportNumber: 25 },
};
if (!CABLES.exportedPatch) {
  CABLES.exportedPatch = CABLES.exportedPatches["GgjVeu"];
}
("use strict");
var CABLES = CABLES || {};
CABLES.OPS = CABLES.OPS || {};
var Ops = Ops || {};
Ops.Gl = Ops.Gl || {};
Ops.Ui = Ops.Ui || {};
Ops.Anim = Ops.Anim || {};
Ops.Html = Ops.Html || {};
Ops.Json = Ops.Json || {};
Ops.Math = Ops.Math || {};
Ops.User = Ops.User || {};
Ops.Vars = Ops.Vars || {};
Ops.Array = Ops.Array || {};
Ops.Color = Ops.Color || {};
Ops.Patch = Ops.Patch || {};
Ops.Cables = Ops.Cables || {};
Ops.Number = Ops.Number || {};
Ops.String = Ops.String || {};
Ops.Boolean = Ops.Boolean || {};
Ops.Devices = Ops.Devices || {};
Ops.Gl.GLTF = Ops.Gl.GLTF || {};
Ops.Trigger = Ops.Trigger || {};
Ops.Extension = Ops.Extension || {};
Ops.Gl.Matrix = Ops.Gl.Matrix || {};
Ops.Gl.Shader = Ops.Gl.Shader || {};
Ops.Gl.Textures = Ops.Gl.Textures || {};
Ops.Math.Compare = Ops.Math.Compare || {};
Ops.User.srcphag = Ops.User.srcphag || {};
Ops.Devices.Mouse = Ops.Devices.Mouse || {};
Ops.Patch.PGgjVeu = Ops.Patch.PGgjVeu || {};
Ops.Gl.ShaderEffects = Ops.Gl.ShaderEffects || {};
Ops.Extension.Deprecated = Ops.Extension.Deprecated || {};
Ops.Ui.SubPatch = function () {
  CABLES.Op.apply(this, arguments);
  const u = this;
  const e = (u.attachments = {});
  u.dyn = u.addInPort(
    new CABLES.Port(u, "create port", CABLES.OP_PORT_TYPE_DYNAMIC)
  );
  u.dynOut = u.addOutPort(
    new CABLES.Port(u, "create port out", CABLES.OP_PORT_TYPE_DYNAMIC)
  );
  const t = u.addInPort(
    new CABLES.Port(u, "dataStr", CABLES.OP_PORT_TYPE_VALUE, {
      display: "readonly",
    })
  );
  u.patchId = u.addInPort(
    new CABLES.Port(u, "patchId", CABLES.OP_PORT_TYPE_VALUE, {
      display: "readonly",
    })
  );
  t.setUiAttribs({ hideParam: true });
  u.patchId.setUiAttribs({ hidePort: true });
  let c = { ports: [], portsOut: [] };
  let n = CABLES.generateUUID();
  u.patchId.set(n);
  m();
  p();
  let d = false;
  u.saveData = s;
  u.init = () => {
    u.setStorage({ subPatchVer: 1 });
  };
  u.patchId.onChange = function () {
    if (!u.patch.isEditorMode()) return;
    const t = u.patch.getSubPatchOps(n);
    if (t.length === 2) {
      if (u.patch.isEditorMode() && CABLES.UI.DEFAULTOPS.isInBlueprint(u))
        CABLES.UI.undo.pause();
      for (let e = 0; e < t.length; e++) {
        u.patch.deleteOp(t[e].id);
      }
      if (u.patch.isEditorMode() && CABLES.UI.DEFAULTOPS.isInBlueprint(u))
        CABLES.UI.undo.resume();
    }
  };
  u.onLoaded = function () {};
  u.onLoadedValueSet = function () {
    c = JSON.parse(t.get());
    if (!c) {
      c = { ports: [], portsOut: [] };
    }
    a();
  };
  function i() {}
  t.onChange = function () {
    if (d) return;
    if (!t.get()) return;
    try {
      i();
    } catch (e) {
      u.logError("cannot load subpatch data...");
      u.logError(e);
    }
  };
  function s() {
    try {
      t.set(JSON.stringify(c));
    } catch (e) {
      u.log(e);
    }
  }
  u.addPortListener = h;
  function h(n, e) {
    if (!n.hasSubpatchLstener) {
      n.hasSubpatchLstener = true;
      n.addEventListener("onUiAttrChange", function (t) {
        if (t.title) {
          let e = 0;
          for (e = 0; e < c.portsOut.length; e++)
            if (c.portsOut[e].name == n.name) c.portsOut[e].title = t.title;
          for (e = 0; e < c.ports.length; e++)
            if (c.ports[e].name == n.name) c.ports[e].title = t.title;
          s();
        }
      });
    }
    if (n.direction == CABLES.PORT_DIR_IN) {
      if (n.type == CABLES.OP_PORT_TYPE_FUNCTION) {
        n.onTriggered = function () {
          if (e.isLinked()) e.trigger();
        };
      } else {
        n.onChange = function () {
          e.set(n.get());
          if (!n.isLinked()) {
            for (let e = 0; e < c.ports.length; e++) {
              if (c.ports[e].name === n.name) {
                c.ports[e].value = n.get();
              }
            }
            s();
          }
        };
      }
    }
  }
  u.setupPorts = a;
  function a() {
    if (!u.patchId.get()) return;
    const e = c.ports || [];
    const t = c.portsOut || [];
    let n = 0;
    for (n = 0; n < e.length; n++) {
      if (!u.getPortByName(e[n].name)) {
        const i = u.addInPort(new CABLES.Port(u, e[n].name, e[n].type));
        const r = m();
        const a = r.addOutPort(new CABLES.Port(r, e[n].name, e[n].type));
        i.ignoreValueSerialize = true;
        i.setUiAttribs({ editableTitle: true });
        if (e[n].title) {
          i.setUiAttribs({ title: e[n].title });
          a.setUiAttribs({ title: e[n].title });
        }
        if (e[n].objType) {
          i.setUiAttribs({ objType: e[n].objType });
          a.setUiAttribs({ objType: e[n].objType });
        }
        if (e[n].value) {
          i.set(e[n].value);
          a.set(e[n].value);
        }
        h(i, a);
      }
    }
    for (n = 0; n < t.length; n++) {
      if (!u.getPortByName(t[n].name)) {
        const s = u.addOutPort(new CABLES.Port(u, t[n].name, t[n].type));
        const o = p();
        const l = o.addInPort(new CABLES.Port(o, t[n].name, t[n].type));
        s.ignoreValueSerialize = true;
        s.setUiAttribs({ editableTitle: true });
        if (t[n].title) {
          s.setUiAttribs({ title: t[n].title });
          l.setUiAttribs({ title: t[n].title });
        }
        if (t[n].objType) {
          s.setUiAttribs({ objType: t[n].objType });
          l.setUiAttribs({ objType: t[n].objType });
        }
        h(l, s);
      }
    }
    d = true;
  }
  u.addNewInPort = function (e, t, n) {
    const i = "in" + c.ports.length + " " + e.op.name + " " + e.name;
    const r = { name: i, type: e.type };
    if (e.uiAttribs.objType) r.objType = e.uiAttribs.objType;
    c.ports.push(r);
    a();
    return i;
  };
  u.dyn.onLinkChanged = function () {
    if (u.dyn.isLinked()) {
      const e = u.dyn.links[0].getOtherPort(u.dyn);
      u.dyn.removeLinks();
      e.removeLinkTo(u.dyn);
      u.log("dyn link changed!!!");
      const t = u.addNewInPort(e);
      const n = gui.scene().link(e.op, e.getName(), u, t);
      d = true;
      s();
    } else {
      setTimeout(function () {
        u.dyn.removeLinks();
      }, 100);
    }
  };
  u.addNewOutPort = function (e, t, n) {
    const i = "out" + c.portsOut.length + " " + e.op.name + " " + e.name;
    const r = { name: i, type: e.type };
    if (e.uiAttribs.objType) r.objType = e.uiAttribs.objType;
    c.portsOut.push(r);
    a();
    return i;
  };
  u.dynOut.onLinkChanged = function () {
    if (u.dynOut.isLinked()) {
      const e = u.dynOut.links[0].getOtherPort(u.dynOut);
      u.dynOut.removeLinks();
      if (e) {
        e.removeLinkTo(u.dynOut);
        const t = u.addNewOutPort(e);
        gui.scene().link(e.op, e.getName(), u, t);
      }
      d = true;
      s();
    } else {
      setTimeout(function () {
        u.dynOut.removeLinks();
      }, 100);
      u.log("dynOut unlinked...");
    }
  };
  function p() {
    let e = u.patch.getSubPatchOp(u.patchId.get(), "Ops.Ui.PatchOutput");
    if (!e) {
      u.patch.addOp("Ops.Ui.PatchOutput", {
        subPatch: u.patchId.get(),
        translate: { x: 0, y: 0 },
      });
      e = u.patch.getSubPatchOp(u.patchId.get(), "Ops.Ui.PatchOutput");
      if (!e) u.warn("no patchoutput!");
    }
    return e;
  }
  function m() {
    let e = u.patch.getSubPatchOp(u.patchId.get(), "Ops.Ui.PatchInput");
    if (!e) {
      u.patch.addOp("Ops.Ui.PatchInput", {
        subPatch: u.patchId.get(),
        translate: { x: 0, y: 0 },
      });
      e = u.patch.getSubPatchOp(u.patchId.get(), "Ops.Ui.PatchInput");
      if (!e) u.warn("no patchinput2!");
    }
    return e;
  }
  u.addSubLink = function (e, t) {
    const n = c.ports.length;
    const i = "in" + (n - 1) + " " + t.op.name + " " + t.name;
    if (e.direction == CABLES.PORT_DIR_IN) {
      gui.scene().link(e.op, e.getName(), m(), i);
    } else {
      const a = c.portsOut.length;
      gui
        .scene()
        .link(
          e.op,
          e.getName(),
          p(),
          "out" + (a - 1) + " " + t.op.name + " " + t.name
        );
    }
    const r = gui.patchView.getSubPatchBounds(u.patchId.get());
    m().uiAttr({ translate: { x: r.minx, y: r.miny - 100 } });
    p().uiAttr({ translate: { x: r.minx, y: r.maxy + 100 } });
    s();
    return i;
  };
  u.onDelete = function () {
    for (let e = u.patch.ops.length - 1; e >= 0; e--)
      if (
        u.patch.ops[e] &&
        u.patch.ops[e].uiAttribs &&
        u.patch.ops[e].uiAttribs.subPatch == u.patchId.get()
      )
        u.patch.deleteOp(u.patch.ops[e].id);
  };
  u.rebuildListeners = () => {
    u.log("rebuild listeners...");
    const t = p();
    for (let e = 0; e < t.portsIn.length; e++) {
      if (t.portsIn[e].isLinked()) {
        h(t.portsIn[e], this.portsOut[e]);
      }
    }
  };
};
Ops.Ui.SubPatch.prototype = new CABLES.Op();
CABLES.OPS["84d9a6f0-ed7a-466d-b386-225ed9e89c60"] = {
  f: Ops.Ui.SubPatch,
  objName: "Ops.Ui.SubPatch",
};
Ops.Patch.PGgjVeu.AutoTransform = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const n = (e.attachments = {
    inc_gen_ports_js:
      'const port_9mnoq6ams=op.inTrigger("9mnoq6ams");\nport_9mnoq6ams.setUiAttribs({title:"Reset",display:"button",});\n\nconst port_x51l5mx3z=op.inFloat("x51l5mx3z",1);\nport_x51l5mx3z.setUiAttribs({title:"number1",});\n\nconst port_via20ae2r=op.inFloat("via20ae2r",1);\nport_via20ae2r.setUiAttribs({title:"number1",});\n\nconst port_eq3wcir2y=op.inFloat("eq3wcir2y",1);\nport_eq3wcir2y.setUiAttribs({title:"number1",});\n\nconst port_x0ic0h4fm=op.inFloat("x0ic0h4fm",1);\nport_x0ic0h4fm.setUiAttribs({title:"number1",});\n\nconst port_fei1jpjm5=op.outNumber("fei1jpjm5");\nport_fei1jpjm5.setUiAttribs({title:"Result",});\n\nconst port_o1i9iyfw1=op.outNumber("o1i9iyfw1");\nport_o1i9iyfw1.setUiAttribs({title:"Result",});\n\nconst port_arp1806j4=op.outNumber("arp1806j4");\nport_arp1806j4.setUiAttribs({title:"result",});\n\nconst port_scw0zze34=op.outTrigger("scw0zze34");\nport_scw0zze34.setUiAttribs({title:"Next",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_9mnoq6ams = addedOps[i].outTrigger("innerOut_9mnoq6ams");\ninnerOut_9mnoq6ams.setUiAttribs({title:"Reset"});\nport_9mnoq6ams.onTriggered = () => { innerOut_9mnoq6ams.trigger(); };\n\nconst innerOut_x51l5mx3z = addedOps[i].outNumber("innerOut_x51l5mx3z");\ninnerOut_x51l5mx3z.set(port_x51l5mx3z.get() );\ninnerOut_x51l5mx3z.setUiAttribs({title:"number1"});\nport_x51l5mx3z.on("change", (a,v) => { innerOut_x51l5mx3z.set(a); });\n\nconst innerOut_via20ae2r = addedOps[i].outNumber("innerOut_via20ae2r");\ninnerOut_via20ae2r.set(port_via20ae2r.get() );\ninnerOut_via20ae2r.setUiAttribs({title:"number1"});\nport_via20ae2r.on("change", (a,v) => { innerOut_via20ae2r.set(a); });\n\nconst innerOut_eq3wcir2y = addedOps[i].outNumber("innerOut_eq3wcir2y");\ninnerOut_eq3wcir2y.set(port_eq3wcir2y.get() );\ninnerOut_eq3wcir2y.setUiAttribs({title:"number1"});\nport_eq3wcir2y.on("change", (a,v) => { innerOut_eq3wcir2y.set(a); });\n\nconst innerOut_x0ic0h4fm = addedOps[i].outNumber("innerOut_x0ic0h4fm");\ninnerOut_x0ic0h4fm.set(port_x0ic0h4fm.get() );\ninnerOut_x0ic0h4fm.setUiAttribs({title:"number1"});\nport_x0ic0h4fm.on("change", (a,v) => { innerOut_x0ic0h4fm.set(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_fei1jpjm5 = addedOps[i].inFloat("innerIn_fei1jpjm5");\ninnerIn_fei1jpjm5.setUiAttribs({title:"Result"});\ninnerIn_fei1jpjm5.on("change", (a,v) => { port_fei1jpjm5.set(a); });\n\nconst innerIn_o1i9iyfw1 = addedOps[i].inFloat("innerIn_o1i9iyfw1");\ninnerIn_o1i9iyfw1.setUiAttribs({title:"Result"});\ninnerIn_o1i9iyfw1.on("change", (a,v) => { port_o1i9iyfw1.set(a); });\n\nconst innerIn_arp1806j4 = addedOps[i].inFloat("innerIn_arp1806j4");\ninnerIn_arp1806j4.setUiAttribs({title:"result"});\ninnerIn_arp1806j4.on("change", (a,v) => { port_arp1806j4.set(a); });\n\nconst innerIn_scw0zze34 = addedOps[i].inTrigger("innerIn_scw0zze34");\ninnerIn_scw0zze34.setUiAttribs({title:"Next"});\ninnerIn_scw0zze34.onTriggered = () => { port_scw0zze34.trigger(); };\n\n}\n}\n};\n',
    subpatch_json:
      '{"ops":[{"id":"bp1-0","uiAttribs":{"subPatch":"ux4t6aw2j"},"storage":{},"portsIn":[{"name":"Sync to timeline","value":0}],"portsOut":[{"name":"Time","links":[{"portIn":"number2","portOut":"Time","objIn":"bp1-6","objOut":"bp1-0"},{"portIn":"number2","portOut":"Time","objIn":"bp1-7","objOut":"bp1-0"},{"portIn":"number2","portOut":"Time","objIn":"bp1-9","objOut":"bp1-0"}]}],"objName":"Ops.Anim.Timer_v2"},{"id":"bp1-1","uiAttribs":{"subPatch":"ux4t6aw2j"},"storage":{},"portsIn":[{"name":"Separate inc/dec","value":0},{"name":"Inc factor","value":10,"title":"Inc/Dec factor"},{"name":"Dec factor","value":4}],"portsOut":[{"name":"Next","links":[{"portIn":"render","portOut":"Next","objIn":"bp1-10","objOut":"bp1-1"}]},{"name":"Result","links":[{"portIn":"rotX","portOut":"Result","objIn":"bp1-10","objOut":"bp1-1"},{"portIn":"innerIn_fei1jpjm5","portOut":"Result","objIn":"bp1-5","objOut":"bp1-1"}]}],"objName":"Ops.Anim.Smooth"},{"id":"bp1-2","uiAttribs":{"subPatch":"ux4t6aw2j"},"storage":{},"portsIn":[{"name":"Separate inc/dec","value":0},{"name":"Inc factor","value":10,"title":"Inc/Dec factor"},{"name":"Dec factor","value":4}],"portsOut":[{"name":"Result","links":[{"portIn":"rotY","portOut":"Result","objIn":"bp1-10","objOut":"bp1-2"},{"portIn":"innerIn_o1i9iyfw1","portOut":"Result","objIn":"bp1-5","objOut":"bp1-2"}]}],"objName":"Ops.Anim.Smooth"},{"id":"bp1-3","uiAttribs":{"subPatch":"ux4t6aw2j"},"storage":{},"portsOut":[{"name":"has focus","links":[{"portIn":"number2","portOut":"has focus","objIn":"bp1-11","objOut":"bp1-3"}]},{"name":"Tab Visible","links":[{"portIn":"Play","portOut":"Tab Visible","objIn":"bp1-0","objOut":"bp1-3"}]}],"objName":"Ops.Html.WindowHasFocus"},{"id":"bp1-4","uiAttribs":{"subPatch":"ux4t6aw2j"},"storage":{},"portsOut":[{"name":"innerOut_9mnoq6ams","title":"Reset","links":[{"portIn":"Update","portOut":"innerOut_9mnoq6ams","objIn":"bp1-1","objOut":"bp1-4"},{"portIn":"Update","portOut":"innerOut_9mnoq6ams","objIn":"bp1-2","objOut":"bp1-4"},{"portIn":"Update","portOut":"innerOut_9mnoq6ams","objIn":"bp1-8","objOut":"bp1-4"}]},{"name":"innerOut_x51l5mx3z","title":"number1","links":[{"portIn":"number1","portOut":"innerOut_x51l5mx3z","objIn":"bp1-6","objOut":"bp1-4"}]},{"name":"innerOut_via20ae2r","title":"number1","links":[{"portIn":"number1","portOut":"innerOut_via20ae2r","objIn":"bp1-7","objOut":"bp1-4"}]},{"name":"innerOut_eq3wcir2y","title":"number1","links":[{"portIn":"number1","portOut":"innerOut_eq3wcir2y","objIn":"bp1-9","objOut":"bp1-4"}]},{"name":"innerOut_x0ic0h4fm","title":"number1","links":[{"portIn":"number1","portOut":"innerOut_x0ic0h4fm","objIn":"bp1-11","objOut":"bp1-4"}]}],"objName":"Ops.Ui.SubPatchInput"},{"id":"bp1-5","uiAttribs":{"subPatch":"ux4t6aw2j"},"storage":{},"portsIn":[{"name":"innerIn_fei1jpjm5","title":"Result"},{"name":"innerIn_o1i9iyfw1","title":"Result"},{"name":"innerIn_arp1806j4","title":"result"},{"name":"innerIn_scw0zze34","title":"Next"}],"objName":"Ops.Ui.SubPatchOutput"},{"id":"bp1-6","uiAttribs":{"subPatch":"ux4t6aw2j"},"storage":{},"portsOut":[{"name":"result","links":[{"portIn":"Value","portOut":"result","objIn":"bp1-1","objOut":"bp1-6"}]}],"objName":"Ops.Math.Multiply"},{"id":"bp1-7","uiAttribs":{"subPatch":"ux4t6aw2j"},"storage":{},"portsOut":[{"name":"result","links":[{"portIn":"Value","portOut":"result","objIn":"bp1-2","objOut":"bp1-7"}]}],"objName":"Ops.Math.Multiply"},{"id":"bp1-8","uiAttribs":{"subPatch":"ux4t6aw2j"},"storage":{},"portsIn":[{"name":"Separate inc/dec","value":0},{"name":"Inc factor","value":10,"title":"Inc/Dec factor"},{"name":"Dec factor","value":4}],"portsOut":[{"name":"Result","links":[{"portIn":"rotZ","portOut":"Result","objIn":"bp1-10","objOut":"bp1-8"},{"portIn":"innerIn_arp1806j4","portOut":"Result","objIn":"bp1-5","objOut":"bp1-8"}]}],"objName":"Ops.Anim.Smooth"},{"id":"bp1-9","uiAttribs":{"subPatch":"ux4t6aw2j"},"storage":{},"portsOut":[{"name":"result","links":[{"portIn":"Value","portOut":"result","objIn":"bp1-8","objOut":"bp1-9"}]}],"objName":"Ops.Math.Multiply"},{"id":"bp1-10","uiAttribs":{"subPatch":"ux4t6aw2j"},"storage":{},"portsIn":[{"name":"posX","value":0},{"name":"posY","value":0},{"name":"posZ","value":0},{"name":"scale","value":1}],"portsOut":[{"name":"trigger","links":[{"portIn":"innerIn_scw0zze34","portOut":"trigger","objIn":"bp1-5","objOut":"bp1-10"}]}],"objName":"Ops.Gl.Matrix.TransformView"},{"id":"bp1-11","uiAttribs":{"subPatch":"ux4t6aw2j"},"storage":{},"portsOut":[{"name":"result","links":[{"portIn":"Speed","portOut":"result","objIn":"bp1-0","objOut":"bp1-11"}]}],"objName":"Ops.Math.Multiply"}]}',
  });
  const d = e.inTrigger("9mnoq6ams");
  d.setUiAttribs({ title: "Reset", display: "button" });
  const h = e.inFloat("x51l5mx3z", 1);
  h.setUiAttribs({ title: "number1" });
  const p = e.inFloat("via20ae2r", 1);
  p.setUiAttribs({ title: "number1" });
  const m = e.inFloat("eq3wcir2y", 1);
  m.setUiAttribs({ title: "number1" });
  const f = e.inFloat("x0ic0h4fm", 1);
  f.setUiAttribs({ title: "number1" });
  const g = e.outNumber("fei1jpjm5");
  g.setUiAttribs({ title: "Result" });
  const b = e.outNumber("o1i9iyfw1");
  b.setUiAttribs({ title: "Result" });
  const v = e.outNumber("arp1806j4");
  v.setUiAttribs({ title: "result" });
  const y = e.outTrigger("scw0zze34");
  y.setUiAttribs({ title: "Next" });
  e.initInnerPorts = function (t) {
    for (let e = 0; e < t.length; e++) {
      if (t[e].innerInput) {
        const n = t[e].outTrigger("innerOut_9mnoq6ams");
        n.setUiAttribs({ title: "Reset" });
        d.onTriggered = () => {
          n.trigger();
        };
        const i = t[e].outNumber("innerOut_x51l5mx3z");
        i.set(h.get());
        i.setUiAttribs({ title: "number1" });
        h.on("change", (e, t) => {
          i.set(e);
        });
        const r = t[e].outNumber("innerOut_via20ae2r");
        r.set(p.get());
        r.setUiAttribs({ title: "number1" });
        p.on("change", (e, t) => {
          r.set(e);
        });
        const a = t[e].outNumber("innerOut_eq3wcir2y");
        a.set(m.get());
        a.setUiAttribs({ title: "number1" });
        m.on("change", (e, t) => {
          a.set(e);
        });
        const s = t[e].outNumber("innerOut_x0ic0h4fm");
        s.set(f.get());
        s.setUiAttribs({ title: "number1" });
        f.on("change", (e, t) => {
          s.set(e);
        });
      }
      if (t[e].innerOutput) {
        const o = t[e].inFloat("innerIn_fei1jpjm5");
        o.setUiAttribs({ title: "Result" });
        o.on("change", (e, t) => {
          g.set(e);
        });
        const l = t[e].inFloat("innerIn_o1i9iyfw1");
        l.setUiAttribs({ title: "Result" });
        l.on("change", (e, t) => {
          b.set(e);
        });
        const u = t[e].inFloat("innerIn_arp1806j4");
        u.setUiAttribs({ title: "result" });
        u.on("change", (e, t) => {
          v.set(e);
        });
        const c = t[e].inTrigger("innerIn_scw0zze34");
        c.setUiAttribs({ title: "Next" });
        c.onTriggered = () => {
          y.trigger();
        };
      }
    }
  };
  const i = "bp2sub_" + e.id;
  new CABLES.SubPatchOp(e, { subId: i });
  t();
  function t() {
    if (!n || !n.subpatch_json) return;
    const t = JSON.parse(n.subpatch_json);
    CABLES.Patch.replaceOpIds(t, {
      parentSubPatchId: i,
      prefixHash: i,
      oldIdAsRef: true,
      doNotUnlinkLostLinks: true,
    });
    for (let e = 0; e < t.ops.length; e++) {
      t.ops[e].uiAttribs.blueprintSubpatch2 = true;
    }
    e.loadDependencies(t, () => {
      e.patch.deSerialize(t, { opsCreated: e.initInnerPorts });
      if (CABLES.UI) gui.savedState.setSaved("blueprintloaded", i);
      e.patch.emitEvent("subpatchExpose", i);
      e.setStorage({ blueprintVer: 2 });
      e.patch.emitEvent("subpatchExpose", i);
    });
  }
};
Ops.Patch.PGgjVeu.AutoTransform.prototype = new CABLES.Op();
CABLES.OPS["36b9d4ca-c0a7-4aeb-8ac1-0e5d1b5fcb96"] = {
  f: Ops.Patch.PGgjVeu.AutoTransform,
  objName: "Ops.Patch.PGgjVeu.AutoTransform",
};
Ops.Patch.PGgjVeu.TransfromFromArray = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const n = (e.attachments = {
    inc_gen_ports_js:
      'const port_2uzay3xk0=op.inTrigger("2uzay3xk0");\nport_2uzay3xk0.setUiAttribs({title:"render",});\n\nconst port_byk06hys1=op.inArray("byk06hys1");\nport_byk06hys1.setUiAttribs({title:"Array",});\n\nconst port_icoiczvtv=op.inFloat("icoiczvtv",0);\nport_icoiczvtv.setUiAttribs({title:"number2",});\n\nconst port_6lhmsuqvg=op.inFloat("6lhmsuqvg",0);\nport_6lhmsuqvg.setUiAttribs({title:"number2",});\n\nconst port_09lct6z2t=op.inFloat("09lct6z2t",0);\nport_09lct6z2t.setUiAttribs({title:"number2",});\n\nconst port_driq8l4om=op.outTrigger("driq8l4om");\nport_driq8l4om.setUiAttribs({title:"trigger",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_2uzay3xk0 = addedOps[i].outTrigger("innerOut_2uzay3xk0");\ninnerOut_2uzay3xk0.setUiAttribs({title:"render"});\nport_2uzay3xk0.onTriggered = () => { innerOut_2uzay3xk0.trigger(); };\n\nconst innerOut_byk06hys1 = addedOps[i].outArray("innerOut_byk06hys1");\ninnerOut_byk06hys1.setUiAttribs({title:"Array"});\nport_byk06hys1.on("change", (a,v) => { innerOut_byk06hys1.setRef(a); });\n\nconst innerOut_icoiczvtv = addedOps[i].outNumber("innerOut_icoiczvtv");\ninnerOut_icoiczvtv.set(port_icoiczvtv.get() );\ninnerOut_icoiczvtv.setUiAttribs({title:"number2"});\nport_icoiczvtv.on("change", (a,v) => { innerOut_icoiczvtv.set(a); });\n\nconst innerOut_6lhmsuqvg = addedOps[i].outNumber("innerOut_6lhmsuqvg");\ninnerOut_6lhmsuqvg.set(port_6lhmsuqvg.get() );\ninnerOut_6lhmsuqvg.setUiAttribs({title:"number2"});\nport_6lhmsuqvg.on("change", (a,v) => { innerOut_6lhmsuqvg.set(a); });\n\nconst innerOut_09lct6z2t = addedOps[i].outNumber("innerOut_09lct6z2t");\ninnerOut_09lct6z2t.set(port_09lct6z2t.get() );\ninnerOut_09lct6z2t.setUiAttribs({title:"number2"});\nport_09lct6z2t.on("change", (a,v) => { innerOut_09lct6z2t.set(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_driq8l4om = addedOps[i].inTrigger("innerIn_driq8l4om");\ninnerIn_driq8l4om.setUiAttribs({title:"trigger"});\ninnerIn_driq8l4om.onTriggered = () => { port_driq8l4om.trigger(); };\n\n}\n}\n};\n',
    subpatch_json:
      '{"ops":[{"id":"bp2-0","uiAttribs":{"subPatch":"wn6chtu8w"},"storage":{},"portsOut":[{"name":"trigger","links":[{"portIn":"innerIn_driq8l4om","portOut":"trigger","objIn":"bp2-3","objOut":"bp2-0"}]}],"objName":"Ops.Gl.Matrix.TransformView"},{"id":"bp2-1","uiAttribs":{"subPatch":"wn6chtu8w"},"storage":{},"portsIn":[{"name":"Index","value":0}],"portsOut":[{"name":"X","links":[{"portIn":"posX","portOut":"X","objIn":"bp2-0","objOut":"bp2-1"}]},{"name":"Y","links":[{"portIn":"posY","portOut":"Y","objIn":"bp2-0","objOut":"bp2-1"}]},{"name":"Z","links":[{"portIn":"posZ","portOut":"Z","objIn":"bp2-0","objOut":"bp2-1"}]}],"objName":"Ops.Array.Array3GetNumbers"},{"id":"bp2-2","uiAttribs":{"subPatch":"wn6chtu8w"},"storage":{},"portsOut":[{"name":"innerOut_2uzay3xk0","title":"render","links":[{"portIn":"Execute","portOut":"innerOut_2uzay3xk0","objIn":"bp2-6","objOut":"bp2-2"}]},{"name":"innerOut_byk06hys1","title":"Array","links":[{"portIn":"Array In","portOut":"innerOut_byk06hys1","objIn":"bp2-6","objOut":"bp2-2"}]},{"name":"innerOut_icoiczvtv","title":"number2","links":[{"portIn":"number2","portOut":"innerOut_icoiczvtv","objIn":"bp2-7","objOut":"bp2-2"}]},{"name":"innerOut_6lhmsuqvg","title":"number2","links":[{"portIn":"number2","portOut":"innerOut_6lhmsuqvg","objIn":"bp2-8","objOut":"bp2-2"}]},{"name":"innerOut_09lct6z2t","title":"number2","links":[{"portIn":"number2","portOut":"innerOut_09lct6z2t","objIn":"bp2-9","objOut":"bp2-2"}]}],"objName":"Ops.Ui.SubPatchInput"},{"id":"bp2-3","uiAttribs":{"subPatch":"wn6chtu8w"},"storage":{},"portsIn":[{"name":"innerIn_driq8l4om","title":"trigger"}],"objName":"Ops.Ui.SubPatchOutput"},{"id":"bp2-4","uiAttribs":{"subPatch":"wn6chtu8w"},"storage":{},"portsIn":[{"name":"index","value":3},{"name":"Value Invalid Index","value":0}],"portsOut":[{"name":"value","links":[{"portIn":"scale","portOut":"value","objIn":"bp2-0","objOut":"bp2-4"}]},{"name":"Valid Index","value":1}],"objName":"Ops.Array.ArrayGetNumber"},{"id":"bp2-5","uiAttribs":{"subPatch":"wn6chtu8w"},"storage":{},"portsIn":[{"name":"Index","value":4}],"portsOut":[{"name":"X","links":[{"portIn":"number1","portOut":"X","objIn":"bp2-7","objOut":"bp2-5"}]},{"name":"Y","links":[{"portIn":"number1","portOut":"Y","objIn":"bp2-8","objOut":"bp2-5"}]},{"name":"Z","links":[{"portIn":"number1","portOut":"Z","objIn":"bp2-9","objOut":"bp2-5"}]}],"objName":"Ops.Array.Array3GetNumbers"},{"id":"bp2-6","uiAttribs":{"subPatch":"wn6chtu8w"},"storage":{},"portsIn":[{"name":"Separate inc/dec","value":0},{"name":"Inc factor","value":30,"title":"Inc/Dec factor"},{"name":"Dec factor","value":4}],"portsOut":[{"name":"Next","links":[{"portIn":"render","portOut":"Next","objIn":"bp2-0","objOut":"bp2-6"}]},{"name":"Array Out","links":[{"portIn":"Array","portOut":"Array Out","objIn":"bp2-1","objOut":"bp2-6"},{"portIn":"array","portOut":"Array Out","objIn":"bp2-4","objOut":"bp2-6"},{"portIn":"Array","portOut":"Array Out","objIn":"bp2-5","objOut":"bp2-6"}]}],"objName":"Ops.Array.SmoothArray"},{"id":"bp2-7","uiAttribs":{"subPatch":"wn6chtu8w"},"storage":{},"portsOut":[{"name":"result","links":[{"portIn":"rotX","portOut":"result","objIn":"bp2-0","objOut":"bp2-7"}]}],"objName":"Ops.Math.Sum"},{"id":"bp2-8","uiAttribs":{"subPatch":"wn6chtu8w"},"storage":{},"portsOut":[{"name":"result","links":[{"portIn":"rotY","portOut":"result","objIn":"bp2-0","objOut":"bp2-8"}]}],"objName":"Ops.Math.Sum"},{"id":"bp2-9","uiAttribs":{"subPatch":"wn6chtu8w"},"storage":{},"portsOut":[{"name":"result","links":[{"portIn":"rotZ","portOut":"result","objIn":"bp2-0","objOut":"bp2-9"}]}],"objName":"Ops.Math.Sum"}]}',
  });
  const l = e.inTrigger("2uzay3xk0");
  l.setUiAttribs({ title: "render" });
  const u = e.inArray("byk06hys1");
  u.setUiAttribs({ title: "Array" });
  const c = e.inFloat("icoiczvtv", 0);
  c.setUiAttribs({ title: "number2" });
  const d = e.inFloat("6lhmsuqvg", 0);
  d.setUiAttribs({ title: "number2" });
  const h = e.inFloat("09lct6z2t", 0);
  h.setUiAttribs({ title: "number2" });
  const p = e.outTrigger("driq8l4om");
  p.setUiAttribs({ title: "trigger" });
  e.initInnerPorts = function (t) {
    for (let e = 0; e < t.length; e++) {
      if (t[e].innerInput) {
        const n = t[e].outTrigger("innerOut_2uzay3xk0");
        n.setUiAttribs({ title: "render" });
        l.onTriggered = () => {
          n.trigger();
        };
        const i = t[e].outArray("innerOut_byk06hys1");
        i.setUiAttribs({ title: "Array" });
        u.on("change", (e, t) => {
          i.setRef(e);
        });
        const r = t[e].outNumber("innerOut_icoiczvtv");
        r.set(c.get());
        r.setUiAttribs({ title: "number2" });
        c.on("change", (e, t) => {
          r.set(e);
        });
        const a = t[e].outNumber("innerOut_6lhmsuqvg");
        a.set(d.get());
        a.setUiAttribs({ title: "number2" });
        d.on("change", (e, t) => {
          a.set(e);
        });
        const s = t[e].outNumber("innerOut_09lct6z2t");
        s.set(h.get());
        s.setUiAttribs({ title: "number2" });
        h.on("change", (e, t) => {
          s.set(e);
        });
      }
      if (t[e].innerOutput) {
        const o = t[e].inTrigger("innerIn_driq8l4om");
        o.setUiAttribs({ title: "trigger" });
        o.onTriggered = () => {
          p.trigger();
        };
      }
    }
  };
  const i = "bp2sub_" + e.id;
  new CABLES.SubPatchOp(e, { subId: i });
  t();
  function t() {
    if (!n || !n.subpatch_json) return;
    const t = JSON.parse(n.subpatch_json);
    CABLES.Patch.replaceOpIds(t, {
      parentSubPatchId: i,
      prefixHash: i,
      oldIdAsRef: true,
      doNotUnlinkLostLinks: true,
    });
    for (let e = 0; e < t.ops.length; e++) {
      t.ops[e].uiAttribs.blueprintSubpatch2 = true;
    }
    e.loadDependencies(t, () => {
      e.patch.deSerialize(t, { opsCreated: e.initInnerPorts });
      if (CABLES.UI) gui.savedState.setSaved("blueprintloaded", i);
      e.patch.emitEvent("subpatchExpose", i);
      e.setStorage({ blueprintVer: 2 });
      e.patch.emitEvent("subpatchExpose", i);
    });
  }
};
Ops.Patch.PGgjVeu.TransfromFromArray.prototype = new CABLES.Op();
CABLES.OPS["fe53a267-5d09-45e5-a791-f1a574055dc4"] = {
  f: Ops.Patch.PGgjVeu.TransfromFromArray,
  objName: "Ops.Patch.PGgjVeu.TransfromFromArray",
};
Ops.Patch.PGgjVeu.MouseInteract = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const n = (e.attachments = {
    inc_gen_ports_js:
      'const port_d7g5c0h5b=op.inTrigger("d7g5c0h5b");\nport_d7g5c0h5b.setUiAttribs({title:"Trigger 2",});\n\nconst port_ieb1lbewd=op.inFloat("ieb1lbewd",0.1);\nport_ieb1lbewd.setUiAttribs({title:"Value",});\n\nconst port_83lvt4w8p=op.inFloat("83lvt4w8p",1);\nport_83lvt4w8p.setUiAttribs({title:"Value",});\n\nconst port_d58ks5o1j=op.outNumber("d58ks5o1j");\nport_d58ks5o1j.setUiAttribs({title:"Result",});\n\nconst port_eqbeofk6o=op.outNumber("eqbeofk6o");\nport_eqbeofk6o.setUiAttribs({title:"Result",});\n\nconst port_vy0njf6dp=op.outNumber("vy0njf6dp");\nport_vy0njf6dp.setUiAttribs({title:"Result",});\n\nconst port_cq7ouht1r=op.outTrigger("cq7ouht1r");\nport_cq7ouht1r.setUiAttribs({title:"Next",});\n\nop.initInnerPorts=function(addedOps)\n{\n  for(let i=0;i<addedOps.length;i++)\n  {\n    if(addedOps[i].innerInput)\n    {\nconst innerOut_d7g5c0h5b = addedOps[i].outTrigger("innerOut_d7g5c0h5b");\ninnerOut_d7g5c0h5b.setUiAttribs({title:"Trigger 2"});\nport_d7g5c0h5b.onTriggered = () => { innerOut_d7g5c0h5b.trigger(); };\n\nconst innerOut_ieb1lbewd = addedOps[i].outNumber("innerOut_ieb1lbewd");\ninnerOut_ieb1lbewd.set(port_ieb1lbewd.get() );\ninnerOut_ieb1lbewd.setUiAttribs({title:"Value"});\nport_ieb1lbewd.on("change", (a,v) => { innerOut_ieb1lbewd.set(a); });\n\nconst innerOut_83lvt4w8p = addedOps[i].outNumber("innerOut_83lvt4w8p");\ninnerOut_83lvt4w8p.set(port_83lvt4w8p.get() );\ninnerOut_83lvt4w8p.setUiAttribs({title:"Value"});\nport_83lvt4w8p.on("change", (a,v) => { innerOut_83lvt4w8p.set(a); });\n\n    }\nif(addedOps[i].innerOutput)\n{\nconst innerIn_d58ks5o1j = addedOps[i].inFloat("innerIn_d58ks5o1j");\ninnerIn_d58ks5o1j.setUiAttribs({title:"Result"});\ninnerIn_d58ks5o1j.on("change", (a,v) => { port_d58ks5o1j.set(a); });\n\nconst innerIn_eqbeofk6o = addedOps[i].inFloat("innerIn_eqbeofk6o");\ninnerIn_eqbeofk6o.setUiAttribs({title:"Result"});\ninnerIn_eqbeofk6o.on("change", (a,v) => { port_eqbeofk6o.set(a); });\n\nconst innerIn_vy0njf6dp = addedOps[i].inFloat("innerIn_vy0njf6dp");\ninnerIn_vy0njf6dp.setUiAttribs({title:"Result"});\ninnerIn_vy0njf6dp.on("change", (a,v) => { port_vy0njf6dp.set(a); });\n\nconst innerIn_cq7ouht1r = addedOps[i].inTrigger("innerIn_cq7ouht1r");\ninnerIn_cq7ouht1r.setUiAttribs({title:"Next"});\ninnerIn_cq7ouht1r.onTriggered = () => { port_cq7ouht1r.trigger(); };\n\n}\n}\n};\n',
    subpatch_json:
      '{"ops":[{"id":"bp3-0","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsIn":[{"name":"Sync to timeline","value":0}],"portsOut":[{"name":"Time","links":[{"portIn":"number2","portOut":"Time","objIn":"bp3-1","objOut":"bp3-0"},{"portIn":"number2","portOut":"Time","objIn":"bp3-2","objOut":"bp3-0"},{"portIn":"number2","portOut":"Time","objIn":"bp3-12","objOut":"bp3-0"}]}],"objName":"Ops.Anim.Timer_v2"},{"id":"bp3-1","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsOut":[{"name":"result","links":[{"portIn":"Value","portOut":"result","objIn":"bp3-4","objOut":"bp3-1"}]}],"objName":"Ops.Math.Sum"},{"id":"bp3-2","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsOut":[{"name":"result","links":[{"portIn":"Value","portOut":"result","objIn":"bp3-5","objOut":"bp3-2"}]}],"objName":"Ops.Math.Sum"},{"id":"bp3-3","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsIn":[{"name":"Default Value","value":0}],"portsOut":[{"name":"Current value","links":[{"portIn":"number1","portOut":"Current value","objIn":"bp3-1","objOut":"bp3-3"}]}],"objName":"Ops.Math.Accumulator"},{"id":"bp3-4","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsIn":[{"name":"Separate inc/dec","value":0},{"name":"Inc factor","value":10,"title":"Inc/Dec factor"},{"name":"Dec factor","value":4}],"portsOut":[{"name":"Next","links":[{"portIn":"innerIn_cq7ouht1r","portOut":"Next","objIn":"bp3-14","objOut":"bp3-4"}]},{"name":"Result","links":[{"portIn":"innerIn_d58ks5o1j","portOut":"Result","objIn":"bp3-14","objOut":"bp3-4"}]}],"objName":"Ops.Anim.Smooth"},{"id":"bp3-5","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsIn":[{"name":"Separate inc/dec","value":0},{"name":"Inc factor","value":10,"title":"Inc/Dec factor"},{"name":"Dec factor","value":4}],"portsOut":[{"name":"Result","links":[{"portIn":"innerIn_eqbeofk6o","portOut":"Result","objIn":"bp3-14","objOut":"bp3-5"}]}],"objName":"Ops.Anim.Smooth"},{"id":"bp3-6","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsIn":[{"name":"Default Value","value":0}],"portsOut":[{"name":"Current value","links":[{"portIn":"number1","portOut":"Current value","objIn":"bp3-2","objOut":"bp3-6"}]}],"objName":"Ops.Math.Accumulator"},{"id":"bp3-7","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsOut":[{"name":"has focus","value":1},{"name":"Tab Visible","links":[{"portIn":"Play","portOut":"Tab Visible","objIn":"bp3-0","objOut":"bp3-7"}]}],"objName":"Ops.Html.WindowHasFocus"},{"id":"bp3-8","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsIn":[{"name":"Play","value":1},{"name":"Sync to timeline","value":0}],"portsOut":[{"name":"Time","links":[{"portIn":"value","portOut":"Time","objIn":"bp3-15","objOut":"bp3-8"}]}],"objName":"Ops.Anim.Timer_v2"},{"id":"bp3-9","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsOut":[{"name":"Next","links":[{"portIn":"Reset","portOut":"Next","objIn":"bp3-8","objOut":"bp3-9"}]},{"name":"Number","value":0.13398940196820597}],"objName":"Ops.Number.TriggerOnChangeNumber"},{"id":"bp3-10","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsIn":[{"name":"Default Value","value":0}],"portsOut":[{"name":"Current value","links":[{"portIn":"number1","portOut":"Current value","objIn":"bp3-12","objOut":"bp3-10"}]}],"objName":"Ops.Math.Accumulator"},{"id":"bp3-11","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsIn":[{"name":"Separate inc/dec","value":0},{"name":"Inc factor","value":10,"title":"Inc/Dec factor"},{"name":"Dec factor","value":4}],"portsOut":[{"name":"Result","links":[{"portIn":"innerIn_vy0njf6dp","portOut":"Result","objIn":"bp3-14","objOut":"bp3-11"}]}],"objName":"Ops.Anim.Smooth"},{"id":"bp3-12","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsOut":[{"name":"result","links":[{"portIn":"Value","portOut":"result","objIn":"bp3-11","objOut":"bp3-12"}]}],"objName":"Ops.Math.Sum"},{"id":"bp3-13","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsOut":[{"name":"innerOut_d7g5c0h5b","title":"Trigger 2","links":[{"portIn":"Update","portOut":"innerOut_d7g5c0h5b","objIn":"bp3-4","objOut":"bp3-13"},{"portIn":"Trigger in","portOut":"innerOut_d7g5c0h5b","objIn":"bp3-3","objOut":"bp3-13"},{"portIn":"Trigger in","portOut":"innerOut_d7g5c0h5b","objIn":"bp3-6","objOut":"bp3-13"},{"portIn":"Trigger in","portOut":"innerOut_d7g5c0h5b","objIn":"bp3-10","objOut":"bp3-13"},{"portIn":"Update","portOut":"innerOut_d7g5c0h5b","objIn":"bp3-5","objOut":"bp3-13"},{"portIn":"Update","portOut":"innerOut_d7g5c0h5b","objIn":"bp3-11","objOut":"bp3-13"}]},{"name":"innerOut_ieb1lbewd","title":"Value","links":[{"portIn":"Speed","portOut":"innerOut_ieb1lbewd","objIn":"bp3-0","objOut":"bp3-13"}]},{"name":"innerOut_83lvt4w8p","title":"Value","links":[{"portIn":"Speed","portOut":"innerOut_83lvt4w8p","objIn":"bp3-8","objOut":"bp3-13"}]}],"objName":"Ops.Ui.SubPatchInput"},{"id":"bp3-14","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsIn":[{"name":"innerIn_d58ks5o1j","title":"Result"},{"name":"innerIn_eqbeofk6o","title":"Result"},{"name":"innerIn_vy0njf6dp","title":"Result"},{"name":"innerIn_cq7ouht1r","title":"Next"}],"objName":"Ops.Ui.SubPatchOutput"},{"id":"bp3-15","uiAttribs":{"subPatch":"frvqybgul"},"storage":{},"portsIn":[{"name":"old min","value":0},{"name":"old max","value":1},{"name":"new min","value":1},{"name":"new max","value":0},{"name":"Easing index","value":0},{"name":"Easing","value":"Linear"},{"name":"Clamp","value":1}],"portsOut":[{"name":"result","links":[{"portIn":"Multiplier to add number","portOut":"result","objIn":"bp3-10","objOut":"bp3-15"},{"portIn":"Multiplier to add number","portOut":"result","objIn":"bp3-6","objOut":"bp3-15"},{"portIn":"Multiplier to add number","portOut":"result","objIn":"bp3-3","objOut":"bp3-15"}]}],"objName":"Ops.Math.MapRange"},{"id":"bp3-16","uiAttribs":{"subPatch":"frvqybgul"},"portsIn":[{"name":"Index","value":0}],"portsOut":[{"name":"X","links":[{"portIn":"Add to number","portOut":"X","objIn":"bp3-3","objOut":"bp3-16"},{"portIn":"Value","portOut":"X","objIn":"bp3-9","objOut":"bp3-16"}]},{"name":"Y","links":[{"portIn":"Add to number","portOut":"Y","objIn":"bp3-6","objOut":"bp3-16"},{"portIn":"Add to number","portOut":"Y","objIn":"bp3-10","objOut":"bp3-16"}]},{"name":"Z","value":0}],"storage":{"ref":"bp3-16"},"objName":"Ops.Array.Array3GetNumbers"},{"id":"bp3-17","uiAttribs":{"subPatch":"frvqybgul"},"portsIn":[{"name":"Variable","value":"mousePosition"}],"portsOut":[{"name":"Value","links":[{"portIn":"Array","portOut":"Value","objIn":"bp3-16","objOut":"bp3-17"}]}],"storage":{"ref":"bp3-17"},"objName":"Ops.Vars.VarGetArray_v2"}]}',
  });
  const u = e.inTrigger("d7g5c0h5b");
  u.setUiAttribs({ title: "Trigger 2" });
  const c = e.inFloat("ieb1lbewd", 0.1);
  c.setUiAttribs({ title: "Value" });
  const d = e.inFloat("83lvt4w8p", 1);
  d.setUiAttribs({ title: "Value" });
  const h = e.outNumber("d58ks5o1j");
  h.setUiAttribs({ title: "Result" });
  const p = e.outNumber("eqbeofk6o");
  p.setUiAttribs({ title: "Result" });
  const m = e.outNumber("vy0njf6dp");
  m.setUiAttribs({ title: "Result" });
  const f = e.outTrigger("cq7ouht1r");
  f.setUiAttribs({ title: "Next" });
  e.initInnerPorts = function (t) {
    for (let e = 0; e < t.length; e++) {
      if (t[e].innerInput) {
        const n = t[e].outTrigger("innerOut_d7g5c0h5b");
        n.setUiAttribs({ title: "Trigger 2" });
        u.onTriggered = () => {
          n.trigger();
        };
        const i = t[e].outNumber("innerOut_ieb1lbewd");
        i.set(c.get());
        i.setUiAttribs({ title: "Value" });
        c.on("change", (e, t) => {
          i.set(e);
        });
        const r = t[e].outNumber("innerOut_83lvt4w8p");
        r.set(d.get());
        r.setUiAttribs({ title: "Value" });
        d.on("change", (e, t) => {
          r.set(e);
        });
      }
      if (t[e].innerOutput) {
        const a = t[e].inFloat("innerIn_d58ks5o1j");
        a.setUiAttribs({ title: "Result" });
        a.on("change", (e, t) => {
          h.set(e);
        });
        const s = t[e].inFloat("innerIn_eqbeofk6o");
        s.setUiAttribs({ title: "Result" });
        s.on("change", (e, t) => {
          p.set(e);
        });
        const o = t[e].inFloat("innerIn_vy0njf6dp");
        o.setUiAttribs({ title: "Result" });
        o.on("change", (e, t) => {
          m.set(e);
        });
        const l = t[e].inTrigger("innerIn_cq7ouht1r");
        l.setUiAttribs({ title: "Next" });
        l.onTriggered = () => {
          f.trigger();
        };
      }
    }
  };
  const i = "bp2sub_" + e.id;
  new CABLES.SubPatchOp(e, { subId: i });
  t();
  function t() {
    if (!n || !n.subpatch_json) return;
    const t = JSON.parse(n.subpatch_json);
    CABLES.Patch.replaceOpIds(t, {
      parentSubPatchId: i,
      prefixHash: i,
      oldIdAsRef: true,
      doNotUnlinkLostLinks: true,
    });
    for (let e = 0; e < t.ops.length; e++) {
      t.ops[e].uiAttribs.blueprintSubpatch2 = true;
    }
    e.loadDependencies(t, () => {
      e.patch.deSerialize(t, { opsCreated: e.initInnerPorts });
      if (CABLES.UI) gui.savedState.setSaved("blueprintloaded", i);
      e.patch.emitEvent("subpatchExpose", i);
      e.setStorage({ blueprintVer: 2 });
      e.patch.emitEvent("subpatchExpose", i);
    });
  }
};
Ops.Patch.PGgjVeu.MouseInteract.prototype = new CABLES.Op();
CABLES.OPS["38017d40-69c5-4b36-ac8d-f29966617da3"] = {
  f: Ops.Patch.PGgjVeu.MouseInteract,
  objName: "Ops.Patch.PGgjVeu.MouseInteract",
};
Ops.Anim.Timer_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const a = e.inValue("Speed", 1),
    n = e.inValueBool("Play", true),
    i = e.inTriggerButton("Reset"),
    r = e.inValueBool("Sync to timeline", false),
    s = e.outNumber("Time");
  e.setPortGroup("Controls", [n, i, a]);
  const o = new CABLES.Timer();
  let l = null;
  let u = 0;
  let c = false;
  n.onChange = d;
  d();
  function d() {
    if (n.get()) {
      o.play();
      e.patch.addOnAnimFrame(e);
    } else {
      o.pause();
      e.patch.removeOnAnimFrame(e);
    }
  }
  i.onTriggered = h;
  function h() {
    u = 0;
    l = null;
    o.setTime(0);
    s.set(0);
  }
  r.onChange = function () {
    c = r.get();
    n.setUiAttribs({ greyout: c });
    i.setUiAttribs({ greyout: c });
  };
  e.onAnimFrame = function (e, t, n) {
    if (o.isPlaying()) {
      if (CABLES.overwriteTime !== undefined) {
        s.set(CABLES.overwriteTime * a.get());
      } else if (c) {
        s.set(e * a.get());
      } else {
        o.update();
        const i = o.get();
        if (l === null) {
          l = i;
          return;
        }
        const r = Math.abs(i - l);
        l = i;
        u += r * a.get();
        if (u != u) u = 0;
        s.set(u);
      }
    }
  };
};
Ops.Anim.Timer_v2.prototype = new CABLES.Op();
CABLES.OPS["aac7f721-208f-411a-adb3-79adae2e471a"] = {
  f: Ops.Anim.Timer_v2,
  objName: "Ops.Anim.Timer_v2",
};
Ops.Anim.Smooth = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inTrigger("Update"),
    i = e.inBool("Separate inc/dec", false),
    r = e.inValue("Value"),
    a = e.outTrigger("Next"),
    s = e.inValue("Inc factor", 4),
    o = e.inValue("Dec factor", 4),
    l = e.outNumber("Result", 0);
  let u = 0;
  let c = 0;
  let d = 0;
  let h = 0;
  e.toWorkPortsNeedToBeLinked(n);
  let p;
  let m;
  let f = 4;
  let g = true;
  let b = 0;
  const v = 0;
  const y = 1;
  _();
  T();
  i.setUiAttribs({ hidePort: true });
  s.onChange = o.onChange = T;
  i.onChange = _;
  O();
  function _() {
    const e = i.get();
    if (!e) b = v;
    else b = y;
    if (b == v) {
      o.setUiAttribs({ greyout: true });
      s.setUiAttribs({ title: "Inc/Dec factor" });
    } else if (b == y) {
      o.setUiAttribs({ greyout: false });
      s.setUiAttribs({ title: "Inc factor" });
    }
    T();
    O();
  }
  function T() {
    if (b == v) {
      p = s.get();
      m = s.get();
    } else if (b == y) {
      p = s.get();
      m = o.get();
    }
    if (p <= 0.2 || p != p) p = 0.2;
    if (m <= 0.2 || m != m) m = 0.2;
  }
  r.onChange = function () {
    g = false;
    let e = c;
    c = r.get();
  };
  s.onChange = function () {
    T();
  };
  function O() {
    let e = 1;
    if (performance.now() - h > 500 || h === 0) u = r.get() || 0;
    else e = (performance.now() - h) / (performance.now() - h);
    h = performance.now();
    if (u != u) u = 0;
    if (f <= 0) f = 1e-4;
    const t = c - u;
    if (t >= 0) u += t / (m * e);
    else u += t / (p * e);
    if (Math.abs(t) < 1e-5) u = c;
    if (f != f) u = 0;
    if (u != u || u == -Infinity || u == Infinity) u = r.get();
    if (d != u) {
      l.set(u);
      d = u;
    }
    if (u == c && !g) {
      g = true;
      l.set(u);
    }
    a.trigger();
  }
  n.onTriggered = function () {
    O();
  };
};
Ops.Anim.Smooth.prototype = new CABLES.Op();
CABLES.OPS["5677b5b5-753a-4fbf-9e91-64c81ec68a2f"] = {
  f: Ops.Anim.Smooth,
  objName: "Ops.Anim.Smooth",
};
Ops.Html.WindowHasFocus = function () {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const e = (t.attachments = {});
  const n = t.outBoolNum("has focus"),
    i = t.outBoolNum("Tab Visible", true);
  const r = true;
  n.set(t.patch.getDocument().hasFocus());
  window.addEventListener("blur", s);
  window.addEventListener("focus", a);
  t.patch.getDocument().addEventListener("visibilitychange", o);
  t.onDelete = function () {
    t.patch.getDocument().removeEventListener("visibilitychange", o);
  };
  function a() {
    n.set(true);
  }
  function s() {
    n.set(false);
  }
  function o(e) {
    i.set(!t.patch.getDocument().hidden);
  }
};
Ops.Html.WindowHasFocus.prototype = new CABLES.Op();
CABLES.OPS["6542896e-aa13-4b57-81e0-163597f4149a"] = {
  f: Ops.Html.WindowHasFocus,
  objName: "Ops.Html.WindowHasFocus",
};
Ops.Ui.SubPatchInput = function () {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const e = (t.attachments = {});
  t.innerInput = true;
  const n = t.inTriggerButton("Goto SubPatchOp");
  n.setUiAttribs({ hidePort: true });
  n.onTriggered = () => {
    const e = t.patch.getSubPatchOuterOp(t.uiAttribs.subPatch);
    gui.patchView.centerSelectOp(e.id);
  };
};
Ops.Ui.SubPatchInput.prototype = new CABLES.Op();
CABLES.OPS["c4e4e933-136e-479e-8de8-0b35b75d9217"] = {
  f: Ops.Ui.SubPatchInput,
  objName: "Ops.Ui.SubPatchInput",
};
Ops.Ui.SubPatchOutput = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  e.innerOutput = true;
};
Ops.Ui.SubPatchOutput.prototype = new CABLES.Op();
CABLES.OPS["02d45073-7936-4830-81ad-59a162febf1f"] = {
  f: Ops.Ui.SubPatchOutput,
  objName: "Ops.Ui.SubPatchOutput",
};
Ops.Math.Multiply = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inValueFloat("number1", 1),
    i = e.inValueFloat("number2", 1),
    r = e.outNumber("result");
  e.setUiAttribs({ mathTitle: true });
  n.onChange = i.onChange = a;
  a();
  function a() {
    const e = n.get();
    const t = i.get();
    r.set(e * t);
  }
};
Ops.Math.Multiply.prototype = new CABLES.Op();
CABLES.OPS["1bbdae06-fbb2-489b-9bcc-36c9d65bd441"] = {
  f: Ops.Math.Multiply,
  objName: "Ops.Math.Multiply",
};
Ops.Gl.Matrix.TransformView = function () {
  CABLES.Op.apply(this, arguments);
  const n = this;
  const e = (n.attachments = {});
  const t = n.inTrigger("render"),
    i = n.inValueFloat("posX"),
    r = n.inValueFloat("posY"),
    a = n.inValueFloat("posZ"),
    s = n.inValueFloat("scale"),
    o = n.inValueFloat("rotX"),
    l = n.inValueFloat("rotY"),
    u = n.inValueFloat("rotZ"),
    c = n.outTrigger("trigger");
  n.setPortGroup("Position", [i, r, a]);
  n.setPortGroup("Scale", [s]);
  n.setPortGroup("Rotation", [o, u, l]);
  const d = vec3.create();
  const h = vec3.create();
  const p = mat4.create();
  mat4.identity(p);
  let m = false;
  let f = false;
  let g = true;
  let b = true;
  let v = true;
  t.onTriggered = function () {
    const e = n.patch.cgl;
    let t = false;
    if (g) {
      _();
      t = true;
    }
    if (b) {
      T();
      t = true;
    }
    if (v) {
      t = true;
    }
    if (t) y();
    e.pushViewMatrix();
    mat4.multiply(e.vMatrix, e.vMatrix, p);
    c.trigger();
    e.popViewMatrix();
    if (n.isCurrentUiOp()) gui.setTransformGizmo({ posX: i, posY: r, posZ: a });
  };
  n.transform3d = function () {
    return { pos: [i, r, a] };
  };
  function y() {
    mat4.identity(p);
    if (f) mat4.translate(p, p, d);
    if (o.get() !== 0) mat4.rotateX(p, p, o.get() * CGL.DEG2RAD);
    if (l.get() !== 0) mat4.rotateY(p, p, l.get() * CGL.DEG2RAD);
    if (u.get() !== 0) mat4.rotateZ(p, p, u.get() * CGL.DEG2RAD);
    if (m) mat4.scale(p, p, h);
    A = false;
  }
  function _() {
    f = false;
    if (i.get() !== 0 || r.get() !== 0 || a.get() !== 0) f = true;
    vec3.set(d, i.get(), r.get(), a.get());
    g = false;
  }
  function T() {
    m = false;
    if (s.get() !== 0) m = true;
    vec3.set(h, s.get(), s.get(), s.get());
    S = false;
  }
  function O() {
    g = true;
  }
  function S() {
    b = true;
  }
  function A() {
    v = true;
  }
  o.onChange = l.onChange = u.onChange = A;
  s.onChange = S;
  i.onChange = r.onChange = a.onChange = O;
  o.set(0);
  l.set(0);
  u.set(0);
  s.set(1);
  i.set(0);
  r.set(0);
  a.set(0);
  y();
};
Ops.Gl.Matrix.TransformView.prototype = new CABLES.Op();
CABLES.OPS["0b3e04f7-323e-4ac8-8a22-a21e2f36e0e9"] = {
  f: Ops.Gl.Matrix.TransformView,
  objName: "Ops.Gl.Matrix.TransformView",
};
Ops.Array.Array3GetNumbers = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inArray("Array", 3),
    i = e.inValueInt("Index"),
    r = e.outNumber("X"),
    a = e.outNumber("Y"),
    s = e.outNumber("Z");
  n.onChange = i.onChange = o;
  function o() {
    let e = n.get();
    if (!e) {
      r.set(0);
      a.set(0);
      s.set(0);
      return;
    }
    let t = Math.min(e.length - 3, i.get() * 3);
    if (e) {
      r.set(e[t + 0]);
      a.set(e[t + 1]);
      s.set(e[t + 2]);
    }
  }
};
Ops.Array.Array3GetNumbers.prototype = new CABLES.Op();
CABLES.OPS["56882cc4-c40d-4dc0-bf7c-db1b5a7acad0"] = {
  f: Ops.Array.Array3GetNumbers,
  objName: "Ops.Array.Array3GetNumbers",
};
Ops.Array.ArrayGetNumber = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inArray("array"),
    i = e.inValueInt("index"),
    r = e.inFloat("Value Invalid Index", 0),
    a = e.outNumber("value"),
    s = e.outBoolNum("Valid Index", true);
  n.ignoreValueSerialize = true;
  i.onChange = n.onChange = o;
  function o() {
    if (n.get()) {
      const e = n.get()[i.get()];
      if (isNaN(e)) {
        a.set(r.get());
        s.set(false);
      } else {
        s.set(true);
        a.set(parseFloat(e));
      }
    }
  }
};
Ops.Array.ArrayGetNumber.prototype = new CABLES.Op();
CABLES.OPS["d1189078-70cf-437d-9a37-b2ebe89acdaf"] = {
  f: Ops.Array.ArrayGetNumber,
  objName: "Ops.Array.ArrayGetNumber",
};
Ops.Array.SmoothArray = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inTrigger("Execute"),
    r = e.inArray("Array In"),
    i = e.inBool("Separate inc/dec", false),
    a = e.inValue("Inc factor", 4),
    s = e.inValue("Dec factor", 4),
    o = e.outTrigger("Next"),
    l = e.outArray("Array Out");
  let u = [];
  let c = false;
  let d = 0;
  let h = [];
  l.set(h);
  let p;
  let m;
  let f = false;
  g();
  b();
  function g() {
    f = i.get();
    if (!f) {
      s.setUiAttribs({ greyout: true });
      a.setUiAttribs({ title: "Inc/Dec factor" });
    } else {
      s.setUiAttribs({ greyout: false });
      a.setUiAttribs({ title: "Inc factor" });
    }
    b();
    y();
  }
  function b() {
    p = a.get();
    if (f == false) m = a.get();
    else m = s.get();
    if (p <= 0 || p != p) p = 1e-4;
    if (m <= 0 || m != m) m = 1e-4;
    if (p <= 1) p = 1;
    if (m <= 1) m = 1;
  }
  r.onLinkChanged = () => {
    if (r) r.copyLinkedUiAttrib("stride", l);
  };
  r.onChange = function () {
    let t = r.get();
    if (!t) return;
    for (let e = 0; e < t.length; e++) {
      u[e] = t[e] || 0;
    }
  };
  let v = 0;
  function y() {
    let e = r.get();
    if (!e) return;
    if (h.length != e.length) {
      h.length = e.length || 0;
      c = true;
    }
    let n = 1;
    if (CABLES.now() - d > 500 || d === 0) c = true;
    else n = (CABLES.now() - d) / 17;
    d = CABLES.now();
    if (c) {
      for (var i = 0; i < e.length; i++) {
        h[i] = e[i];
      }
      c = false;
    }
    for (var i = 0; i < e.length; i++) {
      let e = h[i];
      let t = u[i] - e;
      if (t >= 0) e += t / (m * n);
      else e += t / (p * n);
      if (e > 0 && e < 1e-9) e = 0;
      if (!e) e = 0;
      if (h[i] != e) {
        h[i] = e;
        v = e;
      }
    }
    l.setRef(h);
    o.trigger();
  }
  n.onTriggered = function () {
    y();
  };
  a.onChange = s.onChange = b;
  i.onChange = g;
  y();
};
Ops.Array.SmoothArray.prototype = new CABLES.Op();
CABLES.OPS["8fd2ed9b-02e5-4349-b7bc-6665ca240ffa"] = {
  f: Ops.Array.SmoothArray,
  objName: "Ops.Array.SmoothArray",
};
Ops.Math.Sum = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inValueFloat("number1", 0),
    i = e.inValueFloat("number2", 0),
    r = e.outNumber("result");
  e.setUiAttribs({ mathTitle: true });
  n.onChange = i.onChange = a;
  a();
  function a() {
    const e = n.get() + i.get();
    if (!isNaN(e)) r.set(e);
  }
};
Ops.Math.Sum.prototype = new CABLES.Op();
CABLES.OPS["c8fb181e-0b03-4b41-9e55-06b6267bc634"] = {
  f: Ops.Math.Sum,
  objName: "Ops.Math.Sum",
};
Ops.Math.Accumulator = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inTrigger("Trigger in"),
    i = e.inValueFloat("Add to number", 0),
    r = e.inValueFloat("Multiplier to add number", 1),
    a = e.inValueFloat("Default Value", 1),
    s = e.inTriggerButton("Set Default Value"),
    o = e.outNumber("Current value");
  let l = performance.now();
  let u = 0;
  let c = true;
  s.onTriggered = d;
  function d() {
    u = a.get();
    o.set(u);
    c = true;
  }
  n.onTriggered = function () {
    if (!c) {
      let e = (performance.now() - l) / 100;
      u += i.get() * e * r.get();
      o.set(u);
    }
    l = performance.now();
    c = false;
  };
};
Ops.Math.Accumulator.prototype = new CABLES.Op();
CABLES.OPS["460574ca-dca2-4283-8c37-57a8c446a51f"] = {
  f: Ops.Math.Accumulator,
  objName: "Ops.Math.Accumulator",
};
Ops.Number.TriggerOnChangeNumber = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inFloat("Value"),
    i = e.outTrigger("Next"),
    r = e.outNumber("Number");
  n.onChange = function () {
    r.set(n.get());
    i.trigger();
  };
};
Ops.Number.TriggerOnChangeNumber.prototype = new CABLES.Op();
CABLES.OPS["f5c8c433-ce13-49c4-9a33-74e98f110ed0"] = {
  f: Ops.Number.TriggerOnChangeNumber,
  objName: "Ops.Number.TriggerOnChangeNumber",
};
Ops.Math.MapRange = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const h = e.inValueFloat("value", 0),
    p = e.inValueFloat("old min", 0),
    m = e.inValueFloat("old max", 1),
    f = e.inValueFloat("new min", 0),
    g = e.inValueFloat("new max", 1),
    n = e.inValueSelect(
      "Easing",
      ["Linear", "Smoothstep", "Smootherstep"],
      "Linear"
    ),
    i = e.inBool("Clamp", true),
    b = e.outNumber("result", 0);
  e.setPortGroup("Input Range", [p, m]);
  e.setPortGroup("Output Range", [f, g]);
  let v = true;
  let y = 0;
  let _ = 0;
  h.onChange = p.onChange = m.onChange = f.onChange = g.onChange = r;
  r();
  i.onChange = () => {
    v = i.get();
    r();
  };
  n.onChange = function () {
    if (n.get() == "Smoothstep") y = 1;
    else if (n.get() == "Smootherstep") y = 2;
    else y = 0;
  };
  function r() {
    const e = f.get();
    const t = g.get();
    const n = p.get();
    const i = m.get();
    let r = h.get();
    if (v) {
      if (r >= Math.max(i, n)) {
        b.set(t);
        return;
      } else if (r <= Math.min(i, n)) {
        b.set(e);
        return;
      }
    }
    let a = false;
    const s = Math.min(n, i);
    const o = Math.max(n, i);
    if (s != n) a = true;
    let l = false;
    const u = Math.min(e, t);
    const c = Math.max(e, t);
    if (u != e) l = true;
    let d = 0;
    if (a) d = ((o - r) * (c - u)) / (o - s);
    else d = ((r - s) * (c - u)) / (o - s);
    if (l) _ = c - d;
    else _ = d + u;
    if (y === 0) {
      b.set(_);
    } else if (y == 1) {
      r = Math.max(0, Math.min(1, (_ - e) / (t - e)));
      b.set(e + r * r * (3 - 2 * r) * (t - e));
    } else if (y == 2) {
      r = Math.max(0, Math.min(1, (_ - e) / (t - e)));
      b.set(e + r * r * r * (r * (r * 6 - 15) + 10) * (t - e));
    }
  }
};
Ops.Math.MapRange.prototype = new CABLES.Op();
CABLES.OPS["2617b407-60a0-4ff6-b4a7-18136cfa7817"] = {
  f: Ops.Math.MapRange,
  objName: "Ops.Math.MapRange",
};
Ops.Vars.VarGetArray_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.outArray("Value");
  e.varName = e.inValueSelect("Variable", [], "", true);
  new CABLES.VarGetOpWrapper(e, "array", e.varName, n);
};
Ops.Vars.VarGetArray_v2.prototype = new CABLES.Op();
CABLES.OPS["afa79294-aa9c-43bc-a49a-cade000a1de5"] = {
  f: Ops.Vars.VarGetArray_v2,
  objName: "Ops.Vars.VarGetArray_v2",
};
Ops.Devices.Mouse.Mouse_v3 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const M = (e.attachments = {});
  const t = e.inSwitch(
      "Coordinates",
      ["-1 to 1", "Pixel Display", "Pixel", "0 to 1"],
      "-1 to 1"
    ),
    r = e.inValueSelect(
      "Area",
      ["Canvas", "Document", "Parent Element", "Canvas Area"],
      "Canvas"
    ),
    a = e.inValueBool("flip y", true),
    n = e.inBool("right click prevent default", true),
    i = e.inValueBool("Touch support", true),
    s = e.inValueBool("Passive Events", false),
    o = e.inValueBool("Active", true),
    l = e.outNumber("x", 0),
    u = e.outNumber("y", 0),
    c = e.outTrigger("click"),
    d = e.outTrigger("click right"),
    h = e.outBoolNum("Button is down"),
    p = e.outBoolNum("Mouse is hovering"),
    m = e.outNumber("Movement X", 0),
    f = e.outNumber("Movement Y", 0);
  const g = e.patch.cgl;
  let b = 1;
  let v = null;
  let y = null;
  s.onChange = r.onChange = L;
  t.onChange = R;
  e.onDelete = N;
  L();
  e.on("loadedValueSet", _);
  function _() {
    if (b == 0) {
      if (y.clientWidth === 0) setTimeout(_, 50);
      l.set(y.clientWidth / 2);
      u.set(y.clientHeight / 2);
    } else if (b == 1) {
      l.set(0);
      u.set(0);
    } else if (b == 2) {
      l.set(0.5);
      u.set(0.5);
    } else if (b == 3) {
      if (y.clientWidth === 0) {
        setTimeout(_, 50);
      }
      l.set(y.clientWidth / 2 / g.pixelDensity);
      u.set(y.clientHeight / 2 / g.pixelDensity);
    } else console.error("unknown normalize mouse", b);
  }
  function D(r, a) {
    r = r || 0;
    a = a || 0;
    if (b == 0) {
      l.set(r);
      u.set(a);
    } else if (b == 3) {
      l.set(r * g.pixelDensity);
      u.set(a * g.pixelDensity);
    } else {
      let n = y.clientWidth / g.pixelDensity;
      let i = y.clientHeight / g.pixelDensity;
      n = n || 1;
      i = i || 1;
      if (b == 1) {
        let e = (r / n) * 2 - 1;
        let t = (a / i) * 2 - 1;
        e = CABLES.clamp(e, -1, 1);
        t = CABLES.clamp(t, -1, 1);
        l.set(e);
        u.set(t);
      } else if (b == 2) {
        let e = r / n;
        let t = a / i;
        e = CABLES.clamp(e, 0, 1);
        t = CABLES.clamp(t, 0, 1);
        l.set(e);
        u.set(t);
      }
    }
  }
  function T(e) {
    const t = y.getBoundingClientRect();
    return (
      e.clientX > t.left &&
      e.clientX < t.left + t.width &&
      e.clientY > t.top &&
      e.clientY < t.top + t.height
    );
  }
  i.onChange = function () {
    N();
    L();
  };
  o.onChange = function () {
    if (v) N();
    if (o.get()) L();
  };
  function R() {
    if (t.get() == "Pixel") b = 0;
    else if (t.get() == "-1 to 1") b = 1;
    else if (t.get() == "0 to 1") b = 2;
    else if (t.get() == "Pixel Display") b = 3;
  }
  function O(e) {
    h.set(false);
    p.set(T(e));
  }
  function S(e) {
    if (!T(e)) return;
    h.set(true);
  }
  function A(e) {
    h.set(false);
  }
  function w(e) {
    if (!T(e)) return;
    d.trigger();
    if (n.get()) e.preventDefault();
  }
  function C(e) {
    if (!T(e)) return;
    c.trigger();
  }
  function I(e) {
    h.set(false);
    p.set(T(e));
  }
  function x(e) {
    let t = e.clientX;
    let n = e.clientY;
    if (r.get() != "Document") {
      t = e.offsetX;
      n = e.offsetY;
    }
    if (r.get() === "Canvas Area") {
      const i = y.getBoundingClientRect();
      t = e.clientX - i.left;
      n = e.clientY - i.top;
    }
    if (a.get()) n = y.clientHeight - n;
    D(t / g.pixelDensity, n / g.pixelDensity);
  }
  function E(e) {
    p.set(T(e));
    x(e);
    m.set(e.movementX / g.pixelDensity);
    f.set(e.movementY / g.pixelDensity);
  }
  function k(e) {
    if (event.touches && event.touches.length > 0) x(e.touches[0]);
  }
  function P(e) {
    h.set(true);
    if (e.touches && e.touches.length > 0) S(e.touches[0]);
  }
  function j(e) {
    h.set(false);
    A();
  }
  function N() {
    if (!v) return;
    v.removeEventListener("touchend", j);
    v.removeEventListener("touchstart", P);
    v.removeEventListener("touchmove", k);
    v.removeEventListener("click", C);
    v.removeEventListener("mousemove", E);
    v.removeEventListener("mouseleave", I);
    v.removeEventListener("mousedown", S);
    v.removeEventListener("mouseup", A);
    v.removeEventListener("mouseenter", O);
    v.removeEventListener("contextmenu", w);
    v = null;
  }
  function L() {
    if (v || !o.get()) N();
    if (!o.get()) return;
    v = y = g.canvas;
    if (r.get() == "Canvas Area") {
      y = g.canvas.parentElement;
      v = document.body;
    }
    if (r.get() == "Document") y = v = document.body;
    if (r.get() == "Parent Element") v = y = g.canvas.parentElement;
    let e = false;
    if (s.get()) e = { passive: true };
    if (i.get()) {
      v.addEventListener("touchend", j, e);
      v.addEventListener("touchstart", P, e);
      v.addEventListener("touchmove", k, e);
    }
    v.addEventListener("mousemove", E, e);
    v.addEventListener("mouseleave", I, e);
    v.addEventListener("mousedown", S, e);
    v.addEventListener("mouseup", A, e);
    v.addEventListener("mouseenter", O, e);
    v.addEventListener("contextmenu", w, e);
    v.addEventListener("click", C, e);
  }
};
Ops.Devices.Mouse.Mouse_v3.prototype = new CABLES.Op();
CABLES.OPS["6d1edbc0-088a-43d7-9156-918fb3d7f24b"] = {
  f: Ops.Devices.Mouse.Mouse_v3,
  objName: "Ops.Devices.Mouse.Mouse_v3",
};
Ops.Trigger.TriggerOnChangeString = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inString("String"),
    i = e.outTrigger("Changed"),
    r = e.outString("Result");
  r.ignoreValueSerialize = true;
  n.onChange = function () {
    r.set(n.get());
    i.trigger();
  };
};
Ops.Trigger.TriggerOnChangeString.prototype = new CABLES.Op();
CABLES.OPS["319d07e0-5cbe-4bc1-89fb-a934fd41b0c4"] = {
  f: Ops.Trigger.TriggerOnChangeString,
  objName: "Ops.Trigger.TriggerOnChangeString",
};
Ops.Math.TriggerRandomNumber_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inTriggerButton("Generate"),
    i = e.inValue("min", 0),
    r = e.inValue("max", 1),
    a = e.outTrigger("next"),
    s = e.outNumber("result"),
    o = e.inValueBool("Integer", false),
    l = e.inValueBool("No consecutive duplicates", false);
  e.setPortGroup("Value Range", [i, r]);
  n.onTriggered = r.onChange = i.onChange = o.onChange = u;
  u();
  function u() {
    let e = Math.random() * (r.get() - i.get()) + i.get();
    if (o.get()) e = c();
    if (i.get() != r.get() && r.get() > i.get())
      while (l.get() && e == s.get()) e = c();
    s.set(e);
    a.trigger();
  }
  function c() {
    return Math.floor(Math.random() * (r.get() - i.get() + 1) + i.get());
  }
};
Ops.Math.TriggerRandomNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["26f446cc-9107-4164-8209-5254487fa132"] = {
  f: Ops.Math.TriggerRandomNumber_v2,
  objName: "Ops.Math.TriggerRandomNumber_v2",
};
Ops.Trigger.TriggerButton = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inTriggerButton("Trigger"),
    i = e.outTrigger("Next");
  n.onTriggered = function () {
    i.trigger();
  };
};
Ops.Trigger.TriggerButton.prototype = new CABLES.Op();
CABLES.OPS["21630924-39e4-4df5-9965-b9136510d156"] = {
  f: Ops.Trigger.TriggerButton,
  objName: "Ops.Trigger.TriggerButton",
};
Ops.Vars.VarGetString = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  var n = e.outString("Value");
  e.varName = e.inValueSelect("Variable", [], "", true);
  new CABLES.VarGetOpWrapper(e, "string", e.varName, n);
};
Ops.Vars.VarGetString.prototype = new CABLES.Op();
CABLES.OPS["3ad08cfc-bce6-4175-9746-fef2817a3b12"] = {
  f: Ops.Vars.VarGetString,
  objName: "Ops.Vars.VarGetString",
};
Ops.Ui.PatchInput = function () {
  CABLES.Op.apply(this, arguments);
  const r = this;
  const e = (r.attachments = {});
  const a = r.addOutPort(
    new CABLES.Port(r, "create port", CABLES.OP_PORT_TYPE_DYNAMIC)
  );
  function s() {
    for (let e in r.patch.ops) {
      if (r.patch.ops[e].patchId) {
        if (r.patch.ops[e].patchId.get() == r.uiAttribs.subPatch) {
          return r.patch.ops[e];
        }
      }
    }
  }
  a.onLinkChanged = () => {
    const e = s();
    if (!a.links.length || !e || !e.addNewInPort) return;
    const t = a.links[0].getOtherPort(a);
    a.removeLinks();
    const n = e.addNewInPort(t);
    const i = gui.scene().link(t.parent, t.getName(), r, n);
    e.saveData();
  };
};
Ops.Ui.PatchInput.prototype = new CABLES.Op();
CABLES.OPS["e3f68bc3-892a-4c78-9974-aca25c27025d"] = {
  f: Ops.Ui.PatchInput,
  objName: "Ops.Ui.PatchInput",
};
Ops.Ui.PatchOutput = function () {
  CABLES.Op.apply(this, arguments);
  const r = this;
  const e = (r.attachments = {});
  const a = r.addInPort(
    new CABLES.Port(r, "create port", CABLES.OP_PORT_TYPE_DYNAMIC)
  );
  function s() {
    for (let e in r.patch.ops) {
      if (r.patch.ops[e].patchId) {
        if (r.patch.ops[e].patchId.get() == r.uiAttribs.subPatch) {
          return r.patch.ops[e];
        }
      }
    }
  }
  a.onLinkChanged = () => {
    const e = s();
    if (!a.links.length) return;
    const t = a.links[0].getOtherPort(a);
    a.removeLinks();
    const n = e.addNewOutPort(t);
    const i = gui.scene().link(t.parent, t.getName(), r, n);
    e.saveData();
  };
};
Ops.Ui.PatchOutput.prototype = new CABLES.Op();
CABLES.OPS["851b44cb-5667-4140-9800-5aeb7031f1d7"] = {
  f: Ops.Ui.PatchOutput,
  objName: "Ops.Ui.PatchOutput",
};
Ops.Vars.VarSetNumber_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inValueFloat("Value", 0);
  e.varName = e.inDropDown("Variable", [], "", true);
  new CABLES.VarSetOpWrapper(e, "number", n, e.varName);
};
Ops.Vars.VarSetNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["b5249226-6095-4828-8a1c-080654e192fa"] = {
  f: Ops.Vars.VarSetNumber_v2,
  objName: "Ops.Vars.VarSetNumber_v2",
};
Ops.Vars.VarSetString_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inString("Value", "New String");
  e.varName = e.inDropDown("Variable", [], "", true);
  new CABLES.VarSetOpWrapper(e, "string", n, e.varName);
};
Ops.Vars.VarSetString_v2.prototype = new CABLES.Op();
CABLES.OPS["0b4d9229-8024-4a30-9cc0-f6653942c2e4"] = {
  f: Ops.Vars.VarSetString_v2,
  objName: "Ops.Vars.VarSetString_v2",
};
Ops.Cables.LoadingStatus_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const i = this;
  const e = (i.attachments = {});
  const t = i.inTrigger("exe"),
    r = i.inBool("Play Timeline", true),
    n = i.outTrigger("Next"),
    a = i.outBoolNum("Finished Initial Loading", false),
    s = i.outBoolNum("Loading"),
    o = i.outNumber("Progress"),
    l = i.outArray("Jobs"),
    u = i.outTrigger("Trigger Loading Finished ");
  const c = i.patch.cgl;
  const d = i.patch;
  let h = false;
  const p = [];
  let m = true;
  let f = 0;
  document.body.classList.add("cables-loading");
  let g = c.patch.loading.start("loadingStatusInit", "loadingStatusInit", i);
  i.patch.loading.on("finishedTask", b.bind(this));
  i.patch.loading.on("startTask", b.bind(this));
  function b() {
    const e = i.patch.loading.getListJobs();
    o.set(d.loading.getProgress());
    let t = e.length === 0;
    const n = !t;
    if (n) {
      l.set(i.patch.loading.getListJobs());
    }
    if (n) {
      if (m) {
        i.patch.timer.setTime(0);
        if (r.get()) {
          i.patch.timer.play();
        } else {
          i.patch.timer.pause();
        }
      }
      m = false;
      document.body.classList.remove("cables-loading");
      document.body.classList.add("cables-loaded");
    } else {
      h = true;
      l.set(i.patch.loading.getListJobs());
      if (d.loading.getProgress() < 1) {
        i.patch.timer.setTime(0);
        i.patch.timer.pause();
      }
    }
    a.set(h);
    if (s.get() && t) u.trigger();
    s.set(n);
    i.setUiAttribs({ loading: n });
  }
  t.onTriggered = () => {
    b();
    n.trigger();
    if (g) {
      c.patch.loading.finished(g);
      g = null;
    }
  };
};
Ops.Cables.LoadingStatus_v2.prototype = new CABLES.Op();
CABLES.OPS["e62f7f4c-7436-437e-8451-6bc3c28545f7"] = {
  f: Ops.Cables.LoadingStatus_v2,
  objName: "Ops.Cables.LoadingStatus_v2",
};
Ops.Gl.ClearColor = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inTrigger("render"),
    i = e.outTrigger("trigger"),
    r = e.inFloatSlider("r", 0.1),
    a = e.inFloatSlider("g", 0.1),
    s = e.inFloatSlider("b", 0.1),
    o = e.inFloatSlider("a", 1);
  r.setUiAttribs({ colorPick: true });
  const l = e.patch.cgl;
  n.onTriggered = function () {
    l.gl.clearColor(r.get(), a.get(), s.get(), o.get());
    l.gl.clear(l.gl.COLOR_BUFFER_BIT | l.gl.DEPTH_BUFFER_BIT);
    i.trigger();
  };
};
Ops.Gl.ClearColor.prototype = new CABLES.Op();
CABLES.OPS["19b441eb-9f63-4f35-ba08-b87841517c4d"] = {
  f: Ops.Gl.ClearColor,
  objName: "Ops.Gl.ClearColor",
};
Ops.Trigger.TriggerSend = function () {
  CABLES.Op.apply(this, arguments);
  const i = this;
  const e = (i.attachments = {});
  const t = i.inTriggerButton("Trigger");
  i.varName = i.inValueSelect("Named Trigger", [], "", true);
  i.varName.onChange = r;
  t.onTriggered = a;
  i.patch.addEventListener("namedTriggersChanged", n);
  n();
  i.varName.setUiAttribs({ _triggerSelect: true });
  function n() {
    if (CABLES.UI) {
      let e = [];
      const t = i.patch.namedTriggers;
      e.push("+ create new one");
      for (const n in t) e.push(n);
      e = e.sort();
      i.varName.uiAttribs.values = e;
    }
  }
  function r() {
    if (CABLES.UI) {
      if (i.varName.get() == "+ create new one") {
        new CABLES.UI.ModalDialog({
          prompt: true,
          title: "New Trigger",
          text: "Enter a name for the new trigger",
          promptValue: "",
          promptOk: (e) => {
            i.varName.set(e);
            i.patch.namedTriggers[e] = i.patch.namedTriggers[e] || [];
            n();
          },
        });
        return;
      }
      i.refreshParams();
    }
    if (!i.patch.namedTriggers[i.varName.get()]) {
      i.patch.namedTriggers[i.varName.get()] =
        i.patch.namedTriggers[i.varName.get()] || [];
      i.patch.emitEvent("namedTriggersChanged");
    }
    i.setTitle(">" + i.varName.get());
    i.refreshParams();
    i.patch.emitEvent("opTriggerNameChanged", i, i.varName.get());
  }
  function a() {
    const t = i.patch.namedTriggers[i.varName.get()];
    i.patch.emitEvent("namedTriggerSent", i.varName.get());
    if (!t) {
      i.setUiError("unknowntrigger", "unknown trigger");
      return;
    } else i.setUiError("unknowntrigger", null);
    for (let e = 0; e < t.length; e++) {
      t[e]();
    }
  }
};
Ops.Trigger.TriggerSend.prototype = new CABLES.Op();
CABLES.OPS["ce1eaf2b-943b-4dc0-ab5e-ee11b63c9ed0"] = {
  f: Ops.Trigger.TriggerSend,
  objName: "Ops.Trigger.TriggerSend",
};
Ops.Trigger.RouteTrigger = function () {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const e = (t.attachments = {});
  const n = 24;
  const i = t.inTriggerButton("Execute"),
    r = t.inValueInt("Switch Value"),
    a = t.outTrigger("Next Trigger"),
    s = t.outNumber("Switched Value");
  const o = [];
  i.onTriggered = c;
  for (let e = 0; e < n; e++) {
    o[e] = t.outTrigger("Trigger " + e);
    o[e].onLinkChanged = d;
  }
  const l = t.outTrigger("Default Trigger"),
    u = t.outNumber("Highest Index");
  function c() {
    const e = Math.round(r.get());
    if (e >= 0 && e < n) {
      s.set(e);
      o[e].trigger();
    } else {
      s.set(-1);
      l.trigger();
    }
    a.trigger();
  }
  function d() {
    let t = 0;
    for (let e = 0; e < o.length; e++) if (o[e] && o[e].isLinked()) t = e;
    u.set(t);
  }
};
Ops.Trigger.RouteTrigger.prototype = new CABLES.Op();
CABLES.OPS["44ceb5d8-b040-4722-b189-a6fb8172517d"] = {
  f: Ops.Trigger.RouteTrigger,
  objName: "Ops.Trigger.RouteTrigger",
};
Ops.Vars.VarGetNumber_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.outNumber("Value");
  e.varName = e.inValueSelect("Variable", [], "", true);
  new CABLES.VarGetOpWrapper(e, "number", e.varName, n);
};
Ops.Vars.VarGetNumber_v2.prototype = new CABLES.Op();
CABLES.OPS["421f5b52-c0fa-47c4-8b7a-012b9e1c864a"] = {
  f: Ops.Vars.VarGetNumber_v2,
  objName: "Ops.Vars.VarGetNumber_v2",
};
Ops.Vars.VarSetTexture_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inTexture("Value", null);
  e.varName = e.inDropDown("Variable", [], "", true);
  new CABLES.VarSetOpWrapper(e, "object", n, e.varName);
};
Ops.Vars.VarSetTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["4fbfc71e-1429-439f-8591-ad35961252ed"] = {
  f: Ops.Vars.VarSetTexture_v2,
  objName: "Ops.Vars.VarSetTexture_v2",
};
Ops.Gl.Performance = function () {
  CABLES.Op.apply(this, arguments);
  const s = this;
  const D = (s.attachments = {});
  const e = s.inTrigger("exe"),
    o = s.inValueBool("Active", true),
    l = s.inValueBool("Visible", true),
    R = s.inValueBool("Measure GPU", true),
    u = s.outTrigger("childs"),
    t = s.inSwitch("Position", ["top", "bottom"], "top"),
    n = s.inBool("Open", false),
    B = s.inBool("Smooth Graph", true),
    U = s.inFloat("Scale", 3),
    c = s.inFloat("Size", 128),
    V = s.outObject("Canvas"),
    F = s.outNumber("FPS");
  const i = s.patch.cgl;
  const r = document.createElement("div");
  let a = null;
  let d = null;
  let h = false;
  let p = 0;
  let m = 0;
  let f = 0;
  let g = 0;
  let b = 0;
  const v = [];
  const y = [];
  const _ = [];
  const T = [];
  let O = 0;
  let S = 0;
  let A = null;
  let G = 0;
  let q = 0;
  const w = ["|", "/", "-", "\\"];
  let C = true;
  const z = "#007f9c";
  const H = "#aaaaaa";
  const W = "#222222";
  const I = "#003f5c";
  const x = "#7a5195";
  const E = "#ef5675";
  const X = "#ffa600";
  let Y = false;
  let k = 0;
  let P = 0;
  let j = 0;
  s.toWorkPortsNeedToBeLinked(e, u);
  const K = s.patch.cgl.gl;
  const Q = K.getExtension("EXT_disjoint_timer_query_webgl2");
  o.onChange =
    e.onLinkChanged =
    l.onChange =
      () => {
        M();
        J();
      };
  t.onChange = Z;
  c.onChange = L;
  r.id = "performance";
  r.style.position = "absolute";
  r.style.left = "0px";
  r.style.opacity = "0.8";
  r.style.padding = "10px";
  r.style.cursor = "pointer";
  r.style.background = "#222";
  r.style.color = "white";
  r.style["font-family"] = "monospace";
  r.style["font-size"] = "12px";
  r.style["z-index"] = "99999";
  r.innerHTML = "&nbsp;";
  r.addEventListener("click", $);
  const N = s.patch.cgl.canvas.parentElement;
  N.appendChild(r);
  L();
  M();
  Z();
  J();
  s.onDelete = function () {
    if (A) A.remove();
    if (r) r.remove();
  };
  function Z() {
    A.style["pointer-events"] = "none";
    if (t.get() == "top") {
      A.style.top = r.style.top = "0px";
      A.style.bottom = r.style.bottom = "initial";
    } else {
      A.style.bottom = r.style.bottom = "0px";
      A.style.top = r.style.top = "initial";
    }
  }
  function J() {
    if (!l.get() || !e.isLinked() || !o.get()) {
      r.style.display = "none";
      r.style.opacity = 0;
      A.style.display = "none";
    } else {
      r.style.display = "block";
      r.style.opacity = 1;
      A.style.display = "block";
    }
  }
  function L() {
    if (!A) return;
    const t = Math.max(0, parseInt(c.get()));
    A.width = t;
    A.height = t;
    r.style.left = t + "px";
    v.length = 0;
    y.length = 0;
    _.length = 0;
    T.length = 0;
    for (let e = 0; e < t; e++) {
      v[e] = -1;
      y[e] = -1;
      _[e] = -1;
      T[e] = -1;
    }
  }
  n.onChange = function () {
    h = n.get();
    M();
  };
  function $() {
    if (!l.get()) return;
    r.style.opacity = 1;
    h = !h;
    M();
  }
  function M() {
    ne();
    if (!A) te();
    if (h) {
      A.style.display = "block";
      r.style.left = c.get() + "px";
      r.style["min-height"] = "56px";
    } else {
      A.style.display = "none";
      r.style.left = "0px";
      r.style["min-height"] = "auto";
    }
  }
  function ee() {
    const t = A.height;
    const n = U.get();
    d.fillStyle = W;
    d.fillRect(0, 0, A.width, t);
    d.fillStyle = I;
    let i = 0;
    const r = Math.max(0, parseInt(c.get()));
    for (i = r; i >= 0; i--) {
      if (v[i] > 30) d.fillStyle = z;
      if (v[i] > 60) d.fillStyle = H;
      d.fillRect(r - i, t - v[i] * n, 1, v[i] * n);
      if (v[i] > 30) d.fillStyle = I;
    }
    for (i = r; i >= 0; i--) {
      let e = 0;
      d.fillStyle = x;
      e = y[i];
      d.fillRect(r - i, t - e * n, 1, y[i] * n);
      d.fillStyle = E;
      e += _[i];
      d.fillRect(r - i, t - e * n, 1, _[i] * n);
      d.fillStyle = X;
      e += T[i];
      d.fillRect(r - i, t - e * n, 1, T[i] * n);
    }
    for (let e = 10; e < t; e += 10) {
      d.fillStyle = "#888";
      const a = t - e * n;
      d.fillRect(A.width - 5, a, 5, 1);
      d.font = "8px arial";
      d.fillText(e + "ms", A.width - 27, a + 3);
    }
    d.fillStyle = "#fff";
    d.fillRect(A.width - 5, t - (1e3 / m) * n, 5, 1);
    d.fillText(Math.round(1e3 / m) + "ms", A.width - 27, t - (1e3 / m) * n);
  }
  function te() {
    A = document.createElement("canvas");
    A.id = "performance_" + s.patch.config.glCanvasId;
    A.width = c.get();
    A.height = c.get();
    A.style.display = "block";
    A.style.opacity = 0.9;
    A.style.position = "absolute";
    A.style.left = "0px";
    A.style.cursor = "pointer";
    A.style.top = "-64px";
    A.style["z-index"] = "99998";
    N.appendChild(A);
    d = A.getContext("2d");
    A.addEventListener("click", $);
    L();
  }
  function ne() {
    if (!l.get()) return;
    let e = "";
    if (s.patch.cgl.profileData.profileShaderCompiles > 0)
      e +=
        "Shader compile (" +
        s.patch.cgl.profileData.profileShaderCompileName +
        ") ";
    if (s.patch.cgl.profileData.profileShaderGetUniform > 0)
      e +=
        "Shader get uni loc! (" +
        s.patch.cgl.profileData.profileShaderGetUniformName +
        ")";
    if (s.patch.cgl.profileData.profileTextureResize > 0)
      e += "Texture resize! ";
    if (s.patch.cgl.profileData.profileFrameBuffercreate > 0)
      e += "Framebuffer create! ";
    if (s.patch.cgl.profileData.profileEffectBuffercreate > 0)
      e += "Effectbuffer create! ";
    if (s.patch.cgl.profileData.profileTextureDelete > 0)
      e += "Texture delete! ";
    if (s.patch.cgl.profileData.profileNonTypedAttrib > 0)
      e +=
        "Not-Typed Buffer Attrib! " +
        s.patch.cgl.profileData.profileNonTypedAttribNames;
    if (s.patch.cgl.profileData.profileTextureNew > 0)
      e += "new texture created! ";
    if (s.patch.cgl.profileData.profileGenMipMap > 0)
      e += "generating mip maps!";
    if (e.length > 0) {
      e = '| <span style="color:#f80;">WARNING: ' + e + "<span>";
    }
    let t = "";
    if (h) {
      t += '<span style="color:' + I + '">■</span> ' + m + " fps ";
      t +=
        '<span style="color:' +
        x +
        '">■</span> ' +
        Math.round(P * 100) / 100 +
        "ms mainloop ";
      t +=
        '<span style="color:' +
        E +
        '">■</span> ' +
        Math.round(j * 100) / 100 +
        "ms onframe ";
      if (k)
        t +=
          '<span style="color:' +
          X +
          '">■</span> ' +
          Math.round(k * 100) / 100 +
          "ms GPU";
      t += e;
      r.innerHTML = t;
    } else {
      t += m + " fps / ";
      t +=
        "CPU: " +
        Math.round(s.patch.cgl.profileData.profileOnAnimFrameOps * 100) / 100 +
        "ms / ";
      if (k) t += "GPU: " + Math.round(k * 100) / 100 + "ms  ";
      r.innerHTML = t;
    }
    if (s.patch.loading.getProgress() != 1) {
      r.innerHTML +=
        "<br/>loading " +
        Math.round(s.patch.loading.getProgress() * 100) +
        "% " +
        w[++q % w.length];
    }
    if (h) {
      let t = 0;
      O = 0;
      b = 0;
      for (let e = v.length; e > v.length - v.length / 3; e--) {
        if (v[e] > -1) {
          O += v[e];
          t++;
        }
        if (y[e] > -1) b += y[e];
      }
      O /= t;
      b /= t;
      r.innerHTML +=
        "<br/> " +
        i.canvasWidth +
        " x " +
        i.canvasHeight +
        " (x" +
        i.pixelDensity +
        ") ";
      r.innerHTML +=
        "<br/>frame avg: " +
        Math.round(b * 100) / 100 +
        " ms (" +
        Math.round((b / O) * 100) +
        "%) / " +
        Math.round(O * 100) / 100 +
        " ms";
      r.innerHTML += " (self: " + Math.round(S * 100) / 100 + " ms) ";
      r.innerHTML +=
        "<br/>shader binds: " +
        Math.ceil(s.patch.cgl.profileData.profileShaderBinds / m) +
        " uniforms: " +
        Math.ceil(s.patch.cgl.profileData.profileUniformCount / m) +
        " mvp_uni_mat4: " +
        Math.ceil(s.patch.cgl.profileData.profileMVPMatrixCount / m) +
        " num glPrimitives: " +
        Math.ceil(s.patch.cgl.profileData.profileMeshNumElements / m) +
        " fenced pixelread: " +
        Math.ceil(s.patch.cgl.profileData.profileFencedPixelRead) +
        " mesh.setGeom: " +
        s.patch.cgl.profileData.profileMeshSetGeom +
        " videos: " +
        s.patch.cgl.profileData.profileVideosPlaying +
        " tex preview: " +
        s.patch.cgl.profileData.profileTexPreviews;
      r.innerHTML +=
        " draw meshes: " +
        Math.ceil(s.patch.cgl.profileData.profileMeshDraw / m) +
        " framebuffer blit: " +
        Math.ceil(s.patch.cgl.profileData.profileFramebuffer / m) +
        " texeffect blit: " +
        Math.ceil(s.patch.cgl.profileData.profileTextureEffect / m);
      r.innerHTML +=
        " all shader compiletime: " +
        Math.round(s.patch.cgl.profileData.shaderCompileTime * 100) / 100;
    }
    s.patch.cgl.profileData.clear();
  }
  function ie(e) {
    e.style.padding = "0px";
    e.style.margin = "0px";
  }
  function re(t, e, n, i) {
    const r = 20;
    t.usedAvg = t.usedAvg || t.used;
    if (!t.ele || C) {
      const s = document.createElement("div");
      t.ele = s;
      if (t.childs && t.childs.length > 0) s.style.height = "500px";
      else s.style.height = r + "px";
      s.style.overflow = "hidden";
      s.style.display = "inline-block";
      if (!t.isRoot) {
        s.innerHTML =
          '<div style="min-height:' +
          r +
          'px;width:100%;overflow:hidden;color:black;position:relative">&nbsp;' +
          t.name +
          "</div>";
        s.style["background-color"] =
          "rgb(" + t.colR + "," + t.colG + "," + t.colB + ")";
        s.style["border-left"] = "1px solid black";
      }
      e.appendChild(s);
    }
    if (!t.isRoot) {
      if (performance.now() - t.lastTime > 200) {
        t.ele.style.display = "none";
        t.hidden = true;
      } else {
        if (t.hidden) {
          t.ele.style.display = "inline-block";
          t.hidden = false;
        }
      }
      t.ele.style.float = "left";
      t.ele.style.width = Math.floor((t.usedAvg / n) * 98) + "%";
    } else {
      t.ele.style.width = "100%";
      t.ele.style.clear = "both";
      t.ele.style.float = "none";
    }
    if (t && t.childs && t.childs.length > 0) {
      let e = 0;
      for (var a = 0; a < t.childs.length; a++) {
        t.childs[a].usedAvg =
          (t.childs[a].usedAvg || t.childs[a].used) * 0.95 +
          t.childs[a].used * 0.05;
        e += t.childs[a].usedAvg;
      }
      for (var a = 0; a < t.childs.length; a++) {
        re(t.childs[a], t.ele, e, i + 1);
      }
    }
  }
  function ae(t) {
    for (let e = 0; e < t.childs.length; e++) ae(t.childs[e]);
    t.childs.length = 0;
  }
  function se() {
    if (!CGL.performanceMeasures) return;
    if (!a) {
      s.log("create measure ele");
      a = document.createElement("div");
      a.style.width = "100%";
      a.style["background-color"] = "#444";
      a.style.bottom = "10px";
      a.style.height = "100px";
      a.style.opacity = "1";
      a.style.position = "absolute";
      a.style["z-index"] = "99999";
      a.innerHTML = "";
      N.appendChild(a);
    }
    let t = 0;
    const n = CGL.performanceMeasures[0];
    for (let e = 0; e < n.childs.length; e++) t += n.childs[e].used;
    re(CGL.performanceMeasures[0], a, t, 0);
    n.childs.length = 0;
    ae(CGL.performanceMeasures[0]);
    CGL.performanceMeasures.length = 0;
    C = false;
  }
  e.onTriggered = oe;
  function oe() {
    const e = performance.now();
    if (o.get()) {
      p++;
      if (Q && R.get() && l.get())
        s.patch.cgl.profileData.doProfileGlQuery = true;
      else s.patch.cgl.profileData.doProfileGlQuery = false;
      if (f === 0) f = Date.now();
      if (Date.now() - f >= 1e3) {
        m = p;
        p = 0;
        F.set(m);
        if (l.get()) ne();
        f = Date.now();
      }
      const n = s.patch.cgl.profileData.glQueryData;
      k = 0;
      if (n) {
        let t = 0;
        for (let e in n) {
          t++;
          if (n[e].time) k += n[e].time;
        }
      }
      if (l.get()) {
        se();
        if (h && !s.patch.cgl.profileData.pause) {
          v.push(s.patch.cgl.profileData.profileFrameDelta);
          v.shift();
          y.push(g);
          y.shift();
          _.push(
            s.patch.cgl.profileData.profileOnAnimFrameOps -
              s.patch.cgl.profileData.profileMainloopMs
          );
          _.shift();
          T.push(k);
          T.shift();
          ee();
        }
      }
      G = performance.now();
      S = performance.now() - e;
      V.setRef(A);
    }
    const t = performance.now();
    u.trigger();
    if (o.get()) {
      const i = performance.now() - t;
      const r = s.patch.cgl.profileData.profileMainloopMs;
      const a =
        s.patch.cgl.profileData.profileOnAnimFrameOps -
        s.patch.cgl.profileData.profileMainloopMs;
      if (B.get()) {
        g = g * 0.9 + i * 0.1;
        P = P * 0.5 + r * 0.5;
        j = j * 0.5 + a * 0.5;
      } else {
        g = i;
        P = r;
        j = a;
      }
      s.patch.cgl.profileData.clearGlQuery();
    }
  }
};
Ops.Gl.Performance.prototype = new CABLES.Op();
CABLES.OPS["9cd2d9de-000f-4a14-bd13-e7d5f057583c"] = {
  f: Ops.Gl.Performance,
  objName: "Ops.Gl.Performance",
};
Ops.String.String_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inString("value", ""),
    i = e.outString("String");
  n.onChange = function () {
    if (!n.isLinked()) e.setUiAttrib({ extendTitle: n.get() });
    i.set(n.get());
  };
};
Ops.String.String_v2.prototype = new CABLES.Op();
CABLES.OPS["d697ff82-74fd-4f31-8f54-295bc64e713d"] = {
  f: Ops.String.String_v2,
  objName: "Ops.String.String_v2",
};
Ops.Color.ColorValue = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inValueSlider("r", Math.random());
  const i = e.inValueSlider("g", Math.random());
  const r = e.inValueSlider("b", Math.random());
  n.setUiAttribs({ colorPick: true });
  const a = e.inValueSlider("a", 1);
  const s = e.outNumber("outr");
  const o = e.outNumber("outg");
  const l = e.outNumber("outb");
  const u = e.outNumber("outa");
  const c = e.outNumber("Hex", "000000");
  const d = e.outArray("Array");
  n.onChange = i.onChange = r.onChange = a.onChange = p;
  function h(e) {
    let t = Math.round(e * 255).toString(16);
    if (t.length === 1) {
      t = "0" + t;
    }
    return t.toUpperCase();
  }
  function p() {
    s.set(n.get());
    o.set(i.get());
    l.set(r.get());
    u.set(a.get());
    let e = h(n.get()) + h(i.get()) + h(r.get());
    c.set(e);
    d.set([n.get(), i.get(), r.get(), a.get()]);
  }
  p();
};
Ops.Color.ColorValue.prototype = new CABLES.Op();
CABLES.OPS["7caa37c8-f2a7-49f2-a29c-96af362abca0"] = {
  f: Ops.Color.ColorValue,
  objName: "Ops.Color.ColorValue",
};
Ops.Trigger.RouteTriggerString_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const e = (t.attachments = {});
  const n = 24,
    i = t.inTriggerButton("Execute"),
    r = t.inString("Switch Value"),
    a = t.outTrigger("Next Trigger"),
    s = t.outNumber("Switched Index");
  let o = -1;
  const l = [];
  const u = [];
  for (let e = 0; e < n; e++) {
    l[e] = t.outTrigger("Trigger " + e);
    u[e] = t.inString("String " + e);
    u[e].onChange = c;
  }
  t.onLoad = t.onInit = r.onChange = c;
  function c() {
    o = -1;
    for (let e = 0; e < u.length; e++) {
      if (u[e].get() == r.get()) {
        o = e;
        break;
      }
    }
  }
  i.onTriggered = () => {
    if (o >= 0) l[o].trigger();
    s.set(o);
    a.trigger();
  };
};
Ops.Trigger.RouteTriggerString_v2.prototype = new CABLES.Op();
CABLES.OPS["13bdac27-5da7-4311-890b-6a7e49d72040"] = {
  f: Ops.Trigger.RouteTriggerString_v2,
  objName: "Ops.Trigger.RouteTriggerString_v2",
};
Ops.Html.FontFile_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const r = this;
  const e = (r.attachments = {});
  const a = r.inUrl("file", [".otf", ".ttf", ".woff", ".woff2"]),
    s = r.inString("family"),
    o = r.inBool("Active", true),
    l = r.outBoolNum("Loaded"),
    u = r.outTrigger("Loaded Trigger");
  let c = null;
  let d;
  let h = null;
  let t = null;
  let p = null;
  let m = "";
  a.onChange = function () {
    l.set(false);
    i(null);
  };
  o.onChange = s.onChange = () => {
    n();
  };
  function n() {
    clearTimeout(t);
    t = setTimeout(() => {
      i(null);
    }, 50);
  }
  r.patch.on("windowChanged", (e) => {
    d = null;
    i(e.document);
  });
  function i(e) {
    if (p) p.remove();
    if (d) {
      const t = h.fonts.delete(d);
      d = null;
      setTimeout(() => {
        r.patch.emitEvent("fontLoaded", m);
      }, 100);
    }
    if (!o.get()) return;
    h = e || h || r.patch.cgl.canvas.ownerDocument || document;
    if (c) c = r.patch.cgl.patch.loading.finished(c);
    r.setUiError("loadingerror", null);
    m = s.get();
    if (a.get() && s.get()) {
      if (h.fonts) {
        let e = "url(" + r.patch.getFilePath(String(a.get())) + ")";
        d = new FontFace(s.get(), e);
        c = r.patch.cgl.patch.loading.start("FontFile", a.get(), r);
        h.fonts.add(d);
        d.loaded
          .then(
            (e) => {
              l.set(true);
              u.trigger();
              c = r.patch.cgl.patch.loading.finished(c);
              r.patch.emitEvent("fontLoaded", s.get());
            },
            (e) => {
              r.setUiError(
                "loadingerror",
                "Font loading error: " + d.status + "(" + a.get() + ")"
              );
              c = r.patch.cgl.patch.loading.finished(c);
              l.set(true);
            }
          )
          .catch((e) => {
            c = r.patch.cgl.patch.loading.finished(c);
            console.error("catch ", e);
          });
        d.load();
      } else {
        const n = r.patch.getFilePath(String(a.get()));
        const i =
          "".endl() +
          "@font-face".endl() +
          "{".endl() +
          '  font-family: "' +
          s.get() +
          '";'.endl() +
          '  src: url("' +
          n +
          '") format("truetype");'.endl() +
          "}";
        p = document.createElement("style");
        p.classList.add("cablesEle");
        p.type = "text/css";
        p.innerHTML = i;
        document
          .getElementsByTagName("head")
          [document.getElementsByTagName("head").length - 1].appendChild(p);
      }
    }
  }
};
Ops.Html.FontFile_v2.prototype = new CABLES.Op();
CABLES.OPS["68177370-116e-4c76-aef3-3b10d68e7227"] = {
  f: Ops.Html.FontFile_v2,
  objName: "Ops.Html.FontFile_v2",
};
Ops.Gl.Texture_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const r = this;
  const e = (r.attachments = {});
  const a = r.inUrl("File", [".jpg", ".png", ".webp", ".jpeg", ".avif"]),
    t = r.inSwitch("Filter", ["nearest", "linear", "mipmap"]),
    n = r.inValueSelect(
      "Wrap",
      ["repeat", "mirrored repeat", "clamp to edge"],
      "clamp to edge"
    ),
    i = r.inSwitch("Anisotropic", ["0", "1", "2", "4", "8", "16"], "0"),
    s = r.inSwitch("Data Format", ["R", "RG", "RGB", "RGBA", "SRGBA"], "RGBA"),
    o = r.inValueBool("Flip", false),
    l = r.inValueBool("Pre Multiplied Alpha", false),
    u = r.inValueBool("Active", true),
    c = r.inBool("Save Memory", true),
    d = r.outTexture("Texture"),
    h = r.inBool("Add Cachebuster", false),
    p = r.inTriggerButton("Reload"),
    m = r.outNumber("Width"),
    f = r.outNumber("Height"),
    g = r.outNumber("Aspect Ratio"),
    b = r.outBoolNum("Loaded", 0),
    v = r.outBoolNum("Loading", 0);
  const y = r.patch.cgl;
  r.toWorkPortsNeedToBeLinked(d);
  r.setPortGroup("Size", [m, f]);
  let _ = null;
  let T = null;
  let O = null;
  let S = CGL.Texture.FILTER_MIPMAP;
  let A = CGL.Texture.WRAP_REPEAT;
  let w = 0;
  let C = 0;
  l.setUiAttribs({ hidePort: true });
  l.onChange = a.onChange = s.onChange = h.onChange = o.onChange = x;
  i.onChange = t.onChange = P;
  n.onChange = j;
  t.set("mipmap");
  n.set("repeat");
  d.setRef(CGL.Texture.getEmptyTexture(y));
  p.onTriggered = x;
  u.onChange = function () {
    if (u.get()) {
      if (_ != a.get() || !O) x();
      else d.setRef(O);
    } else {
      d.setRef(CGL.Texture.getEmptyTexture(y));
      m.set(CGL.Texture.getEmptyTexture(y).width);
      f.set(CGL.Texture.getEmptyTexture(y).height);
      if (O) O.delete();
      r.setUiAttrib({ extendTitle: "" });
      O = null;
    }
  };
  const I = function () {
    const e = CGL.Texture.getTempTexture(y);
    d.setRef(e);
  };
  function x(e) {
    clearTimeout(C);
    C = setTimeout(function () {
      k(e);
    }, 1);
  }
  function E() {
    if (s.get() == "R") return CGL.Texture.PFORMATSTR_R8UB;
    if (s.get() == "RG") return CGL.Texture.PFORMATSTR_RG8UB;
    if (s.get() == "RGB") return CGL.Texture.PFORMATSTR_RGB8UB;
    if (s.get() == "SRGBA") return CGL.Texture.PFORMATSTR_SRGBA8;
    return CGL.Texture.PFORMATSTR_RGBA8UB;
  }
  function k(e) {
    r.checkMainloopExists();
    if (!u.get()) return;
    if (T) T = y.patch.loading.finished(T);
    T = y.patch.loading.start(r.objName, a.get(), r);
    let t = r.patch.getFilePath(String(a.get()));
    if (h.get() || e === true) t = CABLES.cacheBust(t);
    if (String(a.get()).indexOf("data:") == 0) t = a.get();
    let n = false;
    _ = a.get();
    if (a.get() && a.get().length > 1) {
      b.set(false);
      v.set(true);
      const i = a.get();
      r.setUiAttrib({ extendTitle: CABLES.basename(t) });
      if (n) r.refreshParams();
      y.patch.loading.addAssetLoadingTask(() => {
        r.setUiError("urlerror", null);
        CGL.Texture.load(
          y,
          t,
          function (e, t) {
            y.checkFrameStarted("texture inittexture");
            if (a.get() != i) {
              T = y.patch.loading.finished(T);
              return;
            }
            if (O) O.delete();
            if (e) {
              const n = CGL.Texture.getErrorTexture(y);
              d.setRef(n);
              r.setUiError(
                "urlerror",
                'could not load texture: "' + a.get() + '"',
                2
              );
              T = y.patch.loading.finished(T);
              return;
            }
            m.set(t.width);
            f.set(t.height);
            g.set(t.width / t.height);
            O = t;
            d.setRef(O);
            v.set(false);
            b.set(true);
            if (c.get()) O.image = null;
            if (T) {
              T = y.patch.loading.finished(T);
            }
            r.checkMainloopExists();
          },
          {
            anisotropic: w,
            wrap: A,
            flip: o.get(),
            unpackAlpha: l.get(),
            pixelFormat: E(),
            filter: S,
          }
        );
        r.checkMainloopExists();
      });
    } else {
      I();
      T = y.patch.loading.finished(T);
    }
  }
  function P() {
    if (t.get() == "nearest") S = CGL.Texture.FILTER_NEAREST;
    else if (t.get() == "linear") S = CGL.Texture.FILTER_LINEAR;
    else if (t.get() == "mipmap") S = CGL.Texture.FILTER_MIPMAP;
    else if (t.get() == "Anisotropic") S = CGL.Texture.FILTER_ANISOTROPIC;
    i.setUiAttribs({ greyout: S != CGL.Texture.FILTER_MIPMAP });
    w = parseFloat(i.get());
    x();
  }
  function j() {
    if (n.get() == "repeat") A = CGL.Texture.WRAP_REPEAT;
    if (n.get() == "mirrored repeat") A = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (n.get() == "clamp to edge") A = CGL.Texture.WRAP_CLAMP_TO_EDGE;
    x();
  }
  r.onFileChanged = function (e) {
    if (a.get() && a.get().indexOf(e) > -1) {
      d.setRef(CGL.Texture.getEmptyTexture(r.patch.cgl));
      d.setRef(CGL.Texture.getTempTexture(y));
      k(true);
    }
  };
};
Ops.Gl.Texture_v2.prototype = new CABLES.Op();
CABLES.OPS["790f3702-9833-464e-8e37-6f0f813f7e16"] = {
  f: Ops.Gl.Texture_v2,
  objName: "Ops.Gl.Texture_v2",
};
Ops.Gl.Textures.SwitchTextures_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const e = (t.attachments = {});
  const n = t.inTrigger("exec"),
    i = this.inValueInt("num"),
    r = t.inValueBool("Default Texture Transparent", true),
    a = t.outTrigger("Next"),
    s = this.outTexture("texture");
  const o = t.patch.cgl;
  const l = [];
  let u = 0;
  let c = -1;
  let d = CGL.Texture.getEmptyTexture(o);
  t.toWorkPortsNeedToBeLinked(n);
  n.onTriggered = function () {
    p();
    a.trigger();
  };
  r.onChange = function () {
    if (r.get()) d = CGL.Texture.getEmptyTexture(o);
    else d = CGL.Texture.getTempTexture(o);
    p(true);
  };
  for (let e = 0; e < 16; e++) {
    const m = t.inTexture("texture" + e);
    l.push(m);
    m.onChange = h;
  }
  function h() {
    p(true);
  }
  function p(e) {
    u = parseInt(i.get(), 10);
    if (!e) {
      if (u == c) return;
      if (u != u) return;
    }
    if (isNaN(u) || u < 0 || u > l.length - 1) u = 0;
    if (l[u].get()) s.setRef(l[u].get());
    else s.setRef(d);
    c = u;
  }
};
Ops.Gl.Textures.SwitchTextures_v2.prototype = new CABLES.Op();
CABLES.OPS["a82ae429-ac07-4760-882b-595a857c7ae0"] = {
  f: Ops.Gl.Textures.SwitchTextures_v2,
  objName: "Ops.Gl.Textures.SwitchTextures_v2",
};
Ops.Number.Number = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inValueFloat("value"),
    i = e.outNumber("result");
  n.onChange = r;
  function r() {
    i.set(Number(n.get()));
  }
};
Ops.Number.Number.prototype = new CABLES.Op();
CABLES.OPS["8fb2bb5d-665a-4d0a-8079-12710ae453be"] = {
  f: Ops.Number.Number,
  objName: "Ops.Number.Number",
};
Ops.Boolean.ToggleBool_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inTriggerButton("trigger"),
    i = e.inTriggerButton("reset"),
    r = e.inBool("Default", false),
    a = e.outTrigger("Next"),
    s = e.outBoolNum("result");
  let o = false;
  e.onLoadedValueSet = () => {
    o = r.get();
    s.set(r.get());
    a.trigger();
  };
  n.onTriggered = function () {
    o = !o;
    s.set(o);
    a.trigger();
  };
  i.onTriggered = function () {
    o = r.get();
    s.set(o);
    a.trigger();
  };
};
Ops.Boolean.ToggleBool_v2.prototype = new CABLES.Op();
CABLES.OPS["4313d9bb-96b6-43bc-9190-6068cfb2593c"] = {
  f: Ops.Boolean.ToggleBool_v2,
  objName: "Ops.Boolean.ToggleBool_v2",
};
Ops.Trigger.GateTrigger = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inTrigger("Execute"),
    i = e.inValueBool("Pass Through", true),
    r = e.outTrigger("Trigger out");
  n.onTriggered = function () {
    if (i.get()) r.trigger();
  };
};
Ops.Trigger.GateTrigger.prototype = new CABLES.Op();
CABLES.OPS["65e8b8a2-ba13-485f-883a-2bcf377989da"] = {
  f: Ops.Trigger.GateTrigger,
  objName: "Ops.Trigger.GateTrigger",
};
Ops.String.StringContains_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inString("String"),
    i = e.inString("SearchValue"),
    r = e.outBoolNum("Found", false),
    a = e.outNumber("Index", -1);
  i.onChange = n.onChange = s;
  s();
  function s() {
    if (n.get() && i.get() && i.get().length > 0) {
      const e = n.get().indexOf(i.get());
      a.set(e);
      r.set(e > -1);
    } else {
      a.set(-1);
      r.set(false);
    }
  }
};
Ops.String.StringContains_v2.prototype = new CABLES.Op();
CABLES.OPS["2ca3e5d7-e6b4-46a7-8381-3fe1ad8b6879"] = {
  f: Ops.String.StringContains_v2,
  objName: "Ops.String.StringContains_v2",
};
Ops.Boolean.Or = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inValueBool("bool 1"),
    i = e.inValueBool("bool 2"),
    r = e.inValueBool("bool 3"),
    a = e.inValueBool("bool 4"),
    s = e.inValueBool("bool 5"),
    o = e.inValueBool("bool 6"),
    l = e.inValueBool("bool 7"),
    u = e.inValueBool("bool 8"),
    c = e.inValueBool("bool 9"),
    d = e.inValueBool("bool 10"),
    h = e.outBoolNum("result");
  n.onChange =
    i.onChange =
    r.onChange =
    a.onChange =
    s.onChange =
    o.onChange =
    l.onChange =
    u.onChange =
    c.onChange =
    d.onChange =
      p;
  function p() {
    h.set(
      n.get() ||
        i.get() ||
        r.get() ||
        a.get() ||
        s.get() ||
        o.get() ||
        l.get() ||
        u.get() ||
        c.get() ||
        d.get()
    );
  }
};
Ops.Boolean.Or.prototype = new CABLES.Op();
CABLES.OPS["b3b36238-4592-4e11-afe3-8361c4fd6be5"] = {
  f: Ops.Boolean.Or,
  objName: "Ops.Boolean.Or",
};
Ops.Extension.Deprecated.ToggleBoolValue = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inValueBool("in bool"),
    i = e.outBoolNum("out bool");
  n.changeAlways = true;
  n.onChange = function () {
    i.set(!(n.get() == true));
  };
};
Ops.Extension.Deprecated.ToggleBoolValue.prototype = new CABLES.Op();
CABLES.OPS["7b1abd02-3aad-4106-9848-7f4c3cfab6a9"] = {
  f: Ops.Extension.Deprecated.ToggleBoolValue,
  objName: "Ops.Extension.Deprecated.ToggleBoolValue",
};
Ops.Boolean.TriggerChangedFalse = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  let n = e.inValueBool("Value", false);
  let i = e.outTrigger("Next");
  let r = 0;
  n.onChange = function () {
    let e = n.get();
    if (r && !e) {
      r = false;
      i.trigger();
    } else {
      r = true;
    }
  };
};
Ops.Boolean.TriggerChangedFalse.prototype = new CABLES.Op();
CABLES.OPS["6387bcb0-6091-4199-8ab7-f96ad4aa3c7d"] = {
  f: Ops.Boolean.TriggerChangedFalse,
  objName: "Ops.Boolean.TriggerChangedFalse",
};
Ops.Boolean.TriggerChangedTrue = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  let n = e.inValueBool("Value", false);
  let i = e.outTrigger("Next");
  let r = 0;
  n.onChange = function () {
    let e = n.get();
    if (!r && e) {
      r = true;
      i.trigger();
    } else {
      r = false;
    }
  };
};
Ops.Boolean.TriggerChangedTrue.prototype = new CABLES.Op();
CABLES.OPS["385197e1-8b34-4d1c-897f-d1386d99e3b3"] = {
  f: Ops.Boolean.TriggerChangedTrue,
  objName: "Ops.Boolean.TriggerChangedTrue",
};
Ops.Trigger.DelayedTrigger = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inTrigger("exe"),
    i = e.inValueFloat("delay", 1),
    r = e.inTriggerButton("Cancel"),
    a = e.outTrigger("next"),
    s = e.outBool("Delaying");
  let o = null;
  r.onTriggered = function () {
    if (o) clearTimeout(o);
    o = null;
  };
  n.onTriggered = function () {
    s.set(true);
    if (o) clearTimeout(o);
    o = setTimeout(function () {
      s.set(false);
      o = null;
      a.trigger();
    }, i.get() * 1e3);
  };
};
Ops.Trigger.DelayedTrigger.prototype = new CABLES.Op();
CABLES.OPS["f4ff66b0-8500-46f7-9117-832aea0c2750"] = {
  f: Ops.Trigger.DelayedTrigger,
  objName: "Ops.Trigger.DelayedTrigger",
};
Ops.Math.Divide = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inValueFloat("number1", 1),
    i = e.inValueFloat("number2", 2),
    r = e.outNumber("result");
  e.setUiAttribs({ mathTitle: true });
  n.onChange = i.onChange = a;
  a();
  function a() {
    r.set(n.get() / i.get());
  }
};
Ops.Math.Divide.prototype = new CABLES.Op();
CABLES.OPS["86fcfd8c-038d-4b91-9820-a08114f6b7eb"] = {
  f: Ops.Math.Divide,
  objName: "Ops.Math.Divide",
};
Ops.Math.Subtract = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inValue("number1", 1),
    i = e.inValue("number2", 1),
    r = e.outNumber("result");
  e.setUiAttribs({ mathTitle: true });
  n.onChange = i.onChange = a;
  a();
  function a() {
    let e = n.get() - i.get();
    if (!isNaN(e)) r.set(e);
  }
};
Ops.Math.Subtract.prototype = new CABLES.Op();
CABLES.OPS["a4ffe852-d200-4b96-9347-68feb01122ca"] = {
  f: Ops.Math.Subtract,
  objName: "Ops.Math.Subtract",
};
Ops.Trigger.NumberByTrigger = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inTriggerButton("0"),
    i = e.inTriggerButton("1"),
    r = e.inTriggerButton("2"),
    a = e.inTriggerButton("3"),
    s = e.inTriggerButton("4"),
    o = e.inTriggerButton("5"),
    l = e.inTriggerButton("6"),
    u = e.inTriggerButton("7"),
    c = e.outNumber("number");
  c.changeAlways = true;
  const d = e.outTrigger("Triggered");
  n.onTriggered = function () {
    c.set(0);
    d.trigger();
  };
  i.onTriggered = function () {
    c.set(1);
    d.trigger();
  };
  r.onTriggered = function () {
    c.set(2);
    d.trigger();
  };
  a.onTriggered = function () {
    c.set(3);
    d.trigger();
  };
  s.onTriggered = function () {
    c.set(4);
    d.trigger();
  };
  o.onTriggered = function () {
    c.set(5);
    d.trigger();
  };
  l.onTriggered = function () {
    c.set(6);
    d.trigger();
  };
  u.onTriggered = function () {
    c.set(7);
    d.trigger();
  };
};
Ops.Trigger.NumberByTrigger.prototype = new CABLES.Op();
CABLES.OPS["43ed1123-1312-4383-b843-27b8ec540c09"] = {
  f: Ops.Trigger.NumberByTrigger,
  objName: "Ops.Trigger.NumberByTrigger",
};
Ops.Trigger.TriggerReceive = function () {
  CABLES.Op.apply(this, arguments);
  const i = this;
  const e = (i.attachments = {});
  const t = i.outTrigger("Triggered");
  i.varName = i.inValueSelect("Named Trigger", [], "", true);
  i.varName.setUiAttribs({ _triggerSelect: true });
  a();
  i.patch.addEventListener("namedTriggersChanged", a);
  let n = null;
  function r() {
    t.trigger();
  }
  function a() {
    if (CABLES.UI) {
      let t = [];
      let n = i.patch.namedTriggers;
      for (let e in n) t.push(e);
      t = t.sort();
      i.varName.uiAttribs.values = t;
    }
  }
  i.varName.onChange = function () {
    if (n) {
      let e = i.patch.namedTriggers[n];
      let t = e.indexOf(r);
      if (t != -1) e.splice(t, 1);
    }
    i.setTitle(">" + i.varName.get());
    i.patch.namedTriggers[i.varName.get()] =
      i.patch.namedTriggers[i.varName.get()] || [];
    let e = i.patch.namedTriggers[i.varName.get()];
    e.push(r);
    n = i.varName.get();
    s();
    i.patch.emitEvent("opTriggerNameChanged", i, i.varName.get());
  };
  i.on("uiParamPanel", s);
  function s() {
    if (!i.varName.get()) {
      i.setUiError("unknowntrigger", "unknown trigger");
    } else i.setUiError("unknowntrigger", null);
  }
};
Ops.Trigger.TriggerReceive.prototype = new CABLES.Op();
CABLES.OPS["0816c999-f2db-466b-9777-2814573574c5"] = {
  f: Ops.Trigger.TriggerReceive,
  objName: "Ops.Trigger.TriggerReceive",
};
Ops.Gl.Shader.CustomShader_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const b = this;
  const e = (b.attachments = {});
  const t = b.inTrigger("render"),
    n = b.inStringEditor("Fragment Code"),
    i = b.inStringEditor("Vertex Code"),
    r = b.inValueBool("Use As Material", true),
    a = b.outTrigger("trigger"),
    s = b.outObject("Shader", null, "shader"),
    o = b.outBool("Has Errors");
  const v = 7;
  const y = b.patch.cgl;
  const _ = [];
  const T = [];
  const O = [];
  b.toWorkPortsNeedToBeLinked(t);
  n.setUiAttribs({ editorSyntax: "glsl" });
  i.setUiAttribs({ editorSyntax: "glsl" });
  const S = new CGL.Shader(y, "customshader", b);
  S.setModules([
    "MODULE_VERTEX_POSITION",
    "MODULE_COLOR",
    "MODULE_BEGIN_FRAG",
    "MODULE_VERTEX_MODELVIEW",
  ]);
  b.setPortGroup("Source Code", [n, i]);
  b.setPortGroup("Options", [r]);
  n.set(CGL.Shader.getDefaultFragmentShader());
  i.set(CGL.Shader.getDefaultVertexShader());
  n.onChange = i.onChange = function () {
    if (n.isLinked() && !n.get()) return;
    u = true;
  };
  t.onTriggered = d;
  let l = 0;
  let u = true;
  b.onLoadedValueSet = c;
  function c(n) {
    g();
    if (!n) return;
    for (let t = 0; t < _.length; t++)
      for (let e = 0; e < n.portsIn.length; e++)
        if (_[t] && _[t].name == n.portsIn[e].name) {
          _[t].set(n.portsIn[e].value);
          _[t].deSerializeSettings(n.portsIn[e]);
        }
  }
  b.init = function () {
    g();
  };
  function d() {
    E();
    if (u) g();
    if (r.get()) y.pushShader(S);
    h();
    a.trigger();
    S.popTextures();
    if (r.get()) y.popShader();
  }
  function h() {
    for (let e = 0; e < T.length; e++)
      if (T[e] && T[e].get() && T[e].get().tex)
        S.pushTexture(T[e].uniform, T[e].get().tex);
      else S.pushTexture(T[e], CGL.Texture.getEmptyTexture(y));
  }
  function p() {
    for (let e = 0; e < T.length; e++)
      if (T[e] && T[e].get() && T[e].get().tex)
        y.setTexture(0 + e + v, T[e].get().tex);
  }
  function A(t) {
    for (let e = 0; e < _.length; e++) if (_[e] && _[e].name == t) return true;
    for (let e = 0; e < T.length; e++) if (T[e] && T[e].name == t) return true;
    return false;
  }
  const m = mat4.create();
  const w = [
    "modelMatrix",
    "viewMatrix",
    "normalMatrix",
    "mvMatrix",
    "projMatrix",
    "inverseViewMatrix",
    "camPos",
  ];
  let C = 0;
  const I = [];
  function f(e) {
    const t = e.split("\n");
    const r = [];
    for (let e = 0; e < t.length; e++) {
      const n = t[e].split(";");
      for (let e = 0; e < n.length; e++) {
        let i = n[e].split(" ");
        for (let e = 0; e < i.length; e++) i[e] = (i[e] + "").trim();
        if (i[0] === "UNI" || i[0] === "uniform") {
          let t = i[2];
          if (i.length > 4) for (let e = 3; e < i.length; e++) t += i[e];
          i = i.filter(function (e) {
            return e !== "";
          });
          const a = i[1];
          let n = [];
          if (t) {
            n = [t];
            if (t.indexOf(",") > -1) n = t.split(",");
          }
          for (let e = 0; e < n.length; e++) {
            if (w.indexOf(n[e]) > -1) continue;
            const s = n[e].trim().replace(/\[\d+\]$/, "");
            if (a === "float") {
              I.push(s);
              if (!A(s)) {
                const o = n[e].trim().match(/\[\d+\]$/);
                if (o) {
                  const l = parseInt(o[0].trim().slice(1, -1));
                  const u = b.inArray(s, []);
                  u.uniform = new CGL.Uniform(S, "f[]", s, new Float32Array(l));
                  _.push(u);
                  r.push(u);
                  const c = {
                    name: s,
                    num: l,
                    port: u,
                    uni: u.uniform,
                    changed: false,
                  };
                  u.onChange = function () {
                    this.changed = true;
                  }.bind(c);
                  O.push(c);
                } else {
                  const u = b.inFloat(s, 0);
                  u.uniform = new CGL.Uniform(S, "f", s, u);
                  _.push(u);
                  r.push(u);
                }
              }
            } else if (a === "int") {
              I.push(s);
              if (!A(s)) {
                const u = b.inInt(s, 0);
                u.uniform = new CGL.Uniform(S, "i", s, u);
                _.push(u);
                r.push(u);
              }
            } else if (a === "bool") {
              I.push(s);
              if (!A(s)) {
                const u = b.inBool(s, false);
                u.uniform = new CGL.Uniform(S, "b", s, u);
                _.push(u);
                r.push(u);
              }
            } else if (a === "mat4") {
              I.push(s);
              if (!A(s)) {
                const u = b.inArray(s, 0);
                u.uniform = new CGL.Uniform(S, "m4", s, u);
                _.push(u);
                r.push(u);
                const c = {
                  name: s,
                  num: 16,
                  port: u,
                  uni: u.uniform,
                  changed: false,
                };
                u.onChange = function () {
                  this.changed = true;
                }.bind(c);
                O.push(c);
              }
            } else if (a === "sampler2D" || a === "samplerCube") {
              I.push(s);
              if (!A(s)) {
                const d = b.inObject(s);
                let e = "t";
                if (a === "samplerCube") e = "tc";
                d.uniform = new CGL.Uniform(S, e, s, v + T.length);
                T.push(d);
                r.push(d);
                d.set(CGL.Texture.getTempTexture(y));
                d.on("change", (e, t) => {
                  if (!e) t.set(CGL.Texture.getTempTexture(y));
                });
                C++;
              }
            } else if (a === "vec3" || a === "vec2" || a === "vec4") {
              let e = 2;
              if (a === "vec4") e = 4;
              if (a === "vec3") e = 3;
              I.push(s + " X");
              I.push(s + " Y");
              if (e > 2) I.push(s + " Z");
              if (e > 3) I.push(s + " W");
              if (!A(s + " X")) {
                const h = [];
                const c = { name: s, num: e, changed: false };
                O.push(c);
                x(c);
                const p = b.inFloat(s + " X", 0);
                p.onChange = function () {
                  this.changed = true;
                }.bind(c);
                _.push(p);
                h.push(p);
                c.x = p;
                const m = b.inFloat(s + " Y", 0);
                m.onChange = function () {
                  this.changed = true;
                }.bind(c);
                _.push(m);
                h.push(m);
                c.y = m;
                if (e > 2) {
                  const f = b.inFloat(s + " Z", 0);
                  f.onChange = function () {
                    this.changed = true;
                  }.bind(c);
                  _.push(f);
                  h.push(f);
                  c.z = f;
                }
                if (e > 3) {
                  const g = b.inFloat(s + " W", 0);
                  g.onChange = function () {
                    this.changed = true;
                  }.bind(c);
                  _.push(g);
                  h.push(g);
                  c.w = g;
                }
                b.setPortGroup(s, h);
              }
            }
          }
        }
      }
    }
    b.setPortGroup("uniforms", r);
  }
  function g() {
    if (!S) return;
    let e = false;
    l++;
    if (l > 2) e = true;
    S.setSource(i.get(), n.get(), e);
    if (y.glVersion == 1) {
      y.enableExtension("OES_standard_derivatives");
      S.enableExtension("GL_OES_standard_derivatives");
    }
    C = 0;
    I.length = 0;
    f(i.get());
    f(n.get());
    for (let t = 0; t < T.length; t++)
      for (let e = 0; e < I.length; e++)
        if (T[t] && I.indexOf(T[t].name) == -1) {
          T[t].remove();
          T[t] = null;
        }
    for (let t = 0; t < _.length; t++)
      for (let e = 0; e < I.length; e++)
        if (_[t] && I.indexOf(_[t].name) == -1) {
          _[t].remove();
          _[t] = null;
        }
    for (let e = 0; e < O.length; e++) {
      x(O[e]);
      O[e].changed = true;
    }
    for (let e = 0; e < _.length; e++)
      if (_[e] && _[e].uniform) _[e].uniform.needsUpdate = true;
    S.compile();
    b.refreshParams();
    s.setRef(S);
    u = false;
    if (S.hasErrors()) b.setUiError("compile", "Shader has errors");
    else b.setUiError("compile", null);
    o.set(S.hasErrors());
  }
  function x(e) {
    if (e.num == 2) e.uni = new CGL.Uniform(S, "2f", e.name, [0, 0]);
    else if (e.num == 3) e.uni = new CGL.Uniform(S, "3f", e.name, [0, 0, 0]);
    else if (e.num == 4) e.uni = new CGL.Uniform(S, "4f", e.name, [0, 0, 0, 0]);
  }
  function E() {
    for (let e = 0; e < O.length; e++) {
      const t = O[e];
      if (t.changed) {
        if (t.num === 2) t.uni.setValue([t.x.get(), t.y.get()]);
        else if (t.num === 3) t.uni.setValue([t.x.get(), t.y.get(), t.z.get()]);
        else if (t.num === 4)
          t.uni.setValue([t.x.get(), t.y.get(), t.z.get(), t.w.get()]);
        else if (t.num > 4) {
          t.uni.setValue(t.port.get());
        }
        t.changed = false;
      }
    }
  }
};
Ops.Gl.Shader.CustomShader_v2.prototype = new CABLES.Op();
CABLES.OPS["a165fc89-a35b-4d39-8930-7345b098bd9d"] = {
  f: Ops.Gl.Shader.CustomShader_v2,
  objName: "Ops.Gl.Shader.CustomShader_v2",
};
Ops.Number.SwitchNumber = function () {
  CABLES.Op.apply(this, arguments);
  const n = this;
  const e = (n.attachments = {});
  const t = n.inValueInt("Index");
  const i = [];
  const r = n.outNumber("Result");
  t.onChange = a;
  for (let t = 0; t < 16; t++) {
    let e = n.inValue("Value " + t);
    i.push(e);
    e.onChange = a;
  }
  function a() {
    if (t.get() >= 0 && i[t.get()]) {
      r.set(i[t.get()].get());
    }
  }
};
Ops.Number.SwitchNumber.prototype = new CABLES.Op();
CABLES.OPS["fbb89f72-f2e3-4d34-ad01-7d884a1bcdc0"] = {
  f: Ops.Number.SwitchNumber,
  objName: "Ops.Number.SwitchNumber",
};
Ops.Array.InterpolateArrays = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inTrigger("Exe"),
    o = e.inArray("Array 1"),
    l = e.inArray("Array 2"),
    u = e.inValueSlider("perc"),
    c = e.outTrigger("Next"),
    d = e.outArray("Result");
  let h = true;
  let p = [];
  function i() {
    h = true;
  }
  o.onChange = l.onChange = u.onChange = i;
  n.onTriggered = r;
  function r() {
    let n = o.get();
    let i = l.get();
    let r;
    let a;
    let s;
    if (!n || !i || n.length < i.length) {
      d.set(null);
      return;
    }
    if (h) {
      if (p.length != n.length) p.length = n.length;
      let t = u.get();
      for (let e = 0; e < n.length; e++) {
        r = n[e];
        a = i[e];
        s = (a - r) * t + r;
        p[e] = s;
      }
      h = false;
      d.setRef(p);
    }
    c.trigger();
  }
  o.onLinkChanged = l.onLinkChanged = function () {
    let e = o.get();
    let t = l.get();
    if (!e || !t) {
      d.set(null);
      return;
    }
    let n = e[0];
    let i = t[0];
    if (typeof n === "string" || typeof i === "string") {
      d.set(null);
    }
  };
};
Ops.Array.InterpolateArrays.prototype = new CABLES.Op();
CABLES.OPS["09296117-7312-4f80-982b-7b4a81d22cf8"] = {
  f: Ops.Array.InterpolateArrays,
  objName: "Ops.Array.InterpolateArrays",
};
Ops.Array.Array3 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const a = e.inValueInt("Num Triplets", 100),
    s = e.inValueFloat("X", 0),
    o = e.inValueFloat("Y", 0),
    l = e.inValueFloat("Z", 0),
    u = e.outArray("Array", null, 3),
    c = e.outNumber("Total points"),
    d = e.outNumber("Array length");
  a.onChange = s.onChange = o.onChange = l.onChange = n;
  let h = [];
  n();
  function n() {
    let t = Math.floor(a.get() * 3);
    if (t < 0) t = 0;
    if (h.length != t) h.length = t;
    const n = s.get();
    const i = o.get();
    const r = l.get();
    for (let e = 0; e < t; e += 3) {
      h[e] = n;
      h[e + 1] = i;
      h[e + 2] = r;
    }
    u.setRef(h);
    c.set(t / 3);
    d.set(t);
  }
};
Ops.Array.Array3.prototype = new CABLES.Op();
CABLES.OPS["2766606a-3ea0-4204-8613-b8950a124435"] = {
  f: Ops.Array.Array3,
  objName: "Ops.Array.Array3",
};
Ops.Array.ArrayMerge_v3 = function () {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const e = (t.attachments = {});
  const n = 8;
  const i = [];
  for (let e = 0; e < n; e++) {
    i[e] = t.inArray("Array " + e);
    i[e].onChange = function () {
      o();
    };
  }
  const r = t.outArray("Result"),
    a = t.outNumber("Array length");
  let s = [];
  function o() {
    s.length = 0;
    for (let e = 0; e < n; e++) {
      const t = i[e].get();
      if (t) s = s.concat(t);
    }
    r.setRef(s);
    a.set(s.length);
  }
};
Ops.Array.ArrayMerge_v3.prototype = new CABLES.Op();
CABLES.OPS["753d053a-04a3-44c7-abf0-ae2676ced13e"] = {
  f: Ops.Array.ArrayMerge_v3,
  objName: "Ops.Array.ArrayMerge_v3",
};
Ops.Array.Array_v3 = function () {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const e = (t.attachments = {});
  const i = t.inValueInt("Array length", 10),
    n = t.inSwitch("Mode select", ["Number", "1,2,3,4", "0-1"], "Number"),
    r = t.inValueFloat("Default Value"),
    a = t.inBool("Reverse", false),
    s = t.outArray("Array"),
    o = t.outNumber("Array length out");
  let l = [];
  let u = 0;
  const c = 0;
  const d = 1;
  const h = 2;
  n.onChange = p;
  a.onChange = r.onChange = i.onChange = m;
  p();
  m();
  function p() {
    let e = n.get();
    if (e === "Number") u = c;
    else if (e === "1,2,3,4") u = d;
    else if (e === "0-1") u = h;
    r.setUiAttribs({ greyout: u !== c });
    t.setUiAttrib({ extendTitle: n.get() });
    m();
  }
  function m() {
    l.length = 0;
    let e = i.get();
    let t = r.get();
    let n;
    if (u === c) {
      for (n = 0; n < e; n++) {
        l[n] = t;
      }
    } else if (u === d) {
      for (n = 0; n < e; n++) {
        l[n] = n;
      }
    } else if (u === h) {
      if (e > 1) {
        for (n = 0; n < e; n++) {
          l[n] = n / (e - 1);
        }
      } else {
        l = [0];
      }
    }
    if (a.get()) l = l.reverse();
    s.setRef(l);
    o.set(l.length);
  }
};
Ops.Array.Array_v3.prototype = new CABLES.Op();
CABLES.OPS["e4d31a46-bf64-42a8-be34-4cbb2bbc2600"] = {
  f: Ops.Array.Array_v3,
  objName: "Ops.Array.Array_v3",
};
Ops.Array.SwitchArray = function () {
  CABLES.Op.apply(this, arguments);
  const n = this;
  const e = (n.attachments = {});
  let t = n.inValueInt("Index");
  let i = [];
  let r = n.outArray("Result");
  t.onChange = a;
  for (let t = 0; t < 10; t++) {
    let e = n.inArray("Array " + t);
    i.push(e);
    e.onChange = a;
  }
  function a() {
    if (t.get() >= 0 && i[t.get()] && i[t.get()].isLinked()) {
      r.setRef(i[t.get()].get());
    } else r.setRef([]);
  }
};
Ops.Array.SwitchArray.prototype = new CABLES.Op();
CABLES.OPS["3fab881c-c2cf-42a0-9c42-2d8edfd93f57"] = {
  f: Ops.Array.SwitchArray,
  objName: "Ops.Array.SwitchArray",
};
Ops.User.srcphag.VideoJS = function () {
  CABLES.Op.apply(this, arguments);
  const n = this;
  const M = (n.attachments = {});
  const e = n.inTrigger("Update"),
    i = n.inUrl("file", "video"),
    t = n.inValueBool("play"),
    r = n.inValueBool("loop", true),
    a = n.inValueSlider("Volume", 1),
    s = n.inValueBool("mute", true),
    o = n.inValueFloat("Update FPS", 30),
    l = n.inSwitch("Filter", ["nearest", "linear"], "linear"),
    u = n.inValueSelect(
      "Wrap",
      ["repeat", "mirrored repeat", "clamp to edge"],
      "clamp to edge"
    ),
    c = n.inValueBool("flip", true),
    d = n.inValueFloat("speed", 1),
    h = n.inValueFloat("set time"),
    p = n.inTriggerButton("Rewind"),
    D = n.inValueBool("Preload", true),
    R = n.inBool("Show Interaction needed Button", true),
    B = n.outTrigger("Next"),
    m = n.outTexture("texture", null, "texture"),
    U = n.outNumber("duration"),
    V = n.outNumber("progress"),
    F = n.outBoolNum("Interaction Needed"),
    G = n.outNumber("CurrentTime"),
    f = n.outBoolNum("Loading"),
    q = n.outBoolNum("Playing"),
    g = n.outBoolNum("Can Play Through", false),
    z = n.outNumber("Width"),
    H = n.outNumber("Height"),
    W = n.outNumber("Aspect Ratio"),
    b = n.outBoolNum("Has Error"),
    X = n.outBoolNum("Auto FPS", false),
    v = n.outString("Error Message");
  n.setPortGroup("Texture", [l, u, c, o]);
  n.setPortGroup("Audio", [s, a]);
  n.setPortGroup("Timing", [h, p, d]);
  let y = false;
  let _ = false;
  let T = false;
  let O = false;
  let S = 0;
  let A = 0;
  let w = null;
  let Y = null;
  let K = true;
  let C = true;
  let I = 0;
  const x = n.patch.cgl;
  const E = document.createElement("video");
  E.setAttribute("playsinline", "");
  E.setAttribute("webkit-playsinline", "");
  E.setAttribute("autoplay", "autoplay");
  let k = videojs(E, {
    controls: true,
    autoplay: false,
    preload: "auto",
    muted: s.get(),
    loop: r.get(),
  });
  X.set(!!E.requestVideoFrameCallback);
  const P = CGL.Texture.getEmptyTexture(x);
  n.toWorkPortsNeedToBeLinked(m);
  m.setRef(CGL.Texture.getEmptyTexture(x));
  t.onChange = N;
  i.onChange = ne;
  a.onChange = n.onMasterVolumeChanged = $;
  l.onChange = u.onChange = () => {
    if (w) w.delete();
    w = null;
  };
  n.onDelete = () => {
    if (w) w.delete();
    E.remove();
  };
  e.onTriggered = () => {
    if (performance.now() - I > 1e3 / o.get()) C = true;
    if (C) {
      Z();
    }
    q.set(!E.paused);
    if (T && !E.paused && t.get()) {
      T = false;
      CABLES.interActionNeededButton.remove("videoplayer");
    }
    F.set(T);
    B.trigger();
  };
  function Q() {
    if (w) w.delete();
    S = CGL.Texture.FILTER_NEAREST;
    if (l.get() == "linear") S = CGL.Texture.FILTER_LINEAR;
    if (u.get() == "repeat") A = CGL.Texture.WRAP_REPEAT;
    if (u.get() == "mirrored repeat") A = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (u.get() == "clamp to edge") A = CGL.Texture.WRAP_CLAMP_TO_EDGE;
    w = new CGL.Texture(x, { wrap: A, filter: S });
  }
  p.onTriggered = function () {
    E.currentTime = 0;
    m.setRef(P);
    C = true;
  };
  h.onChange = function () {
    E.currentTime = h.get() || 0;
    C = true;
  };
  o.onChange = function () {
    C = true;
  };
  function j() {
    E.playbackRate = d.get();
  }
  function N() {
    if (!_) {
      L(true);
    }
    if (t.get()) {
      E.currentTime = h.get() || 0;
      const e = E.play();
      if (e)
        e.then(function () {
          j();
        }).catch(function (e) {
          n.warn("exc", e);
          n.log(e);
          n.log(E);
          if (E.paused && R.get()) {
            T = true;
            CABLES.interActionNeededButton.add(n.patch, "videoplayer", () => {
              T = false;
              E.play();
              j();
              CABLES.interActionNeededButton.remove("videoplayer");
            });
          }
        });
    } else E.pause();
  }
  d.onChange = function () {
    try {
      n.setUiError("playbackRate", null);
      E.playbackRate = d.get();
    } catch (e) {
      n.setUiError(
        "playbackRate",
        "value for 'speed' not supported by browser",
        1
      );
    }
  };
  r.onChange = function () {
    E.loop = r.get();
  };
  s.onChange = function () {
    E.muted = s.get();
  };
  function Z() {
    const e = C;
    I = performance.now();
    if (!i.get()) {
      w = null;
      m.set(P);
      return;
    }
    if (!y) return;
    if (!w) Q();
    if (w.width != E.videoWidth || w.height != E.videoHeight) {
      n.log("video size", E.videoWidth, E.videoHeight);
      w.setSize(E.videoWidth, E.videoHeight);
    }
    z.set(w.width);
    H.set(w.height);
    W.set(w.width / w.height);
    if (!g.get()) return;
    if (!y) return;
    if (!E) return;
    if (E.videoHeight <= 0) {
      n.setUiError("videosize", "video width is 0!");
      return;
    }
    if (E.videoWidth <= 0) {
      n.setUiError("videosize", "video height is 0!");
      return;
    }
    const t = E.currentTime / E.duration;
    if (!isNaN(t)) V.set(t);
    G.set(E.currentTime);
    x.gl.bindTexture(x.gl.TEXTURE_2D, w.tex);
    x.gl.pixelStorei(x.gl.UNPACK_FLIP_Y_WEBGL, c.get());
    x.gl.texImage2D(
      x.gl.TEXTURE_2D,
      0,
      x.gl.RGBA,
      x.gl.RGBA,
      x.gl.UNSIGNED_BYTE,
      E
    );
    w._setFilter();
    if (c.get()) x.gl.pixelStorei(x.gl.UNPACK_FLIP_Y_WEBGL, false);
    K = false;
    m.setRef(w);
    C = false;
    n.patch.cgl.profileData.profileVideosPlaying++;
    if (E.readyState == 4) f.set(false);
    else f.set(false);
    if (E.requestVideoFrameCallback)
      E.requestVideoFrameCallback(() => {
        C = true;
      });
  }
  function J() {
    E.controls = false;
    E.muted = s.get();
    E.loop = r.get();
    C = true;
    g.set(true);
  }
  function $() {
    E.volume = Math.min(
      1,
      Math.max(0, (a.get() || 0) * n.patch.config.masterVolume)
    );
  }
  function ee() {
    U.set(E.duration);
    N();
  }
  function L(e) {
    b.set(false);
    v.set("");
    g.set(false);
    if (!i.get()) {
      v.set(true);
      return;
    }
    if (D.get() || e) {
      clearTimeout(Y);
      f.set(true);
      let e = n.patch.getFilePath(i.get());
      if (String(i.get()).indexOf("data:") === 0) e = i.get();
      if (!e) return;
      k.src({ src: e, type: "application/x-mpegURL" });
      try {
        k.playbackRate(d.get());
      } catch (e) {
        n.setUiError(
          "playbackRate",
          "value for 'speed' not supported by video.js",
          1
        );
      }
      k.loop(r.get());
      k.muted(s.get());
      if (!O) {
        O = true;
        k.on("canplaythrough", J);
        k.on("loadedmetadata", ee);
        k.on("playing", function () {
          y = true;
        });
        k.on("error", function () {
          b.set(true);
          const e = k.error();
          v.set(`Error ${e.code}/${e.message}`);
          n.setUiError("onerror", `Could not load video / ${e.message}`, 2);
        });
      }
      _ = true;
    }
  }
  function te() {
    setTimeout(L, 100);
  }
  function ne() {
    if (!i.get()) return;
    te();
  }
};
Ops.User.srcphag.VideoJS.prototype = new CABLES.Op();
CABLES.OPS["672dfc58-c9cf-477c-8c43-88db0abafb7e"] = {
  f: Ops.User.srcphag.VideoJS,
  objName: "Ops.User.srcphag.VideoJS",
};
Ops.Vars.VarSetArray_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inArray("Value", null);
  e.varName = e.inDropDown("Variable", [], "", true);
  new CABLES.VarSetOpWrapper(e, "array", n, e.varName);
};
Ops.Vars.VarSetArray_v2.prototype = new CABLES.Op();
CABLES.OPS["8088290f-45d4-4312-b4ca-184d34ca4667"] = {
  f: Ops.Vars.VarSetArray_v2,
  objName: "Ops.Vars.VarSetArray_v2",
};
Ops.Color.HexToRGB_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const r = e.inString("Hex", "#ff0000"),
    a = e.inValueBool("Bytes"),
    s = e.outNumber("R"),
    o = e.outNumber("G"),
    l = e.outNumber("B");
  function u(e) {
    return parseInt(n(e).substring(0, 2), 16) || 0;
  }
  function c(e) {
    return parseInt(n(e).substring(2, 4), 16) || 0;
  }
  function d(e) {
    return parseInt(n(e).substring(4, 6), 16) || 0;
  }
  function n(e = "") {
    return e.charAt(0) == "#" ? e.substring(1, 7) : e;
  }
  r.onChange = i;
  a.onChange = i;
  function i() {
    let e = r.get() || "";
    let t = u(e);
    let n = c(e);
    let i = d(e);
    if (!a.get()) {
      t /= 255;
      n /= 255;
      i /= 255;
    }
    s.set(t);
    l.set(i);
    o.set(n);
  }
};
Ops.Color.HexToRGB_v2.prototype = new CABLES.Op();
CABLES.OPS["9877f198-8dac-48e5-9310-244ef1a8dec5"] = {
  f: Ops.Color.HexToRGB_v2,
  objName: "Ops.Color.HexToRGB_v2",
};
Ops.Gl.ShaderEffects.TextureProjection_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {
    maptexture_frag:
      "IN vec2 MOD_tc;\n\n#ifdef MOD_MAP_TRIPLANAR\n    IN vec2 MOD_tc1;\n    IN vec2 MOD_tc2;\n    IN vec3 MOD_blendingTri;\n#endif\n\n\n{{CGL.BLENDMODES3}}",
    maptexture_vert:
      "vec3 MOD_pos;\n\n#ifndef MOD_WORLDSPACE\n   MOD_pos=(vec4(vPosition,1.0)*1.0/MOD_scale).xyz;\n#endif\n#ifdef MOD_WORLDSPACE\n   MOD_pos=(mMatrix*pos).xyz*1.0/MOD_scale;\n#endif\n\nMOD_pos=(vec4(MOD_pos,1.0)*MOD_rotationX(MOD_rotX*MOD_DEG2RAD)).xyz;\nMOD_pos=(vec4(MOD_pos,1.0)*MOD_rotationY(MOD_rotY*MOD_DEG2RAD)).xyz;\nMOD_pos=(vec4(MOD_pos,1.0)*MOD_rotationZ(MOD_rotZ*MOD_DEG2RAD)).xyz;\n\n#ifdef MOD_MAP_XY\n    MOD_tc=MOD_pos.xy;\n#endif\n#ifdef MOD_MAP_XZ\n    MOD_tc=MOD_pos.xz;\n#endif\n#ifdef MOD_MAP_YZ\n    MOD_tc=MOD_pos.yz;\n#endif\n\nMOD_tc.xy+=vec2(0.5,0.5);\nMOD_tc.xy+=MOD_offset;\n\n\n#ifdef MOD_TARGET_POINTSIZE\n\n    gl_PointSize+=(texture(MOD_tex,MOD_tc).x*MOD_amount);\n\n#endif\n\n\n#ifdef MOD_MAP_TRIPLANAR\n    mapTriplanar((mMatrix*vec4(attrVertNormal,1.0)).xyz,MOD_pos);\n#endif\n\n",
    maptexture_body_frag:
      "#ifndef MOD_TARGET_POINTSIZE\n\n\n    vec4 MOD_color;\n\n    #ifdef MOD_MAP_TRIPLANAR\n        vec4 xaxis = texture( MOD_tex, MOD_tc);\n        vec4 yaxis = texture( MOD_tex, MOD_tc1);\n        vec4 zaxis = texture( MOD_tex, MOD_tc2);\n        MOD_color = xaxis *MOD_blendingTri.x + yaxis *MOD_blendingTri.y + zaxis *MOD_blendingTri.z;\n        MOD_color.a=1.0;\n    #endif\n\n\n    vec2 MOD_ntc=MOD_tc;\n\n    #ifdef MOD_MAP_SCREEN\n        MOD_ntc=(vec2(gl_FragCoord.x,gl_FragCoord.y)/vec2(MOD_viewPortW,MOD_viewPortH));\n\n        MOD_ntc-=vec2(0.5,0.5);\n        MOD_ntc*=1.0/MOD_scale;\n        MOD_ntc+=vec2(0.5,0.5);\n        MOD_ntc-=MOD_offset;\n    #endif\n\n    #ifdef MOD_MAP_TEXCOORD\n        MOD_ntc=texCoord*1.0/MOD_scale-MOD_offset;\n    #endif\n\n    #ifdef MOD_MAP_TEXCOORD1\n        MOD_ntc=texCoord1*1.0/MOD_scale-MOD_offset;\n    #endif\n\n    #ifdef MOD_MAP_TEXCOORD2\n        MOD_ntc=texCoord2*1.0/MOD_scale-MOD_offset;\n    #endif\n\n\n    #ifdef MOD_DISCARD\n    if(MOD_ntc.x>0.0 && MOD_ntc.x<1.0 && MOD_ntc.y>0.0 && MOD_ntc.y<1.0)\n    {\n    #endif\n\n        #ifndef MOD_MAP_TRIPLANAR\n            MOD_color=texture(MOD_tex,MOD_ntc);\n        #endif\n\n        #ifdef MOD_USE_IMGALPHA\n            col.a=MOD_color.a;\n        #endif\n\n        #ifdef MOD_TARGET_COLOR\n        col=cgl_blendPixel(col,MOD_color,MOD_amount*col.a);\n        #endif\n        #ifdef MOD_TARGET_ALPHA\n        col.a=1.0-MOD_color.r*MOD_amount;\n        #endif\n\n    #ifdef MOD_DISCARD\n    }\n\n    #endif\n#endif\n",
    maptexture_body_vert:
      "OUT vec2 MOD_tc;\n\nconst float MOD_DEG2RAD = 0.017453292519943;\n\n#ifdef MOD_MAP_TRIPLANAR\n\n    OUT vec2 MOD_tc1;\n    OUT vec2 MOD_tc2;\n    OUT vec3 MOD_blendingTri;\n\n    void mapTriplanar(vec3 wNorm,vec3 pos)\n    {\n        vec3 blending = abs( wNorm );\n        blending = normalize(max(blending, 0.1));\n        float b = (blending.x + blending.y + blending.z);\n        blending /= vec3(b);\n        MOD_blendingTri=blending;\n\n        MOD_tc = pos.yz;\n        MOD_tc1 = pos.xz;\n        MOD_tc2 = pos.xy;\n    }\n\n#endif\n\nmat4 MOD_rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 MOD_rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 MOD_rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n",
  });
  const n = e.inTrigger("render"),
    i = e.outTrigger("trigger"),
    r = e.inTexture("Texture"),
    a = CGL.TextureEffect.AddBlendSelect(e, "blendMode"),
    s = e.inValueSlider("Amount", 0.3),
    o = e.inSwitch("Target", ["Color", "Pointsize", "Alpha"], "Color"),
    l = e.inValue("Scale", 10),
    u = e.inBool("Use Texture Alpha", false),
    c = e.inFloat("Pos X", 0),
    d = e.inFloat("Pos Y", 0),
    h = e.inFloat("Rot X", 0),
    p = e.inFloat("Rot Y", 0),
    m = e.inFloat("Rot Z", 0),
    f = e.inValueSelect(
      "Mapping",
      [
        "Triplanar",
        "XY",
        "XZ",
        "YZ",
        "Screen",
        "TexCoords 1",
        "TexCoords 2",
        "TexCoords 3",
      ],
      "XY"
    ),
    g = e.inValueBool("Discard"),
    b = e.inValueBool("WorldSpace");
  const v = e.patch.cgl;
  n.onLinkChanged =
    u.onChange =
    o.onChange =
    a.onChange =
    g.onChange =
    b.onChange =
    r.onLinkChanged =
    f.onChange =
      S;
  e.toWorkPortsNeedToBeLinked(r, i);
  e.setPortGroup("Rotation", [h, p, m]);
  e.setPortGroup("Position", [c, d]);
  const y = new CGL.ShaderModifier(v, e.name, { opId: e.id });
  y.addModule({
    title: e.name,
    name: "MODULE_VERTEX_POSITION",
    srcHeadVert: t.maptexture_body_vert,
    srcBodyVert: t.maptexture_vert,
    attributes: [
      { type: "vec2", name: "attrTexCoord1", nameFrag: "texCoord1" },
      { type: "vec2", name: "attrTexCoord2", nameFrag: "texCoord2" },
    ],
  });
  let _ = t.maptexture_frag;
  y.addModule({
    title: e.name,
    name: "MODULE_COLOR",
    srcHeadFrag: _,
    srcBodyFrag: t.maptexture_body_frag,
  });
  y.addUniformBoth("f", "MOD_rotX", h);
  y.addUniformBoth("f", "MOD_rotY", p);
  y.addUniformBoth("f", "MOD_rotZ", m);
  y.addUniformBoth("t", "MOD_tex");
  y.addUniformBoth("f", "MOD_scale", l);
  y.addUniformBoth("f", "MOD_amount", s);
  y.addUniformBoth("2f", "MOD_offset", c, d);
  const T = y.addUniformFrag("f", "MOD_viewPortW");
  const O = y.addUniformFrag("f", "MOD_viewPortH");
  CGL.TextureEffect.setupBlending(e, y, a, s);
  S();
  function S() {
    y.toggleDefine("MOD_USE_IMGALPHA", u.get());
    y.toggleDefine("MOD_WORLDSPACE", b.get());
    y.toggleDefine("MOD_MAP_XY", f.get() == "XY");
    y.toggleDefine("MOD_MAP_XZ", f.get() == "XZ");
    y.toggleDefine("MOD_MAP_YZ", f.get() == "YZ");
    y.toggleDefine("MOD_MAP_TEXCOORD", f.get() == "TexCoords 1");
    y.toggleDefine("MOD_MAP_TEXCOORD1", f.get() == "TexCoords 2");
    y.toggleDefine("MOD_MAP_TEXCOORD2", f.get() == "TexCoords 3");
    y.toggleDefine("MOD_MAP_SCREEN", f.get() == "Screen");
    y.toggleDefine("MOD_MAP_TRIPLANAR", f.get() == "Triplanar");
    y.toggleDefine("MOD_DISCARD", g.get());
    y.toggleDefine("MOD_BLEND_NORMAL", a.get() == "Normal");
    y.toggleDefine("MOD_BLEND_ADD", a.get() == "Add");
    y.toggleDefine("MOD_BLEND_MUL", a.get() == "Mul");
    y.toggleDefine("MOD_BLEND_MUL", a.get() == "Mul");
    y.toggleDefine("MOD_TARGET_ALPHA", o.get() == "Alpha");
    y.toggleDefine("MOD_TARGET_COLOR", o.get() == "Color");
    y.toggleDefine("MOD_TARGET_POINTSIZE", o.get() == "Pointsize");
    if (o.get() == "Pointsize" && f.get() == "Screen")
      e.setUiError(
        "pointscreen",
        "This combination of Mapping and Target is not possible",
        1
      );
    else e.setUiError("pointscreen", null);
    CGL.TextureEffect.setupBlending(e, y, a, s);
  }
  n.onTriggered = function () {
    const e = v.getViewPort();
    y.bind();
    y.setUniformValue("MOD_viewPortW", e[2]);
    y.setUniformValue("MOD_viewPortH", e[3]);
    let t = r.get();
    if (!t) t = CGL.Texture.getEmptyTexture(v).tex;
    else t = t.tex;
    y.pushTexture("MOD_tex", t);
    i.trigger();
    y.unbind();
  };
};
Ops.Gl.ShaderEffects.TextureProjection_v2.prototype = new CABLES.Op();
CABLES.OPS["9be647c2-7afd-40ed-b669-9826ea6a50ca"] = {
  f: Ops.Gl.ShaderEffects.TextureProjection_v2,
  objName: "Ops.Gl.ShaderEffects.TextureProjection_v2",
};
Ops.Vars.VarGetTexture_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.outTexture("Value");
  e.varName = e.inValueSelect("Variable", [], "", true);
  new CABLES.VarGetOpWrapper(e, "object", e.varName, n);
};
Ops.Vars.VarGetTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["5f8ce5fc-9787-45c9-9a83-0eebd2c6de15"] = {
  f: Ops.Vars.VarGetTexture_v2,
  objName: "Ops.Vars.VarGetTexture_v2",
};
Ops.Gl.Shader.BasicMaterial_v3 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {
    basicmaterial_frag:
      "{{MODULES_HEAD}}\n\nIN vec2 texCoord;\n\n#ifdef VERTEX_COLORS\nIN vec4 vertCol;\n#endif\n\n#ifdef HAS_TEXTURES\n    IN vec2 texCoordOrig;\n    #ifdef HAS_TEXTURE_DIFFUSE\n        UNI sampler2D tex;\n    #endif\n    #ifdef HAS_TEXTURE_OPACITY\n        UNI sampler2D texOpacity;\n   #endif\n#endif\n\n\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col=color;\n\n\n    #ifdef HAS_TEXTURES\n        vec2 uv=texCoord;\n\n        #ifdef CROP_TEXCOORDS\n            if(uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) discard;\n        #endif\n\n        #ifdef HAS_TEXTURE_DIFFUSE\n            col=texture(tex,uv);\n\n            #ifdef COLORIZE_TEXTURE\n                col.r*=color.r;\n                col.g*=color.g;\n                col.b*=color.b;\n            #endif\n        #endif\n        col.a*=color.a;\n        #ifdef HAS_TEXTURE_OPACITY\n            #ifdef TRANSFORMALPHATEXCOORDS\n                uv=texCoordOrig;\n            #endif\n            #ifdef ALPHA_MASK_IR\n                col.a*=1.0-texture(texOpacity,uv).r;\n            #endif\n            #ifdef ALPHA_MASK_IALPHA\n                col.a*=1.0-texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_ALPHA\n                col.a*=texture(texOpacity,uv).a;\n            #endif\n            #ifdef ALPHA_MASK_LUMI\n                col.a*=dot(vec3(0.2126,0.7152,0.0722), texture(texOpacity,uv).rgb);\n            #endif\n            #ifdef ALPHA_MASK_R\n                col.a*=texture(texOpacity,uv).r;\n            #endif\n            #ifdef ALPHA_MASK_G\n                col.a*=texture(texOpacity,uv).g;\n            #endif\n            #ifdef ALPHA_MASK_B\n                col.a*=texture(texOpacity,uv).b;\n            #endif\n            // #endif\n        #endif\n    #endif\n\n    {{MODULE_COLOR}}\n\n    #ifdef DISCARDTRANS\n        if(col.a<0.2) discard;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        col*=vertCol;\n    #endif\n\n    outColor = col;\n}\n",
    basicmaterial_vert:
      "\n{{MODULES_HEAD}}\n\nOUT vec2 texCoord;\nOUT vec2 texCoordOrig;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\n#ifdef HAS_TEXTURES\n    UNI float diffuseRepeatX;\n    UNI float diffuseRepeatY;\n    UNI float texOffsetX;\n    UNI float texOffsetY;\n#endif\n\n#ifdef VERTEX_COLORS\n    in vec4 attrVertColor;\n    out vec4 vertCol;\n\n#endif\n\n\nvoid main()\n{\n    mat4 mMatrix=modelMatrix;\n    mat4 modelViewMatrix;\n\n    norm=attrVertNormal;\n    texCoordOrig=attrTexCoord;\n    texCoord=attrTexCoord;\n    #ifdef HAS_TEXTURES\n        texCoord.x=texCoord.x*diffuseRepeatX+texOffsetX;\n        texCoord.y=(1.0-texCoord.y)*diffuseRepeatY+texOffsetY;\n    #endif\n\n    #ifdef VERTEX_COLORS\n        vertCol=attrVertColor;\n    #endif\n\n    vec4 pos = vec4(vPosition, 1.0);\n\n    #ifdef BILLBOARD\n       vec3 position=vPosition;\n       modelViewMatrix=viewMatrix*modelMatrix;\n\n       gl_Position = projMatrix * modelViewMatrix * vec4((\n           position.x * vec3(\n               modelViewMatrix[0][0],\n               modelViewMatrix[1][0],\n               modelViewMatrix[2][0] ) +\n           position.y * vec3(\n               modelViewMatrix[0][1],\n               modelViewMatrix[1][1],\n               modelViewMatrix[2][1]) ), 1.0);\n    #endif\n\n    {{MODULE_VERTEX_POSITION}}\n\n    #ifndef BILLBOARD\n        modelViewMatrix=viewMatrix * mMatrix;\n\n        {{MODULE_VERTEX_MODELVIEW}}\n\n    #endif\n\n    // mat4 modelViewMatrix=viewMatrix*mMatrix;\n\n    #ifndef BILLBOARD\n        // gl_Position = projMatrix * viewMatrix * modelMatrix * pos;\n        gl_Position = projMatrix * modelViewMatrix * pos;\n    #endif\n}\n",
  });
  const n = e.inTrigger("render");
  const i = e.outTrigger("trigger");
  const r = e.outObject("shader", null, "shader");
  r.ignoreValueSerialize = true;
  e.toWorkPortsNeedToBeLinked(n);
  e.toWorkShouldNotBeChild(
    "Ops.Gl.TextureEffects.ImageCompose",
    CABLES.OP_PORT_TYPE_FUNCTION
  );
  const a = e.patch.cgl;
  const s = new CGL.Shader(a, "basicmaterialnew", this);
  s.addAttribute({ type: "vec3", name: "vPosition" });
  s.addAttribute({ type: "vec2", name: "attrTexCoord" });
  s.addAttribute({ type: "vec3", name: "attrVertNormal", nameFrag: "norm" });
  s.addAttribute({ type: "float", name: "attrVertIndex" });
  s.setModules([
    "MODULE_VERTEX_POSITION",
    "MODULE_COLOR",
    "MODULE_BEGIN_FRAG",
    "MODULE_VERTEX_MODELVIEW",
  ]);
  s.setSource(t.basicmaterial_vert, t.basicmaterial_frag);
  r.setRef(s);
  n.onTriggered = I;
  const o = e.inValueSlider("r", Math.random());
  const l = e.inValueSlider("g", Math.random());
  const u = e.inValueSlider("b", Math.random());
  const c = e.inValueSlider("a", 1);
  o.setUiAttribs({ colorPick: true });
  const d = s.addUniformFrag("4f", "color", o, l, u, c);
  s.uniformColorDiffuse = d;
  const h = e.inTexture("texture");
  let p = null;
  h.onChange = E;
  const m = e.inValueBool("colorizeTexture", false);
  const f = e.inValueBool("Vertex Colors", false);
  const g = e.inTexture("textureOpacity");
  let b = null;
  const v = e.inSwitch(
    "Alpha Mask Source",
    ["Luminance", "R", "G", "B", "A", "1-A", "1-R"],
    "Luminance"
  );
  v.setUiAttribs({ greyout: true });
  g.onChange = x;
  const y = e.inValueBool("Opacity TexCoords Transform", false);
  const _ = e.inValueBool("Discard Transparent Pixels");
  const T = e.inValue("diffuseRepeatX", 1),
    O = e.inValue("diffuseRepeatY", 1),
    S = e.inValue("Tex Offset X", 0),
    A = e.inValue("Tex Offset Y", 0),
    w = e.inBool("Crop TexCoords", false);
  s.addUniformFrag("f", "diffuseRepeatX", T);
  s.addUniformFrag("f", "diffuseRepeatY", O);
  s.addUniformFrag("f", "texOffsetX", S);
  s.addUniformFrag("f", "texOffsetY", A);
  const C = e.inValueBool("billboard", false);
  v.onChange =
    C.onChange =
    _.onChange =
    y.onChange =
    w.onChange =
    f.onChange =
    m.onChange =
      P;
  e.setPortGroup("Color", [o, l, u, c]);
  e.setPortGroup("Color Texture", [h, f, m]);
  e.setPortGroup("Opacity", [g, v, _, y]);
  e.setPortGroup("Texture Transform", [T, O, S, A, w]);
  x();
  E();
  e.preRender = function () {
    s.bind();
    I();
  };
  function I() {
    if (!s) return;
    a.pushShader(s);
    s.popTextures();
    if (p && h.get()) s.pushTexture(p, h.get());
    if (b && g.get()) s.pushTexture(b, g.get());
    i.trigger();
    a.popShader();
  }
  function x() {
    if (g.get()) {
      if (b !== null) return;
      s.removeUniform("texOpacity");
      s.define("HAS_TEXTURE_OPACITY");
      if (!b) b = new CGL.Uniform(s, "t", "texOpacity");
    } else {
      s.removeUniform("texOpacity");
      s.removeDefine("HAS_TEXTURE_OPACITY");
      b = null;
    }
    P();
  }
  function E() {
    if (h.get()) {
      if (!s.hasDefine("HAS_TEXTURE_DIFFUSE")) s.define("HAS_TEXTURE_DIFFUSE");
      if (!p) p = new CGL.Uniform(s, "t", "texDiffuse");
    } else {
      s.removeUniform("texDiffuse");
      s.removeDefine("HAS_TEXTURE_DIFFUSE");
      p = null;
    }
    k();
  }
  function k() {
    const e = h.isLinked() || g.isLinked();
    T.setUiAttribs({ greyout: !e });
    O.setUiAttribs({ greyout: !e });
    S.setUiAttribs({ greyout: !e });
    A.setUiAttribs({ greyout: !e });
    m.setUiAttribs({ greyout: !e });
    v.setUiAttribs({ greyout: !g.get() });
    y.setUiAttribs({ greyout: !g.get() });
    let t = true;
    t = h.get() && !m.get();
    o.setUiAttribs({ greyout: t });
    l.setUiAttribs({ greyout: t });
    u.setUiAttribs({ greyout: t });
  }
  function P() {
    s.toggleDefine("VERTEX_COLORS", f.get());
    s.toggleDefine("CROP_TEXCOORDS", w.get());
    s.toggleDefine("COLORIZE_TEXTURE", m.get());
    s.toggleDefine("TRANSFORMALPHATEXCOORDS", y.get());
    s.toggleDefine("DISCARDTRANS", _.get());
    s.toggleDefine("BILLBOARD", C.get());
    s.toggleDefine("ALPHA_MASK_ALPHA", v.get() == "A");
    s.toggleDefine("ALPHA_MASK_IALPHA", v.get() == "1-A");
    s.toggleDefine("ALPHA_MASK_IR", v.get() == "1-R");
    s.toggleDefine("ALPHA_MASK_LUMI", v.get() == "Luminance");
    s.toggleDefine("ALPHA_MASK_R", v.get() == "R");
    s.toggleDefine("ALPHA_MASK_G", v.get() == "G");
    s.toggleDefine("ALPHA_MASK_B", v.get() == "B");
    k();
  }
};
Ops.Gl.Shader.BasicMaterial_v3.prototype = new CABLES.Op();
CABLES.OPS["ec55d252-3843-41b1-b731-0482dbd9e72b"] = {
  f: Ops.Gl.Shader.BasicMaterial_v3,
  objName: "Ops.Gl.Shader.BasicMaterial_v3",
};
Ops.Gl.GLTF.GltfScene_v4 = function () {
  CABLES.Op.apply(this, arguments);
  const T = this;
  const l = (T.attachments = {
    inc_camera_js:
      "const gltfCamera = class\n{\n    constructor(gltf, node)\n    {\n        this.node = node;\n        this.name = node.name;\n        // console.log(gltf);\n        this.config = gltf.json.cameras[node.camera];\n\n        this.pos = vec3.create();\n        this.quat = quat.create();\n        this.vCenter = vec3.create();\n        this.vUp = vec3.create();\n        this.vMat = mat4.create();\n    }\n\n    updateAnim(time)\n    {\n        if (this.node && this.node._animTrans)\n        {\n            vec3.set(this.pos,\n                this.node._animTrans[0].getValue(time),\n                this.node._animTrans[1].getValue(time),\n                this.node._animTrans[2].getValue(time));\n\n            quat.set(this.quat,\n                this.node._animRot[0].getValue(time),\n                this.node._animRot[1].getValue(time),\n                this.node._animRot[2].getValue(time),\n                this.node._animRot[3].getValue(time));\n        }\n    }\n\n    start(time)\n    {\n        if (cgl.tempData.shadowPass) return;\n\n        this.updateAnim(time);\n        const asp = cgl.getViewPort()[2] / cgl.getViewPort()[3];\n\n        cgl.pushPMatrix();\n        // mat4.perspective(\n        //     cgl.pMatrix,\n        //     this.config.perspective.yfov*0.5,\n        //     asp,\n        //     this.config.perspective.znear,\n        //     this.config.perspective.zfar);\n\n        cgl.pushViewMatrix();\n        // mat4.identity(cgl.vMatrix);\n\n        // if(this.node && this.node.parent)\n        // {\n        //     console.log(this.node.parent)\n        // vec3.add(this.pos,this.pos,this.node.parent._node.translation);\n        // vec3.sub(this.vCenter,this.vCenter,this.node.parent._node.translation);\n        // mat4.translate(cgl.vMatrix,cgl.vMatrix,\n        // [\n        //     -this.node.parent._node.translation[0],\n        //     -this.node.parent._node.translation[1],\n        //     -this.node.parent._node.translation[2]\n        // ])\n        // }\n\n        // vec3.set(this.vUp, 0, 1, 0);\n        // vec3.set(this.vCenter, 0, -1, 0);\n        // // vec3.set(this.vCenter, 0, 1, 0);\n        // vec3.transformQuat(this.vCenter, this.vCenter, this.quat);\n        // vec3.normalize(this.vCenter, this.vCenter);\n        // vec3.add(this.vCenter, this.vCenter, this.pos);\n\n        // mat4.lookAt(cgl.vMatrix, this.pos, this.vCenter, this.vUp);\n\n        let mv = mat4.create();\n        mat4.invert(mv, this.node.modelMatAbs());\n\n        // console.log(this.node.modelMatAbs());\n\n        this.vMat = mv;\n\n        mat4.identity(cgl.vMatrix);\n        // console.log(mv);\n        mat4.mul(cgl.vMatrix, cgl.vMatrix, mv);\n    }\n\n    end()\n    {\n        if (cgl.tempData.shadowPass) return;\n        cgl.popPMatrix();\n        cgl.popViewMatrix();\n    }\n};\n",
    inc_gltf_js:
      'const le = true; // little endian\n\nconst Gltf = class\n{\n    constructor()\n    {\n        this.json = {};\n        this.accBuffers = [];\n        this.meshes = [];\n        this.nodes = [];\n        this.shaders = [];\n        this.timing = [];\n        this.cams = [];\n        this.startTime = performance.now();\n        this.bounds = new CABLES.CG.BoundingBox();\n        this.loaded = Date.now();\n        this.accBuffersDelete = [];\n    }\n\n    getNode(n)\n    {\n        for (let i = 0; i < this.nodes.length; i++)\n        {\n            if (this.nodes[i].name == n) return this.nodes[i];\n        }\n    }\n\n    unHideAll()\n    {\n        for (let i = 0; i < this.nodes.length; i++)\n        {\n            this.nodes[i].unHide();\n        }\n    }\n};\n\nfunction Utf8ArrayToStr(array)\n{\n    if (window.TextDecoder) return new TextDecoder("utf-8").decode(array);\n\n    let out, i, len, c;\n    let char2, char3;\n\n    out = "";\n    len = array.length;\n    i = 0;\n    while (i < len)\n    {\n        c = array[i++];\n        switch (c >> 4)\n        {\n        case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n            // 0xxxxxxx\n            out += String.fromCharCode(c);\n            break;\n        case 12: case 13:\n            // 110x xxxx   10xx xxxx\n            char2 = array[i++];\n            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\n            break;\n        case 14:\n            // 1110 xxxx  10xx xxxx  10xx xxxx\n            char2 = array[i++];\n            char3 = array[i++];\n            out += String.fromCharCode(((c & 0x0F) << 12) |\n                    ((char2 & 0x3F) << 6) |\n                    ((char3 & 0x3F) << 0));\n            break;\n        }\n    }\n\n    return out;\n}\n\nfunction readChunk(dv, bArr, arrayBuffer, offset)\n{\n    const chunk = {};\n\n    if (offset >= dv.byteLength)\n    {\n        // op.log("could not read chunk...");\n        return;\n    }\n    chunk.size = dv.getUint32(offset + 0, le);\n\n    // chunk.type = new TextDecoder("utf-8").decode(bArr.subarray(offset+4, offset+4+4));\n    chunk.type = Utf8ArrayToStr(bArr.subarray(offset + 4, offset + 4 + 4));\n\n    if (chunk.type == "BIN\\0")\n    {\n        // console.log(chunk.size,arrayBuffer.length,offset);\n        // try\n        // {\n        chunk.dataView = new DataView(arrayBuffer, offset + 8, chunk.size);\n        // }\n        // catch(e)\n        // {\n        //     chunk.dataView = null;\n        //     console.log(e);\n        // }\n    }\n    else\n    if (chunk.type == "JSON")\n    {\n        const json = Utf8ArrayToStr(bArr.subarray(offset + 8, offset + 8 + chunk.size));\n\n        try\n        {\n            const obj = JSON.parse(json);\n            chunk.data = obj;\n            outGenerator.set(obj.asset.generator);\n        }\n        catch (e)\n        {\n        }\n    }\n    else\n    {\n        op.warn("unknown type", chunk.type);\n    }\n\n    return chunk;\n}\n\nfunction loadAnims(gltf)\n{\n    const uniqueAnimNames = {};\n\n    for (let i = 0; i < gltf.json.animations.length; i++)\n    {\n        const an = gltf.json.animations[i];\n\n        an.name = an.name || "unknown";\n\n        for (let ia = 0; ia < an.channels.length; ia++)\n        {\n            const chan = an.channels[ia];\n\n            const node = gltf.nodes[chan.target.node];\n            const sampler = an.samplers[chan.sampler];\n\n            const acc = gltf.json.accessors[sampler.input];\n            const bufferIn = gltf.accBuffers[sampler.input];\n\n            const accOut = gltf.json.accessors[sampler.output];\n            const bufferOut = gltf.accBuffers[sampler.output];\n\n            gltf.accBuffersDelete.push(sampler.output, sampler.input);\n\n            if (bufferIn && bufferOut)\n            {\n                let numComps = 1;\n                if (accOut.type === "VEC2")numComps = 2;\n                else if (accOut.type === "VEC3")numComps = 3;\n                else if (accOut.type === "VEC4")numComps = 4;\n                else if (accOut.type === "SCALAR")\n                {\n                    numComps = bufferOut.length / bufferIn.length; // is this really the way to find out ? cant find any other way,except number of morph targets, but not really connected...\n                }\n                else op.log("[] UNKNOWN accOut.type", accOut.type);\n\n                const anims = [];\n\n                uniqueAnimNames[an.name] = true;\n\n                for (let k = 0; k < numComps; k++)\n                {\n                    const newAnim = new CABLES.Anim();\n                    // newAnim.name=an.name;\n                    anims.push(newAnim);\n                }\n\n                if (sampler.interpolation === "LINEAR") {}\n                else if (sampler.interpolation === "STEP") for (let k = 0; k < numComps; k++) anims[k].defaultEasing = CABLES.EASING_ABSOLUTE;\n                else if (sampler.interpolation === "CUBICSPLINE") for (let k = 0; k < numComps; k++) anims[k].defaultEasing = CABLES.EASING_CUBICSPLINE;\n                else op.warn("unknown interpolation", sampler.interpolation);\n\n                // console.log(bufferOut)\n\n                // if there is no keyframe for time 0 copy value of first keyframe at time 0\n                if (bufferIn[0] !== 0.0)\n                    for (let k = 0; k < numComps; k++)\n                        anims[k].setValue(0, bufferOut[0 * numComps + k]);\n\n                for (let j = 0; j < bufferIn.length; j++)\n                {\n                    maxTime = Math.max(bufferIn[j], maxTime);\n\n                    for (let k = 0; k < numComps; k++)\n                    {\n                        if (anims[k].defaultEasing === CABLES.EASING_CUBICSPLINE)\n                        {\n                            const idx = ((j * numComps) * 3 + k);\n\n                            const key = anims[k].setValue(bufferIn[j], bufferOut[idx + numComps]);\n                            key.bezTangIn = bufferOut[idx];\n                            key.bezTangOut = bufferOut[idx + (numComps * 2)];\n\n                            // console.log(an.name,k,bufferOut[idx+1]);\n                        }\n                        else\n                        {\n                            // console.log(an.name,k,bufferOut[j * numComps + k]);\n                            anims[k].setValue(bufferIn[j], bufferOut[j * numComps + k]);\n                        }\n                    }\n                }\n\n                node.setAnim(chan.target.path, an.name, anims);\n            }\n            else\n            {\n                op.warn("loadAmins bufferIn undefined ", bufferIn === undefined);\n                op.warn("loadAmins bufferOut undefined ", bufferOut === undefined);\n                op.warn("loadAmins ", an.name, sampler, accOut);\n                op.warn("loadAmins num accBuffers", gltf.accBuffers.length);\n                op.warn("loadAmins num accessors", gltf.json.accessors.length);\n            }\n        }\n    }\n\n    gltf.uniqueAnimNames = uniqueAnimNames;\n\n    outAnims.setRef(Object.keys(uniqueAnimNames));\n}\n\nfunction loadCams(gltf)\n{\n    if (!gltf || !gltf.json.cameras) return;\n\n    gltf.cameras = gltf.cameras || [];\n\n    for (let i = 0; i < gltf.nodes.length; i++)\n    {\n        if (gltf.nodes[i].hasOwnProperty("camera"))\n        {\n            const cam = new gltfCamera(gltf, gltf.nodes[i]);\n            gltf.cameras.push(cam);\n        }\n    }\n}\n\nfunction loadAfterDraco()\n{\n    if (!window.DracoDecoder)\n    {\n        setTimeout(() =>\n        {\n            loadAfterDraco();\n        }, 100);\n    }\n\n    reloadSoon();\n}\n\nfunction parseGltf(arrayBuffer)\n{\n    const CHUNK_HEADER_SIZE = 8;\n\n    let j = 0, i = 0;\n\n    const gltf = new Gltf();\n    gltf.timing.push(["Start parsing", Math.round((performance.now() - gltf.startTime))]);\n\n    if (!arrayBuffer) return;\n    const byteArray = new Uint8Array(arrayBuffer);\n    let pos = 0;\n\n    // var string = new TextDecoder("utf-8").decode(byteArray.subarray(pos, 4));\n    const string = Utf8ArrayToStr(byteArray.subarray(pos, 4));\n    pos += 4;\n    if (string != "glTF") return;\n\n    gltf.timing.push(["dataview", Math.round((performance.now() - gltf.startTime))]);\n\n    const dv = new DataView(arrayBuffer);\n    const version = dv.getUint32(pos, le);\n    pos += 4;\n    const size = dv.getUint32(pos, le);\n    pos += 4;\n\n    outVersion.set(version);\n\n    const chunks = [];\n    gltf.chunks = chunks;\n\n    chunks.push(readChunk(dv, byteArray, arrayBuffer, pos));\n    pos += chunks[0].size + CHUNK_HEADER_SIZE;\n    gltf.json = chunks[0].data;\n\n    gltf.cables = {\n        "fileUrl": inFile.get(),\n        "shortFileName": CABLES.basename(inFile.get())\n    };\n\n    outJson.setRef(gltf.json);\n    outExtensions.setRef(gltf.json.extensionsUsed || []);\n\n    let ch = readChunk(dv, byteArray, arrayBuffer, pos);\n    while (ch)\n    {\n        chunks.push(ch);\n        pos += ch.size + CHUNK_HEADER_SIZE;\n        ch = readChunk(dv, byteArray, arrayBuffer, pos);\n    }\n\n    gltf.chunks = chunks;\n\n    const views = chunks[0].data.bufferViews;\n    const accessors = chunks[0].data.accessors;\n\n    gltf.timing.push(["Parse buffers", Math.round((performance.now() - gltf.startTime))]);\n\n    if (gltf.json.extensionsUsed && gltf.json.extensionsUsed.indexOf("KHR_draco_mesh_compression") > -1)\n    {\n        if (!window.DracoDecoder)\n        {\n            op.setUiError("gltfdraco", "GLTF draco compression lib not found / add draco op to your patch!");\n\n            loadAfterDraco();\n            return gltf;\n        }\n        else\n        {\n            gltf.useDraco = true;\n        }\n    }\n\n    op.setUiError("gltfdraco", null);\n    // let accPos = (view.byteOffset || 0) + (acc.byteOffset || 0);\n\n    if (views)\n    {\n        for (i = 0; i < accessors.length; i++)\n        {\n            const acc = accessors[i];\n            const view = views[acc.bufferView];\n\n            let numComps = 0;\n            if (acc.type == "SCALAR")numComps = 1;\n            else if (acc.type == "VEC2")numComps = 2;\n            else if (acc.type == "VEC3")numComps = 3;\n            else if (acc.type == "VEC4")numComps = 4;\n            else if (acc.type == "MAT4")numComps = 16;\n            else console.error("unknown accessor type", acc.type);\n\n            //   const decoder = new decoderModule.Decoder();\n            //   const decodedGeometry = decodeDracoData(data, decoder);\n            //   // Encode mesh\n            //   encodeMeshToFile(decodedGeometry, decoder);\n\n            //   decoderModule.destroy(decoder);\n            //   decoderModule.destroy(decodedGeometry);\n\n            // 5120 (BYTE)\t1\n            // 5121 (UNSIGNED_BYTE)\t1\n            // 5122 (SHORT)\t2\n\n            if (chunks[1].dataView)\n            {\n                if (view)\n                {\n                    const num = acc.count * numComps;\n                    let accPos = (view.byteOffset || 0) + (acc.byteOffset || 0);\n                    let stride = view.byteStride || 0;\n                    let dataBuff = null;\n\n                    if (acc.componentType == 5126 || acc.componentType == 5125) // 4byte FLOAT or INT\n                    {\n                        stride = stride || 4;\n\n                        const isInt = acc.componentType == 5125;\n                        if (isInt)dataBuff = new Uint32Array(num);\n                        else dataBuff = new Float32Array(num);\n\n                        dataBuff.cblStride = numComps;\n\n                        for (j = 0; j < num; j++)\n                        {\n                            if (isInt) dataBuff[j] = chunks[1].dataView.getUint32(accPos, le);\n                            else dataBuff[j] = chunks[1].dataView.getFloat32(accPos, le);\n\n                            if (stride != 4 && (j + 1) % numComps === 0)accPos += stride - (numComps * 4);\n                            accPos += 4;\n                        }\n                    }\n                    else if (acc.componentType == 5123) // UNSIGNED_SHORT\n                    {\n                        stride = stride || 2;\n\n                        dataBuff = new Uint16Array(num);\n                        dataBuff.cblStride = stride;\n\n                        for (j = 0; j < num; j++)\n                        {\n                            dataBuff[j] = chunks[1].dataView.getUint16(accPos, le);\n\n                            if (stride != 2 && (j + 1) % numComps === 0) accPos += stride - (numComps * 2);\n\n                            accPos += 2;\n                        }\n                    }\n                    else if (acc.componentType == 5121) // UNSIGNED_BYTE\n                    {\n                        stride = stride || 1;\n\n                        dataBuff = new Uint8Array(num);\n                        dataBuff.cblStride = stride;\n\n                        for (j = 0; j < num; j++)\n                        {\n                            dataBuff[j] = chunks[1].dataView.getUint8(accPos, le);\n\n                            if (stride != 1 && (j + 1) % numComps === 0) accPos += stride - (numComps * 1);\n\n                            accPos += 1;\n                        }\n                    }\n\n                    else\n                    {\n                        console.error("unknown component type", acc.componentType);\n                    }\n\n                    gltf.accBuffers.push(dataBuff);\n                }\n                else\n                {\n                    // console.log("has no dataview");\n                }\n            }\n        }\n    }\n\n    gltf.timing.push(["Parse mesh groups", Math.round((performance.now() - gltf.startTime))]);\n\n    gltf.json.meshes = gltf.json.meshes || [];\n\n    if (gltf.json.meshes)\n    {\n        for (i = 0; i < gltf.json.meshes.length; i++)\n        {\n            const mesh = new gltfMeshGroup(gltf, gltf.json.meshes[i]);\n            gltf.meshes.push(mesh);\n        }\n    }\n\n    gltf.timing.push(["Parse nodes", Math.round((performance.now() - gltf.startTime))]);\n\n    for (i = 0; i < gltf.json.nodes.length; i++)\n    {\n        if (gltf.json.nodes[i].children)\n            for (j = 0; j < gltf.json.nodes[i].children.length; j++)\n            {\n                gltf.json.nodes[gltf.json.nodes[i].children[j]].isChild = true;\n            }\n    }\n\n    for (i = 0; i < gltf.json.nodes.length; i++)\n    {\n        const node = new gltfNode(gltf.json.nodes[i], gltf);\n        gltf.nodes.push(node);\n    }\n\n    for (i = 0; i < gltf.nodes.length; i++)\n    {\n        const node = gltf.nodes[i];\n\n        if (!node.children) continue;\n        for (let j = 0; j < node.children.length; j++)\n        {\n            gltf.nodes[node.children[j]].parent = node;\n        }\n    }\n\n    for (i = 0; i < gltf.nodes.length; i++)\n    {\n        gltf.nodes[i].initSkin();\n    }\n\n    needsMatUpdate = true;\n\n    gltf.timing.push(["load anims", Math.round((performance.now() - gltf.startTime))]);\n\n    if (gltf.json.animations) loadAnims(gltf);\n\n    gltf.timing.push(["load cameras", Math.round((performance.now() - gltf.startTime))]);\n\n    if (gltf.json.cameras) loadCams(gltf);\n\n    gltf.timing.push(["finished", Math.round((performance.now() - gltf.startTime))]);\n    return gltf;\n}\n',
    inc_mesh_js:
      'let gltfMesh = class\n{\n    constructor(name, prim, gltf, finished)\n    {\n        this.POINTS = 0;\n        this.LINES = 1;\n        this.LINE_LOOP = 2;\n        this.LINE_STRIP = 3;\n        this.TRIANGLES = 4;\n        this.TRIANGLE_STRIP = 5;\n        this.TRIANGLE_FAN = 6;\n\n        this.test = 0;\n        this.name = name;\n        this.submeshIndex = 0;\n        this.material = prim.material;\n        // console.log(prim);\n        this.mesh = null;\n        this.geom = new CGL.Geometry("gltf_" + this.name);\n        this.geom.verticesIndices = [];\n        this.bounds = null;\n        this.primitive = 4;\n        this.morphTargetsRenderMod = null;\n        this.weights = prim.weights;\n\n        if (prim.hasOwnProperty("mode")) this.primitive = prim.mode;\n\n        if (prim.hasOwnProperty("indices")) this.geom.verticesIndices = gltf.accBuffers[prim.indices];\n\n        gltf.loadingMeshes = gltf.loadingMeshes || 0;\n        gltf.loadingMeshes++;\n\n        this.materialJson =\n            this._matPbrMetalness =\n            this._matPbrRoughness =\n            this._matDiffuseColor = null;\n\n        if (gltf.json.materials)\n        {\n            if (this.material != -1) this.materialJson = gltf.json.materials[this.material];\n\n            if (this.materialJson && this.materialJson.pbrMetallicRoughness)\n            {\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("baseColorFactor"))\n                {\n                    this._matDiffuseColor = [1, 1, 1, 1];\n                }\n                else\n                {\n                    this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;\n                }\n\n                this._matDiffuseColor = this.materialJson.pbrMetallicRoughness.baseColorFactor;\n\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("metallicFactor"))\n                {\n                    this._matPbrMetalness = 1.0;\n                }\n                else\n                {\n                    this._matPbrMetalness = this.materialJson.pbrMetallicRoughness.metallicFactor || null;\n                }\n\n                if (!this.materialJson.pbrMetallicRoughness.hasOwnProperty("roughnessFactor"))\n                {\n                    this._matPbrRoughness = 1.0;\n                }\n                else\n                {\n                    this._matPbrRoughness = this.materialJson.pbrMetallicRoughness.roughnessFactor || null;\n                }\n            }\n        }\n\n        if (gltf.useDraco && prim.extensions.KHR_draco_mesh_compression)\n        {\n            const view = gltf.chunks[0].data.bufferViews[prim.extensions.KHR_draco_mesh_compression.bufferView];\n            const num = view.byteLength;\n            const dataBuff = new Int8Array(num);\n            let accPos = (view.byteOffset || 0);// + (acc.byteOffset || 0);\n            for (let j = 0; j < num; j++)\n            {\n                dataBuff[j] = gltf.chunks[1].dataView.getInt8(accPos, le);\n                accPos++;\n            }\n\n            const dracoDecoder = window.DracoDecoder;\n            dracoDecoder.decodeGeometry(dataBuff.buffer, (geometry) =>\n            {\n                const geom = new CGL.Geometry("draco mesh " + name);\n\n                for (let i = 0; i < geometry.attributes.length; i++)\n                {\n                    const attr = geometry.attributes[i];\n\n                    if (attr.name === "position") geom.vertices = attr.array;\n                    else if (attr.name === "normal") geom.vertexNormals = attr.array;\n                    else if (attr.name === "uv") geom.texCoords = attr.array;\n                    else if (attr.name === "color") geom.vertexColors = this.calcVertexColors(attr.array);\n                    else if (attr.name === "joints") geom.setAttribute("attrJoints", Array.from(attr.array), 4);\n                    else if (attr.name === "weights")\n                    {\n                        const arr4 = new Float32Array(attr.array.length / attr.itemSize * 4);\n\n                        for (let k = 0; k < attr.array.length / attr.itemSize; k++)\n                        {\n                            arr4[k * 4] = arr4[k * 4 + 1] = arr4[k * 4 + 2] = arr4[k * 4 + 3] = 0;\n                            for (let j = 0; j < attr.itemSize; j++)\n                                arr4[k * 4 + j] = attr.array[k * attr.itemSize + j];\n                        }\n                        geom.setAttribute("attrWeights", arr4, 4);\n                    }\n                    else op.logWarn("unknown draco attrib", attr);\n                }\n\n                geometry.attributes = null;\n                geom.verticesIndices = geometry.index.array;\n\n                this.setGeom(geom);\n\n                this.mesh = null;\n                gltf.loadingMeshes--;\n                gltf.timing.push(["draco decode", Math.round((performance.now() - gltf.startTime))]);\n\n                if (finished)finished(this);\n            }, (error) => { op.logError(error); });\n        }\n        else\n        {\n            gltf.loadingMeshes--;\n            this.fillGeomAttribs(gltf, this.geom, prim.attributes);\n\n            if (prim.targets)\n            {\n                for (let j = 0; j < prim.targets.length; j++)\n                {\n                    const tgeom = new CGL.Geometry("gltf_target_" + j);\n\n                    // if (prim.hasOwnProperty("indices")) tgeom.verticesIndices = gltf.accBuffers[prim.indices];\n\n                    this.fillGeomAttribs(gltf, tgeom, prim.targets[j], false);\n\n                    // { // calculate normals for final position of morphtarget for later...\n                    //     for (let i = 0; i < tgeom.vertices.length; i++) tgeom.vertices[i] += this.geom.vertices[i];\n                    //     tgeom.calculateNormals();\n                    //     for (let i = 0; i < tgeom.vertices.length; i++) tgeom.vertices[i] -= this.geom.vertices[i];\n                    // }\n\n                    this.geom.morphTargets.push(tgeom);\n                }\n            }\n            if (finished)finished(this);\n        }\n    }\n\n    _linearToSrgb(x)\n    {\n        if (x <= 0)\n            return 0;\n        else if (x >= 1)\n            return 1;\n        else if (x < 0.0031308)\n            return x * 12.92;\n        else\n            return x ** (1 / 2.2) * 1.055 - 0.055;\n    }\n\n    calcVertexColors(arr, type)\n    {\n        let vertexColors = null;\n        if (arr instanceof Float32Array)\n        {\n            let div = false;\n            for (let i = 0; i < arr.length; i++)\n            {\n                if (arr[i] > 1)\n                {\n                    div = true;\n                    continue;\n                }\n            }\n\n            if (div)\n                for (let i = 0; i < arr.length; i++) arr[i] /= 65535;\n\n            vertexColors = arr;\n        }\n\n        else if (arr instanceof Uint16Array)\n        {\n            const fb = new Float32Array(arr.length);\n            for (let i = 0; i < arr.length; i++) fb[i] = arr[i] / 65535;\n\n            vertexColors = fb;\n        }\n        else vertexColors = arr;\n\n        for (let i = 0; i < vertexColors.length; i++)\n        {\n            vertexColors[i] = this._linearToSrgb(vertexColors[i]);\n        }\n\n        console.log("arr.cblStride", arr.cblStride);\n        if (arr.cblStride == 3)\n        {\n            const nc = new Float32Array(vertexColors.length / 3 * 4);\n            for (let i = 0; i < vertexColors.length / 3; i++)\n            {\n                nc[i * 4 + 0] = vertexColors[i * 3 + 0];\n                nc[i * 4 + 1] = vertexColors[i * 3 + 1];\n                nc[i * 4 + 2] = vertexColors[i * 3 + 2];\n                nc[i * 4 + 3] = 1;\n            }\n            vertexColors = nc;\n        }\n\n        return vertexColors;\n    }\n\n    fillGeomAttribs(gltf, tgeom, attribs, setGeom)\n    {\n        if (attribs.hasOwnProperty("POSITION")) tgeom.vertices = gltf.accBuffers[attribs.POSITION];\n        if (attribs.hasOwnProperty("NORMAL")) tgeom.vertexNormals = gltf.accBuffers[attribs.NORMAL];\n        if (attribs.hasOwnProperty("TANGENT")) tgeom.tangents = gltf.accBuffers[attribs.TANGENT];\n\n        // // console.log(gltf.accBuffers[attribs.COLOR_0])\n        // console.log(gltf);\n\n        if (attribs.hasOwnProperty("COLOR_0")) tgeom.vertexColors = this.calcVertexColors(gltf.accBuffers[attribs.COLOR_0], gltf.accBuffers[attribs.COLOR_0].type);\n        if (attribs.hasOwnProperty("COLOR_1")) tgeom.setAttribute("attrVertColor1", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_1]), gltf.accBuffers[attribs.COLOR_1].type);\n        if (attribs.hasOwnProperty("COLOR_2")) tgeom.setAttribute("attrVertColor2", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_2]), gltf.accBuffers[attribs.COLOR_2].type);\n        if (attribs.hasOwnProperty("COLOR_3")) tgeom.setAttribute("attrVertColor3", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_3]), gltf.accBuffers[attribs.COLOR_3].type);\n        if (attribs.hasOwnProperty("COLOR_4")) tgeom.setAttribute("attrVertColor4", this.calcVertexColors(gltf.accBuffers[attribs.COLOR_4]), gltf.accBuffers[attribs.COLOR_4].type);\n\n        if (attribs.hasOwnProperty("TEXCOORD_0")) tgeom.texCoords = gltf.accBuffers[attribs.TEXCOORD_0];\n        if (attribs.hasOwnProperty("TEXCOORD_1")) tgeom.setAttribute("attrTexCoord1", gltf.accBuffers[attribs.TEXCOORD_1], 2);\n        if (attribs.hasOwnProperty("TEXCOORD_2")) tgeom.setAttribute("attrTexCoord2", gltf.accBuffers[attribs.TEXCOORD_2], 2);\n        if (attribs.hasOwnProperty("TEXCOORD_3")) tgeom.setAttribute("attrTexCoord3", gltf.accBuffers[attribs.TEXCOORD_3], 2);\n        if (attribs.hasOwnProperty("TEXCOORD_4")) tgeom.setAttribute("attrTexCoord4", gltf.accBuffers[attribs.TEXCOORD_4], 2);\n\n        if (attribs.hasOwnProperty("WEIGHTS_0"))\n        {\n            tgeom.setAttribute("attrWeights", gltf.accBuffers[attribs.WEIGHTS_0], 4);\n        }\n        if (attribs.hasOwnProperty("JOINTS_0"))\n        {\n            if (!gltf.accBuffers[attribs.JOINTS_0])console.log("no !gltf.accBuffers[attribs.JOINTS_0]");\n            tgeom.setAttribute("attrJoints", gltf.accBuffers[attribs.JOINTS_0], 4);\n        }\n\n        if (attribs.hasOwnProperty("POSITION")) gltf.accBuffersDelete.push(attribs.POSITION);\n        if (attribs.hasOwnProperty("NORMAL")) gltf.accBuffersDelete.push(attribs.NORMAL);\n        if (attribs.hasOwnProperty("TEXCOORD_0")) gltf.accBuffersDelete.push(attribs.TEXCOORD_0);\n        if (attribs.hasOwnProperty("TANGENT")) gltf.accBuffersDelete.push(attribs.TANGENT);\n        if (attribs.hasOwnProperty("COLOR_0"))gltf.accBuffersDelete.push(attribs.COLOR_0);\n        if (attribs.hasOwnProperty("COLOR_0"))gltf.accBuffersDelete.push(attribs.COLOR_0);\n        if (attribs.hasOwnProperty("COLOR_1"))gltf.accBuffersDelete.push(attribs.COLOR_1);\n        if (attribs.hasOwnProperty("COLOR_2"))gltf.accBuffersDelete.push(attribs.COLOR_2);\n        if (attribs.hasOwnProperty("COLOR_3"))gltf.accBuffersDelete.push(attribs.COLOR_3);\n\n        if (attribs.hasOwnProperty("TEXCOORD_1")) gltf.accBuffersDelete.push(attribs.TEXCOORD_1);\n        if (attribs.hasOwnProperty("TEXCOORD_2")) gltf.accBuffersDelete.push(attribs.TEXCOORD_2);\n        if (attribs.hasOwnProperty("TEXCOORD_3")) gltf.accBuffersDelete.push(attribs.TEXCOORD_3);\n        if (attribs.hasOwnProperty("TEXCOORD_4")) gltf.accBuffersDelete.push(attribs.TEXCOORD_4);\n\n        if (setGeom !== false) if (tgeom && tgeom.verticesIndices) this.setGeom(tgeom);\n    }\n\n    setGeom(geom)\n    {\n        if (inNormFormat.get() == "X-ZY")\n        {\n            for (let i = 0; i < geom.vertexNormals.length; i += 3)\n            {\n                let t = geom.vertexNormals[i + 2];\n                geom.vertexNormals[i + 2] = geom.vertexNormals[i + 1];\n                geom.vertexNormals[i + 1] = -t;\n            }\n        }\n\n        if (inVertFormat.get() == "XZ-Y")\n        {\n            for (let i = 0; i < geom.vertices.length; i += 3)\n            {\n                let t = geom.vertices[i + 2];\n                geom.vertices[i + 2] = -geom.vertices[i + 1];\n                geom.vertices[i + 1] = t;\n            }\n        }\n\n        if (this.primitive == this.TRIANGLES)\n        {\n            if (inCalcNormals.get() == "Force Smooth" || inCalcNormals.get() == false) geom.calculateNormals();\n            else if (!geom.vertexNormals.length && inCalcNormals.get() == "Auto") geom.calculateNormals({ "smooth": false });\n\n            if ((!geom.biTangents || geom.biTangents.length == 0) && geom.tangents)\n            {\n                const bitan = vec3.create();\n                const tan = vec3.create();\n\n                const tangents = geom.tangents;\n                geom.tangents = new Float32Array(tangents.length / 4 * 3);\n                geom.biTangents = new Float32Array(tangents.length / 4 * 3);\n\n                for (let i = 0; i < tangents.length; i += 4)\n                {\n                    const idx = i / 4 * 3;\n\n                    vec3.cross(\n                        bitan,\n                        [geom.vertexNormals[idx], geom.vertexNormals[idx + 1], geom.vertexNormals[idx + 2]],\n                        [tangents[i], tangents[i + 1], tangents[i + 2]]\n                    );\n\n                    vec3.div(bitan, bitan, [tangents[i + 3], tangents[i + 3], tangents[i + 3]]);\n                    vec3.normalize(bitan, bitan);\n\n                    geom.biTangents[idx + 0] = bitan[0];\n                    geom.biTangents[idx + 1] = bitan[1];\n                    geom.biTangents[idx + 2] = bitan[2];\n\n                    geom.tangents[idx + 0] = tangents[i + 0];\n                    geom.tangents[idx + 1] = tangents[i + 1];\n                    geom.tangents[idx + 2] = tangents[i + 2];\n                }\n            }\n\n            if (geom.tangents.length === 0 || inCalcNormals.get() != "Never")\n            {\n                // console.log("[gltf ]no tangents... calculating tangents...");\n                geom.calcTangentsBitangents();\n            }\n        }\n\n        this.geom = geom;\n\n        this.bounds = geom.getBounds();\n    }\n\n    render(cgl, ignoreMaterial, skinRenderer)\n    {\n        if (!this.mesh && this.geom && this.geom.verticesIndices)\n        {\n            let g = this.geom;\n            if (this.geom.vertices.length / 3 > 64000)\n            {\n                g = this.geom.copy();\n                g.unIndex(false, true);\n            }\n\n            let glprim;\n\n            if (cgl.gl)\n            {\n                if (this.primitive == this.TRIANGLES)glprim = cgl.gl.TRIANGLES;\n                else if (this.primitive == this.LINES)glprim = cgl.gl.LINES;\n                else if (this.primitive == this.LINE_STRIP)glprim = cgl.gl.LINE_STRIP;\n                else if (this.primitive == this.POINTS)glprim = cgl.gl.POINTS;\n                else\n                {\n                    op.logWarn("unknown primitive type", this);\n                }\n            }\n\n            this.mesh = op.patch.cg.createMesh(g, { "glPrimitive": glprim });\n        }\n\n        if (this.mesh)\n        {\n            // update morphTargets\n            if (this.geom && this.geom.morphTargets.length && !this.morphTargetsRenderMod)\n            {\n                this.mesh.addVertexNumbers = true;\n                this.morphTargetsRenderMod = new GltfTargetsRenderer(this);\n            }\n\n            let useMat = !ignoreMaterial && this.material != -1 && gltf.shaders[this.material];\n            if (skinRenderer)useMat = false;\n\n            if (useMat) cgl.pushShader(gltf.shaders[this.material]);\n\n            const currentShader = cgl.getShader() || {};\n            const uniDiff = currentShader.uniformColorDiffuse;\n\n            const uniPbrMetalness = currentShader.uniformPbrMetalness;\n            const uniPbrRoughness = currentShader.uniformPbrRoughness;\n\n            // if (gltf.shaders[this.material] && !inUseMatProps.get())\n            // {\n            //     gltf.shaders[this.material]=null;\n            // }\n\n            if (!gltf.shaders[this.material] && inUseMatProps.get())\n            {\n                if (uniDiff && this._matDiffuseColor)\n                {\n                    this._matDiffuseColorOrig = [uniDiff.getValue()[0], uniDiff.getValue()[1], uniDiff.getValue()[2], uniDiff.getValue()[3]];\n                    uniDiff.setValue(this._matDiffuseColor);\n                }\n\n                if (uniPbrMetalness)\n                    if (this._matPbrMetalness != null)\n                    {\n                        this._matPbrMetalnessOrig = uniPbrMetalness.getValue();\n                        uniPbrMetalness.setValue(this._matPbrMetalness);\n                    }\n                    else\n                        uniPbrMetalness.setValue(0);\n\n                if (uniPbrRoughness)\n                    if (this._matPbrRoughness != null)\n                    {\n                        this._matPbrRoughnessOrig = uniPbrRoughness.getValue();\n                        uniPbrRoughness.setValue(this._matPbrRoughness);\n                    }\n                    else\n                    {\n                        uniPbrRoughness.setValue(0);\n                    }\n            }\n\n            if (this.morphTargetsRenderMod) this.morphTargetsRenderMod.renderStart(cgl, 0);\n            if (this.mesh)\n            {\n                // console.log(this.mesh)\n                // this.mesh.lastMaterial=0;\n                this.mesh.render(cgl.getShader(), ignoreMaterial);\n            }\n            if (this.morphTargetsRenderMod) this.morphTargetsRenderMod.renderFinish(cgl);\n\n            if (inUseMatProps.get())\n            {\n                if (uniDiff && this._matDiffuseColor) uniDiff.setValue(this._matDiffuseColorOrig);\n                if (uniPbrMetalness && this._matPbrMetalnessOrig != undefined) uniPbrMetalness.setValue(this._matPbrMetalnessOrig);\n                if (uniPbrRoughness && this._matPbrRoughnessOrig != undefined) uniPbrRoughness.setValue(this._matPbrRoughnessOrig);\n            }\n\n            if (useMat) cgl.popShader();\n        }\n    }\n};\n',
    inc_meshGroup_js:
      "const gltfMeshGroup = class\n{\n    constructor(gltf, m)\n    {\n        this.bounds = new CABLES.CG.BoundingBox();\n        this.meshes = [];\n        this.name = m.name;\n        const prims = m.primitives;\n\n        for (let i = 0; i < prims.length; i++)\n        {\n            const mesh = new gltfMesh(this.name, prims[i], gltf,\n                (mesh) =>\n                {\n                    mesh.extras = m.extras;\n                    this.bounds.apply(mesh.bounds);\n                });\n\n            mesh.submeshIndex = i;\n            this.meshes.push(mesh);\n        }\n    }\n\n    render(cgl, ignoreMat, skinRenderer, _time, weights)\n    {\n        for (let i = 0; i < this.meshes.length; i++)\n        {\n            const useMat = gltf.shaders[this.meshes[i].material];\n\n            if (!ignoreMat && useMat) cgl.pushShader(gltf.shaders[this.meshes[i].material]);\n            // console.log(gltf.shaders[this.meshes[i].material],this.meshes[i].material)\n            if (skinRenderer)skinRenderer.renderStart(cgl, _time);\n            if (weights) this.meshes[i].weights = weights;\n            this.meshes[i].render(cgl, ignoreMat, skinRenderer, _time);\n            if (skinRenderer)skinRenderer.renderFinish(cgl);\n            if (!ignoreMat && useMat) cgl.popShader();\n        }\n    }\n};\n",
    inc_node_js:
      'const gltfNode = class\n{\n    constructor(node, gltf)\n    {\n        this.isChild = node.isChild || false;\n        this.name = node.name;\n        if (node.hasOwnProperty("camera")) this.camera = node.camera;\n        this.hidden = false;\n        this.mat = mat4.create();\n        this._animActions = {};\n        this.animWeights = [];\n        this._animMat = mat4.create();\n        this._tempMat = mat4.create();\n        this._tempQuat = quat.create();\n        this._tempRotmat = mat4.create();\n        this.mesh = null;\n        this.children = [];\n        this._node = node;\n        this._gltf = gltf;\n        this.absMat = mat4.create();\n        this.addTranslate = null;\n        this._tempAnimScale = null;\n        this.addMulMat = null;\n        this.updateMatrix();\n        this.skinRenderer = null;\n        this.copies = [];\n    }\n\n    get skin()\n    {\n        if (this._node.hasOwnProperty("skin")) return this._node.skin;\n        else return -1;\n    }\n\n    copy()\n    {\n        this.isCopy = true;\n        const n = new gltfNode(this._node, this._gltf);\n        n.copyOf = this;\n\n        n._animActions = this._animActions;\n        n.children = this.children;\n        if (this.skin) n.skinRenderer = new GltfSkin(this);\n\n        this.updateMatrix();\n        return n;\n    }\n\n    hasSkin()\n    {\n        if (this._node.hasOwnProperty("skin")) return this._gltf.json.skins[this._node.skin].name || "unknown";\n        return false;\n    }\n\n    initSkin()\n    {\n        if (this.skin > -1)\n        {\n            this.skinRenderer = new GltfSkin(this);\n        }\n    }\n\n    updateMatrix()\n    {\n        mat4.identity(this.mat);\n        if (this._node.translation) mat4.translate(this.mat, this.mat, this._node.translation);\n\n        if (this._node.rotation)\n        {\n            const rotmat = mat4.create();\n            this._rot = this._node.rotation;\n\n            mat4.fromQuat(rotmat, this._node.rotation);\n            mat4.mul(this.mat, this.mat, rotmat);\n        }\n\n        if (this._node.scale)\n        {\n            this._scale = this._node.scale;\n            mat4.scale(this.mat, this.mat, this._scale);\n        }\n\n        if (this._node.hasOwnProperty("mesh"))\n        {\n            this.mesh = this._gltf.meshes[this._node.mesh];\n            if (this.isCopy)\n            {\n                // console.log(this.mesh);\n            }\n        }\n\n        if (this._node.children)\n        {\n            for (let i = 0; i < this._node.children.length; i++)\n            {\n                this._gltf.json.nodes[i].isChild = true;\n                if (this._gltf.nodes[this._node.children[i]]) this._gltf.nodes[this._node.children[i]].isChild = true;\n                this.children.push(this._node.children[i]);\n            }\n        }\n    }\n\n    unHide()\n    {\n        this.hidden = false;\n        for (let i = 0; i < this.children.length; i++)\n            if (this.children[i].unHide) this.children[i].unHide();\n    }\n\n    calcBounds(gltf, mat, bounds)\n    {\n        const localMat = mat4.create();\n\n        if (mat) mat4.copy(localMat, mat);\n        if (this.mat) mat4.mul(localMat, localMat, this.mat);\n\n        if (this.mesh)\n        {\n            const bb = this.mesh.bounds.copy();\n            bb.mulMat4(localMat);\n            bounds.apply(bb);\n\n            if (bounds.changed)\n            {\n                boundingPoints.push(\n                    bb._min[0] || 0, bb._min[1] || 0, bb._min[2] || 0,\n                    bb._max[0] || 0, bb._max[1] || 0, bb._max[2] || 0);\n            }\n        }\n\n        for (let i = 0; i < this.children.length; i++)\n        {\n            if (gltf.nodes[this.children[i]] && gltf.nodes[this.children[i]].calcBounds)\n            {\n                const b = gltf.nodes[this.children[i]].calcBounds(gltf, localMat, bounds);\n\n                bounds.apply(b);\n            }\n        }\n\n        if (bounds.changed) return bounds;\n        else return null;\n    }\n\n    setAnimAction(name)\n    {\n        // console.log("setAnimAction:", name);\n        if (!name) return;\n\n        this._currentAnimaction = name;\n\n        if (name && !this._animActions[name])\n        {\n            // console.log("no action found:", name,this._animActions);\n            return null;\n        }\n\n        // else console.log("YES action found:", name);\n        // console.log(this._animActions);\n\n        for (let path in this._animActions[name])\n        {\n            if (path == "translation") this._animTrans = this._animActions[name][path];\n            else if (path == "rotation") this._animRot = this._animActions[name][path];\n            else if (path == "scale") this._animScale = this._animActions[name][path];\n            else if (path == "weights") this.animWeights = this._animActions[name][path];\n            else console.log("[gltfNode] unknown anim path", path, this._animActions[name][path]);\n        }\n    }\n\n    setAnim(path, name, anims)\n    {\n        if (!path || !name || !anims) return;\n\n        // console.log("setanim", this._node.name, path, name, anims);\n\n        this._animActions[name] = this._animActions[name] || {};\n\n        // console.log(this._animActions);\n        // debugger;\n\n        // for (let i = 0; i < this.copies.length; i++) this.copies[i]._animActions = this._animActions;\n\n        if (this._animActions[name][path]) op.log("[gltfNode] animation action path already exists", name, path, this._animActions[name][path]);\n\n        this._animActions[name][path] = anims;\n\n        if (path == "translation") this._animTrans = anims;\n        else if (path == "rotation") this._animRot = anims;\n        else if (path == "scale") this._animScale = anims;\n        else if (path == "weights")\n        {\n            // console.log("weights",name,path,anims)\n            this.animWeights = this._animActions[name][path];\n            // console.log(this.animWeights);\n        }\n        else console.warn("unknown anim path", path, anims);\n    }\n\n    modelMatLocal()\n    {\n        return this._animMat || this.mat;\n    }\n\n    modelMatAbs()\n    {\n        return this.absMat;\n    }\n\n    transform(cgl, _time)\n    {\n        if (!_time && _time != 0)_time = time;\n\n        this._lastTimeTrans = _time;\n\n        // console.log(this._rot)\n\n        gltfTransforms++;\n\n        if (!this._animTrans && !this._animRot && !this._animScale)\n        {\n            mat4.mul(cgl.mMatrix, cgl.mMatrix, this.mat);\n            this._animMat = null;\n        }\n        else\n        {\n            this._animMat = this._animMat || mat4.create();\n            mat4.identity(this._animMat);\n\n            const playAnims = true;\n\n            if (playAnims && this._animTrans)\n            {\n                mat4.translate(this._animMat, this._animMat, [\n                    this._animTrans[0].getValue(_time),\n                    this._animTrans[1].getValue(_time),\n                    this._animTrans[2].getValue(_time)]);\n            }\n            else\n            if (this._node.translation) mat4.translate(this._animMat, this._animMat, this._node.translation);\n\n            if (playAnims && this._animRot)\n            {\n                if (this._animRot[0].defaultEasing == CABLES.EASING_LINEAR) CABLES.Anim.slerpQuaternion(_time, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);\n                else if (this._animRot[0].defaultEasing == CABLES.EASING_ABSOLUTE)\n                {\n                    this._tempQuat[0] = this._animRot[0].getValue(_time);\n                    this._tempQuat[1] = this._animRot[1].getValue(_time);\n                    this._tempQuat[2] = this._animRot[2].getValue(_time);\n                    this._tempQuat[3] = this._animRot[3].getValue(_time);\n                }\n                else if (this._animRot[0].defaultEasing == CABLES.EASING_CUBICSPLINE)\n                {\n                    CABLES.Anim.slerpQuaternion(_time, this._tempQuat, this._animRot[0], this._animRot[1], this._animRot[2], this._animRot[3]);\n                }\n\n                mat4.fromQuat(this._tempMat, this._tempQuat);\n                mat4.mul(this._animMat, this._animMat, this._tempMat);\n            }\n            else if (this._rot)\n            {\n                mat4.fromQuat(this._tempRotmat, this._rot);\n                mat4.mul(this._animMat, this._animMat, this._tempRotmat);\n            }\n\n            if (playAnims && this._animScale)\n            {\n                if (!this._tempAnimScale) this._tempAnimScale = [1, 1, 1];\n                this._tempAnimScale[0] = this._animScale[0].getValue(_time);\n                this._tempAnimScale[1] = this._animScale[1].getValue(_time);\n                this._tempAnimScale[2] = this._animScale[2].getValue(_time);\n                mat4.scale(this._animMat, this._animMat, this._tempAnimScale);\n            }\n            else if (this._scale) mat4.scale(this._animMat, this._animMat, this._scale);\n\n            mat4.mul(cgl.mMatrix, cgl.mMatrix, this._animMat);\n        }\n\n        if (this.animWeights)\n        {\n            this.weights = this.weights || [];\n\n            let str = "";\n            for (let i = 0; i < this.animWeights.length; i++)\n            {\n                this.weights[i] = this.animWeights[i].getValue(_time);\n                str += this.weights[i] + "/";\n            }\n\n            // console.log(str);\n            // this.mesh.weights=this.animWeights.get(_time);\n            // console.log(this.animWeights);\n        }\n\n        if (this.addTranslate) mat4.translate(cgl.mMatrix, cgl.mMatrix, this.addTranslate);\n\n        if (this.addMulMat) mat4.mul(cgl.mMatrix, cgl.mMatrix, this.addMulMat);\n\n        mat4.copy(this.absMat, cgl.mMatrix);\n    }\n\n    render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time)\n    {\n        if (!dontTransform) cgl.pushModelMatrix();\n\n        if (_time === undefined) _time = gltf.time;\n\n        if (!dontTransform || this.skinRenderer) this.transform(cgl, _time);\n\n        if (this.hidden && !drawHidden)\n        {\n        }\n        else\n        {\n            if (this.skinRenderer)\n            {\n                this.skinRenderer.time = _time;\n                if (!dontDrawMesh)\n                    this.mesh.render(cgl, ignoreMaterial, this.skinRenderer, _time, this.weights);\n            }\n            else\n            {\n                if (this.mesh && !dontDrawMesh)\n                    this.mesh.render(cgl, ignoreMaterial, null, _time, this.weights);\n            }\n        }\n\n        if (!ignoreChilds && !this.hidden)\n            for (let i = 0; i < this.children.length; i++)\n                if (gltf.nodes[this.children[i]])\n                    gltf.nodes[this.children[i]].render(cgl, dontTransform, dontDrawMesh, ignoreMaterial, ignoreChilds, drawHidden, _time);\n\n        if (!dontTransform)cgl.popModelMatrix();\n    }\n};\n',
    inc_print_js:
      'let tab = null;\n\nfunction closeTab()\n{\n    if (tab)gui.mainTabs.closeTab(tab.id);\n    tab = null;\n}\n\nfunction formatVec(arr)\n{\n    const nums = [];\n    for (let i = 0; i < arr.length; i++)\n    {\n        nums.push(Math.round(arr[i] * 1000) / 1000);\n    }\n\n    return nums.join(",");\n}\n\nfunction printNode(html, node, level)\n{\n    if (!gltf) return;\n\n    html += "<tr class=\\"row\\">";\n\n    let ident = "";\n    let identSpace = "";\n\n    for (let i = 1; i < level; i++)\n    {\n        identSpace += "&nbsp;&nbsp;&nbsp;";\n        let identClass = "identBg";\n        if (i == 1)identClass = "identBgLevel0";\n        ident += "<td class=\\"ident " + identClass + "\\" ><div style=\\"\\"></div></td>";\n    }\n    let id = CABLES.uuid();\n    html += ident;\n    html += "<td colspan=\\"" + (21 - level) + "\\">";\n\n    if (node.mesh && node.mesh.meshes.length)html += "<span class=\\"icon icon-cube\\"></span>&nbsp;";\n    else html += "<span class=\\"icon icon-box-select\\"></span> &nbsp;";\n\n    html += node.name + "</td><td></td>";\n\n    if (node.mesh)\n    {\n        html += "<td>";\n        for (let i = 0; i < node.mesh.meshes.length; i++)\n        {\n            if (i > 0)html += ", ";\n            html += node.mesh.meshes[i].name;\n        }\n\n        html += "</td>";\n\n        html += "<td>";\n        html += node.hasSkin() || "-";\n        html += "</td>";\n\n        html += "<td>";\n        let countMats = 0;\n        for (let i = 0; i < node.mesh.meshes.length; i++)\n        {\n            if (countMats > 0)html += ", ";\n            if (gltf.json.materials && node.mesh.meshes[i].hasOwnProperty("material"))\n            {\n                if (gltf.json.materials[node.mesh.meshes[i].material])\n                {\n                    html += gltf.json.materials[node.mesh.meshes[i].material].name;\n                    countMats++;\n                }\n            }\n        }\n        if (countMats == 0)html += "none";\n        html += "</td>";\n    }\n    else\n    {\n        html += "<td>-</td><td>-</td><td>-</td>";\n    }\n\n    html += "<td>";\n\n    if (node._node.translation || node._node.rotation || node._node.scale)\n    {\n        let info = "";\n\n        if (node._node.translation)info += "Translate: `" + formatVec(node._node.translation) + "` || ";\n        if (node._node.rotation)info += "Rotation: `" + formatVec(node._node.rotation) + "` || ";\n        if (node._node.scale)info += "Scale: `" + formatVec(node._node.scale) + "` || ";\n\n        html += "<span class=\\"icon icon-gizmo info\\" data-info=\\"" + info + "\\"></span> &nbsp;";\n    }\n\n    if (node._animRot || node._animScale || node._animTrans)\n    {\n        let info = "Animated: ";\n        if (node._animRot) info += "Rot ";\n        if (node._animScale) info += "Scale ";\n        if (node._animTrans) info += "Trans ";\n\n        html += "<span class=\\"icon icon-clock info\\" data-info=\\"" + info + "\\"></span>&nbsp;";\n    }\n\n    if (!node._node.translation && !node._node.rotation && !node._node.scale && !node._animRot && !node._animScale && !node._animTrans) html += "-";\n\n    html += "</td>";\n\n    html += "<td>";\n    let hideclass = "";\n    if (node.hidden)hideclass = "node-hidden";\n\n    // html+=\'\';\n    html += "<a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeNode(\'" + node.name + "\',\'transform\')\\" class=\\"treebutton\\">Transform</a>";\n    html += " <a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeNode(\'" + node.name + "\',\'hierarchy\')\\" class=\\"treebutton\\">Hierarchy</a>";\n    html += " <a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeNode(\'" + node.name + "\')\\" class=\\"treebutton\\">Node</a>";\n\n    if (node.hasSkin())\n        html += " <a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeNode(\'" + node.name + "\',false,{skin:true});\\" class=\\"treebutton\\">Skin</a>";\n\n    html += "</td><td>";\n    html += "&nbsp;<span class=\\"icon iconhover icon-eye " + hideclass + "\\" onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').toggleNodeVisibility(\'" + node.name + "\');this.classList.toggle(\'node-hidden\');\\"></span>";\n    html += "</td>";\n\n    html += "</tr>";\n\n    if (node.children)\n    {\n        for (let i = 0; i < node.children.length; i++)\n            html = printNode(html, gltf.nodes[node.children[i]], level + 1);\n    }\n\n    return html;\n}\n\nfunction printMaterial(mat, idx)\n{\n    let html = "<tr>";\n    html += " <td>" + idx + "</td>";\n    html += " <td>" + mat.name + "</td>";\n\n    html += " <td>";\n\n    const info = JSON.stringify(mat, null, 4).replaceAll("\\"", "").replaceAll("\\n", "<br/>");\n\n    html += "<span class=\\"icon icon-info\\" onclick=\\"new CABLES.UI.ModalDialog({ \'html\': \'<pre>" + info + "</pre>\', \'title\': \'" + mat.name + "\' });\\"></span>&nbsp;";\n\n    if (mat.pbrMetallicRoughness && mat.pbrMetallicRoughness.baseColorFactor)\n    {\n        let rgb = "";\n        rgb += "" + Math.round(mat.pbrMetallicRoughness.baseColorFactor[0] * 255);\n        rgb += "," + Math.round(mat.pbrMetallicRoughness.baseColorFactor[1] * 255);\n        rgb += "," + Math.round(mat.pbrMetallicRoughness.baseColorFactor[2] * 255);\n\n        html += "<div style=\\"width:15px;height:15px;background-color:rgb(" + rgb + ");display:inline-block\\">&nbsp;</a>";\n    }\n    html += " <td style=\\"\\">" + (gltf.shaders[idx] ? "-" : "<a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').assignMaterial(\'" + mat.name + "\')\\" class=\\"treebutton\\">Assign</a>") + "<td>";\n    html += "<td>";\n\n    html += "</tr>";\n    return html;\n}\n\nfunction printInfo()\n{\n    if (!gltf) return;\n\n    const startTime = performance.now();\n    const sizes = {};\n    let html = "<div style=\\"overflow:scroll;width:100%;height:100%\\">";\n\n    html += "File: <a href=\\"" + CABLES.platform.getCablesUrl() + "/asset/patches/?filename=" + inFile.get() + "\\" target=\\"_blank\\">" + CABLES.basename(inFile.get()) + "</a><br/>";\n\n    html += "Generator:" + gltf.json.asset.generator;\n\n    let numNodes = 0;\n    if (gltf.json.nodes)numNodes = gltf.json.nodes.length;\n    html += "<div id=\\"groupNodes\\">Nodes (" + numNodes + ")</div>";\n\n    html += "<table id=\\"sectionNodes\\" class=\\"table treetable\\">";\n\n    html += "<tr>";\n    html += " <th colspan=\\"21\\">Name</th>";\n    html += " <th>Mesh</th>";\n    html += " <th>Skin</th>";\n    html += " <th>Material</th>";\n    html += " <th>Transform</th>";\n    html += " <th>Expose</th>";\n    html += " <th></th>";\n    html += "</tr>";\n\n    for (let i = 0; i < gltf.nodes.length; i++)\n    {\n        if (!gltf.nodes[i].isChild)\n            html = printNode(html, gltf.nodes[i], 1);\n    }\n    html += "</table>";\n\n    // / //////////////////\n\n    let numMaterials = 0;\n    if (gltf.json.materials)numMaterials = gltf.json.materials.length;\n    html += "<div id=\\"groupMaterials\\">Materials (" + numMaterials + ")</div>";\n\n    if (!gltf.json.materials || gltf.json.materials.length == 0)\n    {\n    }\n    else\n    {\n        html += "<table id=\\"materialtable\\"  class=\\"table treetable\\">";\n        html += "<tr>";\n        html += " <th>Index</th>";\n        html += " <th>Name</th>";\n        html += " <th>Color</th>";\n        html += " <th>Function</th>";\n        html += " <th></th>";\n        html += "</tr>";\n        for (let i = 0; i < gltf.json.materials.length; i++)\n        {\n            html += printMaterial(gltf.json.materials[i], i);\n        }\n        html += "</table>";\n    }\n\n    // / ///////////////////////\n\n    html += "<div id=\\"groupMeshes\\">Meshes (" + gltf.json.meshes.length + ")</div>";\n\n    html += "<table id=\\"meshestable\\"  class=\\"table treetable\\">";\n    html += "<tr>";\n    html += " <th>Name</th>";\n    html += " <th>Node</th>";\n    html += " <th>Material</th>";\n    html += " <th>Vertices</th>";\n    html += " <th>Attributes</th>";\n    html += "</tr>";\n\n    let sizeBufferViews = [];\n    sizes.meshes = 0;\n    sizes.meshTargets = 0;\n\n    for (let i = 0; i < gltf.json.meshes.length; i++)\n    {\n        html += "<tr>";\n        html += "<td>" + gltf.json.meshes[i].name + "</td>";\n\n        html += "<td>";\n        let count = 0;\n        let nodename = "";\n        for (let j = 0; j < gltf.json.nodes.length; j++)\n        {\n            if (gltf.json.nodes[j].mesh == i)\n            {\n                count++;\n                if (count == 1)\n                {\n                    nodename = gltf.json.nodes[j].name;\n                }\n            }\n        }\n        if (count > 1) html += (count) + " nodes (" + nodename + " ...)";\n        else html += nodename;\n        html += "</td>";\n\n        // -------\n\n        html += "<td>";\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            if (gltf.json.meshes[i].primitives[j].hasOwnProperty("material"))\n            {\n                if (gltf.json.materials[gltf.json.meshes[i]])\n                {\n                    html += gltf.json.materials[gltf.json.meshes[i].primitives[j].material].name + " ";\n                }\n            }\n            else html += "None";\n        }\n        html += "</td>";\n\n        html += "<td>";\n        let numVerts = 0;\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            if (gltf.json.meshes[i].primitives[j].attributes.POSITION != undefined)\n            {\n                let v = parseInt(gltf.json.accessors[gltf.json.meshes[i].primitives[j].attributes.POSITION].count);\n                numVerts += v;\n                html += "" + v + "<br/>";\n            }\n            else html += "-<br/>";\n        }\n\n        if (gltf.json.meshes[i].primitives.length > 1)\n            html += "=" + numVerts;\n        html += "</td>";\n\n        html += "<td>";\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            html += Object.keys(gltf.json.meshes[i].primitives[j].attributes);\n            html += " <a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeGeom(\'" + gltf.json.meshes[i].name + "\'," + j + ")\\" class=\\"treebutton\\">Geometry</a>";\n            html += "<br/>";\n\n            if (gltf.json.meshes[i].primitives[j].targets)\n            {\n                html += gltf.json.meshes[i].primitives[j].targets.length + " targets<br/>";\n\n                if (gltf.json.meshes[i].extras && gltf.json.meshes[i].extras.targetNames)\n                    html += "Targetnames:<br/>" + gltf.json.meshes[i].extras.targetNames.join("<br/>");\n\n                html += "<br/>";\n            }\n        }\n\n        html += "</td>";\n        html += "</tr>";\n\n        for (let j = 0; j < gltf.json.meshes[i].primitives.length; j++)\n        {\n            const accessor = gltf.json.accessors[gltf.json.meshes[i].primitives[j].indices];\n            if (accessor)\n            {\n                let bufView = accessor.bufferView;\n\n                if (sizeBufferViews.indexOf(bufView) == -1)\n                {\n                    sizeBufferViews.push(bufView);\n                    if (gltf.json.bufferViews[bufView])sizes.meshes += gltf.json.bufferViews[bufView].byteLength;\n                }\n            }\n\n            for (let k in gltf.json.meshes[i].primitives[j].attributes)\n            {\n                const attr = gltf.json.meshes[i].primitives[j].attributes[k];\n                const bufView2 = gltf.json.accessors[attr].bufferView;\n\n                if (sizeBufferViews.indexOf(bufView2) == -1)\n                {\n                    sizeBufferViews.push(bufView2);\n                    if (gltf.json.bufferViews[bufView2])sizes.meshes += gltf.json.bufferViews[bufView2].byteLength;\n                }\n            }\n\n            if (gltf.json.meshes[i].primitives[j].targets)\n                for (let k = 0; k < gltf.json.meshes[i].primitives[j].targets.length; k++)\n                {\n                    for (let l in gltf.json.meshes[i].primitives[j].targets[k])\n                    {\n                        const accessorIdx = gltf.json.meshes[i].primitives[j].targets[k][l];\n                        const accessor = gltf.json.accessors[accessorIdx];\n                        const bufView2 = accessor.bufferView;\n                        console.log("accessor", accessor);\n                        if (sizeBufferViews.indexOf(bufView2) == -1)\n                            if (gltf.json.bufferViews[bufView2])\n                            {\n                                sizeBufferViews.push(bufView2);\n                                sizes.meshTargets += gltf.json.bufferViews[bufView2].byteLength;\n                            }\n                    }\n                }\n        }\n    }\n    html += "</table>";\n\n    // / //////////////////////////////////\n\n    let numSamplers = 0;\n    let numAnims = 0;\n    let numKeyframes = 0;\n\n    if (gltf.json.animations)\n    {\n        numAnims = gltf.json.animations.length;\n        for (let i = 0; i < gltf.json.animations.length; i++)\n        {\n            numSamplers += gltf.json.animations[i].samplers.length;\n        }\n    }\n\n    html += "<div id=\\"groupAnims\\">Animations (" + numAnims + "/" + numSamplers + ")</div>";\n\n    if (gltf.json.animations)\n    {\n        html += "<table id=\\"sectionAnim\\" class=\\"table treetable\\">";\n        html += "<tr>";\n        html += "  <th>Name</th>";\n        html += "  <th>Target node</th>";\n        html += "  <th>Path</th>";\n        html += "  <th>Interpolation</th>";\n        html += "  <th>Keys</th>";\n        html += "</tr>";\n\n\n        sizes.animations = 0;\n\n        for (let i = 0; i < gltf.json.animations.length; i++)\n        {\n            for (let j = 0; j < gltf.json.animations[i].samplers.length; j++)\n            {\n                let bufView = gltf.json.accessors[gltf.json.animations[i].samplers[j].input].bufferView;\n                if (sizeBufferViews.indexOf(bufView) == -1)\n                {\n                    sizeBufferViews.push(bufView);\n                    sizes.animations += gltf.json.bufferViews[bufView].byteLength;\n                }\n\n                bufView = gltf.json.accessors[gltf.json.animations[i].samplers[j].output].bufferView;\n                if (sizeBufferViews.indexOf(bufView) == -1)\n                {\n                    sizeBufferViews.push(bufView);\n                    sizes.animations += gltf.json.bufferViews[bufView].byteLength;\n                }\n            }\n\n            for (let j = 0; j < gltf.json.animations[i].channels.length; j++)\n            {\n                html += "<tr>";\n                html += "  <td> Anim " + i + ": " + gltf.json.animations[i].name + "</td>";\n\n                html += "  <td>" + gltf.nodes[gltf.json.animations[i].channels[j].target.node].name + "</td>";\n                html += "  <td>";\n                html += gltf.json.animations[i].channels[j].target.path + " ";\n                html += "  </td>";\n\n                const smplidx = gltf.json.animations[i].channels[j].sampler;\n                const smplr = gltf.json.animations[i].samplers[smplidx];\n\n                html += "  <td>" + smplr.interpolation + "</td>";\n\n                html += "  <td>" + gltf.json.accessors[smplr.output].count;\n                numKeyframes += gltf.json.accessors[smplr.output].count;\n\n                // html += "&nbsp;&nbsp;<a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').showAnim(\'" + i + "\',\'" + j + "\')\\" class=\\"icon icon-search\\"></a>";\n\n                html += "</td>";\n\n                html += "</tr>";\n            }\n        }\n\n        html += "<tr>";\n        html += "  <td></td>";\n        html += "  <td></td>";\n        html += "  <td></td>";\n        html += "  <td></td>";\n        html += "  <td>" + numKeyframes + " total</td>";\n        html += "</tr>";\n        html += "</table>";\n    }\n    else\n    {\n\n    }\n\n    // / ///////////////////\n\n    let numImages = 0;\n    if (gltf.json.images)numImages = gltf.json.images.length;\n    html += "<div id=\\"groupImages\\">Images (" + numImages + ")</div>";\n\n    if (gltf.json.images)\n    {\n        html += "<table id=\\"sectionImages\\" class=\\"table treetable\\">";\n\n        html += "<tr>";\n        html += "  <th>name</th>";\n        html += "  <th>type</th>";\n        html += "  <th>func</th>";\n        html += "</tr>";\n\n        sizes.images = 0;\n\n        for (let i = 0; i < gltf.json.images.length; i++)\n        {\n            if (gltf.json.images[i].hasOwnProperty("bufferView"))\n            {\n                // if (sizeBufferViews.indexOf(gltf.json.images[i].hasOwnProperty("bufferView")) == -1)console.log("image bufferview already there?!");\n                // else\n                sizes.images += gltf.json.bufferViews[gltf.json.images[i].bufferView].byteLength;\n            }\n            else console.log("image has no bufferview?!");\n\n            html += "<tr>";\n            html += "<td>" + gltf.json.images[i].name + "</td>";\n            html += "<td>" + gltf.json.images[i].mimeType + "</td>";\n            html += "<td>";\n\n            let name = gltf.json.images[i].name;\n            if (name === undefined)name = gltf.json.images[i].bufferView;\n\n            html += "<a onclick=\\"gui.corePatch().getOpById(\'" + op.id + "\').exposeTexture(\'" + name + "\')\\" class=\\"treebutton\\">Expose</a>";\n            html += "</td>";\n\n            html += "<tr>";\n        }\n        html += "</table>";\n    }\n\n    // / ///////////////////////\n\n    let numCameras = 0;\n    if (gltf.json.cameras)numCameras = gltf.json.cameras.length;\n    html += "<div id=\\"groupCameras\\">Cameras (" + numCameras + ")</div>";\n\n    if (gltf.json.cameras)\n    {\n        html += "<table id=\\"sectionCameras\\" class=\\"table treetable\\">";\n\n        html += "<tr>";\n        html += "  <th>name</th>";\n        html += "  <th>type</th>";\n        html += "  <th>info</th>";\n        html += "</tr>";\n\n        for (let i = 0; i < gltf.json.cameras.length; i++)\n        {\n            html += "<tr>";\n            html += "<td>" + gltf.json.cameras[i].name + "</td>";\n            html += "<td>" + gltf.json.cameras[i].type + "</td>";\n            html += "<td>";\n\n            if (gltf.json.cameras[i].perspective)\n            {\n                html += "yfov: " + Math.round(gltf.json.cameras[i].perspective.yfov * 100) / 100;\n                html += ", ";\n                html += "zfar: " + Math.round(gltf.json.cameras[i].perspective.zfar * 100) / 100;\n                html += ", ";\n                html += "znear: " + Math.round(gltf.json.cameras[i].perspective.znear * 100) / 100;\n            }\n            html += "</td>";\n\n            html += "<tr>";\n        }\n        html += "</table>";\n    }\n\n    // / ////////////////////////////////////\n\n    let numSkins = 0;\n    if (gltf.json.skins)numSkins = gltf.json.skins.length;\n    html += "<div id=\\"groupSkins\\">Skins (" + numSkins + ")</div>";\n\n    if (gltf.json.skins)\n    {\n        // html += "<h3>Skins (" + gltf.json.skins.length + ")</h3>";\n        html += "<table id=\\"sectionSkins\\" class=\\"table treetable\\">";\n\n        html += "<tr>";\n        html += "  <th>name</th>";\n        html += "  <th></th>";\n        html += "  <th>total joints</th>";\n        html += "</tr>";\n\n        for (let i = 0; i < gltf.json.skins.length; i++)\n        {\n            html += "<tr>";\n            html += "<td>" + gltf.json.skins[i].name + "</td>";\n            html += "<td>" + "</td>";\n            html += "<td>" + gltf.json.skins[i].joints.length + "</td>";\n            html += "<td>";\n            html += "</td>";\n            html += "<tr>";\n        }\n        html += "</table>";\n    }\n\n    // / ////////////////////////////////////\n\n    if (gltf.timing)\n    {\n        html += "<div id=\\"groupTiming\\">Debug Loading Timing </div>";\n\n        html += "<table id=\\"sectionTiming\\" class=\\"table treetable\\">";\n\n        html += "<tr>";\n        html += "  <th>task</th>";\n        html += "  <th>time used</th>";\n        html += "</tr>";\n\n        let lt = 0;\n        for (let i = 0; i < gltf.timing.length - 1; i++)\n        {\n            html += "<tr>";\n            html += "  <td>" + gltf.timing[i][0] + "</td>";\n            html += "  <td>" + (gltf.timing[i + 1][1] - gltf.timing[i][1]) + " ms</td>";\n            html += "</tr>";\n            // lt = gltf.timing[i][1];\n        }\n        html += "</table>";\n    }\n\n    // / //////////////////////////\n\n    let sizeBin = 0;\n    if (gltf.json.buffers)\n        sizeBin = gltf.json.buffers[0].byteLength;\n\n    html += "<div id=\\"groupBinary\\">File Size Allocation (" + Math.round(sizeBin / 1024) + "k )</div>";\n\n    html += "<table id=\\"sectionBinary\\" class=\\"table treetable\\">";\n    html += "<tr>";\n    html += "  <th>name</th>";\n    html += "  <th>size</th>";\n    html += "  <th>%</th>";\n    html += "</tr>";\n    let sizeUnknown = sizeBin;\n    for (let i in sizes)\n    {\n        // html+=i+\':\'+Math.round(sizes[i]/1024);\n        html += "<tr>";\n        html += "<td>" + i + "</td>";\n        html += "<td>" + readableSize(sizes[i]) + " </td>";\n        html += "<td>" + Math.round(sizes[i] / sizeBin * 100) + "% </td>";\n        html += "<tr>";\n        sizeUnknown -= sizes[i];\n    }\n\n    if (sizeUnknown != 0)\n    {\n        html += "<tr>";\n        html += "<td>unknown</td>";\n        html += "<td>" + readableSize(sizeUnknown) + " </td>";\n        html += "<td>" + Math.round(sizeUnknown / sizeBin * 100) + "% </td>";\n        html += "<tr>";\n    }\n\n    html += "</table>";\n    html += "</div>";\n\n    tab = new CABLES.UI.Tab("GLTF " + CABLES.basename(inFile.get()), { "icon": "cube", "infotext": "tab_gltf", "padding": true, "singleton": true });\n    gui.mainTabs.addTab(tab, true);\n\n    tab.addEventListener("close", closeTab);\n    tab.html(html);\n\n    CABLES.UI.Collapsable.setup(ele.byId("groupNodes"), ele.byId("sectionNodes"), false);\n    CABLES.UI.Collapsable.setup(ele.byId("groupMaterials"), ele.byId("materialtable"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupAnims"), ele.byId("sectionAnim"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupMeshes"), ele.byId("meshestable"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupCameras"), ele.byId("sectionCameras"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupImages"), ele.byId("sectionImages"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupSkins"), ele.byId("sectionSkins"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupBinary"), ele.byId("sectionBinary"), true);\n    CABLES.UI.Collapsable.setup(ele.byId("groupTiming"), ele.byId("sectionTiming"), true);\n\n    gui.maintabPanel.show(true);\n}\n\nfunction readableSize(n)\n{\n    if (n > 1024) return Math.round(n / 1024) + " kb";\n    if (n > 1024 * 500) return Math.round(n / 1024) + " mb";\n    else return n + " bytes";\n}\n',
    inc_skin_js:
      'const GltfSkin = class\n{\n    constructor(node)\n    {\n        this._mod = null;\n        this._node = node;\n        this._lastTime = 0;\n        this._matArr = [];\n        this._m = mat4.create();\n        this._invBindMatrix = mat4.create();\n        this.identity = true;\n    }\n\n    renderFinish(cgl)\n    {\n        cgl.popModelMatrix();\n        this._mod.unbind();\n    }\n\n    renderStart(cgl, time)\n    {\n        if (!this._mod)\n        {\n            this._mod = new CGL.ShaderModifier(cgl, op.name + this._node.name);\n\n            this._mod.addModule({\n                "priority": -2,\n                "name": "MODULE_VERTEX_POSITION",\n                "srcHeadVert": attachments.skin_head_vert || "",\n                "srcBodyVert": attachments.skin_vert || ""\n            });\n\n            this._mod.addUniformVert("m4[]", "MOD_boneMats", []);// bohnenmatze\n            const tr = vec3.create();\n        }\n\n        const skinIdx = this._node.skin;\n        const arrLength = gltf.json.skins[skinIdx].joints.length * 16;\n\n        // if (this._lastTime != time || !time)\n        {\n            // this._lastTime=inTime.get();\n            if (this._matArr.length != arrLength) this._matArr.length = arrLength;\n\n            for (let i = 0; i < gltf.json.skins[skinIdx].joints.length; i++)\n            {\n                const i16 = i * 16;\n                const jointIdx = gltf.json.skins[skinIdx].joints[i];\n                const nodeJoint = gltf.nodes[jointIdx];\n\n                for (let j = 0; j < 16; j++)\n                    this._invBindMatrix[j] = gltf.accBuffers[gltf.json.skins[skinIdx].inverseBindMatrices][i16 + j];\n\n                mat4.mul(this._m, nodeJoint.modelMatAbs(), this._invBindMatrix);\n\n                for (let j = 0; j < this._m.length; j++) this._matArr[i16 + j] = this._m[j];\n            }\n\n            this._mod.setUniformValue("MOD_boneMats", this._matArr);\n            this._lastTime = time;\n        }\n\n        this._mod.define("SKIN_NUM_BONES", gltf.json.skins[skinIdx].joints.length);\n        this._mod.bind();\n\n        // draw mesh...\n        cgl.pushModelMatrix();\n        if (this.identity)mat4.identity(cgl.mMatrix);\n    }\n};\n',
    inc_targets_js:
      'const GltfTargetsRenderer = class\n{\n    constructor(mesh)\n    {\n        this.mesh = mesh;\n        this.tex = null;\n        this.numRowsPerTarget = 0;\n\n        this.makeTex(mesh.geom);\n    }\n\n    renderFinish(cgl)\n    {\n        cgl.popModelMatrix();\n        this._mod.unbind();\n    }\n\n    renderStart(cgl, time)\n    {\n        if (!this._mod)\n        {\n            this._mod = new CGL.ShaderModifier(cgl, "gltftarget");\n\n            this._mod.addModule({\n                "priority": -2,\n                "name": "MODULE_VERTEX_POSITION",\n                "srcHeadVert": attachments.targets_head_vert || "",\n                "srcBodyVert": attachments.targets_vert || ""\n            });\n\n            this._mod.addUniformVert("4f", "MOD_targetTexInfo", [0, 0, 0, 0]);\n            this._mod.addUniformVert("t", "MOD_targetTex", 1);\n            this._mod.addUniformVert("f[]", "MOD_weights", []);\n\n            const tr = vec3.create();\n        }\n\n        this._mod.pushTexture("MOD_targetTex", this.tex);\n        if (this.tex && this.mesh.weights)\n        {\n            this._mod.setUniformValue("MOD_weights", this.mesh.weights);\n            this._mod.setUniformValue("MOD_targetTexInfo", [this.tex.width, this.tex.height, this.numRowsPerTarget, this.mesh.weights.length]);\n\n            this._mod.define("MOD_NUM_WEIGHTS", Math.max(1, this.mesh.weights.length));\n        }\n        else\n        {\n            this._mod.define("MOD_NUM_WEIGHTS", 1);\n        }\n        this._mod.bind();\n\n        // draw mesh...\n        cgl.pushModelMatrix();\n        if (this.identity)mat4.identity(cgl.mMatrix);\n    }\n\n    makeTex(geom)\n    {\n        if (!geom.morphTargets || !geom.morphTargets.length) return;\n\n        let w = geom.morphTargets[0].vertices.length / 3;\n        let h = 0;\n        this.numRowsPerTarget = 0;\n\n        if (geom.morphTargets[0].vertices && geom.morphTargets[0].vertices.length) this.numRowsPerTarget++;\n        if (geom.morphTargets[0].vertexNormals && geom.morphTargets[0].vertexNormals.length) this.numRowsPerTarget++;\n        if (geom.morphTargets[0].tangents && geom.morphTargets[0].tangents.length) this.numRowsPerTarget++;\n        if (geom.morphTargets[0].bitangents && geom.morphTargets[0].bitangents.length) this.numRowsPerTarget++;\n\n        h = geom.morphTargets.length * this.numRowsPerTarget;\n\n        // console.log("this.numRowsPerTarget", this.numRowsPerTarget);\n\n        const pixels = new Float32Array(w * h * 4);\n        let row = 0;\n\n        for (let i = 0; i < geom.morphTargets.length; i++)\n        {\n            if (geom.morphTargets[i].vertices && geom.morphTargets[i].vertices.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].vertices.length; j += 3)\n                {\n                    pixels[((row * w) + (j / 3)) * 4 + 0] = geom.morphTargets[i].vertices[j + 0];\n                    pixels[((row * w) + (j / 3)) * 4 + 1] = geom.morphTargets[i].vertices[j + 1];\n                    pixels[((row * w) + (j / 3)) * 4 + 2] = geom.morphTargets[i].vertices[j + 2];\n                    pixels[((row * w) + (j / 3)) * 4 + 3] = 1;\n                }\n                row++;\n            }\n\n            if (geom.morphTargets[i].vertexNormals && geom.morphTargets[i].vertexNormals.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].vertexNormals.length; j += 3)\n                {\n                    pixels[(row * w + j / 3) * 4 + 0] = geom.morphTargets[i].vertexNormals[j + 0];\n                    pixels[(row * w + j / 3) * 4 + 1] = geom.morphTargets[i].vertexNormals[j + 1];\n                    pixels[(row * w + j / 3) * 4 + 2] = geom.morphTargets[i].vertexNormals[j + 2];\n                    pixels[(row * w + j / 3) * 4 + 3] = 1;\n                }\n\n                row++;\n            }\n\n            if (geom.morphTargets[i].tangents && geom.morphTargets[i].tangents.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].tangents.length; j += 3)\n                {\n                    pixels[(row * w + j / 3) * 4 + 0] = geom.morphTargets[i].tangents[j + 0];\n                    pixels[(row * w + j / 3) * 4 + 1] = geom.morphTargets[i].tangents[j + 1];\n                    pixels[(row * w + j / 3) * 4 + 2] = geom.morphTargets[i].tangents[j + 2];\n                    pixels[(row * w + j / 3) * 4 + 3] = 1;\n                }\n                row++;\n            }\n\n            if (geom.morphTargets[i].bitangents && geom.morphTargets[i].bitangents.length)\n            {\n                for (let j = 0; j < geom.morphTargets[i].bitangents.length; j += 3)\n                {\n                    pixels[(row * w + j / 3) * 4 + 0] = geom.morphTargets[i].bitangents[j + 0];\n                    pixels[(row * w + j / 3) * 4 + 1] = geom.morphTargets[i].bitangents[j + 1];\n                    pixels[(row * w + j / 3) * 4 + 2] = geom.morphTargets[i].bitangents[j + 2];\n                    pixels[(row * w + j / 3) * 4 + 3] = 1;\n                }\n                row++;\n            }\n        }\n\n        this.tex = new CGL.Texture(cgl, { "isFloatingPointTexture": true, "name": "targetsTexture" });\n\n        this.tex.initFromData(pixels, w, h, CGL.Texture.FILTER_LINEAR, CGL.Texture.WRAP_REPEAT);\n\n        // console.log("morphTargets generated texture", w, h);\n    }\n};\n',
    skin_vert:
      "int index=int(attrJoints.x);\nvec4 newPos = (MOD_boneMats[index] * pos) * attrWeights.x;\nvec3 newNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.x).xyz);\n\nindex=int(attrJoints.y);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.y;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.y).xyz)+newNorm;\n\nindex=int(attrJoints.z);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.z;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.z).xyz)+newNorm;\n\nindex=int(attrJoints.w);\nnewPos += (MOD_boneMats[index] * pos) * attrWeights.w ;\nnewNorm = (vec4((MOD_boneMats[index] * vec4(norm.xyz, 0.0)) * attrWeights.w).xyz)+newNorm;\n\npos=newPos;\n\nnorm=normalize(newNorm.xyz);\n\n\n",
    skin_head_vert:
      "\nIN vec4 attrWeights;\nIN vec4 attrJoints;\nUNI mat4 MOD_boneMats[SKIN_NUM_BONES];\n",
    targets_vert:
      "\n\nfloat MOD_width=MOD_targetTexInfo.x;\nfloat MOD_height=MOD_targetTexInfo.y;\nfloat MOD_numTargets=MOD_targetTexInfo.w;\nfloat MOD_numLinesPerTarget=MOD_height/MOD_numTargets;\n\nfloat halfpix=(1.0/MOD_width)*0.5;\nfloat halfpixy=(1.0/MOD_height)*0.5;\n\nfloat x=(attrVertIndex)/MOD_width+halfpix;\n\nvec3 off=vec3(0.0);\n\nfor(float i=0.0;i<MOD_numTargets;i+=1.0)\n{\n    float y=1.0-((MOD_numLinesPerTarget*i)/MOD_height+halfpixy);\n    vec2 coord=vec2(x,y);\n    vec3 targetXYZ = texture(MOD_targetTex,coord).xyz;\n\n    off+=(targetXYZ*MOD_weights[int(i)]);\n\n\n\n    coord.y+=1.0/MOD_height; // normals are in next row\n    vec3 targetNormal = texture(MOD_targetTex,coord).xyz;\n    norm+=targetNormal*MOD_weights[int(i)];\n\n\n}\n\n// norm=normalize(norm);\npos.xyz+=off;\n",
    targets_head_vert: "\nUNI float MOD_weights[MOD_NUM_WEIGHTS];\n",
  });
  const D = class {
    constructor(e, t) {
      this.node = t;
      this.name = t.name;
      this.config = e.json.cameras[t.camera];
      this.pos = vec3.create();
      this.quat = quat.create();
      this.vCenter = vec3.create();
      this.vUp = vec3.create();
      this.vMat = mat4.create();
    }
    updateAnim(e) {
      if (this.node && this.node._animTrans) {
        vec3.set(
          this.pos,
          this.node._animTrans[0].getValue(e),
          this.node._animTrans[1].getValue(e),
          this.node._animTrans[2].getValue(e)
        );
        quat.set(
          this.quat,
          this.node._animRot[0].getValue(e),
          this.node._animRot[1].getValue(e),
          this.node._animRot[2].getValue(e),
          this.node._animRot[3].getValue(e)
        );
      }
    }
    start(e) {
      if (m.tempData.shadowPass) return;
      this.updateAnim(e);
      const t = m.getViewPort()[2] / m.getViewPort()[3];
      m.pushPMatrix();
      m.pushViewMatrix();
      let n = mat4.create();
      mat4.invert(n, this.node.modelMatAbs());
      this.vMat = n;
      mat4.identity(m.vMatrix);
      mat4.mul(m.vMatrix, m.vMatrix, n);
    }
    end() {
      if (m.tempData.shadowPass) return;
      m.popPMatrix();
      m.popViewMatrix();
    }
  };
  const O = true;
  const R = class {
    constructor() {
      this.json = {};
      this.accBuffers = [];
      this.meshes = [];
      this.nodes = [];
      this.shaders = [];
      this.timing = [];
      this.cams = [];
      this.startTime = performance.now();
      this.bounds = new CABLES.CG.BoundingBox();
      this.loaded = Date.now();
      this.accBuffersDelete = [];
    }
    getNode(t) {
      for (let e = 0; e < this.nodes.length; e++) {
        if (this.nodes[e].name == t) return this.nodes[e];
      }
    }
    unHideAll() {
      for (let e = 0; e < this.nodes.length; e++) {
        this.nodes[e].unHide();
      }
    }
  };
  function S(e) {
    if (window.TextDecoder) return new TextDecoder("utf-8").decode(e);
    let t, n, i, r;
    let a, s;
    t = "";
    i = e.length;
    n = 0;
    while (n < i) {
      r = e[n++];
      switch (r >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          t += String.fromCharCode(r);
          break;
        case 12:
        case 13:
          a = e[n++];
          t += String.fromCharCode(((r & 31) << 6) | (a & 63));
          break;
        case 14:
          a = e[n++];
          s = e[n++];
          t += String.fromCharCode(
            ((r & 15) << 12) | ((a & 63) << 6) | ((s & 63) << 0)
          );
          break;
      }
    }
    return t;
  }
  function A(e, t, n, i) {
    const r = {};
    if (i >= e.byteLength) {
      return;
    }
    r.size = e.getUint32(i + 0, O);
    r.type = S(t.subarray(i + 4, i + 4 + 4));
    if (r.type == "BIN\0") {
      r.dataView = new DataView(n, i + 8, r.size);
    } else if (r.type == "JSON") {
      const a = S(t.subarray(i + 8, i + 8 + r.size));
      try {
        const s = JSON.parse(a);
        r.data = s;
        se.set(s.asset.generator);
      } catch (e) {}
    } else {
      T.warn("unknown type", r.type);
    }
    return r;
  }
  function B(t) {
    const i = {};
    for (let e = 0; e < t.json.animations.length; e++) {
      const r = t.json.animations[e];
      r.name = r.name || "unknown";
      for (let e = 0; e < r.channels.length; e++) {
        const a = r.channels[e];
        const s = t.nodes[a.target.node];
        const o = r.samplers[a.sampler];
        const n = t.json.accessors[o.input];
        const l = t.accBuffers[o.input];
        const u = t.json.accessors[o.output];
        const c = t.accBuffers[o.output];
        t.accBuffersDelete.push(o.output, o.input);
        if (l && c) {
          let n = 1;
          if (u.type === "VEC2") n = 2;
          else if (u.type === "VEC3") n = 3;
          else if (u.type === "VEC4") n = 4;
          else if (u.type === "SCALAR") {
            n = c.length / l.length;
          } else T.log("[] UNKNOWN accOut.type", u.type);
          const d = [];
          i[r.name] = true;
          for (let e = 0; e < n; e++) {
            const h = new CABLES.Anim();
            d.push(h);
          }
          if (o.interpolation === "LINEAR") {
          } else if (o.interpolation === "STEP")
            for (let e = 0; e < n; e++)
              d[e].defaultEasing = CABLES.EASING_ABSOLUTE;
          else if (o.interpolation === "CUBICSPLINE")
            for (let e = 0; e < n; e++)
              d[e].defaultEasing = CABLES.EASING_CUBICSPLINE;
          else T.warn("unknown interpolation", o.interpolation);
          if (l[0] !== 0)
            for (let e = 0; e < n; e++) d[e].setValue(0, c[0 * n + e]);
          for (let t = 0; t < l.length; t++) {
            y = Math.max(l[t], y);
            for (let e = 0; e < n; e++) {
              if (d[e].defaultEasing === CABLES.EASING_CUBICSPLINE) {
                const p = t * n * 3 + e;
                const m = d[e].setValue(l[t], c[p + n]);
                m.bezTangIn = c[p];
                m.bezTangOut = c[p + n * 2];
              } else {
                d[e].setValue(l[t], c[t * n + e]);
              }
            }
          }
          s.setAnim(a.target.path, r.name, d);
        } else {
          T.warn("loadAmins bufferIn undefined ", l === undefined);
          T.warn("loadAmins bufferOut undefined ", c === undefined);
          T.warn("loadAmins ", r.name, o, u);
          T.warn("loadAmins num accBuffers", t.accBuffers.length);
          T.warn("loadAmins num accessors", t.json.accessors.length);
        }
      }
    }
    t.uniqueAnimNames = i;
    he.setRef(Object.keys(i));
  }
  function U(n) {
    if (!n || !n.json.cameras) return;
    n.cameras = n.cameras || [];
    for (let t = 0; t < n.nodes.length; t++) {
      if (n.nodes[t].hasOwnProperty("camera")) {
        const e = new D(n, n.nodes[t]);
        n.cameras.push(e);
      }
    }
  }
  function V() {
    if (!window.DracoDecoder) {
      setTimeout(() => {
        V();
      }, 100);
    }
    L();
  }
  function F(e) {
    const t = 8;
    let r = 0,
      n = 0;
    const a = new R();
    a.timing.push([
      "Start parsing",
      Math.round(performance.now() - a.startTime),
    ]);
    if (!e) return;
    const i = new Uint8Array(e);
    let s = 0;
    const o = S(i.subarray(s, 4));
    s += 4;
    if (o != "glTF") return;
    a.timing.push(["dataview", Math.round(performance.now() - a.startTime)]);
    const l = new DataView(e);
    const u = l.getUint32(s, O);
    s += 4;
    const c = l.getUint32(s, O);
    s += 4;
    oe.set(u);
    const d = [];
    a.chunks = d;
    d.push(A(l, i, e, s));
    s += d[0].size + t;
    a.json = d[0].data;
    a.cables = { fileUrl: C.get(), shortFileName: CABLES.basename(C.get()) };
    de.setRef(a.json);
    le.setRef(a.json.extensionsUsed || []);
    let h = A(l, i, e, s);
    while (h) {
      d.push(h);
      s += h.size + t;
      h = A(l, i, e, s);
    }
    a.chunks = d;
    const p = d[0].data.bufferViews;
    const m = d[0].data.accessors;
    a.timing.push([
      "Parse buffers",
      Math.round(performance.now() - a.startTime),
    ]);
    if (
      a.json.extensionsUsed &&
      a.json.extensionsUsed.indexOf("KHR_draco_mesh_compression") > -1
    ) {
      if (!window.DracoDecoder) {
        T.setUiError(
          "gltfdraco",
          "GLTF draco compression lib not found / add draco op to your patch!"
        );
        V();
        return a;
      } else {
        a.useDraco = true;
      }
    }
    T.setUiError("gltfdraco", null);
    if (p) {
      for (n = 0; n < m.length; n++) {
        const f = m[n];
        const g = p[f.bufferView];
        let i = 0;
        if (f.type == "SCALAR") i = 1;
        else if (f.type == "VEC2") i = 2;
        else if (f.type == "VEC3") i = 3;
        else if (f.type == "VEC4") i = 4;
        else if (f.type == "MAT4") i = 16;
        else console.error("unknown accessor type", f.type);
        if (d[1].dataView) {
          if (g) {
            const b = f.count * i;
            let e = (g.byteOffset || 0) + (f.byteOffset || 0);
            let t = g.byteStride || 0;
            let n = null;
            if (f.componentType == 5126 || f.componentType == 5125) {
              t = t || 4;
              const v = f.componentType == 5125;
              if (v) n = new Uint32Array(b);
              else n = new Float32Array(b);
              n.cblStride = i;
              for (r = 0; r < b; r++) {
                if (v) n[r] = d[1].dataView.getUint32(e, O);
                else n[r] = d[1].dataView.getFloat32(e, O);
                if (t != 4 && (r + 1) % i === 0) e += t - i * 4;
                e += 4;
              }
            } else if (f.componentType == 5123) {
              t = t || 2;
              n = new Uint16Array(b);
              n.cblStride = t;
              for (r = 0; r < b; r++) {
                n[r] = d[1].dataView.getUint16(e, O);
                if (t != 2 && (r + 1) % i === 0) e += t - i * 2;
                e += 2;
              }
            } else if (f.componentType == 5121) {
              t = t || 1;
              n = new Uint8Array(b);
              n.cblStride = t;
              for (r = 0; r < b; r++) {
                n[r] = d[1].dataView.getUint8(e, O);
                if (t != 1 && (r + 1) % i === 0) e += t - i * 1;
                e += 1;
              }
            } else {
              console.error("unknown component type", f.componentType);
            }
            a.accBuffers.push(n);
          } else {
          }
        }
      }
    }
    a.timing.push([
      "Parse mesh groups",
      Math.round(performance.now() - a.startTime),
    ]);
    a.json.meshes = a.json.meshes || [];
    if (a.json.meshes) {
      for (n = 0; n < a.json.meshes.length; n++) {
        const y = new q(a, a.json.meshes[n]);
        a.meshes.push(y);
      }
    }
    a.timing.push(["Parse nodes", Math.round(performance.now() - a.startTime)]);
    for (n = 0; n < a.json.nodes.length; n++) {
      if (a.json.nodes[n].children)
        for (r = 0; r < a.json.nodes[n].children.length; r++) {
          a.json.nodes[a.json.nodes[n].children[r]].isChild = true;
        }
    }
    for (n = 0; n < a.json.nodes.length; n++) {
      const _ = new z(a.json.nodes[n], a);
      a.nodes.push(_);
    }
    for (n = 0; n < a.nodes.length; n++) {
      const _ = a.nodes[n];
      if (!_.children) continue;
      for (let e = 0; e < _.children.length; e++) {
        a.nodes[_.children[e]].parent = _;
      }
    }
    for (n = 0; n < a.nodes.length; n++) {
      a.nodes[n].initSkin();
    }
    E = true;
    a.timing.push(["load anims", Math.round(performance.now() - a.startTime)]);
    if (a.json.animations) B(a);
    a.timing.push([
      "load cameras",
      Math.round(performance.now() - a.startTime),
    ]);
    if (a.json.cameras) U(a);
    a.timing.push(["finished", Math.round(performance.now() - a.startTime)]);
    return a;
  }
  let G = class {
    constructor(e, n, a, s) {
      this.POINTS = 0;
      this.LINES = 1;
      this.LINE_LOOP = 2;
      this.LINE_STRIP = 3;
      this.TRIANGLES = 4;
      this.TRIANGLE_STRIP = 5;
      this.TRIANGLE_FAN = 6;
      this.test = 0;
      this.name = e;
      this.submeshIndex = 0;
      this.material = n.material;
      this.mesh = null;
      this.geom = new CGL.Geometry("gltf_" + this.name);
      this.geom.verticesIndices = [];
      this.bounds = null;
      this.primitive = 4;
      this.morphTargetsRenderMod = null;
      this.weights = n.weights;
      if (n.hasOwnProperty("mode")) this.primitive = n.mode;
      if (n.hasOwnProperty("indices"))
        this.geom.verticesIndices = a.accBuffers[n.indices];
      a.loadingMeshes = a.loadingMeshes || 0;
      a.loadingMeshes++;
      this.materialJson =
        this._matPbrMetalness =
        this._matPbrRoughness =
        this._matDiffuseColor =
          null;
      if (a.json.materials) {
        if (this.material != -1)
          this.materialJson = a.json.materials[this.material];
        if (this.materialJson && this.materialJson.pbrMetallicRoughness) {
          if (
            !this.materialJson.pbrMetallicRoughness.hasOwnProperty(
              "baseColorFactor"
            )
          ) {
            this._matDiffuseColor = [1, 1, 1, 1];
          } else {
            this._matDiffuseColor =
              this.materialJson.pbrMetallicRoughness.baseColorFactor;
          }
          this._matDiffuseColor =
            this.materialJson.pbrMetallicRoughness.baseColorFactor;
          if (
            !this.materialJson.pbrMetallicRoughness.hasOwnProperty(
              "metallicFactor"
            )
          ) {
            this._matPbrMetalness = 1;
          } else {
            this._matPbrMetalness =
              this.materialJson.pbrMetallicRoughness.metallicFactor || null;
          }
          if (
            !this.materialJson.pbrMetallicRoughness.hasOwnProperty(
              "roughnessFactor"
            )
          ) {
            this._matPbrRoughness = 1;
          } else {
            this._matPbrRoughness =
              this.materialJson.pbrMetallicRoughness.roughnessFactor || null;
          }
        }
      }
      if (a.useDraco && n.extensions.KHR_draco_mesh_compression) {
        const i =
          a.chunks[0].data.bufferViews[
            n.extensions.KHR_draco_mesh_compression.bufferView
          ];
        const r = i.byteLength;
        const o = new Int8Array(r);
        let t = i.byteOffset || 0;
        for (let e = 0; e < r; e++) {
          o[e] = a.chunks[1].dataView.getInt8(t, O);
          t++;
        }
        const l = window.DracoDecoder;
        l.decodeGeometry(
          o.buffer,
          (t) => {
            const n = new CGL.Geometry("draco mesh " + e);
            for (let e = 0; e < t.attributes.length; e++) {
              const i = t.attributes[e];
              if (i.name === "position") n.vertices = i.array;
              else if (i.name === "normal") n.vertexNormals = i.array;
              else if (i.name === "uv") n.texCoords = i.array;
              else if (i.name === "color")
                n.vertexColors = this.calcVertexColors(i.array);
              else if (i.name === "joints")
                n.setAttribute("attrJoints", Array.from(i.array), 4);
              else if (i.name === "weights") {
                const r = new Float32Array((i.array.length / i.itemSize) * 4);
                for (let t = 0; t < i.array.length / i.itemSize; t++) {
                  r[t * 4] = r[t * 4 + 1] = r[t * 4 + 2] = r[t * 4 + 3] = 0;
                  for (let e = 0; e < i.itemSize; e++)
                    r[t * 4 + e] = i.array[t * i.itemSize + e];
                }
                n.setAttribute("attrWeights", r, 4);
              } else T.logWarn("unknown draco attrib", i);
            }
            t.attributes = null;
            n.verticesIndices = t.index.array;
            this.setGeom(n);
            this.mesh = null;
            a.loadingMeshes--;
            a.timing.push([
              "draco decode",
              Math.round(performance.now() - a.startTime),
            ]);
            if (s) s(this);
          },
          (e) => {
            T.logError(e);
          }
        );
      } else {
        a.loadingMeshes--;
        this.fillGeomAttribs(a, this.geom, n.attributes);
        if (n.targets) {
          for (let e = 0; e < n.targets.length; e++) {
            const t = new CGL.Geometry("gltf_target_" + e);
            this.fillGeomAttribs(a, t, n.targets[e], false);
            this.geom.morphTargets.push(t);
          }
        }
        if (s) s(this);
      }
    }
    _linearToSrgb(e) {
      if (e <= 0) return 0;
      else if (e >= 1) return 1;
      else if (e < 0.0031308) return e * 12.92;
      else return e ** (1 / 2.2) * 1.055 - 0.055;
    }
    calcVertexColors(n, e) {
      let i = null;
      if (n instanceof Float32Array) {
        let t = false;
        for (let e = 0; e < n.length; e++) {
          if (n[e] > 1) {
            t = true;
            continue;
          }
        }
        if (t) for (let e = 0; e < n.length; e++) n[e] /= 65535;
        i = n;
      } else if (n instanceof Uint16Array) {
        const t = new Float32Array(n.length);
        for (let e = 0; e < n.length; e++) t[e] = n[e] / 65535;
        i = t;
      } else i = n;
      for (let e = 0; e < i.length; e++) {
        i[e] = this._linearToSrgb(i[e]);
      }
      console.log("arr.cblStride", n.cblStride);
      if (n.cblStride == 3) {
        const r = new Float32Array((i.length / 3) * 4);
        for (let e = 0; e < i.length / 3; e++) {
          r[e * 4 + 0] = i[e * 3 + 0];
          r[e * 4 + 1] = i[e * 3 + 1];
          r[e * 4 + 2] = i[e * 3 + 2];
          r[e * 4 + 3] = 1;
        }
        i = r;
      }
      return i;
    }
    fillGeomAttribs(e, t, n, i) {
      if (n.hasOwnProperty("POSITION")) t.vertices = e.accBuffers[n.POSITION];
      if (n.hasOwnProperty("NORMAL")) t.vertexNormals = e.accBuffers[n.NORMAL];
      if (n.hasOwnProperty("TANGENT")) t.tangents = e.accBuffers[n.TANGENT];
      if (n.hasOwnProperty("COLOR_0"))
        t.vertexColors = this.calcVertexColors(
          e.accBuffers[n.COLOR_0],
          e.accBuffers[n.COLOR_0].type
        );
      if (n.hasOwnProperty("COLOR_1"))
        t.setAttribute(
          "attrVertColor1",
          this.calcVertexColors(e.accBuffers[n.COLOR_1]),
          e.accBuffers[n.COLOR_1].type
        );
      if (n.hasOwnProperty("COLOR_2"))
        t.setAttribute(
          "attrVertColor2",
          this.calcVertexColors(e.accBuffers[n.COLOR_2]),
          e.accBuffers[n.COLOR_2].type
        );
      if (n.hasOwnProperty("COLOR_3"))
        t.setAttribute(
          "attrVertColor3",
          this.calcVertexColors(e.accBuffers[n.COLOR_3]),
          e.accBuffers[n.COLOR_3].type
        );
      if (n.hasOwnProperty("COLOR_4"))
        t.setAttribute(
          "attrVertColor4",
          this.calcVertexColors(e.accBuffers[n.COLOR_4]),
          e.accBuffers[n.COLOR_4].type
        );
      if (n.hasOwnProperty("TEXCOORD_0"))
        t.texCoords = e.accBuffers[n.TEXCOORD_0];
      if (n.hasOwnProperty("TEXCOORD_1"))
        t.setAttribute("attrTexCoord1", e.accBuffers[n.TEXCOORD_1], 2);
      if (n.hasOwnProperty("TEXCOORD_2"))
        t.setAttribute("attrTexCoord2", e.accBuffers[n.TEXCOORD_2], 2);
      if (n.hasOwnProperty("TEXCOORD_3"))
        t.setAttribute("attrTexCoord3", e.accBuffers[n.TEXCOORD_3], 2);
      if (n.hasOwnProperty("TEXCOORD_4"))
        t.setAttribute("attrTexCoord4", e.accBuffers[n.TEXCOORD_4], 2);
      if (n.hasOwnProperty("WEIGHTS_0")) {
        t.setAttribute("attrWeights", e.accBuffers[n.WEIGHTS_0], 4);
      }
      if (n.hasOwnProperty("JOINTS_0")) {
        if (!e.accBuffers[n.JOINTS_0])
          console.log("no !gltf.accBuffers[attribs.JOINTS_0]");
        t.setAttribute("attrJoints", e.accBuffers[n.JOINTS_0], 4);
      }
      if (n.hasOwnProperty("POSITION")) e.accBuffersDelete.push(n.POSITION);
      if (n.hasOwnProperty("NORMAL")) e.accBuffersDelete.push(n.NORMAL);
      if (n.hasOwnProperty("TEXCOORD_0")) e.accBuffersDelete.push(n.TEXCOORD_0);
      if (n.hasOwnProperty("TANGENT")) e.accBuffersDelete.push(n.TANGENT);
      if (n.hasOwnProperty("COLOR_0")) e.accBuffersDelete.push(n.COLOR_0);
      if (n.hasOwnProperty("COLOR_0")) e.accBuffersDelete.push(n.COLOR_0);
      if (n.hasOwnProperty("COLOR_1")) e.accBuffersDelete.push(n.COLOR_1);
      if (n.hasOwnProperty("COLOR_2")) e.accBuffersDelete.push(n.COLOR_2);
      if (n.hasOwnProperty("COLOR_3")) e.accBuffersDelete.push(n.COLOR_3);
      if (n.hasOwnProperty("TEXCOORD_1")) e.accBuffersDelete.push(n.TEXCOORD_1);
      if (n.hasOwnProperty("TEXCOORD_2")) e.accBuffersDelete.push(n.TEXCOORD_2);
      if (n.hasOwnProperty("TEXCOORD_3")) e.accBuffersDelete.push(n.TEXCOORD_3);
      if (n.hasOwnProperty("TEXCOORD_4")) e.accBuffersDelete.push(n.TEXCOORD_4);
      if (i !== false) if (t && t.verticesIndices) this.setGeom(t);
    }
    setGeom(n) {
      if (te.get() == "X-ZY") {
        for (let t = 0; t < n.vertexNormals.length; t += 3) {
          let e = n.vertexNormals[t + 2];
          n.vertexNormals[t + 2] = n.vertexNormals[t + 1];
          n.vertexNormals[t + 1] = -e;
        }
      }
      if (ne.get() == "XZ-Y") {
        for (let t = 0; t < n.vertices.length; t += 3) {
          let e = n.vertices[t + 2];
          n.vertices[t + 2] = -n.vertices[t + 1];
          n.vertices[t + 1] = e;
        }
      }
      if (this.primitive == this.TRIANGLES) {
        if (c.get() == "Force Smooth" || c.get() == false) n.calculateNormals();
        else if (!n.vertexNormals.length && c.get() == "Auto")
          n.calculateNormals({ smooth: false });
        if ((!n.biTangents || n.biTangents.length == 0) && n.tangents) {
          const t = vec3.create();
          const e = vec3.create();
          const i = n.tangents;
          n.tangents = new Float32Array((i.length / 4) * 3);
          n.biTangents = new Float32Array((i.length / 4) * 3);
          for (let e = 0; e < i.length; e += 4) {
            const r = (e / 4) * 3;
            vec3.cross(
              t,
              [
                n.vertexNormals[r],
                n.vertexNormals[r + 1],
                n.vertexNormals[r + 2],
              ],
              [i[e], i[e + 1], i[e + 2]]
            );
            vec3.div(t, t, [i[e + 3], i[e + 3], i[e + 3]]);
            vec3.normalize(t, t);
            n.biTangents[r + 0] = t[0];
            n.biTangents[r + 1] = t[1];
            n.biTangents[r + 2] = t[2];
            n.tangents[r + 0] = i[e + 0];
            n.tangents[r + 1] = i[e + 1];
            n.tangents[r + 2] = i[e + 2];
          }
        }
        if (n.tangents.length === 0 || c.get() != "Never") {
          n.calcTangentsBitangents();
        }
      }
      this.geom = n;
      this.bounds = n.getBounds();
    }
    render(n, t, i) {
      if (!this.mesh && this.geom && this.geom.verticesIndices) {
        let e = this.geom;
        if (this.geom.vertices.length / 3 > 64e3) {
          e = this.geom.copy();
          e.unIndex(false, true);
        }
        let t;
        if (n.gl) {
          if (this.primitive == this.TRIANGLES) t = n.gl.TRIANGLES;
          else if (this.primitive == this.LINES) t = n.gl.LINES;
          else if (this.primitive == this.LINE_STRIP) t = n.gl.LINE_STRIP;
          else if (this.primitive == this.POINTS) t = n.gl.POINTS;
          else {
            T.logWarn("unknown primitive type", this);
          }
        }
        this.mesh = T.patch.cg.createMesh(e, { glPrimitive: t });
      }
      if (this.mesh) {
        if (
          this.geom &&
          this.geom.morphTargets.length &&
          !this.morphTargetsRenderMod
        ) {
          this.mesh.addVertexNumbers = true;
          this.morphTargetsRenderMod = new K(this);
        }
        let e = !t && this.material != -1 && I.shaders[this.material];
        if (i) e = false;
        if (e) n.pushShader(I.shaders[this.material]);
        const r = n.getShader() || {};
        const a = r.uniformColorDiffuse;
        const s = r.uniformPbrMetalness;
        const o = r.uniformPbrRoughness;
        if (!I.shaders[this.material] && re.get()) {
          if (a && this._matDiffuseColor) {
            this._matDiffuseColorOrig = [
              a.getValue()[0],
              a.getValue()[1],
              a.getValue()[2],
              a.getValue()[3],
            ];
            a.setValue(this._matDiffuseColor);
          }
          if (s)
            if (this._matPbrMetalness != null) {
              this._matPbrMetalnessOrig = s.getValue();
              s.setValue(this._matPbrMetalness);
            } else s.setValue(0);
          if (o)
            if (this._matPbrRoughness != null) {
              this._matPbrRoughnessOrig = o.getValue();
              o.setValue(this._matPbrRoughness);
            } else {
              o.setValue(0);
            }
        }
        if (this.morphTargetsRenderMod)
          this.morphTargetsRenderMod.renderStart(n, 0);
        if (this.mesh) {
          this.mesh.render(n.getShader(), t);
        }
        if (this.morphTargetsRenderMod)
          this.morphTargetsRenderMod.renderFinish(n);
        if (re.get()) {
          if (a && this._matDiffuseColor) a.setValue(this._matDiffuseColorOrig);
          if (s && this._matPbrMetalnessOrig != undefined)
            s.setValue(this._matPbrMetalnessOrig);
          if (o && this._matPbrRoughnessOrig != undefined)
            o.setValue(this._matPbrRoughnessOrig);
        }
        if (e) n.popShader();
      }
    }
  };
  const q = class {
    constructor(t, n) {
      this.bounds = new CABLES.CG.BoundingBox();
      this.meshes = [];
      this.name = n.name;
      const i = n.primitives;
      for (let e = 0; e < i.length; e++) {
        const r = new G(this.name, i[e], t, (e) => {
          e.extras = n.extras;
          this.bounds.apply(e.bounds);
        });
        r.submeshIndex = e;
        this.meshes.push(r);
      }
    }
    render(t, n, i, r, a) {
      for (let e = 0; e < this.meshes.length; e++) {
        const s = I.shaders[this.meshes[e].material];
        if (!n && s) t.pushShader(I.shaders[this.meshes[e].material]);
        if (i) i.renderStart(t, r);
        if (a) this.meshes[e].weights = a;
        this.meshes[e].render(t, n, i, r);
        if (i) i.renderFinish(t);
        if (!n && s) t.popShader();
      }
    }
  };
  const z = class {
    constructor(e, t) {
      this.isChild = e.isChild || false;
      this.name = e.name;
      if (e.hasOwnProperty("camera")) this.camera = e.camera;
      this.hidden = false;
      this.mat = mat4.create();
      this._animActions = {};
      this.animWeights = [];
      this._animMat = mat4.create();
      this._tempMat = mat4.create();
      this._tempQuat = quat.create();
      this._tempRotmat = mat4.create();
      this.mesh = null;
      this.children = [];
      this._node = e;
      this._gltf = t;
      this.absMat = mat4.create();
      this.addTranslate = null;
      this._tempAnimScale = null;
      this.addMulMat = null;
      this.updateMatrix();
      this.skinRenderer = null;
      this.copies = [];
    }
    get skin() {
      if (this._node.hasOwnProperty("skin")) return this._node.skin;
      else return -1;
    }
    copy() {
      this.isCopy = true;
      const e = new z(this._node, this._gltf);
      e.copyOf = this;
      e._animActions = this._animActions;
      e.children = this.children;
      if (this.skin) e.skinRenderer = new Y(this);
      this.updateMatrix();
      return e;
    }
    hasSkin() {
      if (this._node.hasOwnProperty("skin"))
        return this._gltf.json.skins[this._node.skin].name || "unknown";
      return false;
    }
    initSkin() {
      if (this.skin > -1) {
        this.skinRenderer = new Y(this);
      }
    }
    updateMatrix() {
      mat4.identity(this.mat);
      if (this._node.translation)
        mat4.translate(this.mat, this.mat, this._node.translation);
      if (this._node.rotation) {
        const e = mat4.create();
        this._rot = this._node.rotation;
        mat4.fromQuat(e, this._node.rotation);
        mat4.mul(this.mat, this.mat, e);
      }
      if (this._node.scale) {
        this._scale = this._node.scale;
        mat4.scale(this.mat, this.mat, this._scale);
      }
      if (this._node.hasOwnProperty("mesh")) {
        this.mesh = this._gltf.meshes[this._node.mesh];
        if (this.isCopy) {
        }
      }
      if (this._node.children) {
        for (let e = 0; e < this._node.children.length; e++) {
          this._gltf.json.nodes[e].isChild = true;
          if (this._gltf.nodes[this._node.children[e]])
            this._gltf.nodes[this._node.children[e]].isChild = true;
          this.children.push(this._node.children[e]);
        }
      }
    }
    unHide() {
      this.hidden = false;
      for (let e = 0; e < this.children.length; e++)
        if (this.children[e].unHide) this.children[e].unHide();
    }
    calcBounds(t, e, n) {
      const i = mat4.create();
      if (e) mat4.copy(i, e);
      if (this.mat) mat4.mul(i, i, this.mat);
      if (this.mesh) {
        const r = this.mesh.bounds.copy();
        r.mulMat4(i);
        n.apply(r);
        if (n.changed) {
          v.push(
            r._min[0] || 0,
            r._min[1] || 0,
            r._min[2] || 0,
            r._max[0] || 0,
            r._max[1] || 0,
            r._max[2] || 0
          );
        }
      }
      for (let e = 0; e < this.children.length; e++) {
        if (t.nodes[this.children[e]] && t.nodes[this.children[e]].calcBounds) {
          const a = t.nodes[this.children[e]].calcBounds(t, i, n);
          n.apply(a);
        }
      }
      if (n.changed) return n;
      else return null;
    }
    setAnimAction(t) {
      if (!t) return;
      this._currentAnimaction = t;
      if (t && !this._animActions[t]) {
        return null;
      }
      for (let e in this._animActions[t]) {
        if (e == "translation") this._animTrans = this._animActions[t][e];
        else if (e == "rotation") this._animRot = this._animActions[t][e];
        else if (e == "scale") this._animScale = this._animActions[t][e];
        else if (e == "weights") this.animWeights = this._animActions[t][e];
        else
          console.log(
            "[gltfNode] unknown anim path",
            e,
            this._animActions[t][e]
          );
      }
    }
    setAnim(e, t, n) {
      if (!e || !t || !n) return;
      this._animActions[t] = this._animActions[t] || {};
      if (this._animActions[t][e])
        T.log(
          "[gltfNode] animation action path already exists",
          t,
          e,
          this._animActions[t][e]
        );
      this._animActions[t][e] = n;
      if (e == "translation") this._animTrans = n;
      else if (e == "rotation") this._animRot = n;
      else if (e == "scale") this._animScale = n;
      else if (e == "weights") {
        this.animWeights = this._animActions[t][e];
      } else console.warn("unknown anim path", e, n);
    }
    modelMatLocal() {
      return this._animMat || this.mat;
    }
    modelMatAbs() {
      return this.absMat;
    }
    transform(e, n) {
      if (!n && n != 0) n = x;
      this._lastTimeTrans = n;
      ve++;
      if (!this._animTrans && !this._animRot && !this._animScale) {
        mat4.mul(e.mMatrix, e.mMatrix, this.mat);
        this._animMat = null;
      } else {
        this._animMat = this._animMat || mat4.create();
        mat4.identity(this._animMat);
        const t = true;
        if (t && this._animTrans) {
          mat4.translate(this._animMat, this._animMat, [
            this._animTrans[0].getValue(n),
            this._animTrans[1].getValue(n),
            this._animTrans[2].getValue(n),
          ]);
        } else if (this._node.translation)
          mat4.translate(this._animMat, this._animMat, this._node.translation);
        if (t && this._animRot) {
          if (this._animRot[0].defaultEasing == CABLES.EASING_LINEAR)
            CABLES.Anim.slerpQuaternion(
              n,
              this._tempQuat,
              this._animRot[0],
              this._animRot[1],
              this._animRot[2],
              this._animRot[3]
            );
          else if (this._animRot[0].defaultEasing == CABLES.EASING_ABSOLUTE) {
            this._tempQuat[0] = this._animRot[0].getValue(n);
            this._tempQuat[1] = this._animRot[1].getValue(n);
            this._tempQuat[2] = this._animRot[2].getValue(n);
            this._tempQuat[3] = this._animRot[3].getValue(n);
          } else if (
            this._animRot[0].defaultEasing == CABLES.EASING_CUBICSPLINE
          ) {
            CABLES.Anim.slerpQuaternion(
              n,
              this._tempQuat,
              this._animRot[0],
              this._animRot[1],
              this._animRot[2],
              this._animRot[3]
            );
          }
          mat4.fromQuat(this._tempMat, this._tempQuat);
          mat4.mul(this._animMat, this._animMat, this._tempMat);
        } else if (this._rot) {
          mat4.fromQuat(this._tempRotmat, this._rot);
          mat4.mul(this._animMat, this._animMat, this._tempRotmat);
        }
        if (t && this._animScale) {
          if (!this._tempAnimScale) this._tempAnimScale = [1, 1, 1];
          this._tempAnimScale[0] = this._animScale[0].getValue(n);
          this._tempAnimScale[1] = this._animScale[1].getValue(n);
          this._tempAnimScale[2] = this._animScale[2].getValue(n);
          mat4.scale(this._animMat, this._animMat, this._tempAnimScale);
        } else if (this._scale)
          mat4.scale(this._animMat, this._animMat, this._scale);
        mat4.mul(e.mMatrix, e.mMatrix, this._animMat);
      }
      if (this.animWeights) {
        this.weights = this.weights || [];
        let t = "";
        for (let e = 0; e < this.animWeights.length; e++) {
          this.weights[e] = this.animWeights[e].getValue(n);
          t += this.weights[e] + "/";
        }
      }
      if (this.addTranslate)
        mat4.translate(e.mMatrix, e.mMatrix, this.addTranslate);
      if (this.addMulMat) mat4.mul(e.mMatrix, e.mMatrix, this.addMulMat);
      mat4.copy(this.absMat, e.mMatrix);
    }
    render(t, n, i, r, a, s, o) {
      if (!n) t.pushModelMatrix();
      if (o === undefined) o = I.time;
      if (!n || this.skinRenderer) this.transform(t, o);
      if (this.hidden && !s) {
      } else {
        if (this.skinRenderer) {
          this.skinRenderer.time = o;
          if (!i) this.mesh.render(t, r, this.skinRenderer, o, this.weights);
        } else {
          if (this.mesh && !i) this.mesh.render(t, r, null, o, this.weights);
        }
      }
      if (!a && !this.hidden)
        for (let e = 0; e < this.children.length; e++)
          if (I.nodes[this.children[e]])
            I.nodes[this.children[e]].render(t, n, i, r, a, s, o);
      if (!n) t.popModelMatrix();
    }
  };
  let _ = null;
  function w() {
    if (_) gui.mainTabs.closeTab(_.id);
    _ = null;
  }
  function o(t) {
    const n = [];
    for (let e = 0; e < t.length; e++) {
      n.push(Math.round(t[e] * 1e3) / 1e3);
    }
    return n.join(",");
  }
  function H(n, i, r) {
    if (!I) return;
    n += '<tr class="row">';
    let a = "";
    let s = "";
    for (let t = 1; t < r; t++) {
      s += "&nbsp;&nbsp;&nbsp;";
      let e = "identBg";
      if (t == 1) e = "identBgLevel0";
      a += '<td class="ident ' + e + '" ><div style=""></div></td>';
    }
    let e = CABLES.uuid();
    n += a;
    n += '<td colspan="' + (21 - r) + '">';
    if (i.mesh && i.mesh.meshes.length)
      n += '<span class="icon icon-cube"></span>&nbsp;';
    else n += '<span class="icon icon-box-select"></span> &nbsp;';
    n += i.name + "</td><td></td>";
    if (i.mesh) {
      n += "<td>";
      for (let e = 0; e < i.mesh.meshes.length; e++) {
        if (e > 0) n += ", ";
        n += i.mesh.meshes[e].name;
      }
      n += "</td>";
      n += "<td>";
      n += i.hasSkin() || "-";
      n += "</td>";
      n += "<td>";
      let t = 0;
      for (let e = 0; e < i.mesh.meshes.length; e++) {
        if (t > 0) n += ", ";
        if (I.json.materials && i.mesh.meshes[e].hasOwnProperty("material")) {
          if (I.json.materials[i.mesh.meshes[e].material]) {
            n += I.json.materials[i.mesh.meshes[e].material].name;
            t++;
          }
        }
      }
      if (t == 0) n += "none";
      n += "</td>";
    } else {
      n += "<td>-</td><td>-</td><td>-</td>";
    }
    n += "<td>";
    if (i._node.translation || i._node.rotation || i._node.scale) {
      let e = "";
      if (i._node.translation)
        e += "Translate: `" + o(i._node.translation) + "` || ";
      if (i._node.rotation) e += "Rotation: `" + o(i._node.rotation) + "` || ";
      if (i._node.scale) e += "Scale: `" + o(i._node.scale) + "` || ";
      n +=
        '<span class="icon icon-gizmo info" data-info="' +
        e +
        '"></span> &nbsp;';
    }
    if (i._animRot || i._animScale || i._animTrans) {
      let e = "Animated: ";
      if (i._animRot) e += "Rot ";
      if (i._animScale) e += "Scale ";
      if (i._animTrans) e += "Trans ";
      n +=
        '<span class="icon icon-clock info" data-info="' +
        e +
        '"></span>&nbsp;';
    }
    if (
      !i._node.translation &&
      !i._node.rotation &&
      !i._node.scale &&
      !i._animRot &&
      !i._animScale &&
      !i._animTrans
    )
      n += "-";
    n += "</td>";
    n += "<td>";
    let t = "";
    if (i.hidden) t = "node-hidden";
    n +=
      "<a onclick=\"gui.corePatch().getOpById('" +
      T.id +
      "').exposeNode('" +
      i.name +
      "','transform')\" class=\"treebutton\">Transform</a>";
    n +=
      " <a onclick=\"gui.corePatch().getOpById('" +
      T.id +
      "').exposeNode('" +
      i.name +
      "','hierarchy')\" class=\"treebutton\">Hierarchy</a>";
    n +=
      " <a onclick=\"gui.corePatch().getOpById('" +
      T.id +
      "').exposeNode('" +
      i.name +
      '\')" class="treebutton">Node</a>';
    if (i.hasSkin())
      n +=
        " <a onclick=\"gui.corePatch().getOpById('" +
        T.id +
        "').exposeNode('" +
        i.name +
        '\',false,{skin:true});" class="treebutton">Skin</a>';
    n += "</td><td>";
    n +=
      '&nbsp;<span class="icon iconhover icon-eye ' +
      t +
      '" onclick="gui.corePatch().getOpById(\'' +
      T.id +
      "').toggleNodeVisibility('" +
      i.name +
      "');this.classList.toggle('node-hidden');\"></span>";
    n += "</td>";
    n += "</tr>";
    if (i.children) {
      for (let e = 0; e < i.children.length; e++)
        n = H(n, I.nodes[i.children[e]], r + 1);
    }
    return n;
  }
  function W(t, e) {
    let n = "<tr>";
    n += " <td>" + e + "</td>";
    n += " <td>" + t.name + "</td>";
    n += " <td>";
    const i = JSON.stringify(t, null, 4)
      .replaceAll('"', "")
      .replaceAll("\n", "<br/>");
    n +=
      "<span class=\"icon icon-info\" onclick=\"new CABLES.UI.ModalDialog({ 'html': '<pre>" +
      i +
      "</pre>', 'title': '" +
      t.name +
      "' });\"></span>&nbsp;";
    if (t.pbrMetallicRoughness && t.pbrMetallicRoughness.baseColorFactor) {
      let e = "";
      e += "" + Math.round(t.pbrMetallicRoughness.baseColorFactor[0] * 255);
      e += "," + Math.round(t.pbrMetallicRoughness.baseColorFactor[1] * 255);
      e += "," + Math.round(t.pbrMetallicRoughness.baseColorFactor[2] * 255);
      n +=
        '<div style="width:15px;height:15px;background-color:rgb(' +
        e +
        ');display:inline-block">&nbsp;</a>';
    }
    n +=
      ' <td style="">' +
      (I.shaders[e]
        ? "-"
        : "<a onclick=\"gui.corePatch().getOpById('" +
          T.id +
          "').assignMaterial('" +
          t.name +
          '\')" class="treebutton">Assign</a>') +
      "<td>";
    n += "<td>";
    n += "</tr>";
    return n;
  }
  function e() {
    if (!I) return;
    const e = performance.now();
    const a = {};
    let s = '<div style="overflow:scroll;width:100%;height:100%">';
    s +=
      'File: <a href="' +
      CABLES.platform.getCablesUrl() +
      "/asset/patches/?filename=" +
      C.get() +
      '" target="_blank">' +
      CABLES.basename(C.get()) +
      "</a><br/>";
    s += "Generator:" + I.json.asset.generator;
    let t = 0;
    if (I.json.nodes) t = I.json.nodes.length;
    s += '<div id="groupNodes">Nodes (' + t + ")</div>";
    s += '<table id="sectionNodes" class="table treetable">';
    s += "<tr>";
    s += ' <th colspan="21">Name</th>';
    s += " <th>Mesh</th>";
    s += " <th>Skin</th>";
    s += " <th>Material</th>";
    s += " <th>Transform</th>";
    s += " <th>Expose</th>";
    s += " <th></th>";
    s += "</tr>";
    for (let e = 0; e < I.nodes.length; e++) {
      if (!I.nodes[e].isChild) s = H(s, I.nodes[e], 1);
    }
    s += "</table>";
    let n = 0;
    if (I.json.materials) n = I.json.materials.length;
    s += '<div id="groupMaterials">Materials (' + n + ")</div>";
    if (!I.json.materials || I.json.materials.length == 0) {
    } else {
      s += '<table id="materialtable"  class="table treetable">';
      s += "<tr>";
      s += " <th>Index</th>";
      s += " <th>Name</th>";
      s += " <th>Color</th>";
      s += " <th>Function</th>";
      s += " <th></th>";
      s += "</tr>";
      for (let e = 0; e < I.json.materials.length; e++) {
        s += W(I.json.materials[e], e);
      }
      s += "</table>";
    }
    s += '<div id="groupMeshes">Meshes (' + I.json.meshes.length + ")</div>";
    s += '<table id="meshestable"  class="table treetable">';
    s += "<tr>";
    s += " <th>Name</th>";
    s += " <th>Node</th>";
    s += " <th>Material</th>";
    s += " <th>Vertices</th>";
    s += " <th>Attributes</th>";
    s += "</tr>";
    let o = [];
    a.meshes = 0;
    a.meshTargets = 0;
    for (let r = 0; r < I.json.meshes.length; r++) {
      s += "<tr>";
      s += "<td>" + I.json.meshes[r].name + "</td>";
      s += "<td>";
      let t = 0;
      let n = "";
      for (let e = 0; e < I.json.nodes.length; e++) {
        if (I.json.nodes[e].mesh == r) {
          t++;
          if (t == 1) {
            n = I.json.nodes[e].name;
          }
        }
      }
      if (t > 1) s += t + " nodes (" + n + " ...)";
      else s += n;
      s += "</td>";
      s += "<td>";
      for (let e = 0; e < I.json.meshes[r].primitives.length; e++) {
        if (I.json.meshes[r].primitives[e].hasOwnProperty("material")) {
          if (I.json.materials[I.json.meshes[r]]) {
            s +=
              I.json.materials[I.json.meshes[r].primitives[e].material].name +
              " ";
          }
        } else s += "None";
      }
      s += "</td>";
      s += "<td>";
      let i = 0;
      for (let t = 0; t < I.json.meshes[r].primitives.length; t++) {
        if (I.json.meshes[r].primitives[t].attributes.POSITION != undefined) {
          let e = parseInt(
            I.json.accessors[I.json.meshes[r].primitives[t].attributes.POSITION]
              .count
          );
          i += e;
          s += "" + e + "<br/>";
        } else s += "-<br/>";
      }
      if (I.json.meshes[r].primitives.length > 1) s += "=" + i;
      s += "</td>";
      s += "<td>";
      for (let e = 0; e < I.json.meshes[r].primitives.length; e++) {
        s += Object.keys(I.json.meshes[r].primitives[e].attributes);
        s +=
          " <a onclick=\"gui.corePatch().getOpById('" +
          T.id +
          "').exposeGeom('" +
          I.json.meshes[r].name +
          "'," +
          e +
          ')" class="treebutton">Geometry</a>';
        s += "<br/>";
        if (I.json.meshes[r].primitives[e].targets) {
          s += I.json.meshes[r].primitives[e].targets.length + " targets<br/>";
          if (I.json.meshes[r].extras && I.json.meshes[r].extras.targetNames)
            s +=
              "Targetnames:<br/>" +
              I.json.meshes[r].extras.targetNames.join("<br/>");
          s += "<br/>";
        }
      }
      s += "</td>";
      s += "</tr>";
      for (let n = 0; n < I.json.meshes[r].primitives.length; n++) {
        const m = I.json.accessors[I.json.meshes[r].primitives[n].indices];
        if (m) {
          let e = m.bufferView;
          if (o.indexOf(e) == -1) {
            o.push(e);
            if (I.json.bufferViews[e])
              a.meshes += I.json.bufferViews[e].byteLength;
          }
        }
        for (let e in I.json.meshes[r].primitives[n].attributes) {
          const f = I.json.meshes[r].primitives[n].attributes[e];
          const g = I.json.accessors[f].bufferView;
          if (o.indexOf(g) == -1) {
            o.push(g);
            if (I.json.bufferViews[g])
              a.meshes += I.json.bufferViews[g].byteLength;
          }
        }
        if (I.json.meshes[r].primitives[n].targets)
          for (
            let t = 0;
            t < I.json.meshes[r].primitives[n].targets.length;
            t++
          ) {
            for (let e in I.json.meshes[r].primitives[n].targets[t]) {
              const b = I.json.meshes[r].primitives[n].targets[t][e];
              const m = I.json.accessors[b];
              const g = m.bufferView;
              console.log("accessor", m);
              if (o.indexOf(g) == -1)
                if (I.json.bufferViews[g]) {
                  o.push(g);
                  a.meshTargets += I.json.bufferViews[g].byteLength;
                }
            }
          }
      }
    }
    s += "</table>";
    let i = 0;
    let r = 0;
    let l = 0;
    if (I.json.animations) {
      r = I.json.animations.length;
      for (let e = 0; e < I.json.animations.length; e++) {
        i += I.json.animations[e].samplers.length;
      }
    }
    s += '<div id="groupAnims">Animations (' + r + "/" + i + ")</div>";
    if (I.json.animations) {
      s += '<table id="sectionAnim" class="table treetable">';
      s += "<tr>";
      s += "  <th>Name</th>";
      s += "  <th>Target node</th>";
      s += "  <th>Path</th>";
      s += "  <th>Interpolation</th>";
      s += "  <th>Keys</th>";
      s += "</tr>";
      a.animations = 0;
      for (let n = 0; n < I.json.animations.length; n++) {
        for (let t = 0; t < I.json.animations[n].samplers.length; t++) {
          let e =
            I.json.accessors[I.json.animations[n].samplers[t].input].bufferView;
          if (o.indexOf(e) == -1) {
            o.push(e);
            a.animations += I.json.bufferViews[e].byteLength;
          }
          e =
            I.json.accessors[I.json.animations[n].samplers[t].output]
              .bufferView;
          if (o.indexOf(e) == -1) {
            o.push(e);
            a.animations += I.json.bufferViews[e].byteLength;
          }
        }
        for (let e = 0; e < I.json.animations[n].channels.length; e++) {
          s += "<tr>";
          s += "  <td> Anim " + n + ": " + I.json.animations[n].name + "</td>";
          s +=
            "  <td>" +
            I.nodes[I.json.animations[n].channels[e].target.node].name +
            "</td>";
          s += "  <td>";
          s += I.json.animations[n].channels[e].target.path + " ";
          s += "  </td>";
          const v = I.json.animations[n].channels[e].sampler;
          const y = I.json.animations[n].samplers[v];
          s += "  <td>" + y.interpolation + "</td>";
          s += "  <td>" + I.json.accessors[y.output].count;
          l += I.json.accessors[y.output].count;
          s += "</td>";
          s += "</tr>";
        }
      }
      s += "<tr>";
      s += "  <td></td>";
      s += "  <td></td>";
      s += "  <td></td>";
      s += "  <td></td>";
      s += "  <td>" + l + " total</td>";
      s += "</tr>";
      s += "</table>";
    } else {
    }
    let u = 0;
    if (I.json.images) u = I.json.images.length;
    s += '<div id="groupImages">Images (' + u + ")</div>";
    if (I.json.images) {
      s += '<table id="sectionImages" class="table treetable">';
      s += "<tr>";
      s += "  <th>name</th>";
      s += "  <th>type</th>";
      s += "  <th>func</th>";
      s += "</tr>";
      a.images = 0;
      for (let t = 0; t < I.json.images.length; t++) {
        if (I.json.images[t].hasOwnProperty("bufferView")) {
          a.images +=
            I.json.bufferViews[I.json.images[t].bufferView].byteLength;
        } else console.log("image has no bufferview?!");
        s += "<tr>";
        s += "<td>" + I.json.images[t].name + "</td>";
        s += "<td>" + I.json.images[t].mimeType + "</td>";
        s += "<td>";
        let e = I.json.images[t].name;
        if (e === undefined) e = I.json.images[t].bufferView;
        s +=
          "<a onclick=\"gui.corePatch().getOpById('" +
          T.id +
          "').exposeTexture('" +
          e +
          '\')" class="treebutton">Expose</a>';
        s += "</td>";
        s += "<tr>";
      }
      s += "</table>";
    }
    let c = 0;
    if (I.json.cameras) c = I.json.cameras.length;
    s += '<div id="groupCameras">Cameras (' + c + ")</div>";
    if (I.json.cameras) {
      s += '<table id="sectionCameras" class="table treetable">';
      s += "<tr>";
      s += "  <th>name</th>";
      s += "  <th>type</th>";
      s += "  <th>info</th>";
      s += "</tr>";
      for (let e = 0; e < I.json.cameras.length; e++) {
        s += "<tr>";
        s += "<td>" + I.json.cameras[e].name + "</td>";
        s += "<td>" + I.json.cameras[e].type + "</td>";
        s += "<td>";
        if (I.json.cameras[e].perspective) {
          s +=
            "yfov: " +
            Math.round(I.json.cameras[e].perspective.yfov * 100) / 100;
          s += ", ";
          s +=
            "zfar: " +
            Math.round(I.json.cameras[e].perspective.zfar * 100) / 100;
          s += ", ";
          s +=
            "znear: " +
            Math.round(I.json.cameras[e].perspective.znear * 100) / 100;
        }
        s += "</td>";
        s += "<tr>";
      }
      s += "</table>";
    }
    let d = 0;
    if (I.json.skins) d = I.json.skins.length;
    s += '<div id="groupSkins">Skins (' + d + ")</div>";
    if (I.json.skins) {
      s += '<table id="sectionSkins" class="table treetable">';
      s += "<tr>";
      s += "  <th>name</th>";
      s += "  <th></th>";
      s += "  <th>total joints</th>";
      s += "</tr>";
      for (let e = 0; e < I.json.skins.length; e++) {
        s += "<tr>";
        s += "<td>" + I.json.skins[e].name + "</td>";
        s += "<td>" + "</td>";
        s += "<td>" + I.json.skins[e].joints.length + "</td>";
        s += "<td>";
        s += "</td>";
        s += "<tr>";
      }
      s += "</table>";
    }
    if (I.timing) {
      s += '<div id="groupTiming">Debug Loading Timing </div>';
      s += '<table id="sectionTiming" class="table treetable">';
      s += "<tr>";
      s += "  <th>task</th>";
      s += "  <th>time used</th>";
      s += "</tr>";
      let e = 0;
      for (let e = 0; e < I.timing.length - 1; e++) {
        s += "<tr>";
        s += "  <td>" + I.timing[e][0] + "</td>";
        s += "  <td>" + (I.timing[e + 1][1] - I.timing[e][1]) + " ms</td>";
        s += "</tr>";
      }
      s += "</table>";
    }
    let h = 0;
    if (I.json.buffers) h = I.json.buffers[0].byteLength;
    s +=
      '<div id="groupBinary">File Size Allocation (' +
      Math.round(h / 1024) +
      "k )</div>";
    s += '<table id="sectionBinary" class="table treetable">';
    s += "<tr>";
    s += "  <th>name</th>";
    s += "  <th>size</th>";
    s += "  <th>%</th>";
    s += "</tr>";
    let p = h;
    for (let e in a) {
      s += "<tr>";
      s += "<td>" + e + "</td>";
      s += "<td>" + X(a[e]) + " </td>";
      s += "<td>" + Math.round((a[e] / h) * 100) + "% </td>";
      s += "<tr>";
      p -= a[e];
    }
    if (p != 0) {
      s += "<tr>";
      s += "<td>unknown</td>";
      s += "<td>" + X(p) + " </td>";
      s += "<td>" + Math.round((p / h) * 100) + "% </td>";
      s += "<tr>";
    }
    s += "</table>";
    s += "</div>";
    _ = new CABLES.UI.Tab("GLTF " + CABLES.basename(C.get()), {
      icon: "cube",
      infotext: "tab_gltf",
      padding: true,
      singleton: true,
    });
    gui.mainTabs.addTab(_, true);
    _.addEventListener("close", w);
    _.html(s);
    CABLES.UI.Collapsable.setup(
      ele.byId("groupNodes"),
      ele.byId("sectionNodes"),
      false
    );
    CABLES.UI.Collapsable.setup(
      ele.byId("groupMaterials"),
      ele.byId("materialtable"),
      true
    );
    CABLES.UI.Collapsable.setup(
      ele.byId("groupAnims"),
      ele.byId("sectionAnim"),
      true
    );
    CABLES.UI.Collapsable.setup(
      ele.byId("groupMeshes"),
      ele.byId("meshestable"),
      true
    );
    CABLES.UI.Collapsable.setup(
      ele.byId("groupCameras"),
      ele.byId("sectionCameras"),
      true
    );
    CABLES.UI.Collapsable.setup(
      ele.byId("groupImages"),
      ele.byId("sectionImages"),
      true
    );
    CABLES.UI.Collapsable.setup(
      ele.byId("groupSkins"),
      ele.byId("sectionSkins"),
      true
    );
    CABLES.UI.Collapsable.setup(
      ele.byId("groupBinary"),
      ele.byId("sectionBinary"),
      true
    );
    CABLES.UI.Collapsable.setup(
      ele.byId("groupTiming"),
      ele.byId("sectionTiming"),
      true
    );
    gui.maintabPanel.show(true);
  }
  function X(e) {
    if (e > 1024) return Math.round(e / 1024) + " kb";
    if (e > 1024 * 500) return Math.round(e / 1024) + " mb";
    else return e + " bytes";
  }
  const Y = class {
    constructor(e) {
      this._mod = null;
      this._node = e;
      this._lastTime = 0;
      this._matArr = [];
      this._m = mat4.create();
      this._invBindMatrix = mat4.create();
      this.identity = true;
    }
    renderFinish(e) {
      e.popModelMatrix();
      this._mod.unbind();
    }
    renderStart(e, t) {
      if (!this._mod) {
        this._mod = new CGL.ShaderModifier(e, T.name + this._node.name);
        this._mod.addModule({
          priority: -2,
          name: "MODULE_VERTEX_POSITION",
          srcHeadVert: l.skin_head_vert || "",
          srcBodyVert: l.skin_vert || "",
        });
        this._mod.addUniformVert("m4[]", "MOD_boneMats", []);
        const r = vec3.create();
      }
      const n = this._node.skin;
      const i = I.json.skins[n].joints.length * 16;
      {
        if (this._matArr.length != i) this._matArr.length = i;
        for (let e = 0; e < I.json.skins[n].joints.length; e++) {
          const a = e * 16;
          const s = I.json.skins[n].joints[e];
          const o = I.nodes[s];
          for (let e = 0; e < 16; e++)
            this._invBindMatrix[e] =
              I.accBuffers[I.json.skins[n].inverseBindMatrices][a + e];
          mat4.mul(this._m, o.modelMatAbs(), this._invBindMatrix);
          for (let e = 0; e < this._m.length; e++)
            this._matArr[a + e] = this._m[e];
        }
        this._mod.setUniformValue("MOD_boneMats", this._matArr);
        this._lastTime = t;
      }
      this._mod.define("SKIN_NUM_BONES", I.json.skins[n].joints.length);
      this._mod.bind();
      e.pushModelMatrix();
      if (this.identity) mat4.identity(e.mMatrix);
    }
  };
  const K = class {
    constructor(e) {
      this.mesh = e;
      this.tex = null;
      this.numRowsPerTarget = 0;
      this.makeTex(e.geom);
    }
    renderFinish(e) {
      e.popModelMatrix();
      this._mod.unbind();
    }
    renderStart(e, t) {
      if (!this._mod) {
        this._mod = new CGL.ShaderModifier(e, "gltftarget");
        this._mod.addModule({
          priority: -2,
          name: "MODULE_VERTEX_POSITION",
          srcHeadVert: l.targets_head_vert || "",
          srcBodyVert: l.targets_vert || "",
        });
        this._mod.addUniformVert("4f", "MOD_targetTexInfo", [0, 0, 0, 0]);
        this._mod.addUniformVert("t", "MOD_targetTex", 1);
        this._mod.addUniformVert("f[]", "MOD_weights", []);
        const n = vec3.create();
      }
      this._mod.pushTexture("MOD_targetTex", this.tex);
      if (this.tex && this.mesh.weights) {
        this._mod.setUniformValue("MOD_weights", this.mesh.weights);
        this._mod.setUniformValue("MOD_targetTexInfo", [
          this.tex.width,
          this.tex.height,
          this.numRowsPerTarget,
          this.mesh.weights.length,
        ]);
        this._mod.define(
          "MOD_NUM_WEIGHTS",
          Math.max(1, this.mesh.weights.length)
        );
      } else {
        this._mod.define("MOD_NUM_WEIGHTS", 1);
      }
      this._mod.bind();
      e.pushModelMatrix();
      if (this.identity) mat4.identity(e.mMatrix);
    }
    makeTex(n) {
      if (!n.morphTargets || !n.morphTargets.length) return;
      let i = n.morphTargets[0].vertices.length / 3;
      let e = 0;
      this.numRowsPerTarget = 0;
      if (n.morphTargets[0].vertices && n.morphTargets[0].vertices.length)
        this.numRowsPerTarget++;
      if (
        n.morphTargets[0].vertexNormals &&
        n.morphTargets[0].vertexNormals.length
      )
        this.numRowsPerTarget++;
      if (n.morphTargets[0].tangents && n.morphTargets[0].tangents.length)
        this.numRowsPerTarget++;
      if (n.morphTargets[0].bitangents && n.morphTargets[0].bitangents.length)
        this.numRowsPerTarget++;
      e = n.morphTargets.length * this.numRowsPerTarget;
      const r = new Float32Array(i * e * 4);
      let a = 0;
      for (let t = 0; t < n.morphTargets.length; t++) {
        if (n.morphTargets[t].vertices && n.morphTargets[t].vertices.length) {
          for (let e = 0; e < n.morphTargets[t].vertices.length; e += 3) {
            r[(a * i + e / 3) * 4 + 0] = n.morphTargets[t].vertices[e + 0];
            r[(a * i + e / 3) * 4 + 1] = n.morphTargets[t].vertices[e + 1];
            r[(a * i + e / 3) * 4 + 2] = n.morphTargets[t].vertices[e + 2];
            r[(a * i + e / 3) * 4 + 3] = 1;
          }
          a++;
        }
        if (
          n.morphTargets[t].vertexNormals &&
          n.morphTargets[t].vertexNormals.length
        ) {
          for (let e = 0; e < n.morphTargets[t].vertexNormals.length; e += 3) {
            r[(a * i + e / 3) * 4 + 0] = n.morphTargets[t].vertexNormals[e + 0];
            r[(a * i + e / 3) * 4 + 1] = n.morphTargets[t].vertexNormals[e + 1];
            r[(a * i + e / 3) * 4 + 2] = n.morphTargets[t].vertexNormals[e + 2];
            r[(a * i + e / 3) * 4 + 3] = 1;
          }
          a++;
        }
        if (n.morphTargets[t].tangents && n.morphTargets[t].tangents.length) {
          for (let e = 0; e < n.morphTargets[t].tangents.length; e += 3) {
            r[(a * i + e / 3) * 4 + 0] = n.morphTargets[t].tangents[e + 0];
            r[(a * i + e / 3) * 4 + 1] = n.morphTargets[t].tangents[e + 1];
            r[(a * i + e / 3) * 4 + 2] = n.morphTargets[t].tangents[e + 2];
            r[(a * i + e / 3) * 4 + 3] = 1;
          }
          a++;
        }
        if (
          n.morphTargets[t].bitangents &&
          n.morphTargets[t].bitangents.length
        ) {
          for (let e = 0; e < n.morphTargets[t].bitangents.length; e += 3) {
            r[(a * i + e / 3) * 4 + 0] = n.morphTargets[t].bitangents[e + 0];
            r[(a * i + e / 3) * 4 + 1] = n.morphTargets[t].bitangents[e + 1];
            r[(a * i + e / 3) * 4 + 2] = n.morphTargets[t].bitangents[e + 2];
            r[(a * i + e / 3) * 4 + 3] = 1;
          }
          a++;
        }
      }
      this.tex = new CGL.Texture(m, {
        isFloatingPointTexture: true,
        name: "targetsTexture",
      });
      this.tex.initFromData(
        r,
        i,
        e,
        CGL.Texture.FILTER_LINEAR,
        CGL.Texture.WRAP_REPEAT
      );
    }
  };
  const Q = T.inTrigger("Render"),
    t = T.inString("data"),
    C = T.inUrl("glb File", [".glb"]),
    Z = T.inBool("Draw", true),
    n = T.inDropDown("Camera", ["None"], "None"),
    J = T.inString("Animation", ""),
    $ = T.inTriggerButton("Show Structure"),
    i = T.inSwitch("Center", ["None", "XYZ", "XZ"], "XYZ"),
    r = T.inBool("Rescale", true),
    a = T.inFloat("Rescale Size", 2.5),
    s = T.inFloat("Time"),
    u = T.inBool("Sync to timeline", false),
    ee = T.inBool("Loop", true),
    te = T.inSwitch("Normals Format", ["XYZ", "X-ZY"], "XYZ"),
    ne = T.inSwitch("Vertices Format", ["XYZ", "XZ-Y"], "XYZ"),
    c = T.inSwitch("Calc Normals", ["Auto", "Force Smooth", "Never"], "Auto"),
    d = T.inObject("Materials"),
    ie = T.inArray("Hide Nodes"),
    re = T.inBool("Use Material Properties", false),
    h = T.inBool("Active", true),
    ae = T.outTrigger("Render Before"),
    p = T.outTrigger("Next"),
    se = T.outString("Generator"),
    oe = T.outNumber("GLTF Version"),
    le = T.outArray("GLTF Extensions Used"),
    ue = T.outNumber("Anim Length", 0),
    ce = T.outNumber("Anim Time", 0),
    de = T.outObject("Json"),
    he = T.outArray("Anims"),
    pe = T.outArray("BoundingPoints"),
    me = T.outObject("Bounds"),
    fe = T.outTrigger("Finished"),
    ge = T.outBool("Loading");
  T.setPortGroup("Timing", [s, u, ee]);
  let m = T.patch.cg || T.patch.cgl;
  let f = null;
  let be = false;
  let ve = 0;
  let g = false;
  let b = null;
  let v = [];
  let I = null;
  let y = 0;
  let x = 0;
  let E = true;
  let ye = null;
  let k = null;
  let P = null;
  const _e = vec3.create();
  let Te = 0;
  let Oe = false;
  const j = vec3.create();
  C.onChange = ne.onChange = c.onChange = te.onChange = L;
  $.onTriggered = e;
  t.onChange = ke;
  ie.onChange = Ee;
  J.onChange = je;
  i.onChange = Ae;
  T.toWorkPortsNeedToBeLinked(Q);
  t.setUiAttribs({ hideParam: true, hidePort: true });
  T.setPortGroup("Transform", [r, a, i]);
  function Se() {
    const t = ["None"];
    if (I) {
      for (let e = 0; e < I.nodes.length; e++) {
        if (I.nodes[e].camera >= 0) {
          t.push(I.nodes[e].name);
        }
      }
    }
    n.uiAttribs.values = t;
  }
  function Ae() {
    Oe = i.get() != "None";
    if (I && I.bounds) {
      j.set(I.bounds.center);
      j[0] = -j[0];
      j[1] = -j[1];
      j[2] = -j[2];
      if (i.get() == "XZ") j[1] = -I.bounds.minY;
    }
  }
  r.onChange = function () {
    a.setUiAttribs({ greyout: !r.get() });
  };
  d.onChange = function () {
    E = true;
  };
  T.onDelete = function () {
    w();
  };
  u.onChange = function () {
    s.setUiAttribs({ greyout: u.get() });
  };
  n.onChange = we;
  function we() {
    b = null;
    if (!I) return;
    for (let e = 0; e < I.nodes.length; e++) {
      if (I.nodes[e].name == n.get()) b = new D(I, I.nodes[e]);
    }
  }
  Q.onTriggered = function () {
    m = T.patch.cg || T.patch.cgl;
    if (!g) return;
    if (!h.get()) return;
    if (be) {
      if (!f) f = CGL.MESHES.getSimpleCube(m, "ErrorCube");
      f.render(m.getShader());
    }
    ve = 0;
    if (u.get()) x = T.patch.timer.getTime();
    else x = Math.max(0, s.get());
    if (ee.get()) {
      x %= y;
      if (x < Te) fe.trigger();
    } else {
      if (y > 0 && x >= y) fe.trigger();
    }
    Te = x;
    m.pushModelMatrix();
    ce.set(x || 0);
    if (g && I && I.bounds) {
      if (r.get()) {
        let e = a.get() / I.bounds.maxAxis;
        I.scale = e;
        vec3.set(_e, e, e, e);
        mat4.scale(m.mMatrix, m.mMatrix, _e);
      }
      if (Oe) {
        mat4.translate(m.mMatrix, m.mMatrix, j);
      }
    }
    let e = m.tempData.currentScene || null;
    m.tempData.currentScene = I;
    ae.trigger();
    if (g) {
      if (E) Ie();
      if (b) b.start(x);
      if (I) {
        I.time = x;
        if (I.bounds && m.shouldDrawHelpers(T)) {
          if (T.isCurrentUiOp())
            m.pushShader(CABLES.GL_MARKER.getSelectedShader(m));
          else m.pushShader(CABLES.GL_MARKER.getDefaultShader(m));
          I.bounds.render(m, null, T);
          m.popShader();
        }
        if (Z.get()) {
          for (let e = 0; e < I.nodes.length; e++)
            if (!I.nodes[e].isChild) I.nodes[e].render(m);
        } else {
          for (let e = 0; e < I.nodes.length; e++)
            if (!I.nodes[e].isChild) I.nodes[e].render(m, false, true);
        }
      }
    }
    p.trigger();
    m.tempData.currentScene = e;
    m.popModelMatrix();
    if (b) b.end();
  };
  function N() {
    if (!I) {
      g = true;
      be = true;
      m.patch.loading.finished(k);
      T.setUiError("nogltf", "GLTF File not found");
      return;
    }
    T.setUiError("nogltf", null);
    if (I.loadingMeshes > 0) {
      setTimeout(N, 100);
      return;
    }
    I.timing.push([
      "finishLoading()",
      Math.round(performance.now() - I.startTime),
    ]);
    E = true;
    ue.set(y);
    I.bounds = new CABLES.CG.BoundingBox();
    I.timing.push([
      "start calc bounds",
      Math.round(performance.now() - I.startTime),
    ]);
    for (let e = 0; e < I.nodes.length; e++) {
      const t = I.nodes[e];
      t.updateMatrix();
      if (!t.isChild) t.calcBounds(I, null, I.bounds);
    }
    if (I.bounds) me.set(I.bounds);
    I.timing.push([
      "calced bounds",
      Math.round(performance.now() - I.startTime),
    ]);
    Ee();
    I.timing.push([
      "hideNodesFromData",
      Math.round(performance.now() - I.startTime),
    ]);
    if (_) e();
    I.timing.push(["printinfo", Math.round(performance.now() - I.startTime)]);
    Se();
    we();
    pe.set(v);
    if (I) {
      if (C.get() && !C.get().startsWith("data:")) {
        T.setUiAttrib({ extendTitle: CABLES.basename(C.get()) });
      }
      I.loaded = Date.now();
    }
    if (I) {
      for (let e = 0; e < I.nodes.length; e++) {
        if (!I.nodes[e].isChild) {
          I.nodes[e].render(m, false, true, true, false, true, 0);
        }
      }
      for (let e = 0; e < I.nodes.length; e++) {
        const t = I.nodes[e];
        t.children = Le(t.children);
      }
    }
    Ae();
    je();
    ge.set(false);
    m.patch.loading.finished(k);
    k = null;
    if (I.accBuffersDelete) {
      for (let e = 0; e < I.accBuffersDelete.length; e++) {
        I.accBuffers[I.accBuffersDelete[e]] = null;
      }
    }
    if (!(I.json.images && I.json.images.length)) I.chunks = null;
    g = true;
  }
  function Ce(e) {
    if (!h.get()) return;
    if (!k) k = m.patch.loading.start("gltfScene", C.get(), T);
    let t = C.get();
    if (!t || t == "null") return;
    let n = T.patch.getFilePath(String(C.get()));
    if (!n) return;
    if (C.get() && !C.get().startsWith("data:")) {
      if (e === true) n += "?rnd=" + CABLES.generateUUID();
    }
    E = true;
    ge.set(true);
    fetch(n)
      .then((e) => {
        return e.arrayBuffer();
      })
      .then((e) => {
        if (C.get() != t) {
          m.patch.loading.finished(k);
          k = null;
          return;
        }
        v = [];
        y = 0;
        I = F(e);
        e = null;
        N();
      })
      .catch((e) => {
        if (k) m.patch.loading.finished(k);
        k = null;
        N();
        T.logError("gltf fetch error", e);
      });
    w();
    const i = new XMLHttpRequest();
    i.open("GET", n, true);
    i.responseType = "arraybuffer";
    m.patch.loading.addAssetLoadingTask(() => {});
  }
  T.onFileChanged = function (e) {
    if (C.get() && C.get().indexOf(e) > -1) {
      L(true);
    }
  };
  h.onChange = () => {
    if (h.get()) L();
    if (!h.get()) {
      I = null;
    }
  };
  function L(e) {
    clearTimeout(ye);
    ye = setTimeout(function () {
      Ce(e);
    }, 30);
  }
  function Ie() {
    if (!I) return;
    I.shaders = {};
    if (d.links.length == 1 && d.get()) {
      E = true;
      const n = d.links[0].portOut.op;
      const i = n.getPort("Shader");
      const r = n.getPort("Material Name");
      if (!i && !r) {
        const a = d.get();
        for (let t in a) {
          if (a[t] && I.json.materials)
            for (let e = 0; e < I.json.materials.length; e++) {
              if (I.json.materials[e].name == t) {
                if (I.shaders[e]) {
                  n.warn("double material assignment:", name);
                }
                I.shaders[e] = a[t];
              }
            }
        }
      }
    }
    if (d.get()) {
      for (let e = 0; e < d.links.length; e++) {
        const t = d.links[e].portOut.op;
        const i = t.getPort("Shader");
        const r = t.getPort("Material Name");
        if (i && r && i.get()) {
          const name = r.get();
          if (I.json.materials)
            for (let e = 0; e < I.json.materials.length; e++)
              if (I.json.materials[e].name == name) {
                if (I.shaders[e]) {
                  t.warn("double material assignment:", name);
                }
                I.shaders[e] = i.get();
              }
        }
      }
    }
    E = false;
    if (_) e();
  }
  function xe() {
    const t = ie.get();
    if (!I || !P || !P.hiddenNodes) return;
    if (!t) {
      return;
    }
    for (let e = 0; e < t.length; e++) {
      const n = I.getNode(t[e]);
      if (n) n.hidden = true;
    }
  }
  function Ee() {
    if (!P) ke();
    if (!I) return;
    I.unHideAll();
    if (P && P.hiddenNodes) {
      for (const e in P.hiddenNodes) {
        const t = I.getNode(e);
        if (t) t.hidden = true;
        else T.verbose("node to be hidden not found", e, t);
      }
    }
    xe();
  }
  function ke() {
    P = t.get();
    if (!P || P === "") P = {};
    else P = JSON.parse(P);
    if (I) Ee();
    return P;
  }
  function Pe() {
    t.set(JSON.stringify(P));
  }
  function je() {
    if (I && I.nodes) {
      for (let e = 0; e < I.nodes.length; e++) {
        I.nodes[e].setAnimAction(J.get());
      }
    }
  }
  function Ne(t, n) {
    for (let e = 0; e < I.nodes.length; e++) {
      if (I.nodes[e].children.indexOf(n) >= 0) {
        t.push(I.nodes[e]);
        if (I.nodes[e].isChild) Ne(t, e);
      }
    }
  }
  T.exposeTexture = function (e) {
    const t = gui.corePatch().addOp("Ops.Gl.GLTF.GltfTexture");
    t.getPort("Name").set(e);
    M(t, 1);
    T.patch.link(T, p.name, t, "Render");
    gui.patchView.testCollision(t);
    gui.patchView.centerSelectOp(t.id, true);
  };
  T.exposeGeom = function (e, t) {
    const n = gui.corePatch().addOp("Ops.Gl.GLTF.GltfGeometry");
    n.getPort("Name").set(e);
    n.getPort("Submesh").set(t);
    M(n, 1);
    T.patch.link(T, p.name, n, "Update");
    gui.patchView.testCollision(n);
    gui.patchView.centerSelectOp(n.id, true);
  };
  function M(e, t) {
    t = t || 1;
    e.setUiAttrib({
      subPatch: T.uiAttribs.subPatch,
      translate: {
        x: T.uiAttribs.translate.x,
        y: T.uiAttribs.translate.y + t * CABLES.GLUI.glUiConfig.newOpDistanceY,
      },
    });
  }
  T.exposeNode = function (n, e, i) {
    let t = e == "hierarchy";
    if (t) {
      let r = [];
      for (let e = 0; e < I.nodes.length; e++) {
        if (I.nodes[e].name == n) {
          let t = [];
          const a = I.nodes[e];
          Ne(t, e);
          t = t.reverse();
          t.push(a, a);
          let n = p.name;
          let i = T;
          for (let e = 0; e < t.length; e++) {
            const s = gui.corePatch().addOp("Ops.Gl.GLTF.GltfNode_v2");
            s.getPort("Node Name").set(t[e].name);
            T.patch.link(i, n, s, "Render");
            M(s, e);
            if (e == t.length - 1) {
              s.getPort("Transformation").set(false);
            } else {
              s.getPort("Draw Mesh").set(false);
              s.getPort("Draw Childs").set(false);
            }
            n = "Next";
            i = s;
            r.push(s);
            gui.patchView.testCollision(s);
          }
        }
      }
      for (let e = 0; e < r.length; e++) {
        r[e].selectChilds();
      }
    } else {
      let t = "Ops.Gl.GLTF.GltfNode_v2";
      if (i && i.skin) t = "Ops.Gl.GLTF.GltfSkin";
      if (e == "transform") t = "Ops.Gl.GLTF.GltfNodeTransform_v2";
      gui.serverOps.loadOpLibs(t, () => {
        let e = gui.corePatch().addOp(t);
        e.getPort("Node Name").set(n);
        M(e);
        T.patch.link(T, p.name, e, "Render");
        gui.patchView.testCollision(e);
        gui.patchView.centerSelectOp(e.id, true);
      });
    }
    gui.closeModal();
  };
  T.assignMaterial = function (e) {
    const t = gui.corePatch().addOp("Ops.Gl.GLTF.GltfSetMaterial");
    t.getPort("Material Name").set(e);
    T.patch.link(T, d.name, t, "Material");
    M(t);
    gui.patchView.testCollision(t);
    gui.patchView.centerSelectOp(t.id, true);
    gui.closeModal();
  };
  T.toggleNodeVisibility = function (e) {
    const t = I.getNode(e);
    t.hidden = !t.hidden;
    P.hiddenNodes = P.hiddenNodes || {};
    if (t)
      if (t.hidden) P.hiddenNodes[e] = true;
      else delete P.hiddenNodes[e];
    Pe();
  };
  function Le(n) {
    const i = {},
      r = [];
    for (let e = 0, t = n.length; e < t; ++e) {
      if (!i.hasOwnProperty(n[e])) {
        r.push(n[e]);
        i[n[e]] = 1;
      }
    }
    return r;
  }
};
Ops.Gl.GLTF.GltfScene_v4.prototype = new CABLES.Op();
CABLES.OPS["c9cbb226-46f7-4ca6-8dab-a9d0bdca4331"] = {
  f: Ops.Gl.GLTF.GltfScene_v4,
  objName: "Ops.Gl.GLTF.GltfScene_v4",
};
Ops.Ui.Area = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inString("Title", ""),
    i = e.inTriggerButton("Delete");
  n.setUiAttribs({ hidePort: true });
  e.setUiAttrib({ hasArea: true });
  e.init = n.onChange = e.onLoaded = r;
  r();
  function r() {
    if (CABLES.UI) {
      gui.savedState.setUnSaved("areaOp", e.getSubPatch());
      e.uiAttr({ comment_title: n.get() || " " });
      e.name = n.get();
    }
  }
  i.onTriggered = () => {
    e.patch.deleteOp(e.id);
  };
};
Ops.Ui.Area.prototype = new CABLES.Op();
CABLES.OPS["38f79614-b0de-4960-8da5-2827e7f43415"] = {
  f: Ops.Ui.Area,
  objName: "Ops.Ui.Area",
};
Ops.Json.SwitchObject = function () {
  CABLES.Op.apply(this, arguments);
  const n = this;
  const e = (n.attachments = {});
  const t = n.inValueInt("Object Index", 0);
  const i = n.outObject("object out");
  const r = 8;
  const a = [];
  n.onLoaded = function () {
    s();
  };
  t.onChange = s;
  for (let t = 0; t < r; t++) {
    let e = n.inObject("object port " + t);
    e.inputNum = t;
    e.onChange = o.bind(e);
    a[t] = e;
  }
  function s() {
    let e = Math.max(0, Math.floor(t.get()));
    if (e < 0) e = 0;
    else if (e > r - 1) e = r - 1;
    i.setRef(a[e].get());
  }
  function o() {
    if (this.inputNum != t.get()) return;
    i.setRef(this.get());
  }
};
Ops.Json.SwitchObject.prototype = new CABLES.Op();
CABLES.OPS["345d535e-267d-49fb-98c0-c8a8f9424160"] = {
  f: Ops.Json.SwitchObject,
  objName: "Ops.Json.SwitchObject",
};
Ops.Array.ArrayPack = function () {
  CABLES.Op.apply(this, arguments);
  const r = this;
  const e = (r.attachments = {});
  const a = r.outArray("Result");
  const s = 8;
  const o = [];
  let l = false;
  for (let t = 0; t < s; t++) {
    let e = r.inArray("Array " + t);
    e.onChange = n;
    o.push(e);
  }
  function n() {
    const t = [];
    const n = [];
    let i = 0;
    for (i = 0; i < s; i++) {
      let e = o[i].get();
      if (e) {
        n.push(e);
        if (e.length != n[0].length) {
          if (!l)
            r.setUiError("arraylen", "Arrays do not have the same length !");
          a.set(null);
          l = true;
          return;
        }
      }
    }
    if (n.length === 0) {
      if (!l) r.setUiError("invalid", "No Valid Arrays");
      a.set(null);
      l = true;
      return;
    }
    if (l) {
      r.setUiError("arraylen", null);
      r.setUiError("invalid", null);
    }
    l = false;
    for (let e = 0; e < n[0].length; e++)
      for (i = 0; i < n.length; i++) t.push(n[i][e]);
    a.setRef(t);
  }
};
Ops.Array.ArrayPack.prototype = new CABLES.Op();
CABLES.OPS["51df396d-87be-4890-8fbd-c8bb3d364d3b"] = {
  f: Ops.Array.ArrayPack,
  objName: "Ops.Array.ArrayPack",
};
Ops.Boolean.Boolean = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inBool("value", false),
    i = e.outBoolNum("result");
  i.set(false);
  n.onChange = r;
  function r() {
    if (i.get() != n.get()) i.set(n.get());
  }
};
Ops.Boolean.Boolean.prototype = new CABLES.Op();
CABLES.OPS["83e2d74c-9741-41aa-a4d7-1bda4ef55fb3"] = {
  f: Ops.Boolean.Boolean,
  objName: "Ops.Boolean.Boolean",
};
Ops.Gl.Textures.TextTexture_v6 = function () {
  CABLES.Op.apply(this, arguments);
  const g = this;
  const a = (g.attachments = {
    text_frag:
      "{{MODULES_HEAD}}\n\nUNI sampler2D tex;\nUNI float a;\nUNI vec4 color;\nIN vec2 texCoord;\n\nvoid main()\n{\n\n    vec4 col=texture(tex,vec2(texCoord.x,(1.0-texCoord.y)));\n\n    {{MODULE_COLOR}}\n\n    outColor=col;\n}\n",
    text_vert:
      "{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\nUNI float aspect;\nOUT vec2 texCoord;\nIN vec2 attrTexCoord;\n\nvoid main()\n{\n    vec4 pos=vec4(vPosition,  1.0);\n\n    pos.x*=aspect;\n\n    texCoord=vec2(attrTexCoord.x,1.0-attrTexCoord.y);;\n\n    mat4 mMatrix=modelMatrix;\n\n    {{MODULE_VERTEX_POSITION}}\n    mat4 modelViewMatrix=viewMatrix*mMatrix;\n\n    gl_Position = projMatrix * modelViewMatrix * pos;\n}\n",
  });
  const e = g.inTriggerButton("Render"),
    X = g.inString("text", "cables"),
    t = g.inValueBool("Draw Mesh", true),
    n = g.inValueFloat("Scale Mesh", 0.5),
    b = g.inSwitch("Size", ["Auto", "Manual"], "Auto"),
    v = g.inInt("Width", 512),
    y = g.inInt("Height", 512),
    _ = g.inBool("Auto Height", true),
    T = g.inBool("Auto Line Breaks", true),
    O = g.inString("font", "Arial"),
    S = g.inString("weight", "normal"),
    A = g.inValueFloat("fontSize", 300),
    w = g.inSwitch("align", ["left", "center", "right"], "center"),
    C = g.inSwitch("Vertical align", ["Top", "Middle", "Bottom"], "Top"),
    I = g.inFloat("Letter Spacing", 0),
    x = g.inFloat("Line Height Add", 0),
    Y = g.inInt("Padding Y Top", 3),
    K = g.inInt("Padding Y Bottom", 3),
    Q = g.inInt("Padding X", 0),
    E = g.inSwitch("filter", ["nearest", "linear", "mipmap"], "linear"),
    k = g.inValueSelect(
      "Wrap",
      ["repeat", "mirrored repeat", "clamp to edge"],
      "clamp to edge"
    ),
    P = g.inSwitch("Anisotropic", [0, 1, 2, 4, 8, 16], 0),
    j = g.inValueBool("Reuse Texture", true),
    Z = g.inBool("Show Debug", false),
    s = g.inBool("Redraw On Font Load", true),
    N = g.inValueSlider("r", 1),
    L = g.inValueSlider("g", 1),
    M = g.inValueSlider("b", 1),
    D = g.inFloatSlider("Opacity", 1),
    R = g.inValueSlider("background R", 0),
    J = g.inValueSlider("background G", 0),
    $ = g.inValueSlider("background B", 0),
    ee = g.inValueSlider("background A", 1),
    o = g.inTriggerButton("Force Redraw"),
    l = g.outTrigger("Next"),
    te = g.outNumber("Ratio"),
    B = g.outTexture("texture"),
    u = g.outObject("Canvas", null, "element"),
    c = g.outNumber("Aspect", 1),
    ne = g.outNumber("Num Lines");
  const U = " ";
  N.setUiAttribs({ colorPick: true });
  R.setUiAttribs({ colorPick: true });
  g.toWorkPortsNeedToBeLinked(e);
  g.setPortGroup("Text Color", [N, L, M, D]);
  g.setPortGroup("Background", [R, J, $, ee]);
  g.setPortGroup("Font", [O, S, A, w, C, I, x]);
  g.setPortGroup("Texture", [k, E, P, j, Z]);
  g.setPortGroup("Rendering", [t, n]);
  e.onLinkChanged = () => {
    if (!e.isLinked()) B.setRef(CGL.Texture.getEmptyTexture(V));
    else B.setRef(F);
  };
  o.onTriggered =
    N.onChange =
    L.onChange =
    M.onChange =
    D.onChange =
    C.onChange =
    T.onChange =
    _.onChange =
    x.onChange =
    b.onChange =
    v.onChange =
    y.onChange =
    w.onChange =
    I.onChange =
    Y.onChange =
    K.onChange =
    Q.onChange =
    X.onChange =
    A.onChange =
    S.onChange =
    P.onChange =
    O.onChange =
    Z.onChange =
    j.onChange =
      function () {
        W = true;
        ue();
      };
  B.ignoreValueSerialize = true;
  const V = g.patch.cgl;
  let F = new CGL.Texture(V);
  let G = 2;
  let q = 2;
  const z = document.createElement("canvas");
  z.id = "texturetext_" + CABLES.generateUUID();
  z.style.display = "none";
  document.body.appendChild(z);
  z.style.letterSpacing = "0px";
  u.setRef(z);
  let H = z.getContext("2d");
  let W = true;
  const d = CGL.MESHES.getSimpleRect(V, "texttexture rect");
  const i = vec3.create();
  const r = new CGL.Shader(V, "texttexture");
  r.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);
  r.setSource(a.text_vert, a.text_frag);
  const h = new CGL.Uniform(r, "t", "tex");
  const p = new CGL.Uniform(r, "f", "aspect", 0);
  const m = new CGL.Uniform(r, "f", "a", D);
  const f = new CGL.Uniform(r, "4f", "color", N, L, M, D);
  if (g.patch.isEditorMode())
    CABLES.UI.SIMPLEWIREFRAMERECT =
      CABLES.UI.SIMPLEWIREFRAMERECT || new CGL.WireframeRect(V);
  e.onTriggered = ae;
  t.onChange = ue;
  ue();
  g.on("delete", () => {
    H = null;
    z.remove();
  });
  P.onChange =
    E.onChange =
    k.onChange =
      () => {
        if (F) F.delete();
        F = null;
        W = true;
      };
  R.onChange =
    J.onChange =
    $.onChange =
    ee.onChange =
    N.onChange =
    L.onChange =
    M.onChange =
    D.onChange =
      () => {
        if (!t.get() || B.isLinked()) W = true;
      };
  B.onLinkChanged = () => {
    if (B.isLinked()) W = true;
  };
  g.patch.on("fontLoaded", (e) => {
    if (e == O.get()) W = true;
  });
  document.fonts.ready.then(() => {
    if (s.get()) W = true;
  });
  document.fonts.onloadingdone = function (e) {
    if (s.get()) W = true;
  };
  function ie() {
    return q;
  }
  function re() {
    return G;
  }
  function ae() {
    let e = 0;
    while (W && e < 10) {
      se();
      le();
      e++;
    }
    if (t.get()) {
      i[0] = i[1] = i[2] = n.get();
      V.pushBlendMode(CGL.BLEND_NORMAL, false);
      V.pushModelMatrix();
      mat4.scale(V.mMatrix, V.mMatrix, i);
      r.popTextures();
      r.pushTexture(h, F.tex);
      p.set(c.get());
      if (V.shouldDrawHelpers(g))
        CABLES.UI.SIMPLEWIREFRAMERECT.render(c.get(), 1, 1);
      V.pushShader(r);
      d.render(g.patch.cg.getShader());
      V.popShader();
      V.popBlendMode();
      V.popModelMatrix();
    }
    l.trigger();
  }
  function se() {
    if (F) F.setSize(ie(), re());
    H.canvas.width = z.width = ie();
    H.canvas.height = z.height = re();
    c.set(z.width / z.height);
    W = true;
  }
  function oe(n) {
    let i = "";
    for (let e = 0; e < n.length; e++) {
      if (!n[e]) {
        i += "\n";
        continue;
      }
      let t = 0;
      const r = n[e].split(U);
      for (let e = 0; e < r.length; e++) {
        if (!r[e]) continue;
        t += H.measureText(r[e] + U).width;
        if (t > v.get()) {
          i += "\n" + r[e] + U;
          t = H.measureText(r[e] + U).width;
        } else {
          i += r[e] + U;
        }
      }
      i += "\n";
    }
    let e = i;
    n = e.split("\n");
    if (n[n.length - 1] == "") n.pop();
    return n;
  }
  function le() {
    V.checkFrameStarted("texttrexture refresh");
    const e =
      "rgba(" +
      Math.floor(R.get() * 255) +
      "," +
      Math.floor(J.get() * 255) +
      "," +
      Math.floor($.get() * 255) +
      "," +
      ee.get() +
      ")";
    H.fillStyle = e;
    H.fillRect(0, 0, H.canvas.width, H.canvas.height);
    const t =
      "rgba(" +
      Math.floor(N.get() * 255) +
      "," +
      Math.floor(L.get() * 255) +
      "," +
      Math.floor(M.get() * 255) +
      "," +
      D.get() +
      ")";
    H.fillStyle = t;
    let n = parseFloat(A.get());
    let i = O.get();
    if (i.indexOf(U) > -1) i = '"' + i + '"';
    H.font = S.get() + U + n + "px " + i + "";
    H.textBaseline = "top";
    H.textAlign = w.get();
    H.letterSpacing = I.get() + "px";
    let r = (X.get() + "").replace(/<br\/>/g, "\n");
    r = r.trim();
    let a = r.split("\n");
    W = false;
    let s = Math.max(0, Y.get());
    let o = Math.max(0, K.get());
    let l = Math.max(0, Q.get());
    q = 0;
    G = 0;
    if (T.get() && b.get() == "Manual") {
      if (v.get() > 128) {
        a = oe(a);
      }
    }
    const u = [];
    for (let e = 0; e < a.length; e++) {
      const f = H.measureText(a[e]);
      u[e] =
        Math.ceil(f.fontBoundingBoxAscent) +
        Math.ceil(f.fontBoundingBoxDescent) +
        x.get();
    }
    for (let e = 0; e < a.length; e++) {
      const f = H.measureText(a[e]);
      q = Math.max(q, Math.ceil(f.width));
      G += u[e];
    }
    q += l * 2;
    if (x.get() < 0) G += (x.get() / 2) * -1;
    let c = G;
    if (b.get() == "Manual") {
      q = v.get() + l * 2;
      if (!_.get()) {
        G = y.get();
      }
    }
    G = Math.ceil(G);
    q = Math.ceil(q);
    if (q > V.maxTexSize || G > V.maxTexSize)
      g.setUiError("textoobig", "Texture too big!");
    else g.setUiError("textoobig", null);
    G = Math.min(V.maxTexSize, G);
    q = Math.min(V.maxTexSize, q);
    let d = 0;
    if (C.get() == "Middle") d = (G - c) / 2;
    else if (C.get() == "Bottom") d = G - c;
    d += s;
    G += s + o;
    if (H.canvas.width != q || H.canvas.height != G) se();
    const h = Z.get();
    for (let t = 0; t < a.length; t++) {
      let e = 0 + l;
      if (w.get() == "center") e = H.canvas.width / 2;
      if (w.get() == "right") e = H.canvas.width - l;
      if (b.get() == "Manual") e += I.get();
      H.fillText(a[t], e, d);
      if (h) {
        H.lineWidth = 3;
        H.strokeStyle = "#FF0000";
        H.beginPath();
        H.moveTo(0, d);
        H.lineTo(H.canvas.width, d);
        H.stroke();
      }
      d += u[t];
    }
    let p = CGL.Texture.WRAP_REPEAT;
    if (k.get() == "mirrored repeat") p = CGL.Texture.WRAP_MIRRORED_REPEAT;
    else if (k.get() == "clamp to edge") p = CGL.Texture.WRAP_CLAMP_TO_EDGE;
    let m = CGL.Texture.FILTER_LINEAR;
    if (E.get() == "nearest") m = CGL.Texture.FILTER_NEAREST;
    else if (E.get() == "mipmap") m = CGL.Texture.FILTER_MIPMAP;
    if (
      !j.get() ||
      !F ||
      !B.get() ||
      F.width != z.width ||
      F.height != z.height ||
      F.anisotropic != parseFloat(P.get())
    ) {
      if (F) F.delete();
      F = new CGL.Texture.createFromImage(V, z, {
        filter: m,
        anisotropic: parseFloat(P.get()),
        wrap: p,
      });
    }
    F.unpackAlpha = false;
    F.flip = false;
    F.initTexture(z, m);
    te.set(H.canvas.height / H.canvas.width);
    ne.set(a.length);
    B.setRef(F);
  }
  function ue() {
    v.setUiAttribs({ greyout: b.get() != "Manual" });
    y.setUiAttribs({ greyout: b.get() != "Manual" || _.get() });
    T.setUiAttribs({ greyout: b.get() != "Manual" });
    C.setUiAttribs({ greyout: b.get() != "Manual" });
    _.setUiAttribs({ greyout: b.get() != "Manual" });
    n.setUiAttribs({ greyout: !t.get() });
  }
};
Ops.Gl.Textures.TextTexture_v6.prototype = new CABLES.Op();
CABLES.OPS["2c042efa-3604-4717-b8f4-5ad08d6740e5"] = {
  f: Ops.Gl.Textures.TextTexture_v6,
  objName: "Ops.Gl.Textures.TextTexture_v6",
};
Ops.Math.Compare.LessThan = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inValue("number1");
  const i = e.inValue("number2");
  const r = e.outBoolNum("result");
  e.setUiAttribs({ mathTitle: true });
  n.onChange = a;
  i.onChange = a;
  a();
  function a() {
    r.set(n.get() < i.get());
  }
};
Ops.Math.Compare.LessThan.prototype = new CABLES.Op();
CABLES.OPS["04fd113f-ade1-43fb-99fa-f8825f8814c0"] = {
  f: Ops.Math.Compare.LessThan,
  objName: "Ops.Math.Compare.LessThan",
};
Ops.Gl.Textures.EmptyTexture = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inValue("width", 8);
  const i = e.inValue("height", 8);
  const r = e.outTexture("texture");
  const a = e.patch.cgl;
  const s = new CGL.Texture(a);
  n.onChange = o;
  i.onChange = o;
  o();
  function o() {
    s.setSize(n.get(), i.get());
    r.set(s);
  }
};
Ops.Gl.Textures.EmptyTexture.prototype = new CABLES.Op();
CABLES.OPS["fc124913-0916-4f5c-83e0-702ddf66420c"] = {
  f: Ops.Gl.Textures.EmptyTexture,
  objName: "Ops.Gl.Textures.EmptyTexture",
};
Ops.Gl.Shader.ShaderToTexture_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const t = (e.attachments = {});
  const n = e.inTrigger("Render"),
    i = e.inObject("Shader", null, "shader"),
    s = e.inSwitch("Size", ["Canvas", "Manual"], "Manual"),
    o = e.inValueInt("Width", 512),
    l = e.inValueInt("Height", 512),
    u = e.inValueSelect("filter", ["nearest", "linear", "mipmap"]),
    c = e.inSwitch("Anisotropic", ["0", "1", "2", "4", "8", "16"], "0"),
    d = e.inValueSelect(
      "wrap",
      ["clamp to edge", "repeat", "mirrored repeat"],
      "clamp to edge"
    ),
    h = e.inDropDown(
      "Pixel Format",
      CGL.Texture.PIXELFORMATS,
      CGL.Texture.PFORMATSTR_RGBA8UB
    ),
    p = e.inSwitch("Num Textures", ["1", "4"], "1"),
    r = e.outTrigger("Next"),
    a = e.outTexture("Texture"),
    m = e.outTexture("Texture 2"),
    f = e.outTexture("Texture 3"),
    g = e.outTexture("Texture 4");
  e.setPortGroup("Texture Size", [s, o, l]);
  e.setPortGroup("Texture settings", [u, d, h, c]);
  let b = 1;
  const v = e.patch.cgl;
  const y = [0, 0, 0, 0];
  const _ = null;
  const T = [];
  let O = null;
  let S = null;
  o.onChange =
    l.onChange =
    h.onChange =
    u.onChange =
    p.onChange =
    c.onChange =
    d.onChange =
      P;
  s.onChange = k;
  const A = false;
  let w = null;
  const C = null;
  let I = true;
  const x = CGL.MESHES.getSimpleRect(v, "shader2texture rect");
  e.toWorkPortsNeedToBeLinked(i);
  u.set("nearest");
  k();
  function E() {
    if (u.get() == "mipmap" && C && C.isFloatingPoint()) {
      e.setUiError(
        "warning",
        "HDR and mipmap filtering at the same time is not possible"
      );
    } else {
      e.setUiError("warning", null);
    }
  }
  function k() {
    c.setUiAttribs({ greyout: u.get() != "mipmap" });
    o.setUiAttribs({ greyout: s.get() == "Canvas" });
    l.setUiAttribs({ greyout: s.get() == "Canvas" });
  }
  function P() {
    I = true;
    E();
    k();
  }
  function j() {
    if (S) S.dispose();
    O = null;
    S = null;
  }
  function N() {
    I = false;
    if (w) w.delete();
    const e = T.length;
    b = parseInt(p.get());
    T.length = 0;
    for (let e = 0; e < b; e++) T[e] = true;
    if (e != T.length) {
      j();
    }
    w = null;
    let t = o.get();
    let n = l.get();
    if (s.get() == "Canvas") {
      t = v.canvasWidth;
      n = v.canvasHeight;
    }
    let i = CGL.Texture.FILTER_NEAREST;
    if (u.get() == "linear") i = CGL.Texture.FILTER_LINEAR;
    else if (u.get() == "mipmap") i = CGL.Texture.FILTER_MIPMAP;
    let r = CGL.Texture.WRAP_CLAMP_TO_EDGE;
    if (d.get() == "repeat") r = CGL.Texture.WRAP_REPEAT;
    if (d.get() == "mirrored repeat") r = CGL.Texture.WRAP_MIRRORED_REPEAT;
    const a = Math.min(v.maxAnisotropic, parseFloat(c.get()));
    if (v.glVersion >= 2) {
      w = new CGL.Framebuffer2(v, t, n, {
        anisotropic: a,
        pixelFormat: h.get(),
        multisampling: false,
        numRenderBuffers: b,
        wrap: r,
        filter: i,
        depth: true,
        multisamplingSamples: 0,
        clear: true,
      });
    } else {
      w = new CGL.Framebuffer(v, o.get(), l.get(), {
        isFloatingPointTexture: inFloatingPoint.get(),
        filter: i,
        wrap: r,
      });
    }
  }
  n.onTriggered = function () {
    if (!w || I) N();
    if (
      s.get() == "Manual" &&
      (w.getTextureColor().width != o.get() ||
        w.getTextureColor().height != l.get())
    ) {
      N();
    } else if (
      s.get() == "Canvas" &&
      w &&
      (w.getTextureColor().width != v.canvasWidth ||
        w.getTextureColor().height != v.canvasHeight)
    )
      N();
    if (!i.get() || !i.get().setDrawBuffers) return;
    if (i.get() != O) {
      O = i.get();
      S = i.get().copy();
      S.setDrawBuffers(T);
    }
    if (!S) {
      a.set(null);
      return;
    }
    v.pushViewPort(0, 0, o.get(), l.get());
    w.renderStart(v);
    v.pushPMatrix();
    mat4.identity(v.pMatrix);
    v.pushViewMatrix();
    mat4.identity(v.vMatrix);
    v.pushModelMatrix();
    mat4.identity(v.mMatrix);
    v.pushShader(i.get());
    if (S.bindTextures) S.bindTextures();
    v.pushBlend(false);
    x.render(i.get());
    v.popBlend();
    v.popPMatrix();
    v.popModelMatrix();
    v.popViewMatrix();
    w.renderEnd(v);
    if (b >= 2) {
      a.set(w.getTextureColorNum(0));
      m.set(w.getTextureColorNum(1));
      f.set(w.getTextureColorNum(2));
      g.set(w.getTextureColorNum(3));
    } else a.set(w.getTextureColor());
    v.popShader();
    v.popViewPort();
    r.trigger();
  };
};
Ops.Gl.Shader.ShaderToTexture_v2.prototype = new CABLES.Op();
CABLES.OPS["eb40e0e0-761b-4ce7-987a-014fff720873"] = {
  f: Ops.Gl.Shader.ShaderToTexture_v2,
  objName: "Ops.Gl.Shader.ShaderToTexture_v2",
};
Ops.Gl.Matrix.Camera_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const e = this;
  const M = (e.attachments = {});
  const t = e.inTrigger("render");
  const n = e.outTrigger("trigger");
  const i = e.inBool("Identity", true);
  const r = e.inValueSelect(
    "projection mode",
    ["prespective", "ortogonal"],
    "prespective"
  );
  const a = e.inValue("frustum near", 0.01);
  const s = e.inValue("frustum far", 5e3);
  const o = e.inValue("fov", 45);
  const l = e.inValueBool("Auto Aspect Ratio", true);
  const u = e.inValue("Aspect Ratio", 1);
  const c = e.inValue("eye X", 0);
  const d = e.inValue("eye Y", 0);
  const h = e.inValue("eye Z", 5);
  const p = e.inValue("center X", 0);
  const m = e.inValue("center Y", 0);
  const f = e.inValue("center Z", 0);
  const g = e.inValue("truck", 0);
  const b = e.inValue("boom", 0);
  const v = e.inValue("dolly", 0);
  const y = e.inValue("tilt", 0);
  const _ = e.inValue("pan", 0);
  const T = e.inValue("roll", 0);
  const O = e.outNumber("Aspect");
  const D = e.outArray("Look At Array");
  const S = e.patch.cgl;
  let A = 0;
  const w = vec3.create();
  const C = vec3.create();
  const I = vec3.create();
  const x = mat4.create();
  mat4.identity(x);
  const E = [];
  const k = vec3.create();
  const P = mat4.create();
  mat4.identity(P);
  let j = true;
  t.onTriggered = function () {
    if (S.tempData.shadowPass) return n.trigger();
    if (!l.get()) A = u.get();
    else A = S.getViewPort()[2] / S.getViewPort()[3];
    O.set(A);
    S.pushViewMatrix();
    if (i.get()) mat4.identity(S.vMatrix);
    if (j) {
      mat4.identity(P);
      vec3.set(k, g.get(), b.get(), v.get());
      if (g.get() !== 0 || b.get() !== 0 || v.get() !== 0)
        mat4.translate(P, P, k);
      if (y.get() !== 0) mat4.rotateX(P, P, y.get() * CGL.DEG2RAD);
      if (_.get() !== 0) mat4.rotateY(P, P, _.get() * CGL.DEG2RAD);
      if (T.get() !== 0) mat4.rotateZ(P, P, T.get() * CGL.DEG2RAD);
      j = false;
    }
    mat4.multiply(S.vMatrix, S.vMatrix, P);
    S.pushPMatrix();
    S.pushViewMatrix();
    if (r.get() == "prespective") {
      mat4.perspective(S.pMatrix, o.get() * 0.0174533, A, a.get(), s.get());
    } else if (r.get() == "ortogonal") {
      mat4.ortho(
        S.pMatrix,
        -1 * (o.get() / 14),
        1 * (o.get() / 14),
        (-1 * (o.get() / 14)) / A,
        (1 * (o.get() / 14)) / A,
        a.get(),
        s.get()
      );
    }
    E[0] = c.get();
    E[1] = d.get();
    E[2] = h.get();
    E[3] = p.get();
    E[4] = m.get();
    E[5] = f.get();
    E[6] = 0;
    E[7] = 1;
    E[8] = 0;
    D.setRef(E);
    vec3.set(w, 0, 1, 0);
    vec3.set(C, c.get(), d.get(), h.get());
    vec3.set(I, p.get(), m.get(), f.get());
    mat4.lookAt(x, C, I, w);
    mat4.multiply(S.vMatrix, S.vMatrix, x);
    n.trigger();
    S.popViewMatrix();
    S.popPMatrix();
    S.popViewMatrix();
    if (e.isCurrentUiOp()) gui.setTransformGizmo({ posX: g, posY: b, posZ: v });
  };
  const N = function () {
    if (!l.get()) {
      u.setUiAttribs({ greyout: false });
    } else {
      u.setUiAttribs({ greyout: true });
    }
  };
  const L = function () {
    j = true;
  };
  g.onChange = L;
  b.onChange = L;
  v.onChange = L;
  y.onChange = L;
  _.onChange = L;
  T.onChange = L;
  l.onChange = N;
  N();
};
Ops.Gl.Matrix.Camera_v2.prototype = new CABLES.Op();
CABLES.OPS["f7673a93-7772-4ade-9d3d-df7174f5258b"] = {
  f: Ops.Gl.Matrix.Camera_v2,
  objName: "Ops.Gl.Matrix.Camera_v2",
};
Ops.Gl.MainLoop_v2 = function () {
  CABLES.Op.apply(this, arguments);
  const n = this;
  const e = (n.attachments = {});
  const t = n.inFloat("Max Pixel Density (DPR)", 2),
    i = n.inValue("FPS Limit", 0),
    r = n.inValueBool("Reduce FPS unfocussed", false),
    a = n.inValueBool("Transparent", false),
    s = n.inValueBool("Active", 1),
    o = n.outTrigger("trigger"),
    l = n.outNumber("width"),
    u = n.outNumber("height"),
    c = n.outNumber("Pixel Density");
  n.onAnimFrame = A;
  t.onChange = T;
  const d = n.patch.cgl;
  let h = 0;
  let p = 0;
  let m = null;
  let f = false;
  if (!n.patch.cgl) n.uiAttr({ error: "No webgl cgl context" });
  const g = vec3.create();
  vec3.set(g, 0, 0, 0);
  const b = vec3.create();
  vec3.set(b, 0, 0, -2);
  let v = null;
  let y = true;
  let _ = true;
  window.addEventListener("blur", () => {
    y = false;
  });
  window.addEventListener("focus", () => {
    y = true;
  });
  document.addEventListener("visibilitychange", () => {
    _ = !document.hidden;
  });
  w();
  n.patch.tempData.mainloopOp = this;
  function T() {
    S();
    if (CABLES.UI) {
      if (t.get() < 1) n.patch.cgl.canvas.style.imageRendering = "pixelated";
    }
    n.patch.cgl.updateSize();
    if (CABLES.UI) gui.setLayout();
  }
  s.onChange = function () {
    n.patch.removeOnAnimFrame(n);
    if (s.get()) {
      n.setUiAttrib({ extendTitle: "" });
      n.onAnimFrame = A;
      n.patch.addOnAnimFrame(n);
      n.log("adding again!");
    } else {
      n.setUiAttrib({ extendTitle: "Inactive" });
    }
  };
  function O() {
    if (r.get()) {
      if (!_) return 10;
      if (!y) return 30;
    }
    return i.get();
  }
  n.onDelete = function () {
    d.gl.clearColor(0, 0, 0, 0);
    d.gl.clear(d.gl.COLOR_BUFFER_BIT | d.gl.DEPTH_BUFFER_BIT);
  };
  function S() {
    if (t.get() != 0)
      n.patch.cgl.pixelDensity = Math.min(t.get(), window.devicePixelRatio);
    else n.patch.cgl.pixelDensity = window.devicePixelRatio;
  }
  function A(e) {
    if (!s.get()) return;
    if (d.aborted || d.canvas.clientWidth === 0 || d.canvas.clientHeight === 0)
      return;
    n.patch.cg = d;
    S();
    const t = performance.now();
    n.patch.config.fpsLimit = O();
    if (d.canvasWidth == -1) {
      d.setCanvas(n.patch.config.glCanvasId);
      return;
    }
    if (d.canvasWidth != l.get() || d.canvasHeight != u.get()) {
      l.set(d.canvasWidth / 1);
      u.set(d.canvasHeight / 1);
    }
    if (CABLES.now() - p > 1e3) {
      CGL.fpsReport = CGL.fpsReport || [];
      if (n.patch.loading.getProgress() >= 1 && p !== 0) CGL.fpsReport.push(h);
      h = 0;
      p = CABLES.now();
    }
    CGL.MESH.lastShader = null;
    CGL.MESH.lastMesh = null;
    d.renderStart(d, g, b);
    if (!a.get()) d.gl.clearColor(0, 0, 0, 1);
    else d.gl.clearColor(0, 0, 0, 0);
    d.gl.clear(d.gl.COLOR_BUFFER_BIT | d.gl.DEPTH_BUFFER_BIT);
    o.trigger();
    if (CGL.MESH.lastMesh) CGL.MESH.lastMesh.unBind();
    if (CGL.Texture.previewTexture) {
      if (!CGL.Texture.texturePreviewer)
        CGL.Texture.texturePreviewer = new CGL.Texture.texturePreview(d);
      CGL.Texture.texturePreviewer.render(CGL.Texture.previewTexture);
    }
    d.renderEnd(d);
    n.patch.cg = null;
    if (!a.get()) {
      d.gl.clearColor(1, 1, 1, 1);
      d.gl.colorMask(false, false, false, true);
      d.gl.clear(d.gl.COLOR_BUFFER_BIT);
      d.gl.colorMask(true, true, true, true);
    }
    if (!d.tempData.phong) d.tempData.phong = {};
    h++;
    c.set(n.patch.cgl.pixelDensity);
    n.patch.cgl.profileData.profileMainloopMs = performance.now() - t;
  }
  function w() {
    clearTimeout(m);
    m = setTimeout(() => {
      if (n.patch.getOpsByObjName(n.name).length > 1) {
        n.setUiError("multimainloop", "there should only be one mainloop op!");
        if (!f) f = n.patch.addEventListener("onOpDelete", w);
      } else n.setUiError("multimainloop", null, 1);
    }, 500);
  }
};
Ops.Gl.MainLoop_v2.prototype = new CABLES.Op();
CABLES.OPS["f1029550-d877-42da-9b1e-63a5163a0350"] = {
  f: Ops.Gl.MainLoop_v2,
  objName: "Ops.Gl.MainLoop_v2",
};
Ops.Gl.CanvasInfo_v3 = function () {
  CABLES.Op.apply(this, arguments);
  const t = this;
  const e = (t.attachments = {});
  const n = t.outNumber("CSS Width"),
    i = t.outNumber("CSS Height"),
    r = t.outNumber("Pixel Ratio"),
    a = t.outNumber("Pixel Width"),
    s = t.outNumber("Pixel Height"),
    o = t.outNumber("Aspect Ratio"),
    l = t.outBool("Landscape"),
    u = t.outObject("Canvas", "element"),
    c = t.outObject("Canvas Parent", "element");
  let d = t.patch.cgl;
  u.set(t.patch.cgl.canvas);
  c.set(t.patch.cgl.canvas.parentElement);
  d.on("resize", h);
  h();
  function h() {
    let e = 1;
    if (d.canvasHeight == 0) setTimeout(h, 100);
    i.set(d.canvasHeight / t.patch.cgl.pixelDensity);
    n.set(d.canvasWidth / t.patch.cgl.pixelDensity);
    a.set(d.canvasWidth);
    s.set(d.canvasHeight);
    r.set(t.patch.cgl.pixelDensity);
    o.set(d.canvasWidth / d.canvasHeight);
    l.set(d.canvasWidth > d.canvasHeight ? 1 : 0);
  }
};
Ops.Gl.CanvasInfo_v3.prototype = new CABLES.Op();
CABLES.OPS["be186ff9-427e-409f-b6a4-f8d957bf7bc7"] = {
  f: Ops.Gl.CanvasInfo_v3,
  objName: "Ops.Gl.CanvasInfo_v3",
};
window.addEventListener("load", function (e) {
  CABLES.jsLoaded = new Event("CABLES.jsLoaded");
  document.dispatchEvent(CABLES.jsLoaded);
});
!(function (e, t) {
  "object" == typeof exports && "undefined" != typeof module
    ? (module.exports = t())
    : "function" == typeof define && define.amd
    ? define(t)
    : ((e = "undefined" != typeof globalThis ? globalThis : e || self).videojs =
        t());
})(this, function () {
  "use strict";
  for (
    var D,
      R = "7.20.3",
      B = {},
      U = function (e, t) {
        return (B[e] = B[e] || []), t && (B[e] = B[e].concat(t)), B[e];
      },
      V = function (e, t) {
        t = U(e).indexOf(t);
        return !(t <= -1) && ((B[e] = B[e].slice()), B[e].splice(t, 1), !0);
      },
      F = { prefixed: !0 },
      G = [
        [
          "requestFullscreen",
          "exitFullscreen",
          "fullscreenElement",
          "fullscreenEnabled",
          "fullscreenchange",
          "fullscreenerror",
          "fullscreen",
        ],
        [
          "webkitRequestFullscreen",
          "webkitExitFullscreen",
          "webkitFullscreenElement",
          "webkitFullscreenEnabled",
          "webkitfullscreenchange",
          "webkitfullscreenerror",
          "-webkit-full-screen",
        ],
        [
          "mozRequestFullScreen",
          "mozCancelFullScreen",
          "mozFullScreenElement",
          "mozFullScreenEnabled",
          "mozfullscreenchange",
          "mozfullscreenerror",
          "-moz-full-screen",
        ],
        [
          "msRequestFullscreen",
          "msExitFullscreen",
          "msFullscreenElement",
          "msFullscreenEnabled",
          "MSFullscreenChange",
          "MSFullscreenError",
          "-ms-fullscreen",
        ],
      ],
      q = G[0],
      z = 0;
    z < G.length;
    z++
  )
    if (G[z][1] in document) {
      D = G[z];
      break;
    }
  if (D) {
    for (var H = 0; H < D.length; H++) F[q[H]] = D[H];
    F.prefixed = D[0] !== q[0];
  }
  var W = [],
    X = function (a, s) {
      return function (e, t, n) {
        var i,
          r = s.levels[t],
          t = new RegExp("^(" + r + ")$");
        "log" !== e && n.unshift(e.toUpperCase() + ":"),
          n.unshift(a + ":"),
          W &&
            (W.push([].concat(n)),
            (i = W.length - 1e3),
            W.splice(0, 0 < i ? i : 0)),
          !window.console ||
            ((i =
              !(i = window.console[e]) && "debug" === e
                ? window.console.info || window.console.log
                : i) &&
              r &&
              t.test(e) &&
              i[Array.isArray(n) ? "apply" : "call"](window.console, n));
      };
    };
  var d = (function t(n) {
      function i() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
          t[n] = arguments[n];
        a("log", r, t);
      }
      var r = "info",
        a = X(n, i);
      return (
        (i.createLogger = function (e) {
          return t(n + ": " + e);
        }),
        (i.levels = {
          all: "debug|log|warn|error",
          off: "",
          debug: "debug|log|warn|error",
          info: "log|warn|error",
          warn: "warn|error",
          error: "error",
          DEFAULT: r,
        }),
        (i.level = function (e) {
          if ("string" == typeof e) {
            if (!i.levels.hasOwnProperty(e))
              throw new Error('"' + e + '" in not a valid log level');
            r = e;
          }
          return r;
        }),
        ((i.history = function () {
          return W ? [].concat(W) : [];
        }).filter = function (t) {
          return (W || []).filter(function (e) {
            return new RegExp(".*" + t + ".*").test(e[0]);
          });
        }),
        (i.history.clear = function () {
          W && (W.length = 0);
        }),
        (i.history.disable = function () {
          null !== W && ((W.length = 0), (W = null));
        }),
        (i.history.enable = function () {
          null === W && (W = []);
        }),
        (i.error = function () {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          return a("error", r, t);
        }),
        (i.warn = function () {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          return a("warn", r, t);
        }),
        (i.debug = function () {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          return a("debug", r, t);
        }),
        i
      );
    })("VIDEOJS"),
    Y = d.createLogger,
    e =
      "undefined" != typeof globalThis
        ? globalThis
        : "undefined" != typeof window
        ? window
        : "undefined" != typeof global
        ? global
        : "undefined" != typeof self
        ? self
        : {};
  function K(e, t) {
    return e((t = { exports: {} }), t.exports), t.exports;
  }
  var Q = K(function (e) {
      function t() {
        return (
          (e.exports = t =
            Object.assign ||
            function (e) {
              for (var t = 1; t < arguments.length; t++) {
                var n,
                  i = arguments[t];
                for (n in i)
                  Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n]);
              }
              return e;
            }),
          t.apply(this, arguments)
        );
      }
      e.exports = t;
    }),
    Z = Object.prototype.toString,
    J = function (e) {
      return ee(e) ? Object.keys(e) : [];
    };
  function $(t, n) {
    J(t).forEach(function (e) {
      return n(t[e], e);
    });
  }
  function h(n) {
    for (
      var e = arguments.length, t = new Array(1 < e ? e - 1 : 0), i = 1;
      i < e;
      i++
    )
      t[i - 1] = arguments[i];
    return Object.assign
      ? Q.apply(void 0, [n].concat(t))
      : (t.forEach(function (e) {
          e &&
            $(e, function (e, t) {
              n[t] = e;
            });
        }),
        n);
  }
  function ee(e) {
    return !!e && "object" == typeof e;
  }
  function te(e) {
    return ee(e) && "[object Object]" === Z.call(e) && e.constructor === Object;
  }
  function ne(e, t) {
    if (!e || !t) return "";
    if ("function" != typeof window.getComputedStyle) return "";
    var n;
    try {
      n = window.getComputedStyle(e);
    } catch (e) {
      return "";
    }
    return n ? n.getPropertyValue(t) || n[t] : "";
  }
  var i = (window.navigator && window.navigator.userAgent) || "",
    t = /AppleWebKit\/([\d.]+)/i.exec(i),
    ie = t ? parseFloat(t.pop()) : null,
    n = /iPod/i.test(i),
    r = (o = i.match(/OS (\d+)_/i)) && o[1] ? o[1] : null,
    re = /Android/i.test(i),
    ae = (function () {
      var e = i.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
      if (!e) return null;
      var t = e[1] && parseFloat(e[1]),
        n = e[2] && parseFloat(e[2]);
      return t && n ? parseFloat(e[1] + "." + e[2]) : t || null;
    })(),
    se = re && ae < 5 && ie < 537,
    oe = /Firefox/i.test(i),
    le = /Edg/i.test(i),
    ue = !le && (/Chrome/i.test(i) || /CriOS/i.test(i)),
    ce =
      (cn = i.match(/(Chrome|CriOS)\/(\d+)/)) && cn[2]
        ? parseFloat(cn[2])
        : null,
    de = (v =
      !(v = (v = /MSIE\s(\d+)\.\d/.exec(i)) && parseFloat(v[1])) &&
      /Trident\/7.0/i.test(i) &&
      /rv:11.0/.test(i)
        ? 11
        : v),
    he = /Safari/i.test(i) && !ue && !re && !le,
    pe = /Windows/i.test(i),
    me = Boolean(
      _e() &&
        ("ontouchstart" in window ||
          window.navigator.maxTouchPoints ||
          (window.DocumentTouch &&
            window.document instanceof window.DocumentTouch))
    ),
    a = /iPad/i.test(i) || (he && me && !/iPhone/i.test(i)),
    fe = /iPhone/i.test(i) && !a,
    ge = fe || a || n,
    be = (he || ge) && !ue,
    s = Object.freeze({
      __proto__: null,
      IS_IPOD: n,
      IOS_VERSION: r,
      IS_ANDROID: re,
      ANDROID_VERSION: ae,
      IS_NATIVE_ANDROID: se,
      IS_FIREFOX: oe,
      IS_EDGE: le,
      IS_CHROME: ue,
      CHROME_VERSION: ce,
      IE_VERSION: de,
      IS_SAFARI: he,
      IS_WINDOWS: pe,
      TOUCH_ENABLED: me,
      IS_IPAD: a,
      IS_IPHONE: fe,
      IS_IOS: ge,
      IS_ANY_SAFARI: be,
    });
  function ve(e) {
    return "string" == typeof e && Boolean(e.trim());
  }
  function ye(e) {
    if (0 <= e.indexOf(" "))
      throw new Error("class has illegal whitespace characters");
  }
  function _e() {
    return document === window.document;
  }
  function Te(e) {
    return ee(e) && 1 === e.nodeType;
  }
  function Oe() {
    try {
      return window.parent !== window.self;
    } catch (e) {
      return !0;
    }
  }
  function Se(n) {
    return function (e, t) {
      if (!ve(e)) return document[n](null);
      t = Te((t = ve(t) ? document.querySelector(t) : t)) ? t : document;
      return t[n] && t[n](e);
    };
  }
  function c(e, n, t, i) {
    void 0 === e && (e = "div"),
      void 0 === n && (n = {}),
      void 0 === t && (t = {});
    var r = document.createElement(e);
    return (
      Object.getOwnPropertyNames(n).forEach(function (e) {
        var t = n[e];
        -1 !== e.indexOf("aria-") || "role" === e || "type" === e
          ? (d.warn(
              "Setting attributes in the second argument of createEl()\nhas been deprecated. Use the third argument instead.\ncreateEl(type, properties, attributes). Attempting to set " +
                e +
                " to " +
                t +
                "."
            ),
            r.setAttribute(e, t))
          : "textContent" === e
          ? Ae(r, t)
          : (r[e] === t && "tabIndex" !== e) || (r[e] = t);
      }),
      Object.getOwnPropertyNames(t).forEach(function (e) {
        r.setAttribute(e, t[e]);
      }),
      i && qe(r, i),
      r
    );
  }
  function Ae(e, t) {
    return (
      "undefined" == typeof e.textContent
        ? (e.innerText = t)
        : (e.textContent = t),
      e
    );
  }
  function we(e, t) {
    t.firstChild ? t.insertBefore(e, t.firstChild) : t.appendChild(e);
  }
  function Ce(e, t) {
    return (
      ye(t),
      e.classList
        ? e.classList.contains(t)
        : new RegExp("(^|\\s)" + t + "($|\\s)").test(e.className)
    );
  }
  function Ie(e, t) {
    return (
      e.classList
        ? e.classList.add(t)
        : Ce(e, t) || (e.className = (e.className + " " + t).trim()),
      e
    );
  }
  function xe(e, t) {
    return e
      ? (e.classList
          ? e.classList.remove(t)
          : (ye(t),
            (e.className = e.className
              .split(/\s+/)
              .filter(function (e) {
                return e !== t;
              })
              .join(" "))),
        e)
      : (d.warn("removeClass was called with an element that doesn't exist"),
        null);
  }
  function Ee(e, t, n) {
    var i = Ce(e, t);
    if (
      (n =
        "boolean" != typeof (n = "function" == typeof n ? n(e, t) : n)
          ? !i
          : n) !== i
    )
      return (n ? Ie : xe)(e, t), e;
  }
  function ke(n, i) {
    Object.getOwnPropertyNames(i).forEach(function (e) {
      var t = i[e];
      null === t || "undefined" == typeof t || !1 === t
        ? n.removeAttribute(e)
        : n.setAttribute(e, !0 === t ? "" : t);
    });
  }
  function Pe(e) {
    var t = {},
      n = ",autoplay,controls,playsinline,loop,muted,default,defaultMuted,";
    if (e && e.attributes && 0 < e.attributes.length)
      for (var i = e.attributes, r = i.length - 1; 0 <= r; r--) {
        var a = i[r].name,
          s = i[r].value;
        ("boolean" != typeof e[a] && -1 === n.indexOf("," + a + ",")) ||
          (s = null !== s),
          (t[a] = s);
      }
    return t;
  }
  function je(e, t) {
    return e.getAttribute(t);
  }
  function Ne(e, t, n) {
    e.setAttribute(t, n);
  }
  function Le(e, t) {
    e.removeAttribute(t);
  }
  function Me() {
    document.body.focus(),
      (document.onselectstart = function () {
        return !1;
      });
  }
  function De() {
    document.onselectstart = function () {
      return !0;
    };
  }
  function Re(e) {
    if (e && e.getBoundingClientRect && e.parentNode) {
      var t = e.getBoundingClientRect(),
        n = {};
      return (
        ["bottom", "height", "left", "right", "top", "width"].forEach(function (
          e
        ) {
          void 0 !== t[e] && (n[e] = t[e]);
        }),
        n.height || (n.height = parseFloat(ne(e, "height"))),
        n.width || (n.width = parseFloat(ne(e, "width"))),
        n
      );
    }
  }
  function Be(e) {
    if (!e || (e && !e.offsetParent))
      return { left: 0, top: 0, width: 0, height: 0 };
    for (
      var t = e.offsetWidth, n = e.offsetHeight, i = 0, r = 0;
      e.offsetParent && e !== document[F.fullscreenElement];

    )
      (i += e.offsetLeft), (r += e.offsetTop), (e = e.offsetParent);
    return { left: i, top: r, width: t, height: n };
  }
  function Ue(e, t) {
    var n = { x: 0, y: 0 };
    if (ge)
      for (var i = e; i && "html" !== i.nodeName.toLowerCase(); ) {
        var r,
          a = ne(i, "transform");
        /^matrix/.test(a)
          ? ((r = a.slice(7, -1).split(/,\s/).map(Number)),
            (n.x += r[4]),
            (n.y += r[5]))
          : /^matrix3d/.test(a) &&
            ((a = a.slice(9, -1).split(/,\s/).map(Number)),
            (n.x += a[12]),
            (n.y += a[13])),
          (i = i.parentNode);
      }
    var s = {},
      o = Be(t.target),
      l = Be(e),
      u = l.width,
      c = l.height,
      e = t.offsetY - (l.top - o.top),
      o = t.offsetX - (l.left - o.left);
    return (
      t.changedTouches &&
        ((o = t.changedTouches[0].pageX - l.left),
        (e = t.changedTouches[0].pageY + l.top),
        ge && ((o -= n.x), (e -= n.y))),
      (s.y = 1 - Math.max(0, Math.min(1, e / c))),
      (s.x = Math.max(0, Math.min(1, o / u))),
      s
    );
  }
  function Ve(e) {
    return ee(e) && 3 === e.nodeType;
  }
  function Fe(e) {
    for (; e.firstChild; ) e.removeChild(e.firstChild);
    return e;
  }
  function Ge(e) {
    return (
      "function" == typeof e && (e = e()),
      (Array.isArray(e) ? e : [e])
        .map(function (e) {
          return Te((e = "function" == typeof e ? e() : e)) || Ve(e)
            ? e
            : "string" == typeof e && /\S/.test(e)
            ? document.createTextNode(e)
            : void 0;
        })
        .filter(function (e) {
          return e;
        })
    );
  }
  function qe(t, e) {
    return (
      Ge(e).forEach(function (e) {
        return t.appendChild(e);
      }),
      t
    );
  }
  function ze(e, t) {
    return qe(Fe(e), t);
  }
  function He(e) {
    return (
      (void 0 === e.button && void 0 === e.buttons) ||
      (0 === e.button && void 0 === e.buttons) ||
      ("mouseup" === e.type && 0 === e.button && 0 === e.buttons) ||
      (0 === e.button && 1 === e.buttons)
    );
  }
  var We,
    Xe = Se("querySelector"),
    Ye = Se("querySelectorAll"),
    Ke = Object.freeze({
      __proto__: null,
      isReal: _e,
      isEl: Te,
      isInFrame: Oe,
      createEl: c,
      textContent: Ae,
      prependTo: we,
      hasClass: Ce,
      addClass: Ie,
      removeClass: xe,
      toggleClass: Ee,
      setAttributes: ke,
      getAttributes: Pe,
      getAttribute: je,
      setAttribute: Ne,
      removeAttribute: Le,
      blockTextSelection: Me,
      unblockTextSelection: De,
      getBoundingClientRect: Re,
      findPosition: Be,
      getPointerPosition: Ue,
      isTextNode: Ve,
      emptyEl: Fe,
      normalizeContent: Ge,
      appendContent: qe,
      insertContent: ze,
      isSingleLeftClick: He,
      $: Xe,
      $$: Ye,
    }),
    Qe = !1,
    Ze = function () {
      if (!1 !== We.options.autoSetup) {
        var e = Array.prototype.slice.call(
            document.getElementsByTagName("video")
          ),
          t = Array.prototype.slice.call(
            document.getElementsByTagName("audio")
          ),
          n = Array.prototype.slice.call(
            document.getElementsByTagName("video-js")
          ),
          i = e.concat(t, n);
        if (i && 0 < i.length)
          for (var r = 0, a = i.length; r < a; r++) {
            var s = i[r];
            if (!s || !s.getAttribute) {
              Je(1);
              break;
            }
            void 0 === s.player &&
              null !== s.getAttribute("data-setup") &&
              We(s);
          }
        else Qe || Je(1);
      }
    };
  function Je(e, t) {
    _e() && (t && (We = t), window.setTimeout(Ze, e));
  }
  function $e() {
    (Qe = !0), window.removeEventListener("load", $e);
  }
  _e() &&
    ("complete" === document.readyState
      ? $e()
      : window.addEventListener("load", $e));
  function et(e) {
    var t = document.createElement("style");
    return (t.className = e), t;
  }
  function tt(e, t) {
    e.styleSheet ? (e.styleSheet.cssText = t) : (e.textContent = t);
  }
  var nt = 3;
  window.WeakMap ||
    (_ = (function () {
      function e() {
        (this.vdata =
          "vdata" +
          Math.floor(
            (window.performance && window.performance.now()) || Date.now()
          )),
          (this.data = {});
      }
      var t = e.prototype;
      return (
        (t.set = function (e, t) {
          var n = e[this.vdata] || nt++;
          return e[this.vdata] || (e[this.vdata] = n), (this.data[n] = t), this;
        }),
        (t.get = function (e) {
          var t = e[this.vdata];
          if (t) return this.data[t];
          d("We have no data for this element", e);
        }),
        (t.has = function (e) {
          return e[this.vdata] in this.data;
        }),
        (t.delete = function (e) {
          var t = e[this.vdata];
          t && (delete this.data[t], delete e[this.vdata]);
        }),
        e
      );
    })());
  var it,
    rt = new (window.WeakMap ? WeakMap : _)();
  function at(e, t) {
    var n;
    rt.has(e) &&
      (0 === (n = rt.get(e)).handlers[t].length &&
        (delete n.handlers[t],
        e.removeEventListener
          ? e.removeEventListener(t, n.dispatcher, !1)
          : e.detachEvent && e.detachEvent("on" + t, n.dispatcher)),
      Object.getOwnPropertyNames(n.handlers).length <= 0 &&
        (delete n.handlers, delete n.dispatcher, delete n.disabled),
      0 === Object.getOwnPropertyNames(n).length && rt.delete(e));
  }
  function st(t, n, e, i) {
    e.forEach(function (e) {
      t(n, e, i);
    });
  }
  function ot(e) {
    if (e.fixed_) return e;
    function t() {
      return !0;
    }
    function n() {
      return !1;
    }
    if (!e || !e.isPropagationStopped || !e.isImmediatePropagationStopped) {
      var i,
        r,
        a,
        s = e || window.event;
      for (i in ((e = {}), s))
        "layerX" !== i &&
          "layerY" !== i &&
          "keyLocation" !== i &&
          "webkitMovementX" !== i &&
          "webkitMovementY" !== i &&
          "path" !== i &&
          (("returnValue" === i && s.preventDefault) || (e[i] = s[i]));
      e.target || (e.target = e.srcElement || document),
        e.relatedTarget ||
          (e.relatedTarget =
            e.fromElement === e.target ? e.toElement : e.fromElement),
        (e.preventDefault = function () {
          s.preventDefault && s.preventDefault(),
            (e.returnValue = !1),
            (s.returnValue = !1),
            (e.defaultPrevented = !0);
        }),
        (e.defaultPrevented = !1),
        (e.stopPropagation = function () {
          s.stopPropagation && s.stopPropagation(),
            (e.cancelBubble = !0),
            (s.cancelBubble = !0),
            (e.isPropagationStopped = t);
        }),
        (e.isPropagationStopped = n),
        (e.stopImmediatePropagation = function () {
          s.stopImmediatePropagation && s.stopImmediatePropagation(),
            (e.isImmediatePropagationStopped = t),
            e.stopPropagation();
        }),
        (e.isImmediatePropagationStopped = n),
        null !== e.clientX &&
          void 0 !== e.clientX &&
          ((r = document.documentElement),
          (a = document.body),
          (e.pageX =
            e.clientX +
            ((r && r.scrollLeft) || (a && a.scrollLeft) || 0) -
            ((r && r.clientLeft) || (a && a.clientLeft) || 0)),
          (e.pageY =
            e.clientY +
            ((r && r.scrollTop) || (a && a.scrollTop) || 0) -
            ((r && r.clientTop) || (a && a.clientTop) || 0))),
        (e.which = e.charCode || e.keyCode),
        null !== e.button &&
          void 0 !== e.button &&
          (e.button =
            1 & e.button ? 0 : 4 & e.button ? 1 : 2 & e.button ? 2 : 0);
    }
    return (e.fixed_ = !0), e;
  }
  var lt = function () {
      if ("boolean" != typeof it) {
        it = !1;
        try {
          var e = Object.defineProperty({}, "passive", {
            get: function () {
              it = !0;
            },
          });
          window.addEventListener("test", null, e),
            window.removeEventListener("test", null, e);
        } catch (e) {}
      }
      return it;
    },
    ut = ["touchstart", "touchmove"];
  function ct(s, e, t) {
    if (Array.isArray(e)) return st(ct, s, e, t);
    rt.has(s) || rt.set(s, {});
    var o = rt.get(s);
    o.handlers || (o.handlers = {}),
      o.handlers[e] || (o.handlers[e] = []),
      t.guid || (t.guid = nt++),
      o.handlers[e].push(t),
      o.dispatcher ||
        ((o.disabled = !1),
        (o.dispatcher = function (e, t) {
          if (!o.disabled) {
            e = ot(e);
            var n = o.handlers[e.type];
            if (n)
              for (
                var i = n.slice(0), r = 0, a = i.length;
                r < a && !e.isImmediatePropagationStopped();
                r++
              )
                try {
                  i[r].call(s, e, t);
                } catch (e) {
                  d.error(e);
                }
          }
        })),
      1 === o.handlers[e].length &&
        (s.addEventListener
          ? ((t = !1),
            lt() && -1 < ut.indexOf(e) && (t = { passive: !0 }),
            s.addEventListener(e, o.dispatcher, t))
          : s.attachEvent && s.attachEvent("on" + e, o.dispatcher));
  }
  function l(e, t, n) {
    if (rt.has(e)) {
      var i = rt.get(e);
      if (i.handlers) {
        if (Array.isArray(t)) return st(l, e, t, n);
        var r = function (e, t) {
          (i.handlers[t] = []), at(e, t);
        };
        if (void 0 !== t) {
          var a = i.handlers[t];
          if (a)
            if (n) {
              if (n.guid)
                for (var s = 0; s < a.length; s++)
                  a[s].guid === n.guid && a.splice(s--, 1);
              at(e, t);
            } else r(e, t);
        } else
          for (var o in i.handlers)
            Object.prototype.hasOwnProperty.call(i.handlers || {}, o) &&
              r(e, o);
      }
    }
  }
  function dt(e, t, n) {
    var i = rt.has(e) ? rt.get(e) : {},
      r = e.parentNode || e.ownerDocument;
    return (
      "string" == typeof t
        ? (t = { type: t, target: e })
        : t.target || (t.target = e),
      (t = ot(t)),
      i.dispatcher && i.dispatcher.call(e, t, n),
      r && !t.isPropagationStopped() && !0 === t.bubbles
        ? dt.call(null, r, t, n)
        : !r &&
          !t.defaultPrevented &&
          t.target &&
          t.target[t.type] &&
          (rt.has(t.target) || rt.set(t.target, {}),
          (r = rt.get(t.target)),
          t.target[t.type] &&
            ((r.disabled = !0),
            "function" == typeof t.target[t.type] && t.target[t.type](),
            (r.disabled = !1))),
      !t.defaultPrevented
    );
  }
  function ht(e, t, n) {
    if (Array.isArray(t)) return st(ht, e, t, n);
    function i() {
      l(e, t, i), n.apply(this, arguments);
    }
    (i.guid = n.guid = n.guid || nt++), ct(e, t, i);
  }
  function pt(e, t, n) {
    function i() {
      l(e, t, i), n.apply(this, arguments);
    }
    (i.guid = n.guid = n.guid || nt++), ct(e, t, i);
  }
  function u(e, t, n) {
    return (
      t.guid || (t.guid = nt++),
      ((e = t.bind(e)).guid = n ? n + "_" + t.guid : t.guid),
      e
    );
  }
  function mt(t, n) {
    var i = window.performance.now();
    return function () {
      var e = window.performance.now();
      n <= e - i && (t.apply(void 0, arguments), (i = e));
    };
  }
  function ft(i, r, a, s) {
    var o;
    function e() {
      var e = this,
        t = arguments,
        n = function () {
          (n = o = null), a || i.apply(e, t);
        };
      !o && a && i.apply(e, t), s.clearTimeout(o), (o = s.setTimeout(n, r));
    }
    return (
      void 0 === s && (s = window),
      (e.cancel = function () {
        s.clearTimeout(o), (o = null);
      }),
      e
    );
  }
  function gt() {}
  var bt,
    vt = Object.freeze({
      __proto__: null,
      fixEvent: ot,
      on: ct,
      off: l,
      trigger: dt,
      one: ht,
      any: pt,
    });
  (gt.prototype.allowedEvents_ = {}),
    (gt.prototype.addEventListener = gt.prototype.on =
      function (e, t) {
        var n = this.addEventListener;
        (this.addEventListener = function () {}),
          ct(this, e, t),
          (this.addEventListener = n);
      }),
    (gt.prototype.removeEventListener = gt.prototype.off =
      function (e, t) {
        l(this, e, t);
      }),
    (gt.prototype.one = function (e, t) {
      var n = this.addEventListener;
      (this.addEventListener = function () {}),
        ht(this, e, t),
        (this.addEventListener = n);
    }),
    (gt.prototype.any = function (e, t) {
      var n = this.addEventListener;
      (this.addEventListener = function () {}),
        pt(this, e, t),
        (this.addEventListener = n);
    }),
    (gt.prototype.dispatchEvent = gt.prototype.trigger =
      function (e) {
        var t = e.type || e;
        (e = ot((e = "string" == typeof e ? { type: t } : e))),
          this.allowedEvents_[t] && this["on" + t] && this["on" + t](e),
          dt(this, e);
      }),
    (gt.prototype.queueTrigger = function (e) {
      var t = this;
      bt = bt || new Map();
      var n = e.type || e,
        i = bt.get(this);
      i || ((i = new Map()), bt.set(this, i));
      var r = i.get(n);
      i.delete(n), window.clearTimeout(r);
      r = window.setTimeout(function () {
        0 === i.size && ((i = null), bt.delete(t)), t.trigger(e);
      }, 0);
      i.set(n, r);
    });
  function yt(e) {
    return "function" == typeof e.name
      ? e.name()
      : "string" == typeof e.name
      ? e.name
      : e.name_ ||
        (e.constructor && e.constructor.name ? e.constructor.name : typeof e);
  }
  function _t(e) {
    return (
      ("string" == typeof e && /\S/.test(e)) || (Array.isArray(e) && !!e.length)
    );
  }
  function Tt(e, t, n) {
    if (!e || (!e.nodeName && !Ct(e)))
      throw new Error(
        "Invalid target for " +
          yt(t) +
          "#" +
          n +
          "; must be a DOM node or evented object."
      );
  }
  function Ot(e, t, n) {
    if (!_t(e))
      throw new Error(
        "Invalid event type for " +
          yt(t) +
          "#" +
          n +
          "; must be a non-empty string or array."
      );
  }
  function St(e, t, n) {
    if ("function" != typeof e)
      throw new Error(
        "Invalid listener for " + yt(t) + "#" + n + "; must be a function."
      );
  }
  function At(e, t, n) {
    var i,
      r,
      a = t.length < 3 || t[0] === e || t[0] === e.eventBusEl_,
      t = a
        ? ((i = e.eventBusEl_), 3 <= t.length && t.shift(), (r = t[0]), t[1])
        : ((i = t[0]), (r = t[1]), t[2]);
    return (
      Tt(i, e, n),
      Ot(r, e, n),
      St(t, e, n),
      { isTargetingSelf: a, target: i, type: r, listener: (t = u(e, t)) }
    );
  }
  function wt(e, t, n, i) {
    Tt(e, e, t), e.nodeName ? vt[t](e, n, i) : e[t](n, i);
  }
  var Ct = function (t) {
      return (
        t instanceof gt ||
        (!!t.eventBusEl_ &&
          ["on", "one", "off", "trigger"].every(function (e) {
            return "function" == typeof t[e];
          }))
      );
    },
    It = {
      on: function () {
        for (
          var e = this, t = arguments.length, n = new Array(t), i = 0;
          i < t;
          i++
        )
          n[i] = arguments[i];
        var r,
          a = At(this, n, "on"),
          s = a.isTargetingSelf,
          o = a.target,
          l = a.type,
          u = a.listener;
        wt(o, "on", l, u),
          s ||
            (((r = function () {
              return e.off(o, l, u);
            }).guid = u.guid),
            ((s = function () {
              return e.off("dispose", r);
            }).guid = u.guid),
            wt(this, "on", "dispose", r),
            wt(o, "on", "dispose", s));
      },
      one: function () {
        for (
          var r = this, e = arguments.length, t = new Array(e), n = 0;
          n < e;
          n++
        )
          t[n] = arguments[n];
        var i = At(this, t, "one"),
          a = i.isTargetingSelf,
          s = i.target,
          o = i.type,
          l = i.listener;
        a
          ? wt(s, "one", o, l)
          : (((a = function e() {
              r.off(s, o, e);
              for (
                var t = arguments.length, n = new Array(t), i = 0;
                i < t;
                i++
              )
                n[i] = arguments[i];
              l.apply(null, n);
            }).guid = l.guid),
            wt(s, "one", o, a));
      },
      any: function () {
        for (
          var r = this, e = arguments.length, t = new Array(e), n = 0;
          n < e;
          n++
        )
          t[n] = arguments[n];
        var i = At(this, t, "any"),
          a = i.isTargetingSelf,
          s = i.target,
          o = i.type,
          l = i.listener;
        a
          ? wt(s, "any", o, l)
          : (((a = function e() {
              r.off(s, o, e);
              for (
                var t = arguments.length, n = new Array(t), i = 0;
                i < t;
                i++
              )
                n[i] = arguments[i];
              l.apply(null, n);
            }).guid = l.guid),
            wt(s, "any", o, a));
      },
      off: function (e, t, n) {
        !e || _t(e)
          ? l(this.eventBusEl_, e, t)
          : ((t = t),
            Tt((e = e), this, "off"),
            Ot(t, this, "off"),
            St(n, this, "off"),
            (n = u(this, n)),
            this.off("dispose", n),
            e.nodeName
              ? (l(e, t, n), l(e, "dispose", n))
              : Ct(e) && (e.off(t, n), e.off("dispose", n)));
      },
      trigger: function (e, t) {
        Tt(this.eventBusEl_, this, "trigger");
        var n = e && "string" != typeof e ? e.type : e;
        if (!_t(n)) {
          n =
            "Invalid event type for " +
            yt(this) +
            "#trigger; must be a non-empty string or object with a type key that has a non-empty value.";
          if (!e) throw new Error(n);
          (this.log || d).error(n);
        }
        return dt(this.eventBusEl_, e, t);
      },
    };
  function xt(e, t) {
    t = (t = void 0 === t ? {} : t).eventBusKey;
    if (t) {
      if (!e[t].nodeName)
        throw new Error(
          'The eventBusKey "' + t + '" does not refer to an element.'
        );
      e.eventBusEl_ = e[t];
    } else e.eventBusEl_ = c("span", { className: "vjs-event-bus" });
    return (
      h(e, It),
      e.eventedCallbacks &&
        e.eventedCallbacks.forEach(function (e) {
          e();
        }),
      e.on("dispose", function () {
        e.off(),
          [e, e.el_, e.eventBusEl_].forEach(function (e) {
            e && rt.has(e) && rt.delete(e);
          }),
          window.setTimeout(function () {
            e.eventBusEl_ = null;
          }, 0);
      }),
      e
    );
  }
  var Et = {
    state: {},
    setState: function (e) {
      var n,
        i = this;
      return (
        $((e = "function" == typeof e ? e() : e), function (e, t) {
          i.state[t] !== e && ((n = n || {})[t] = { from: i.state[t], to: e }),
            (i.state[t] = e);
        }),
        n && Ct(this) && this.trigger({ changes: n, type: "statechanged" }),
        n
      );
    },
  };
  function kt(e, t) {
    return (
      h(e, Et),
      (e.state = h({}, e.state, t)),
      "function" == typeof e.handleStateChanged &&
        Ct(e) &&
        e.on("statechanged", e.handleStateChanged),
      e
    );
  }
  function Pt(e) {
    return "string" != typeof e
      ? e
      : e.replace(/./, function (e) {
          return e.toLowerCase();
        });
  }
  function p(e) {
    return "string" != typeof e
      ? e
      : e.replace(/./, function (e) {
          return e.toUpperCase();
        });
  }
  function m() {
    for (var n = {}, e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return (
      t.forEach(function (e) {
        e &&
          $(e, function (e, t) {
            te(e) ? (te(n[t]) || (n[t] = {}), (n[t] = m(n[t], e))) : (n[t] = e);
          });
      }),
      n
    );
  }
  var jt =
      window.Map ||
      (function () {
        function e() {
          this.map_ = {};
        }
        var t = e.prototype;
        return (
          (t.has = function (e) {
            return e in this.map_;
          }),
          (t.delete = function (e) {
            var t = this.has(e);
            return delete this.map_[e], t;
          }),
          (t.set = function (e, t) {
            return (this.map_[e] = t), this;
          }),
          (t.forEach = function (e, t) {
            for (var n in this.map_) e.call(t, this.map_[n], n, this);
          }),
          e
        );
      })(),
    Nt =
      window.Set ||
      (function () {
        function e() {
          this.set_ = {};
        }
        var t = e.prototype;
        return (
          (t.has = function (e) {
            return e in this.set_;
          }),
          (t.delete = function (e) {
            var t = this.has(e);
            return delete this.set_[e], t;
          }),
          (t.add = function (e) {
            return (this.set_[e] = 1), this;
          }),
          (t.forEach = function (e, t) {
            for (var n in this.set_) e.call(t, n, n, this);
          }),
          e
        );
      })(),
    f = K(function (e, t) {
      function n(e) {
        if (
          (!e ||
            "object" != typeof e ||
            ((t = e.which || e.keyCode || e.charCode) && (e = t)),
          "number" == typeof e)
        )
          return o[e];
        var t = String(e),
          e = i[t.toLowerCase()];
        return (
          e ||
          ((e = r[t.toLowerCase()])
            ? e
            : 1 === t.length
            ? t.charCodeAt(0)
            : void 0)
        );
      }
      n.isEventKey = function (e, t) {
        if (e && "object" == typeof e) {
          var n = e.which || e.keyCode || e.charCode;
          if (null == n) return !1;
          if ("string" == typeof t) {
            e = i[t.toLowerCase()];
            if (e) return e === n;
            if ((e = r[t.toLowerCase()])) return e === n;
          } else if ("number" == typeof t) return t === n;
          return !1;
        }
      };
      for (
        var i =
            ((t = e.exports = n).code =
            t.codes =
              {
                backspace: 8,
                tab: 9,
                enter: 13,
                shift: 16,
                ctrl: 17,
                alt: 18,
                "pause/break": 19,
                "caps lock": 20,
                esc: 27,
                space: 32,
                "page up": 33,
                "page down": 34,
                end: 35,
                home: 36,
                left: 37,
                up: 38,
                right: 39,
                down: 40,
                insert: 45,
                delete: 46,
                command: 91,
                "left command": 91,
                "right command": 93,
                "numpad *": 106,
                "numpad +": 107,
                "numpad -": 109,
                "numpad .": 110,
                "numpad /": 111,
                "num lock": 144,
                "scroll lock": 145,
                "my computer": 182,
                "my calculator": 183,
                ";": 186,
                "=": 187,
                ",": 188,
                "-": 189,
                ".": 190,
                "/": 191,
                "`": 192,
                "[": 219,
                "\\": 220,
                "]": 221,
                "'": 222,
              }),
          r = (t.aliases = {
            windows: 91,
            "â‡§": 16,
            "âŒ¥": 18,
            âŒƒ: 17,
            "âŒ˜": 91,
            ctl: 17,
            control: 17,
            option: 18,
            pause: 19,
            break: 19,
            caps: 20,
            return: 13,
            escape: 27,
            spc: 32,
            spacebar: 32,
            pgup: 33,
            pgdn: 34,
            ins: 45,
            del: 46,
            cmd: 91,
          }),
          a = 97;
        a < 123;
        a++
      )
        i[String.fromCharCode(a)] = a - 32;
      for (var a = 48; a < 58; a++) i[a - 48] = a;
      for (a = 1; a < 13; a++) i["f" + a] = a + 111;
      for (a = 0; a < 10; a++) i["numpad " + a] = a + 96;
      var s,
        o = (t.names = t.title = {});
      for (a in i) o[i[a]] = a;
      for (s in r) i[s] = r[s];
    });
  f.code, f.codes, f.aliases, f.names, f.title;
  var g = (function () {
    function s(e, t, n) {
      var i = this;
      !e && this.play ? (this.player_ = e = this) : (this.player_ = e),
        (this.isDisposed_ = !1),
        (this.parentComponent_ = null),
        (this.options_ = m({}, this.options_)),
        (t = this.options_ = m(this.options_, t)),
        (this.id_ = t.id || (t.el && t.el.id)),
        this.id_ ||
          ((e = (e && e.id && e.id()) || "no_player"),
          (this.id_ = e + "_component_" + nt++)),
        (this.name_ = t.name || null),
        t.el
          ? (this.el_ = t.el)
          : !1 !== t.createEl && (this.el_ = this.createEl()),
        t.className &&
          this.el_ &&
          t.className.split(" ").forEach(function (e) {
            return i.addClass(e);
          }),
        !1 !== t.evented &&
          (xt(this, { eventBusKey: this.el_ ? "el_" : null }),
          (this.handleLanguagechange = this.handleLanguagechange.bind(this)),
          this.on(this.player_, "languagechange", this.handleLanguagechange)),
        kt(this, this.constructor.defaultState),
        (this.children_ = []),
        (this.childIndex_ = {}),
        (this.childNameIndex_ = {}),
        (this.setTimeoutIds_ = new Nt()),
        (this.setIntervalIds_ = new Nt()),
        (this.rafIds_ = new Nt()),
        (this.namedRafs_ = new jt()),
        (this.clearingTimersOnDispose_ = !1) !== t.initChildren &&
          this.initChildren(),
        this.ready(n),
        !1 !== t.reportTouchActivity && this.enableTouchActivity();
    }
    var e = s.prototype;
    return (
      (e.dispose = function (e) {
        if ((void 0 === e && (e = {}), !this.isDisposed_)) {
          if (
            (this.readyQueue_ && (this.readyQueue_.length = 0),
            this.trigger({ type: "dispose", bubbles: !1 }),
            (this.isDisposed_ = !0),
            this.children_)
          )
            for (var t = this.children_.length - 1; 0 <= t; t--)
              this.children_[t].dispose && this.children_[t].dispose();
          (this.children_ = null),
            (this.childIndex_ = null),
            (this.childNameIndex_ = null),
            (this.parentComponent_ = null),
            this.el_ &&
              (this.el_.parentNode &&
                (e.restoreEl
                  ? this.el_.parentNode.replaceChild(e.restoreEl, this.el_)
                  : this.el_.parentNode.removeChild(this.el_)),
              (this.el_ = null)),
            (this.player_ = null);
        }
      }),
      (e.isDisposed = function () {
        return Boolean(this.isDisposed_);
      }),
      (e.player = function () {
        return this.player_;
      }),
      (e.options = function (e) {
        return e && (this.options_ = m(this.options_, e)), this.options_;
      }),
      (e.el = function () {
        return this.el_;
      }),
      (e.createEl = function (e, t, n) {
        return c(e, t, n);
      }),
      (e.localize = function (e, n, t) {
        void 0 === t && (t = e);
        var i = this.player_.language && this.player_.language(),
          r = this.player_.languages && this.player_.languages(),
          a = r && r[i],
          i = i && i.split("-")[0],
          i = r && r[i],
          t = t;
        return (
          a && a[e] ? (t = a[e]) : i && i[e] && (t = i[e]),
          (t = n
            ? t.replace(/\{(\d+)\}/g, function (e, t) {
                t = n[t - 1];
                return "undefined" == typeof t ? e : t;
              })
            : t)
        );
      }),
      (e.handleLanguagechange = function () {}),
      (e.contentEl = function () {
        return this.contentEl_ || this.el_;
      }),
      (e.id = function () {
        return this.id_;
      }),
      (e.name = function () {
        return this.name_;
      }),
      (e.children = function () {
        return this.children_;
      }),
      (e.getChildById = function (e) {
        return this.childIndex_[e];
      }),
      (e.getChild = function (e) {
        if (e) return this.childNameIndex_[e];
      }),
      (e.getDescendant = function () {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
          t[n] = arguments[n];
        for (
          var t = t.reduce(function (e, t) {
              return e.concat(t);
            }, []),
            i = this,
            r = 0;
          r < t.length;
          r++
        )
          if (!(i = i.getChild(t[r])) || !i.getChild) return;
        return i;
      }),
      (e.addChild = function (e, t, n) {
        if (
          (void 0 === t && (t = {}),
          void 0 === n && (n = this.children_.length),
          "string" == typeof e)
        ) {
          var i = p(e),
            r = t.componentClass || i;
          t.name = i;
          var a = s.getComponent(r);
          if (!a) throw new Error("Component " + r + " does not exist");
          if ("function" != typeof a) return null;
          a = new a(this.player_ || this, t);
        } else a = e;
        return (
          a.parentComponent_ && a.parentComponent_.removeChild(a),
          this.children_.splice(n, 0, a),
          (a.parentComponent_ = this),
          "function" == typeof a.id && (this.childIndex_[a.id()] = a),
          (i = i || (a.name && p(a.name()))) &&
            ((this.childNameIndex_[i] = a), (this.childNameIndex_[Pt(i)] = a)),
          "function" == typeof a.el &&
            a.el() &&
            ((i = null),
            this.children_[n + 1] &&
              (this.children_[n + 1].el_
                ? (i = this.children_[n + 1].el_)
                : Te(this.children_[n + 1]) && (i = this.children_[n + 1])),
            this.contentEl().insertBefore(a.el(), i)),
          a
        );
      }),
      (e.removeChild = function (e) {
        if (
          (e = "string" == typeof e ? this.getChild(e) : e) &&
          this.children_
        ) {
          for (var t, n = !1, i = this.children_.length - 1; 0 <= i; i--)
            if (this.children_[i] === e) {
              (n = !0), this.children_.splice(i, 1);
              break;
            }
          n &&
            ((e.parentComponent_ = null),
            (this.childIndex_[e.id()] = null),
            (this.childNameIndex_[p(e.name())] = null),
            (this.childNameIndex_[Pt(e.name())] = null),
            (t = e.el()) &&
              t.parentNode === this.contentEl() &&
              this.contentEl().removeChild(e.el()));
        }
      }),
      (e.initChildren = function () {
        var n,
          t,
          e,
          i = this,
          r = this.options_.children;
        r &&
          ((n = this.options_),
          (t = s.getComponent("Tech")),
          (e = Array.isArray(r) ? r : Object.keys(r))
            .concat(
              Object.keys(this.options_).filter(function (t) {
                return !e.some(function (e) {
                  return "string" == typeof e ? t === e : t === e.name;
                });
              })
            )
            .map(function (e) {
              var t,
                e =
                  "string" == typeof e
                    ? r[(t = e)] || i.options_[t] || {}
                    : ((t = e.name), e);
              return { name: t, opts: e };
            })
            .filter(function (e) {
              e = s.getComponent(e.opts.componentClass || p(e.name));
              return e && !t.isTech(e);
            })
            .forEach(function (e) {
              var t = e.name,
                e = e.opts;
              !1 !== (e = void 0 !== n[t] ? n[t] : e) &&
                (((e = !0 === e ? {} : e).playerOptions =
                  i.options_.playerOptions),
                (e = i.addChild(t, e)) && (i[t] = e));
            }));
      }),
      (e.buildCSSClass = function () {
        return "";
      }),
      (e.ready = function (e, t) {
        if ((void 0 === t && (t = !1), e))
          return this.isReady_
            ? void (t ? e.call(this) : this.setTimeout(e, 1))
            : ((this.readyQueue_ = this.readyQueue_ || []),
              void this.readyQueue_.push(e));
      }),
      (e.triggerReady = function () {
        (this.isReady_ = !0),
          this.setTimeout(function () {
            var e = this.readyQueue_;
            (this.readyQueue_ = []),
              e &&
                0 < e.length &&
                e.forEach(function (e) {
                  e.call(this);
                }, this),
              this.trigger("ready");
          }, 1);
      }),
      (e.$ = function (e, t) {
        return Xe(e, t || this.contentEl());
      }),
      (e.$$ = function (e, t) {
        return Ye(e, t || this.contentEl());
      }),
      (e.hasClass = function (e) {
        return Ce(this.el_, e);
      }),
      (e.addClass = function (e) {
        Ie(this.el_, e);
      }),
      (e.removeClass = function (e) {
        xe(this.el_, e);
      }),
      (e.toggleClass = function (e, t) {
        Ee(this.el_, e, t);
      }),
      (e.show = function () {
        this.removeClass("vjs-hidden");
      }),
      (e.hide = function () {
        this.addClass("vjs-hidden");
      }),
      (e.lockShowing = function () {
        this.addClass("vjs-lock-showing");
      }),
      (e.unlockShowing = function () {
        this.removeClass("vjs-lock-showing");
      }),
      (e.getAttribute = function (e) {
        return je(this.el_, e);
      }),
      (e.setAttribute = function (e, t) {
        Ne(this.el_, e, t);
      }),
      (e.removeAttribute = function (e) {
        Le(this.el_, e);
      }),
      (e.width = function (e, t) {
        return this.dimension("width", e, t);
      }),
      (e.height = function (e, t) {
        return this.dimension("height", e, t);
      }),
      (e.dimensions = function (e, t) {
        this.width(e, !0), this.height(t);
      }),
      (e.dimension = function (e, t, n) {
        if (void 0 !== t)
          return (
            -1 !== ("" + (t = null === t || t != t ? 0 : t)).indexOf("%") ||
            -1 !== ("" + t).indexOf("px")
              ? (this.el_.style[e] = t)
              : (this.el_.style[e] = "auto" === t ? "" : t + "px"),
            void (n || this.trigger("componentresize"))
          );
        if (!this.el_) return 0;
        (t = this.el_.style[e]), (n = t.indexOf("px"));
        return -1 !== n
          ? parseInt(t.slice(0, n), 10)
          : parseInt(this.el_["offset" + p(e)], 10);
      }),
      (e.currentDimension = function (e) {
        var t = 0;
        if ("width" !== e && "height" !== e)
          throw new Error(
            "currentDimension only accepts width or height value"
          );
        return (
          (t = ne(this.el_, e)),
          (0 !== (t = parseFloat(t)) && !isNaN(t)) ||
            ((e = "offset" + p(e)), (t = this.el_[e])),
          t
        );
      }),
      (e.currentDimensions = function () {
        return {
          width: this.currentDimension("width"),
          height: this.currentDimension("height"),
        };
      }),
      (e.currentWidth = function () {
        return this.currentDimension("width");
      }),
      (e.currentHeight = function () {
        return this.currentDimension("height");
      }),
      (e.focus = function () {
        this.el_.focus();
      }),
      (e.blur = function () {
        this.el_.blur();
      }),
      (e.handleKeyDown = function (e) {
        this.player_ &&
          (f.isEventKey(e, "Tab") || e.stopPropagation(),
          this.player_.handleKeyDown(e));
      }),
      (e.handleKeyPress = function (e) {
        this.handleKeyDown(e);
      }),
      (e.emitTapEvents = function () {
        var n,
          t = 0,
          i = null;
        this.on("touchstart", function (e) {
          1 === e.touches.length &&
            ((i = { pageX: e.touches[0].pageX, pageY: e.touches[0].pageY }),
            (t = window.performance.now()),
            (n = !0));
        }),
          this.on("touchmove", function (e) {
            var t;
            1 < e.touches.length
              ? (n = !1)
              : i &&
                ((t = e.touches[0].pageX - i.pageX),
                (e = e.touches[0].pageY - i.pageY),
                10 < Math.sqrt(t * t + e * e) && (n = !1));
          });
        function e() {
          n = !1;
        }
        this.on("touchleave", e),
          this.on("touchcancel", e),
          this.on("touchend", function (e) {
            !(i = null) === n &&
              window.performance.now() - t < 200 &&
              (e.preventDefault(), this.trigger("tap"));
          });
      }),
      (e.enableTouchActivity = function () {
        var t, n, e;
        this.player() &&
          this.player().reportUserActivity &&
          ((t = u(this.player(), this.player().reportUserActivity)),
          this.on("touchstart", function () {
            t(), this.clearInterval(n), (n = this.setInterval(t, 250));
          }),
          (e = function (e) {
            t(), this.clearInterval(n);
          }),
          this.on("touchmove", t),
          this.on("touchend", e),
          this.on("touchcancel", e));
      }),
      (e.setTimeout = function (e, t) {
        var n,
          i = this;
        return (
          (e = u(this, e)),
          this.clearTimersOnDispose_(),
          (n = window.setTimeout(function () {
            i.setTimeoutIds_.has(n) && i.setTimeoutIds_.delete(n), e();
          }, t)),
          this.setTimeoutIds_.add(n),
          n
        );
      }),
      (e.clearTimeout = function (e) {
        return (
          this.setTimeoutIds_.has(e) &&
            (this.setTimeoutIds_.delete(e), window.clearTimeout(e)),
          e
        );
      }),
      (e.setInterval = function (e, t) {
        (e = u(this, e)), this.clearTimersOnDispose_();
        t = window.setInterval(e, t);
        return this.setIntervalIds_.add(t), t;
      }),
      (e.clearInterval = function (e) {
        return (
          this.setIntervalIds_.has(e) &&
            (this.setIntervalIds_.delete(e), window.clearInterval(e)),
          e
        );
      }),
      (e.requestAnimationFrame = function (e) {
        var t,
          n = this;
        return this.supportsRaf_
          ? (this.clearTimersOnDispose_(),
            (e = u(this, e)),
            (t = window.requestAnimationFrame(function () {
              n.rafIds_.has(t) && n.rafIds_.delete(t), e();
            })),
            this.rafIds_.add(t),
            t)
          : this.setTimeout(e, 1e3 / 60);
      }),
      (e.requestNamedAnimationFrame = function (e, t) {
        var n = this;
        if (!this.namedRafs_.has(e)) {
          this.clearTimersOnDispose_(), (t = u(this, t));
          var i = this.requestAnimationFrame(function () {
            t(), n.namedRafs_.has(e) && n.namedRafs_.delete(e);
          });
          return this.namedRafs_.set(e, i), e;
        }
      }),
      (e.cancelNamedAnimationFrame = function (e) {
        this.namedRafs_.has(e) &&
          (this.cancelAnimationFrame(this.namedRafs_.get(e)),
          this.namedRafs_.delete(e));
      }),
      (e.cancelAnimationFrame = function (e) {
        return this.supportsRaf_
          ? (this.rafIds_.has(e) &&
              (this.rafIds_.delete(e), window.cancelAnimationFrame(e)),
            e)
          : this.clearTimeout(e);
      }),
      (e.clearTimersOnDispose_ = function () {
        var i = this;
        this.clearingTimersOnDispose_ ||
          ((this.clearingTimersOnDispose_ = !0),
          this.one("dispose", function () {
            [
              ["namedRafs_", "cancelNamedAnimationFrame"],
              ["rafIds_", "cancelAnimationFrame"],
              ["setTimeoutIds_", "clearTimeout"],
              ["setIntervalIds_", "clearInterval"],
            ].forEach(function (e) {
              var t = e[0],
                n = e[1];
              i[t].forEach(function (e, t) {
                return i[n](t);
              });
            }),
              (i.clearingTimersOnDispose_ = !1);
          }));
      }),
      (s.registerComponent = function (e, t) {
        if ("string" != typeof e || !e)
          throw new Error(
            'Illegal component name, "' + e + '"; must be a non-empty string.'
          );
        var n = s.getComponent("Tech"),
          i = n && n.isTech(t),
          n = s === t || s.prototype.isPrototypeOf(t.prototype);
        if (i || !n) {
          var r = i
            ? "techs must be registered using Tech.registerTech()"
            : "must be a Component subclass";
          throw new Error('Illegal component, "' + e + '"; ' + r + ".");
        }
        (e = p(e)), s.components_ || (s.components_ = {});
        r = s.getComponent("Player");
        if ("Player" === e && r && r.players) {
          var a = r.players,
            r = Object.keys(a);
          if (
            a &&
            0 < r.length &&
            r
              .map(function (e) {
                return a[e];
              })
              .every(Boolean)
          )
            throw new Error(
              "Can not register Player component after player has been created."
            );
        }
        return (s.components_[e] = t), (s.components_[Pt(e)] = t);
      }),
      (s.getComponent = function (e) {
        if (e && s.components_) return s.components_[e];
      }),
      s
    );
  })();
  (g.prototype.supportsRaf_ =
    "function" == typeof window.requestAnimationFrame &&
    "function" == typeof window.cancelAnimationFrame),
    g.registerComponent("Component", g);
  var y = function (e) {
    if (void 0 === e)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return e;
  };
  var b = function (e, t) {
    (e.prototype = Object.create(t.prototype)),
      ((e.prototype.constructor = e).__proto__ = t);
  };
  function Lt(e, t, n, i) {
    return (
      (function (e, t, n) {
        if ("number" != typeof t || t < 0 || n < t)
          throw new Error(
            "Failed to execute '" +
              e +
              "' on 'TimeRanges': The index provided (" +
              t +
              ") is non-numeric or out of bounds (0-" +
              n +
              ")."
          );
      })(e, i, n.length - 1),
      n[i][t]
    );
  }
  function Mt(e) {
    var t =
      void 0 === e || 0 === e.length
        ? {
            length: 0,
            start: function () {
              throw new Error("This TimeRanges object is empty");
            },
            end: function () {
              throw new Error("This TimeRanges object is empty");
            },
          }
        : {
            length: e.length,
            start: Lt.bind(null, "start", 0, e),
            end: Lt.bind(null, "end", 1, e),
          };
    return (
      window.Symbol &&
        window.Symbol.iterator &&
        (t[window.Symbol.iterator] = function () {
          return (e || []).values();
        }),
      t
    );
  }
  function Dt(e, t) {
    return Array.isArray(e)
      ? Mt(e)
      : void 0 === e || void 0 === t
      ? Mt()
      : Mt([[e, t]]);
  }
  function Rt(e, t) {
    var n,
      i,
      r = 0;
    if (!t) return 0;
    (e && e.length) || (e = Dt(0, 0));
    for (var a = 0; a < e.length; a++)
      (n = e.start(a)), (r += (i = t < (i = e.end(a)) ? t : i) - n);
    return r / t;
  }
  function Bt(e) {
    if (e instanceof Bt) return e;
    "number" == typeof e
      ? (this.code = e)
      : "string" == typeof e
      ? (this.message = e)
      : ee(e) &&
        ("number" == typeof e.code && (this.code = e.code), h(this, e)),
      this.message || (this.message = Bt.defaultMessages[this.code] || "");
  }
  (Bt.prototype.code = 0),
    (Bt.prototype.message = ""),
    (Bt.prototype.status = null),
    (Bt.errorTypes = [
      "MEDIA_ERR_CUSTOM",
      "MEDIA_ERR_ABORTED",
      "MEDIA_ERR_NETWORK",
      "MEDIA_ERR_DECODE",
      "MEDIA_ERR_SRC_NOT_SUPPORTED",
      "MEDIA_ERR_ENCRYPTED",
    ]),
    (Bt.defaultMessages = {
      1: "You aborted the media playback",
      2: "A network error caused the media download to fail part-way.",
      3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
      4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
      5: "The media is encrypted and we do not have the keys to decrypt it.",
    });
  for (var Ut = 0; Ut < Bt.errorTypes.length; Ut++)
    (Bt[Bt.errorTypes[Ut]] = Ut), (Bt.prototype[Bt.errorTypes[Ut]] = Ut);
  var Vt = function (e, t) {
    var n,
      i = null;
    try {
      n = JSON.parse(e, t);
    } catch (e) {
      i = e;
    }
    return [i, n];
  };
  function Ft(e) {
    return null != e && "function" == typeof e.then;
  }
  function Gt(e) {
    Ft(e) && e.then(null, function (e) {});
  }
  function qt(i) {
    return [
      "kind",
      "label",
      "language",
      "id",
      "inBandMetadataTrackDispatchType",
      "mode",
      "src",
    ].reduce(
      function (e, t, n) {
        return i[t] && (e[t] = i[t]), e;
      },
      {
        cues:
          i.cues &&
          Array.prototype.map.call(i.cues, function (e) {
            return {
              startTime: e.startTime,
              endTime: e.endTime,
              text: e.text,
              id: e.id,
            };
          }),
      }
    );
  }
  var zt = function (e) {
      var t = e.$$("track"),
        n = Array.prototype.map.call(t, function (e) {
          return e.track;
        });
      return Array.prototype.map
        .call(t, function (e) {
          var t = qt(e.track);
          return e.src && (t.src = e.src), t;
        })
        .concat(
          Array.prototype.filter
            .call(e.textTracks(), function (e) {
              return -1 === n.indexOf(e);
            })
            .map(qt)
        );
    },
    Ht = function (e, n) {
      return (
        e.forEach(function (e) {
          var t = n.addRemoteTextTrack(e).track;
          !e.src &&
            e.cues &&
            e.cues.forEach(function (e) {
              return t.addCue(e);
            });
        }),
        n.textTracks()
      );
    },
    Wt = "vjs-modal-dialog",
    Xt = (function (i) {
      function e(e, t) {
        var n = i.call(this, e, t) || this;
        return (
          (n.handleKeyDown_ = function (e) {
            return n.handleKeyDown(e);
          }),
          (n.close_ = function (e) {
            return n.close(e);
          }),
          (n.opened_ = n.hasBeenOpened_ = n.hasBeenFilled_ = !1),
          n.closeable(!n.options_.uncloseable),
          n.content(n.options_.content),
          (n.contentEl_ = c(
            "div",
            { className: Wt + "-content" },
            { role: "document" }
          )),
          (n.descEl_ = c("p", {
            className: Wt + "-description vjs-control-text",
            id: n.el().getAttribute("aria-describedby"),
          })),
          Ae(n.descEl_, n.description()),
          n.el_.appendChild(n.descEl_),
          n.el_.appendChild(n.contentEl_),
          n
        );
      }
      b(e, i);
      var t = e.prototype;
      return (
        (t.createEl = function () {
          return i.prototype.createEl.call(
            this,
            "div",
            { className: this.buildCSSClass(), tabIndex: -1 },
            {
              "aria-describedby": this.id() + "_description",
              "aria-hidden": "true",
              "aria-label": this.label(),
              role: "dialog",
            }
          );
        }),
        (t.dispose = function () {
          (this.contentEl_ = null),
            (this.descEl_ = null),
            (this.previouslyActiveEl_ = null),
            i.prototype.dispose.call(this);
        }),
        (t.buildCSSClass = function () {
          return Wt + " vjs-hidden " + i.prototype.buildCSSClass.call(this);
        }),
        (t.label = function () {
          return this.localize(this.options_.label || "Modal Window");
        }),
        (t.description = function () {
          var e =
            this.options_.description ||
            this.localize("This is a modal window.");
          return (
            this.closeable() &&
              (e +=
                " " +
                this.localize(
                  "This modal can be closed by pressing the Escape key or activating the close button."
                )),
            e
          );
        }),
        (t.open = function () {
          var e;
          this.opened_ ||
            ((e = this.player()),
            this.trigger("beforemodalopen"),
            (this.opened_ = !0),
            (!this.options_.fillAlways &&
              (this.hasBeenOpened_ || this.hasBeenFilled_)) ||
              this.fill(),
            (this.wasPlaying_ = !e.paused()),
            this.options_.pauseOnOpen && this.wasPlaying_ && e.pause(),
            this.on("keydown", this.handleKeyDown_),
            (this.hadControls_ = e.controls()),
            e.controls(!1),
            this.show(),
            this.conditionalFocus_(),
            this.el().setAttribute("aria-hidden", "false"),
            this.trigger("modalopen"),
            (this.hasBeenOpened_ = !0));
        }),
        (t.opened = function (e) {
          return (
            "boolean" == typeof e && this[e ? "open" : "close"](), this.opened_
          );
        }),
        (t.close = function () {
          var e;
          this.opened_ &&
            ((e = this.player()),
            this.trigger("beforemodalclose"),
            (this.opened_ = !1),
            this.wasPlaying_ && this.options_.pauseOnOpen && e.play(),
            this.off("keydown", this.handleKeyDown_),
            this.hadControls_ && e.controls(!0),
            this.hide(),
            this.el().setAttribute("aria-hidden", "true"),
            this.trigger("modalclose"),
            this.conditionalBlur_(),
            this.options_.temporary && this.dispose());
        }),
        (t.closeable = function (e) {
          var t, n;
          return (
            "boolean" == typeof e &&
              ((t = this.closeable_ = !!e),
              (n = this.getChild("closeButton")),
              t &&
                !n &&
                ((e = this.contentEl_),
                (this.contentEl_ = this.el_),
                (n = this.addChild("closeButton", {
                  controlText: "Close Modal Dialog",
                })),
                (this.contentEl_ = e),
                this.on(n, "close", this.close_)),
              !t &&
                n &&
                (this.off(n, "close", this.close_),
                this.removeChild(n),
                n.dispose())),
            this.closeable_
          );
        }),
        (t.fill = function () {
          this.fillWith(this.content());
        }),
        (t.fillWith = function (e) {
          var t = this.contentEl(),
            n = t.parentNode,
            i = t.nextSibling;
          this.trigger("beforemodalfill"),
            (this.hasBeenFilled_ = !0),
            n.removeChild(t),
            this.empty(),
            ze(t, e),
            this.trigger("modalfill"),
            i ? n.insertBefore(t, i) : n.appendChild(t);
          t = this.getChild("closeButton");
          t && n.appendChild(t.el_);
        }),
        (t.empty = function () {
          this.trigger("beforemodalempty"),
            Fe(this.contentEl()),
            this.trigger("modalempty");
        }),
        (t.content = function (e) {
          return "undefined" != typeof e && (this.content_ = e), this.content_;
        }),
        (t.conditionalFocus_ = function () {
          var e = document.activeElement,
            t = this.player_.el_;
          (this.previouslyActiveEl_ = null),
            (!t.contains(e) && t !== e) ||
              ((this.previouslyActiveEl_ = e), this.focus());
        }),
        (t.conditionalBlur_ = function () {
          this.previouslyActiveEl_ &&
            (this.previouslyActiveEl_.focus(),
            (this.previouslyActiveEl_ = null));
        }),
        (t.handleKeyDown = function (e) {
          if (
            (e.stopPropagation(), f.isEventKey(e, "Escape") && this.closeable())
          )
            return e.preventDefault(), void this.close();
          if (f.isEventKey(e, "Tab")) {
            for (
              var t,
                n = this.focusableEls_(),
                i = this.el_.querySelector(":focus"),
                r = 0;
              r < n.length;
              r++
            )
              if (i === n[r]) {
                t = r;
                break;
              }
            document.activeElement === this.el_ && (t = 0),
              e.shiftKey && 0 === t
                ? (n[n.length - 1].focus(), e.preventDefault())
                : e.shiftKey ||
                  t !== n.length - 1 ||
                  (n[0].focus(), e.preventDefault());
          }
        }),
        (t.focusableEls_ = function () {
          var e = this.el_.querySelectorAll("*");
          return Array.prototype.filter.call(e, function (e) {
            return (
              ((e instanceof window.HTMLAnchorElement ||
                e instanceof window.HTMLAreaElement) &&
                e.hasAttribute("href")) ||
              ((e instanceof window.HTMLInputElement ||
                e instanceof window.HTMLSelectElement ||
                e instanceof window.HTMLTextAreaElement ||
                e instanceof window.HTMLButtonElement) &&
                !e.hasAttribute("disabled")) ||
              e instanceof window.HTMLIFrameElement ||
              e instanceof window.HTMLObjectElement ||
              e instanceof window.HTMLEmbedElement ||
              (e.hasAttribute("tabindex") &&
                -1 !== e.getAttribute("tabindex")) ||
              e.hasAttribute("contenteditable")
            );
          });
        }),
        e
      );
    })(g);
  (Xt.prototype.options_ = { pauseOnOpen: !0, temporary: !0 }),
    g.registerComponent("ModalDialog", Xt);
  var Yt,
    Kt = (function (i) {
      function e(e) {
        var t;
        void 0 === e && (e = []),
          ((t = i.call(this) || this).tracks_ = []),
          Object.defineProperty(y(t), "length", {
            get: function () {
              return this.tracks_.length;
            },
          });
        for (var n = 0; n < e.length; n++) t.addTrack(e[n]);
        return t;
      }
      b(e, i);
      var t = e.prototype;
      return (
        (t.addTrack = function (e) {
          var t = this,
            n = this.tracks_.length;
          "" + n in this ||
            Object.defineProperty(this, n, {
              get: function () {
                return this.tracks_[n];
              },
            }),
            -1 === this.tracks_.indexOf(e) &&
              (this.tracks_.push(e),
              this.trigger({ track: e, type: "addtrack", target: this })),
            (e.labelchange_ = function () {
              t.trigger({ track: e, type: "labelchange", target: t });
            }),
            Ct(e) && e.addEventListener("labelchange", e.labelchange_);
        }),
        (t.removeTrack = function (e) {
          for (var t, n = 0, i = this.length; n < i; n++)
            if (this[n] === e) {
              (t = this[n]).off && t.off(), this.tracks_.splice(n, 1);
              break;
            }
          t && this.trigger({ track: t, type: "removetrack", target: this });
        }),
        (t.getTrackById = function (e) {
          for (var t = null, n = 0, i = this.length; n < i; n++) {
            var r = this[n];
            if (r.id === e) {
              t = r;
              break;
            }
          }
          return t;
        }),
        e
      );
    })(gt);
  for (Yt in ((Kt.prototype.allowedEvents_ = {
    change: "change",
    addtrack: "addtrack",
    removetrack: "removetrack",
    labelchange: "labelchange",
  }),
  Kt.prototype.allowedEvents_))
    Kt.prototype["on" + Yt] = null;
  function Qt(e, t) {
    for (var n = 0; n < e.length; n++)
      Object.keys(e[n]).length && t.id !== e[n].id && (e[n].enabled = !1);
  }
  function Zt(e, t) {
    for (var n = 0; n < e.length; n++)
      Object.keys(e[n]).length && t.id !== e[n].id && (e[n].selected = !1);
  }
  function Jt(e) {
    var t = [
        "protocol",
        "hostname",
        "port",
        "pathname",
        "search",
        "hash",
        "host",
      ],
      n = document.createElement("a");
    n.href = e;
    for (var i = {}, r = 0; r < t.length; r++) i[t[r]] = n[t[r]];
    return (
      "http:" === i.protocol && (i.host = i.host.replace(/:80$/, "")),
      "https:" === i.protocol && (i.host = i.host.replace(/:443$/, "")),
      i.protocol || (i.protocol = window.location.protocol),
      i.host || (i.host = window.location.host),
      i
    );
  }
  function $t(e) {
    var t;
    return (
      e.match(/^https?:\/\//) ||
        (((t = document.createElement("a")).href = e), (e = t.href)),
      e
    );
  }
  function en(e) {
    if ("string" == typeof e) {
      e =
        /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/.exec(
          e
        );
      if (e) return e.pop().toLowerCase();
    }
    return "";
  }
  function tn(e, t) {
    return (
      void 0 === t && (t = window.location),
      (":" === (e = Jt(e)).protocol ? t : e).protocol + e.host !==
        t.protocol + t.host
    );
  }
  var nn = (function (i) {
      function e(e) {
        for (var t, n = (e = void 0 === e ? [] : e).length - 1; 0 <= n; n--)
          if (e[n].enabled) {
            Qt(e, e[n]);
            break;
          }
        return ((t = i.call(this, e) || this).changing_ = !1), t;
      }
      b(e, i);
      var t = e.prototype;
      return (
        (t.addTrack = function (e) {
          var t = this;
          e.enabled && Qt(this, e),
            i.prototype.addTrack.call(this, e),
            e.addEventListener &&
              ((e.enabledChange_ = function () {
                t.changing_ ||
                  ((t.changing_ = !0),
                  Qt(t, e),
                  (t.changing_ = !1),
                  t.trigger("change"));
              }),
              e.addEventListener("enabledchange", e.enabledChange_));
        }),
        (t.removeTrack = function (e) {
          i.prototype.removeTrack.call(this, e),
            e.removeEventListener &&
              e.enabledChange_ &&
              (e.removeEventListener("enabledchange", e.enabledChange_),
              (e.enabledChange_ = null));
        }),
        e
      );
    })(Kt),
    rn = (function (i) {
      function e(e) {
        for (var t, n = (e = void 0 === e ? [] : e).length - 1; 0 <= n; n--)
          if (e[n].selected) {
            Zt(e, e[n]);
            break;
          }
        return (
          ((t = i.call(this, e) || this).changing_ = !1),
          Object.defineProperty(y(t), "selectedIndex", {
            get: function () {
              for (var e = 0; e < this.length; e++)
                if (this[e].selected) return e;
              return -1;
            },
            set: function () {},
          }),
          t
        );
      }
      b(e, i);
      var t = e.prototype;
      return (
        (t.addTrack = function (e) {
          var t = this;
          e.selected && Zt(this, e),
            i.prototype.addTrack.call(this, e),
            e.addEventListener &&
              ((e.selectedChange_ = function () {
                t.changing_ ||
                  ((t.changing_ = !0),
                  Zt(t, e),
                  (t.changing_ = !1),
                  t.trigger("change"));
              }),
              e.addEventListener("selectedchange", e.selectedChange_));
        }),
        (t.removeTrack = function (e) {
          i.prototype.removeTrack.call(this, e),
            e.removeEventListener &&
              e.selectedChange_ &&
              (e.removeEventListener("selectedchange", e.selectedChange_),
              (e.selectedChange_ = null));
        }),
        e
      );
    })(Kt),
    t = (function (n) {
      function e() {
        return n.apply(this, arguments) || this;
      }
      b(e, n);
      var t = e.prototype;
      return (
        (t.addTrack = function (e) {
          var t = this;
          n.prototype.addTrack.call(this, e),
            this.queueChange_ ||
              (this.queueChange_ = function () {
                return t.queueTrigger("change");
              }),
            this.triggerSelectedlanguagechange ||
              (this.triggerSelectedlanguagechange_ = function () {
                return t.trigger("selectedlanguagechange");
              }),
            e.addEventListener("modechange", this.queueChange_);
          -1 === ["metadata", "chapters"].indexOf(e.kind) &&
            e.addEventListener(
              "modechange",
              this.triggerSelectedlanguagechange_
            );
        }),
        (t.removeTrack = function (e) {
          n.prototype.removeTrack.call(this, e),
            e.removeEventListener &&
              (this.queueChange_ &&
                e.removeEventListener("modechange", this.queueChange_),
              this.selectedlanguagechange_ &&
                e.removeEventListener(
                  "modechange",
                  this.triggerSelectedlanguagechange_
                ));
        }),
        e
      );
    })(Kt),
    o = (function () {
      function e(e) {
        void 0 === e && (e = []),
          (this.trackElements_ = []),
          Object.defineProperty(this, "length", {
            get: function () {
              return this.trackElements_.length;
            },
          });
        for (var t = 0, n = e.length; t < n; t++) this.addTrackElement_(e[t]);
      }
      var t = e.prototype;
      return (
        (t.addTrackElement_ = function (e) {
          var t = this.trackElements_.length;
          "" + t in this ||
            Object.defineProperty(this, t, {
              get: function () {
                return this.trackElements_[t];
              },
            }),
            -1 === this.trackElements_.indexOf(e) &&
              this.trackElements_.push(e);
        }),
        (t.getTrackElementByTrack_ = function (e) {
          for (var t, n = 0, i = this.trackElements_.length; n < i; n++)
            if (e === this.trackElements_[n].track) {
              t = this.trackElements_[n];
              break;
            }
          return t;
        }),
        (t.removeTrackElement_ = function (e) {
          for (var t = 0, n = this.trackElements_.length; t < n; t++)
            if (e === this.trackElements_[t]) {
              this.trackElements_[t].track &&
                "function" == typeof this.trackElements_[t].track.off &&
                this.trackElements_[t].track.off(),
                "function" == typeof this.trackElements_[t].off &&
                  this.trackElements_[t].off(),
                this.trackElements_.splice(t, 1);
              break;
            }
        }),
        e
      );
    })(),
    an = (function () {
      function t(e) {
        t.prototype.setCues_.call(this, e),
          Object.defineProperty(this, "length", {
            get: function () {
              return this.length_;
            },
          });
      }
      var e = t.prototype;
      return (
        (e.setCues_ = function (e) {
          var t = this.length || 0,
            n = 0,
            i = e.length;
          (this.cues_ = e), (this.length_ = e.length);
          function r(e) {
            "" + e in this ||
              Object.defineProperty(this, "" + e, {
                get: function () {
                  return this.cues_[e];
                },
              });
          }
          if (t < i) for (n = t; n < i; n++) r.call(this, n);
        }),
        (e.getCueById = function (e) {
          for (var t = null, n = 0, i = this.length; n < i; n++) {
            var r = this[n];
            if (r.id === e) {
              t = r;
              break;
            }
          }
          return t;
        }),
        t
      );
    })(),
    sn = {
      alternative: "alternative",
      captions: "captions",
      main: "main",
      sign: "sign",
      subtitles: "subtitles",
      commentary: "commentary",
    },
    on = {
      alternative: "alternative",
      descriptions: "descriptions",
      main: "main",
      "main-desc": "main-desc",
      translation: "translation",
      commentary: "commentary",
    },
    ln = {
      subtitles: "subtitles",
      captions: "captions",
      descriptions: "descriptions",
      chapters: "chapters",
      metadata: "metadata",
    },
    un = { disabled: "disabled", hidden: "hidden", showing: "showing" },
    ie = (function (a) {
      function e(e) {
        void 0 === e && (e = {});
        var t,
          n = a.call(this) || this,
          i = {
            id: e.id || "vjs_track_" + nt++,
            kind: e.kind || "",
            language: e.language || "",
          },
          r = e.label || "";
        for (t in i)
          !(function (e) {
            Object.defineProperty(y(n), e, {
              get: function () {
                return i[e];
              },
              set: function () {},
            });
          })(t);
        return (
          Object.defineProperty(y(n), "label", {
            get: function () {
              return r;
            },
            set: function (e) {
              e !== r && ((r = e), this.trigger("labelchange"));
            },
          }),
          n
        );
      }
      return b(e, a), e;
    })(gt),
    cn = Object.freeze({
      __proto__: null,
      parseUrl: Jt,
      getAbsoluteURL: $t,
      getFileExtension: en,
      isCrossOrigin: tn,
    }),
    v =
      "undefined" != typeof window
        ? window
        : "undefined" != typeof e
        ? e
        : "undefined" != typeof self
        ? self
        : {},
    dn = v,
    hn = function (e) {
      if (!e) return !1;
      var t = pn.call(e);
      return (
        "[object Function]" === t ||
        ("function" == typeof e && "[object RegExp]" !== t) ||
        ("undefined" != typeof window &&
          (e === window.setTimeout ||
            e === window.alert ||
            e === window.confirm ||
            e === window.prompt))
      );
    },
    pn = Object.prototype.toString;
  bn.httpHandler = function (i, r) {
    return (
      void 0 === r && (r = !1),
      function (e, t, n) {
        if (e) i(e);
        else if (400 <= t.statusCode && t.statusCode <= 599) {
          e = n;
          if (r)
            if (dn.TextDecoder) {
              t = (function (e) {
                void 0 === e && (e = "");
                return e
                  .toLowerCase()
                  .split(";")
                  .reduce(function (e, t) {
                    var n = t.split("="),
                      t = n[0],
                      n = n[1];
                    return "charset" === t.trim() ? n.trim() : e;
                  }, "utf-8");
              })(t.headers && t.headers["content-type"]);
              try {
                e = new TextDecoder(t).decode(n);
              } catch (e) {}
            } else e = String.fromCharCode.apply(null, new Uint8Array(n));
          i({ cause: e });
        } else i(null, n);
      }
    );
  };
  var mn = function (e) {
      var i = {};
      return (
        e &&
          e
            .trim()
            .split("\n")
            .forEach(function (e) {
              var t = e.indexOf(":"),
                n = e.slice(0, t).trim().toLowerCase(),
                t = e.slice(t + 1).trim();
              "undefined" == typeof i[n]
                ? (i[n] = t)
                : Array.isArray(i[n])
                ? i[n].push(t)
                : (i[n] = [i[n], t]);
            }),
        i
      );
    },
    fn = bn,
    n = bn;
  function gn(e, t, n) {
    var i = e;
    return (
      hn(t)
        ? ((n = t), "string" == typeof e && (i = { uri: e }))
        : (i = Q({}, t, { uri: e })),
      (i.callback = n),
      i
    );
  }
  function bn(e, t, n) {
    return vn((t = gn(e, t, n)));
  }
  function vn(i) {
    if ("undefined" == typeof i.callback)
      throw new Error("callback argument missing");
    var r = !1,
      a = function (e, t, n) {
        r || ((r = !0), i.callback(e, t, n));
      };
    function s() {
      var e = void 0,
        e =
          u.response ||
          u.responseText ||
          (function (e) {
            try {
              if ("document" === e.responseType) return e.responseXML;
              var t =
                e.responseXML &&
                "parsererror" === e.responseXML.documentElement.nodeName;
              if ("" === e.responseType && !t) return e.responseXML;
            } catch (e) {}
            return null;
          })(u);
      if (f)
        try {
          e = JSON.parse(e);
        } catch (e) {}
      return e;
    }
    function t(e) {
      return (
        clearTimeout(l),
        ((e = !(e instanceof Error)
          ? new Error("" + (e || "Unknown XMLHttpRequest Error"))
          : e).statusCode = 0),
        a(e, g)
      );
    }
    function e() {
      if (!o) {
        clearTimeout(l);
        var e =
            i.useXDR && void 0 === u.status
              ? 200
              : 1223 === u.status
              ? 204
              : u.status,
          t = g,
          n = null;
        return (
          0 !== e
            ? ((t = {
                body: s(),
                statusCode: e,
                method: d,
                headers: {},
                url: c,
                rawRequest: u,
              }),
              u.getAllResponseHeaders &&
                (t.headers = mn(u.getAllResponseHeaders())))
            : (n = new Error("Internal XMLHttpRequest Error")),
          a(n, t, t.body)
        );
      }
    }
    var n,
      o,
      l,
      u = i.xhr || null,
      c = ((u =
        u ||
        new (i.cors || i.useXDR
          ? bn.XDomainRequest
          : bn.XMLHttpRequest)()).url = i.uri || i.url),
      d = (u.method = i.method || "GET"),
      h = i.body || i.data,
      p = (u.headers = i.headers || {}),
      m = !!i.sync,
      f = !1,
      g = {
        body: void 0,
        headers: {},
        statusCode: 0,
        method: d,
        url: c,
        rawRequest: u,
      };
    if (
      ("json" in i &&
        !1 !== i.json &&
        ((f = !0),
        p.accept || p.Accept || (p.Accept = "application/json"),
        "GET" !== d &&
          "HEAD" !== d &&
          (p["content-type"] ||
            p["Content-Type"] ||
            (p["Content-Type"] = "application/json"),
          (h = JSON.stringify(!0 === i.json ? h : i.json)))),
      (u.onreadystatechange = function () {
        4 === u.readyState && setTimeout(e, 0);
      }),
      (u.onload = e),
      (u.onerror = t),
      (u.onprogress = function () {}),
      (u.onabort = function () {
        o = !0;
      }),
      (u.ontimeout = t),
      u.open(d, c, !m, i.username, i.password),
      m || (u.withCredentials = !!i.withCredentials),
      !m &&
        0 < i.timeout &&
        (l = setTimeout(function () {
          var e;
          o ||
            ((o = !0),
            u.abort("timeout"),
            ((e = new Error("XMLHttpRequest timeout")).code = "ETIMEDOUT"),
            t(e));
        }, i.timeout)),
      u.setRequestHeader)
    )
      for (n in p) p.hasOwnProperty(n) && u.setRequestHeader(n, p[n]);
    else if (
      i.headers &&
      !(function (e) {
        for (var t in e) if (e.hasOwnProperty(t)) return;
        return 1;
      })(i.headers)
    )
      throw new Error("Headers cannot be set on an XDomainRequest object");
    return (
      "responseType" in i && (u.responseType = i.responseType),
      "beforeSend" in i && "function" == typeof i.beforeSend && i.beforeSend(u),
      u.send(h || null),
      u
    );
  }
  (bn.XMLHttpRequest = dn.XMLHttpRequest || function () {}),
    (bn.XDomainRequest =
      "withCredentials" in new bn.XMLHttpRequest()
        ? bn.XMLHttpRequest
        : dn.XDomainRequest),
    (function (e, t) {
      for (var n = 0; n < e.length; n++) t(e[n]);
    })(["get", "put", "post", "patch", "head", "delete"], function (i) {
      bn["delete" === i ? "del" : i] = function (e, t, n) {
        return ((t = gn(e, t, n)).method = i.toUpperCase()), vn(t);
      };
    }),
    (fn.default = n);
  function yn(e, t) {
    var n = new window.WebVTT.Parser(
        window,
        window.vttjs,
        window.WebVTT.StringDecoder()
      ),
      i = [];
    (n.oncue = function (e) {
      t.addCue(e);
    }),
      (n.onparsingerror = function (e) {
        i.push(e);
      }),
      (n.onflush = function () {
        t.trigger({ type: "loadeddata", target: t });
      }),
      n.parse(e),
      0 < i.length &&
        (window.console &&
          window.console.groupCollapsed &&
          window.console.groupCollapsed(
            "Text Track parsing errors for " + t.src
          ),
        i.forEach(function (e) {
          return d.error(e);
        }),
        window.console && window.console.groupEnd && window.console.groupEnd()),
      n.flush();
  }
  function _n(e, i) {
    var t = { uri: e };
    (e = tn(e)) && (t.cors = e),
      (e = "use-credentials" === i.tech_.crossOrigin()) &&
        (t.withCredentials = e),
      fn(
        t,
        u(this, function (e, t, n) {
          return e
            ? d.error(e, t)
            : ((i.loaded_ = !0),
              void ("function" != typeof window.WebVTT
                ? i.tech_ &&
                  i.tech_.any(["vttjsloaded", "vttjserror"], function (e) {
                    return "vttjserror" !== e.type
                      ? yn(n, i)
                      : void d.error(
                          "vttjs failed to load, stopping trying to process " +
                            i.src
                        );
                  })
                : yn(n, i)));
        })
      );
  }
  var Tn = (function (a) {
    function e(e) {
      var t;
      if (!(e = void 0 === e ? {} : e).tech)
        throw new Error("A tech was not provided.");
      var e = m(e, {
          kind: ln[e.kind] || "subtitles",
          language: e.language || e.srclang || "",
        }),
        n = un[e.mode] || "disabled",
        i = e.default;
      ("metadata" !== e.kind && "chapters" !== e.kind) || (n = "hidden"),
        ((t = a.call(this, e) || this).tech_ = e.tech),
        (t.cues_ = []),
        (t.activeCues_ = []),
        (t.preload_ = !1 !== t.tech_.preloadTextTracks);
      var r = new an(t.cues_),
        s = new an(t.activeCues_),
        o = !1;
      t.timeupdateHandler = u(y(t), function (e) {
        void 0 === e && (e = {}),
          this.tech_.isDisposed() ||
            (this.tech_.isReady_ &&
              ((this.activeCues = this.activeCues),
              o && (this.trigger("cuechange"), (o = !1))),
            "timeupdate" !== e.type &&
              (this.rvf_ = this.tech_.requestVideoFrameCallback(
                this.timeupdateHandler
              )));
      });
      return (
        t.tech_.one("dispose", function () {
          t.stopTracking();
        }),
        "disabled" !== n && t.startTracking(),
        Object.defineProperties(y(t), {
          default: {
            get: function () {
              return i;
            },
            set: function () {},
          },
          mode: {
            get: function () {
              return n;
            },
            set: function (e) {
              un[e] &&
                n !== e &&
                ((n = e),
                this.preload_ ||
                  "disabled" === n ||
                  0 !== this.cues.length ||
                  _n(this.src, this),
                this.stopTracking(),
                "disabled" !== n && this.startTracking(),
                this.trigger("modechange"));
            },
          },
          cues: {
            get: function () {
              return this.loaded_ ? r : null;
            },
            set: function () {},
          },
          activeCues: {
            get: function () {
              if (!this.loaded_) return null;
              if (0 === this.cues.length) return s;
              for (
                var e = this.tech_.currentTime(),
                  t = [],
                  n = 0,
                  i = this.cues.length;
                n < i;
                n++
              ) {
                var r = this.cues[n];
                ((r.startTime <= e && r.endTime >= e) ||
                  (r.startTime === r.endTime &&
                    r.startTime <= e &&
                    r.startTime + 0.5 >= e)) &&
                  t.push(r);
              }
              if (((o = !1), t.length !== this.activeCues_.length)) o = !0;
              else
                for (var a = 0; a < t.length; a++)
                  -1 === this.activeCues_.indexOf(t[a]) && (o = !0);
              return (this.activeCues_ = t), s.setCues_(this.activeCues_), s;
            },
            set: function () {},
          },
        }),
        e.src
          ? ((t.src = e.src),
            t.preload_ || (t.loaded_ = !0),
            (t.preload_ || ("subtitles" !== e.kind && "captions" !== e.kind)) &&
              _n(t.src, y(t)))
          : (t.loaded_ = !0),
        t
      );
    }
    b(e, a);
    var t = e.prototype;
    return (
      (t.startTracking = function () {
        (this.rvf_ = this.tech_.requestVideoFrameCallback(
          this.timeupdateHandler
        )),
          this.tech_.on("timeupdate", this.timeupdateHandler);
      }),
      (t.stopTracking = function () {
        this.rvf_ &&
          (this.tech_.cancelVideoFrameCallback(this.rvf_),
          (this.rvf_ = void 0)),
          this.tech_.off("timeupdate", this.timeupdateHandler);
      }),
      (t.addCue = function (e) {
        var t = e;
        if (window.vttjs && !(e instanceof window.vttjs.VTTCue)) {
          for (var n in ((t = new window.vttjs.VTTCue(
            e.startTime,
            e.endTime,
            e.text
          )),
          e))
            n in t || (t[n] = e[n]);
          (t.id = e.id), (t.originalCue_ = e);
        }
        for (var i = this.tech_.textTracks(), r = 0; r < i.length; r++)
          i[r] !== this && i[r].removeCue(t);
        this.cues_.push(t), this.cues.setCues_(this.cues_);
      }),
      (t.removeCue = function (e) {
        for (var t = this.cues_.length; t--; ) {
          var n = this.cues_[t];
          if (n === e || (n.originalCue_ && n.originalCue_ === e)) {
            this.cues_.splice(t, 1), this.cues.setCues_(this.cues_);
            break;
          }
        }
      }),
      e
    );
  })(ie);
  Tn.prototype.allowedEvents_ = { cuechange: "cuechange" };
  (r = (function (i) {
    function e(e) {
      var t = m((e = void 0 === e ? {} : e), { kind: on[e.kind] || "" }),
        e = i.call(this, t) || this,
        n = !1;
      return (
        Object.defineProperty(y(e), "enabled", {
          get: function () {
            return n;
          },
          set: function (e) {
            "boolean" == typeof e &&
              e !== n &&
              ((n = e), this.trigger("enabledchange"));
          },
        }),
        t.enabled && (e.enabled = t.enabled),
        (e.loaded_ = !0),
        e
      );
    }
    return b(e, i), e;
  })(ie)),
    (he = (function (i) {
      function e(e) {
        var t = m((e = void 0 === e ? {} : e), { kind: sn[e.kind] || "" }),
          e = i.call(this, t) || this,
          n = !1;
        return (
          Object.defineProperty(y(e), "selected", {
            get: function () {
              return n;
            },
            set: function (e) {
              "boolean" == typeof e &&
                e !== n &&
                ((n = e), this.trigger("selectedchange"));
            },
          }),
          t.selected && (e.selected = t.selected),
          e
        );
      }
      return b(e, i), e;
    })(ie)),
    (a = (function (r) {
      function e(e) {
        var t;
        void 0 === e && (e = {});
        var n = r.call(this) || this,
          i = new Tn(e);
        return (
          (n.kind = i.kind),
          (n.src = i.src),
          (n.srclang = i.language),
          (n.label = i.label),
          (n.default = i.default),
          Object.defineProperties(y(n), {
            readyState: {
              get: function () {
                return t;
              },
            },
            track: {
              get: function () {
                return i;
              },
            },
          }),
          (t = 0),
          i.addEventListener("loadeddata", function () {
            (t = 2), n.trigger({ type: "load", target: y(n) });
          }),
          n
        );
      }
      return b(e, r), e;
    })(gt));
  (a.prototype.allowedEvents_ = { load: "load" }),
    (a.NONE = 0),
    (a.LOADING = 1),
    (a.LOADED = 2),
    (a.ERROR = 3);
  var On = {
    audio: { ListClass: nn, TrackClass: r, capitalName: "Audio" },
    video: { ListClass: rn, TrackClass: he, capitalName: "Video" },
    text: { ListClass: t, TrackClass: Tn, capitalName: "Text" },
  };
  Object.keys(On).forEach(function (e) {
    (On[e].getterName = e + "Tracks"), (On[e].privateName = e + "Tracks_");
  });
  var Sn = {
      remoteText: {
        ListClass: t,
        TrackClass: Tn,
        capitalName: "RemoteText",
        getterName: "remoteTextTracks",
        privateName: "remoteTextTracks_",
      },
      remoteTextEl: {
        ListClass: o,
        TrackClass: a,
        capitalName: "RemoteTextTrackEls",
        getterName: "remoteTextTrackEls",
        privateName: "remoteTextTrackEls_",
      },
    },
    An = Q({}, On, Sn);
  (Sn.names = Object.keys(Sn)),
    (On.names = Object.keys(On)),
    (An.names = [].concat(Sn.names).concat(On.names));
  var _ =
      "undefined" != typeof e ? e : "undefined" != typeof window ? window : {},
    T =
      "undefined" != typeof document
        ? document
        : (T = _["__GLOBAL_DOCUMENT_CACHE@4"]) ||
          (_["__GLOBAL_DOCUMENT_CACHE@4"] = {}),
    v = T,
    wn =
      Object.create ||
      function (e) {
        if (1 !== arguments.length)
          throw new Error("Object.create shim only accepts one parameter.");
        return (Cn.prototype = e), new Cn();
      };
  function Cn() {}
  function In(e, t) {
    (this.name = "ParsingError"),
      (this.code = e.code),
      (this.message = t || e.message);
  }
  function xn(e) {
    function t(e, t, n, i) {
      return 3600 * (0 | e) + 60 * (0 | t) + (0 | n) + (0 | i) / 1e3;
    }
    e = e.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
    return e
      ? e[3]
        ? t(e[1], e[2], e[3].replace(":", ""), e[4])
        : 59 < e[1]
        ? t(e[1], e[2], 0, e[4])
        : t(0, e[1], e[2], e[4])
      : null;
  }
  function En() {
    this.values = wn(null);
  }
  function kn(e, t, n, i) {
    var r,
      a,
      s = i ? e.split(i) : [e];
    for (r in s)
      "string" == typeof s[r] &&
        2 === (a = s[r].split(n)).length &&
        t(a[0].trim(), a[1].trim());
  }
  function Pn(t, e, s) {
    var n = t;
    function i() {
      var e = xn(t);
      if (null === e)
        throw new In(In.Errors.BadTimeStamp, "Malformed timestamp: " + n);
      return (t = t.replace(/^[^\sa-zA-Z-]+/, "")), e;
    }
    function r() {
      t = t.replace(/^\s+/, "");
    }
    if ((r(), (e.startTime = i()), r(), "--\x3e" !== t.substr(0, 3)))
      throw new In(
        In.Errors.BadTimeStamp,
        "Malformed time stamp (time stamps must be separated by '--\x3e'): " + n
      );
    (t = t.substr(3)),
      r(),
      (e.endTime = i()),
      r(),
      (function (e, t) {
        var a = new En();
        kn(
          e,
          function (e, t) {
            switch (e) {
              case "region":
                for (var n = s.length - 1; 0 <= n; n--)
                  if (s[n].id === t) {
                    a.set(e, s[n].region);
                    break;
                  }
                break;
              case "vertical":
                a.alt(e, t, ["rl", "lr"]);
                break;
              case "line":
                var i = t.split(","),
                  r = i[0];
                a.integer(e, r),
                  a.percent(e, r) && a.set("snapToLines", !1),
                  a.alt(e, r, ["auto"]),
                  2 === i.length &&
                    a.alt("lineAlign", i[1], ["start", "center", "end"]);
                break;
              case "position":
                (i = t.split(",")),
                  a.percent(e, i[0]),
                  2 === i.length &&
                    a.alt("positionAlign", i[1], ["start", "center", "end"]);
                break;
              case "size":
                a.percent(e, t);
                break;
              case "align":
                a.alt(e, t, ["start", "center", "end", "left", "right"]);
            }
          },
          /:/,
          /\s/
        ),
          (t.region = a.get("region", null)),
          (t.vertical = a.get("vertical", ""));
        try {
          t.line = a.get("line", "auto");
        } catch (e) {}
        (t.lineAlign = a.get("lineAlign", "start")),
          (t.snapToLines = a.get("snapToLines", !0)),
          (t.size = a.get("size", 100));
        try {
          t.align = a.get("align", "center");
        } catch (e) {
          t.align = a.get("align", "middle");
        }
        try {
          t.position = a.get("position", "auto");
        } catch (e) {
          t.position = a.get(
            "position",
            { start: 0, left: 0, center: 50, middle: 50, end: 100, right: 100 },
            t.align
          );
        }
        t.positionAlign = a.get(
          "positionAlign",
          {
            start: "start",
            left: "start",
            center: "center",
            middle: "center",
            end: "end",
            right: "end",
          },
          t.align
        );
      })(t, e);
  }
  (((In.prototype = wn(Error.prototype)).constructor = In).Errors = {
    BadSignature: { code: 0, message: "Malformed WebVTT signature." },
    BadTimeStamp: { code: 1, message: "Malformed time stamp." },
  }),
    (En.prototype = {
      set: function (e, t) {
        this.get(e) || "" === t || (this.values[e] = t);
      },
      get: function (e, t, n) {
        return n
          ? this.has(e)
            ? this.values[e]
            : t[n]
          : this.has(e)
          ? this.values[e]
          : t;
      },
      has: function (e) {
        return e in this.values;
      },
      alt: function (e, t, n) {
        for (var i = 0; i < n.length; ++i)
          if (t === n[i]) {
            this.set(e, t);
            break;
          }
      },
      integer: function (e, t) {
        /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10));
      },
      percent: function (e, t) {
        return (
          !!(
            t.match(/^([\d]{1,3})(\.[\d]*)?%$/) &&
            0 <= (t = parseFloat(t)) &&
            t <= 100
          ) && (this.set(e, t), !0)
        );
      },
    });
  var jn = v.createElement && v.createElement("textarea"),
    Nn = {
      c: "span",
      i: "i",
      b: "b",
      u: "u",
      ruby: "ruby",
      rt: "rt",
      v: "span",
      lang: "span",
    },
    Ln = {
      white: "rgba(255,255,255,1)",
      lime: "rgba(0,255,0,1)",
      cyan: "rgba(0,255,255,1)",
      red: "rgba(255,0,0,1)",
      yellow: "rgba(255,255,0,1)",
      magenta: "rgba(255,0,255,1)",
      blue: "rgba(0,0,255,1)",
      black: "rgba(0,0,0,1)",
    },
    Mn = { v: "title", lang: "lang" },
    Dn = { rt: "ruby" };
  function Rn(e, t) {
    for (
      var n,
        i,
        r,
        a,
        s,
        o,
        l,
        u,
        c,
        d,
        h = e.document.createElement("div"),
        p = h,
        m = [];
      null !==
      (n = (function () {
        if (!t) return null;
        var e = t.match(/^([^<]*)(<[^>]*>?)?/);
        return (e = e[1] || e[2]), (t = t.substr(e.length)), e;
      })());

    )
      "<" !== n[0]
        ? p.appendChild(
            e.document.createTextNode(
              ((s = n),
              (jn.innerHTML = s),
              (s = jn.textContent),
              (jn.textContent = ""),
              s)
            )
          )
        : "/" !== n[1]
        ? (a = xn(n.substr(1, n.length - 2)))
          ? ((i = e.document.createProcessingInstruction("timestamp", a)),
            p.appendChild(i))
          : (r = n.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/)) &&
            ((u = r[1]),
            (c = r[3]),
            (d = void 0),
            (d = Nn[u]),
            (i = d
              ? ((d = e.document.createElement(d)),
                (u = Mn[u]) && c && (d[u] = c.trim()),
                d)
              : null) &&
              ((o = p),
              (Dn[(l = i).localName] && Dn[l.localName] !== o.localName) ||
                (r[2] &&
                  ((a = r[2].split(".")).forEach(function (e) {
                    var t = /^bg_/.test(e),
                      e = t ? e.slice(3) : e;
                    Ln.hasOwnProperty(e) &&
                      ((e = Ln[e]),
                      (i.style[t ? "background-color" : "color"] = e));
                  }),
                  (i.className = a.join(" "))),
                m.push(r[1]),
                p.appendChild(i),
                (p = i))))
        : m.length &&
          m[m.length - 1] === n.substr(2).replace(">", "") &&
          (m.pop(), (p = p.parentNode));
    return h;
  }
  var Bn = [
    [1470, 1470],
    [1472, 1472],
    [1475, 1475],
    [1478, 1478],
    [1488, 1514],
    [1520, 1524],
    [1544, 1544],
    [1547, 1547],
    [1549, 1549],
    [1563, 1563],
    [1566, 1610],
    [1645, 1647],
    [1649, 1749],
    [1765, 1766],
    [1774, 1775],
    [1786, 1805],
    [1807, 1808],
    [1810, 1839],
    [1869, 1957],
    [1969, 1969],
    [1984, 2026],
    [2036, 2037],
    [2042, 2042],
    [2048, 2069],
    [2074, 2074],
    [2084, 2084],
    [2088, 2088],
    [2096, 2110],
    [2112, 2136],
    [2142, 2142],
    [2208, 2208],
    [2210, 2220],
    [8207, 8207],
    [64285, 64285],
    [64287, 64296],
    [64298, 64310],
    [64312, 64316],
    [64318, 64318],
    [64320, 64321],
    [64323, 64324],
    [64326, 64449],
    [64467, 64829],
    [64848, 64911],
    [64914, 64967],
    [65008, 65020],
    [65136, 65140],
    [65142, 65276],
    [67584, 67589],
    [67592, 67592],
    [67594, 67637],
    [67639, 67640],
    [67644, 67644],
    [67647, 67669],
    [67671, 67679],
    [67840, 67867],
    [67872, 67897],
    [67903, 67903],
    [67968, 68023],
    [68030, 68031],
    [68096, 68096],
    [68112, 68115],
    [68117, 68119],
    [68121, 68147],
    [68160, 68167],
    [68176, 68184],
    [68192, 68223],
    [68352, 68405],
    [68416, 68437],
    [68440, 68466],
    [68472, 68479],
    [68608, 68680],
    [126464, 126467],
    [126469, 126495],
    [126497, 126498],
    [126500, 126500],
    [126503, 126503],
    [126505, 126514],
    [126516, 126519],
    [126521, 126521],
    [126523, 126523],
    [126530, 126530],
    [126535, 126535],
    [126537, 126537],
    [126539, 126539],
    [126541, 126543],
    [126545, 126546],
    [126548, 126548],
    [126551, 126551],
    [126553, 126553],
    [126555, 126555],
    [126557, 126557],
    [126559, 126559],
    [126561, 126562],
    [126564, 126564],
    [126567, 126570],
    [126572, 126578],
    [126580, 126583],
    [126585, 126588],
    [126590, 126590],
    [126592, 126601],
    [126603, 126619],
    [126625, 126627],
    [126629, 126633],
    [126635, 126651],
    [1114109, 1114109],
  ];
  function Un(e) {
    var t = [],
      n = "";
    if (!e || !e.childNodes) return "ltr";
    function a(e, t) {
      for (var n = t.childNodes.length - 1; 0 <= n; n--)
        e.push(t.childNodes[n]);
    }
    for (
      a(t, e);
      (n = (function e(t) {
        if (!t || !t.length) return null;
        var n = t.pop(),
          i = n.textContent || n.innerText;
        if (i) {
          var r = i.match(/^.*(\n|\r)/);
          return r ? r[(t.length = 0)] : i;
        }
        return "ruby" === n.tagName
          ? e(t)
          : n.childNodes
          ? (a(t, n), e(t))
          : void 0;
      })(t));

    )
      for (var i = 0; i < n.length; i++)
        if (
          (function (e) {
            for (var t = 0; t < Bn.length; t++) {
              var n = Bn[t];
              if (e >= n[0] && e <= n[1]) return 1;
            }
          })(n.charCodeAt(i))
        )
          return "rtl";
    return "ltr";
  }
  function Vn() {}
  function Fn(e, t, n) {
    Vn.call(this), (this.cue = t), (this.cueDiv = Rn(e, t.text));
    var i = {
      color: "rgba(255, 255, 255, 1)",
      backgroundColor: "rgba(0, 0, 0, 0.8)",
      position: "relative",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      display: "inline",
      writingMode:
        "" === t.vertical
          ? "horizontal-tb"
          : "lr" === t.vertical
          ? "vertical-lr"
          : "vertical-rl",
      unicodeBidi: "plaintext",
    };
    this.applyStyles(i, this.cueDiv),
      (this.div = e.document.createElement("div")),
      (i = {
        direction: Un(this.cueDiv),
        writingMode:
          "" === t.vertical
            ? "horizontal-tb"
            : "lr" === t.vertical
            ? "vertical-lr"
            : "vertical-rl",
        unicodeBidi: "plaintext",
        textAlign: "middle" === t.align ? "center" : t.align,
        font: n.font,
        whiteSpace: "pre-line",
        position: "absolute",
      }),
      this.applyStyles(i),
      this.div.appendChild(this.cueDiv);
    var r = 0;
    switch (t.positionAlign) {
      case "start":
        r = t.position;
        break;
      case "center":
        r = t.position - t.size / 2;
        break;
      case "end":
        r = t.position - t.size;
    }
    "" === t.vertical
      ? this.applyStyles({
          left: this.formatStyle(r, "%"),
          width: this.formatStyle(t.size, "%"),
        })
      : this.applyStyles({
          top: this.formatStyle(r, "%"),
          height: this.formatStyle(t.size, "%"),
        }),
      (this.move = function (e) {
        this.applyStyles({
          top: this.formatStyle(e.top, "px"),
          bottom: this.formatStyle(e.bottom, "px"),
          left: this.formatStyle(e.left, "px"),
          right: this.formatStyle(e.right, "px"),
          height: this.formatStyle(e.height, "px"),
          width: this.formatStyle(e.width, "px"),
        });
      });
  }
  function Gn(e) {
    var t, n, i, r;
    e.div &&
      ((t = e.div.offsetHeight),
      (n = e.div.offsetWidth),
      (i = e.div.offsetTop),
      (r =
        (r = e.div.childNodes) &&
        (r = r[0]) &&
        r.getClientRects &&
        r.getClientRects()),
      (e = e.div.getBoundingClientRect()),
      (r = r ? Math.max((r[0] && r[0].height) || 0, e.height / r.length) : 0)),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top || i),
      (this.height = e.height || t),
      (this.bottom = e.bottom || i + (e.height || t)),
      (this.width = e.width || n),
      (this.lineHeight = void 0 !== r ? r : e.lineHeight);
  }
  function qn(e, t, o, l) {
    var n,
      i = new Gn(t),
      r = t.cue,
      a = (function (e) {
        if (
          "number" == typeof e.line &&
          (e.snapToLines || (0 <= e.line && e.line <= 100))
        )
          return e.line;
        if (
          !e.track ||
          !e.track.textTrackList ||
          !e.track.textTrackList.mediaElement
        )
          return -1;
        for (
          var t = e.track, n = t.textTrackList, i = 0, r = 0;
          r < n.length && n[r] !== t;
          r++
        )
          "showing" === n[r].mode && i++;
        return -1 * ++i;
      })(r),
      s = [];
    if (r.snapToLines) {
      switch (r.vertical) {
        case "":
          (s = ["+y", "-y"]), (n = "height");
          break;
        case "rl":
          (s = ["+x", "-x"]), (n = "width");
          break;
        case "lr":
          (s = ["-x", "+x"]), (n = "width");
      }
      var u = i.lineHeight,
        c = u * Math.round(a),
        d = o[n] + u,
        h = s[0];
      Math.abs(c) > d && ((c = c < 0 ? -1 : 1), (c *= Math.ceil(d / u) * u)),
        a < 0 &&
          ((c += "" === r.vertical ? o.height : o.width), (s = s.reverse())),
        i.move(h, c);
    } else {
      var p = (i.lineHeight / o.height) * 100;
      switch (r.lineAlign) {
        case "center":
          a -= p / 2;
          break;
        case "end":
          a -= p;
      }
      switch (r.vertical) {
        case "":
          t.applyStyles({ top: t.formatStyle(a, "%") });
          break;
        case "rl":
          t.applyStyles({ left: t.formatStyle(a, "%") });
          break;
        case "lr":
          t.applyStyles({ right: t.formatStyle(a, "%") });
      }
      (s = ["+y", "-x", "+x", "-y"]), (i = new Gn(t));
    }
    i = (function (e, t) {
      for (var n, i = new Gn(e), r = 1, a = 0; a < t.length; a++) {
        for (
          ;
          e.overlapsOppositeAxis(o, t[a]) || (e.within(o) && e.overlapsAny(l));

        )
          e.move(t[a]);
        if (e.within(o)) return e;
        var s = e.intersectPercentage(o);
        s < r && ((n = new Gn(e)), (r = s)), (e = new Gn(i));
      }
      return n || i;
    })(i, s);
    t.move(i.toCSSCompatValues(o));
  }
  function zn() {}
  (Vn.prototype.applyStyles = function (e, t) {
    for (var n in ((t = t || this.div), e))
      e.hasOwnProperty(n) && (t.style[n] = e[n]);
  }),
    (Vn.prototype.formatStyle = function (e, t) {
      return 0 === e ? 0 : e + t;
    }),
    ((Fn.prototype = wn(Vn.prototype)).constructor = Fn),
    (Gn.prototype.move = function (e, t) {
      switch (((t = void 0 !== t ? t : this.lineHeight), e)) {
        case "+x":
          (this.left += t), (this.right += t);
          break;
        case "-x":
          (this.left -= t), (this.right -= t);
          break;
        case "+y":
          (this.top += t), (this.bottom += t);
          break;
        case "-y":
          (this.top -= t), (this.bottom -= t);
      }
    }),
    (Gn.prototype.overlaps = function (e) {
      return (
        this.left < e.right &&
        this.right > e.left &&
        this.top < e.bottom &&
        this.bottom > e.top
      );
    }),
    (Gn.prototype.overlapsAny = function (e) {
      for (var t = 0; t < e.length; t++) if (this.overlaps(e[t])) return !0;
      return !1;
    }),
    (Gn.prototype.within = function (e) {
      return (
        this.top >= e.top &&
        this.bottom <= e.bottom &&
        this.left >= e.left &&
        this.right <= e.right
      );
    }),
    (Gn.prototype.overlapsOppositeAxis = function (e, t) {
      switch (t) {
        case "+x":
          return this.left < e.left;
        case "-x":
          return this.right > e.right;
        case "+y":
          return this.top < e.top;
        case "-y":
          return this.bottom > e.bottom;
      }
    }),
    (Gn.prototype.intersectPercentage = function (e) {
      return (
        (Math.max(
          0,
          Math.min(this.right, e.right) - Math.max(this.left, e.left)
        ) *
          Math.max(
            0,
            Math.min(this.bottom, e.bottom) - Math.max(this.top, e.top)
          )) /
        (this.height * this.width)
      );
    }),
    (Gn.prototype.toCSSCompatValues = function (e) {
      return {
        top: this.top - e.top,
        bottom: e.bottom - this.bottom,
        left: this.left - e.left,
        right: e.right - this.right,
        height: this.height,
        width: this.width,
      };
    }),
    (Gn.getSimpleBoxPosition = function (e) {
      var t = e.div ? e.div.offsetHeight : e.tagName ? e.offsetHeight : 0,
        n = e.div ? e.div.offsetWidth : e.tagName ? e.offsetWidth : 0,
        i = e.div ? e.div.offsetTop : e.tagName ? e.offsetTop : 0;
      return {
        left: (e = e.div
          ? e.div.getBoundingClientRect()
          : e.tagName
          ? e.getBoundingClientRect()
          : e).left,
        right: e.right,
        top: e.top || i,
        height: e.height || t,
        bottom: e.bottom || i + (e.height || t),
        width: e.width || n,
      };
    }),
    (zn.StringDecoder = function () {
      return {
        decode: function (e) {
          if (!e) return "";
          if ("string" != typeof e)
            throw new Error("Error - expected string data.");
          return decodeURIComponent(encodeURIComponent(e));
        },
      };
    }),
    (zn.convertCueToDOMTree = function (e, t) {
      return e && t ? Rn(e, t) : null;
    });
  (zn.processCues = function (i, r, e) {
    if (!i || !r || !e) return null;
    for (; e.firstChild; ) e.removeChild(e.firstChild);
    var a = i.document.createElement("div");
    if (
      ((a.style.position = "absolute"),
      (a.style.left = "0"),
      (a.style.right = "0"),
      (a.style.top = "0"),
      (a.style.bottom = "0"),
      (a.style.margin = "1.5%"),
      e.appendChild(a),
      (function (e) {
        for (var t = 0; t < e.length; t++)
          if (e[t].hasBeenReset || !e[t].displayState) return 1;
      })(r))
    ) {
      var s = [],
        o = Gn.getSimpleBoxPosition(a),
        l = { font: Math.round(0.05 * o.height * 100) / 100 + "px sans-serif" };
      !(function () {
        for (var e, t, n = 0; n < r.length; n++)
          (t = r[n]),
            (e = new Fn(i, t, l)),
            a.appendChild(e.div),
            qn(0, e, o, s),
            (t.displayState = e.div),
            s.push(Gn.getSimpleBoxPosition(e));
      })();
    } else for (var t = 0; t < r.length; t++) a.appendChild(r[t].displayState);
  }),
    ((zn.Parser = function (e, t, n) {
      n || ((n = t), (t = {})),
        (t = t || {}),
        (this.window = e),
        (this.vttjs = t),
        (this.state = "INITIAL"),
        (this.buffer = ""),
        (this.decoder = n || new TextDecoder("utf8")),
        (this.regionList = []);
    }).prototype = {
      reportOrThrowError: function (e) {
        if (!(e instanceof In)) throw e;
        this.onparsingerror && this.onparsingerror(e);
      },
      parse: function (e) {
        var i = this;
        function t() {
          for (
            var e = i.buffer, t = 0;
            t < e.length && "\r" !== e[t] && "\n" !== e[t];

          )
            ++t;
          var n = e.substr(0, t);
          return (
            "\r" === e[t] && ++t,
            "\n" === e[t] && ++t,
            (i.buffer = e.substr(t)),
            n
          );
        }
        function n(e) {
          e.match(/X-TIMESTAMP-MAP/)
            ? kn(
                e,
                function (e, t) {
                  var n;
                  "X-TIMESTAMP-MAP" === e &&
                    ((t = t),
                    (n = new En()),
                    kn(
                      t,
                      function (e, t) {
                        switch (e) {
                          case "MPEGT":
                            n.integer(e + "S", t);
                            break;
                          case "LOCA":
                            n.set(e + "L", xn(t));
                        }
                      },
                      /[^\d]:/,
                      /,/
                    ),
                    i.ontimestampmap &&
                      i.ontimestampmap({
                        MPEGTS: n.get("MPEGTS"),
                        LOCAL: n.get("LOCAL"),
                      }));
                },
                /=/
              )
            : kn(
                e,
                function (e, t) {
                  var r;
                  "Region" === e &&
                    ((t = t),
                    (r = new En()),
                    kn(
                      t,
                      function (e, t) {
                        switch (e) {
                          case "id":
                            r.set(e, t);
                            break;
                          case "width":
                            r.percent(e, t);
                            break;
                          case "lines":
                            r.integer(e, t);
                            break;
                          case "regionanchor":
                          case "viewportanchor":
                            var n = t.split(",");
                            if (2 !== n.length) break;
                            var i = new En();
                            if (
                              (i.percent("x", n[0]),
                              i.percent("y", n[1]),
                              !i.has("x") || !i.has("y"))
                            )
                              break;
                            r.set(e + "X", i.get("x")),
                              r.set(e + "Y", i.get("y"));
                            break;
                          case "scroll":
                            r.alt(e, t, ["up"]);
                        }
                      },
                      /=/,
                      /\s/
                    ),
                    r.has("id") &&
                      (((t = new (i.vttjs.VTTRegion ||
                        i.window.VTTRegion)()).width = r.get("width", 100)),
                      (t.lines = r.get("lines", 3)),
                      (t.regionAnchorX = r.get("regionanchorX", 0)),
                      (t.regionAnchorY = r.get("regionanchorY", 100)),
                      (t.viewportAnchorX = r.get("viewportanchorX", 0)),
                      (t.viewportAnchorY = r.get("viewportanchorY", 100)),
                      (t.scroll = r.get("scroll", "")),
                      i.onregion && i.onregion(t),
                      i.regionList.push({ id: r.get("id"), region: t })));
                },
                /:/
              );
        }
        e && (i.buffer += i.decoder.decode(e, { stream: !0 }));
        try {
          if ("INITIAL" === i.state) {
            if (!/\r\n|\n/.test(i.buffer)) return this;
            var r,
              a = (r = t()).match(/^WEBVTT([ \t].*)?$/);
            if (!a || !a[0]) throw new In(In.Errors.BadSignature);
            i.state = "HEADER";
          }
          for (var s = !1; i.buffer; ) {
            if (!/\r\n|\n/.test(i.buffer)) return this;
            switch ((s ? (s = !1) : (r = t()), i.state)) {
              case "HEADER":
                /:/.test(r) ? n(r) : r || (i.state = "ID");
                continue;
              case "NOTE":
                r || (i.state = "ID");
                continue;
              case "ID":
                if (/^NOTE($|[ \t])/.test(r)) {
                  i.state = "NOTE";
                  break;
                }
                if (!r) continue;
                i.cue = new (i.vttjs.VTTCue || i.window.VTTCue)(0, 0, "");
                try {
                  i.cue.align = "center";
                } catch (e) {
                  i.cue.align = "middle";
                }
                if (((i.state = "CUE"), -1 === r.indexOf("--\x3e"))) {
                  i.cue.id = r;
                  continue;
                }
              case "CUE":
                try {
                  Pn(r, i.cue, i.regionList);
                } catch (e) {
                  i.reportOrThrowError(e), (i.cue = null), (i.state = "BADCUE");
                  continue;
                }
                i.state = "CUETEXT";
                continue;
              case "CUETEXT":
                var o = -1 !== r.indexOf("--\x3e");
                if (!r || (o && (s = !0))) {
                  i.oncue && i.oncue(i.cue), (i.cue = null), (i.state = "ID");
                  continue;
                }
                i.cue.text && (i.cue.text += "\n"),
                  (i.cue.text += r
                    .replace(/\u2028/g, "\n")
                    .replace(/u2029/g, "\n"));
                continue;
              case "BADCUE":
                r || (i.state = "ID");
                continue;
            }
          }
        } catch (e) {
          i.reportOrThrowError(e),
            "CUETEXT" === i.state && i.cue && i.oncue && i.oncue(i.cue),
            (i.cue = null),
            (i.state = "INITIAL" === i.state ? "BADWEBVTT" : "BADCUE");
        }
        return this;
      },
      flush: function () {
        var t = this;
        try {
          if (
            ((t.buffer += t.decoder.decode()),
            (!t.cue && "HEADER" !== t.state) ||
              ((t.buffer += "\n\n"), t.parse()),
            "INITIAL" === t.state)
          )
            throw new In(In.Errors.BadSignature);
        } catch (e) {
          t.reportOrThrowError(e);
        }
        return t.onflush && t.onflush(), this;
      },
    });
  var Hn = zn,
    Wn = { "": 1, lr: 1, rl: 1 },
    Xn = {
      start: 1,
      center: 1,
      end: 1,
      left: 1,
      right: 1,
      auto: 1,
      "line-left": 1,
      "line-right": 1,
    };
  function Yn(e) {
    return "string" == typeof e && !!Xn[e.toLowerCase()] && e.toLowerCase();
  }
  function Kn(e, t, n) {
    this.hasBeenReset = !1;
    var i = "",
      r = !1,
      a = e,
      s = t,
      o = n,
      l = null,
      u = "",
      c = !0,
      d = "auto",
      h = "start",
      p = "auto",
      m = "auto",
      f = 100,
      g = "center";
    Object.defineProperties(this, {
      id: {
        enumerable: !0,
        get: function () {
          return i;
        },
        set: function (e) {
          i = "" + e;
        },
      },
      pauseOnExit: {
        enumerable: !0,
        get: function () {
          return r;
        },
        set: function (e) {
          r = !!e;
        },
      },
      startTime: {
        enumerable: !0,
        get: function () {
          return a;
        },
        set: function (e) {
          if ("number" != typeof e)
            throw new TypeError("Start time must be set to a number.");
          (a = e), (this.hasBeenReset = !0);
        },
      },
      endTime: {
        enumerable: !0,
        get: function () {
          return s;
        },
        set: function (e) {
          if ("number" != typeof e)
            throw new TypeError("End time must be set to a number.");
          (s = e), (this.hasBeenReset = !0);
        },
      },
      text: {
        enumerable: !0,
        get: function () {
          return o;
        },
        set: function (e) {
          (o = "" + e), (this.hasBeenReset = !0);
        },
      },
      region: {
        enumerable: !0,
        get: function () {
          return l;
        },
        set: function (e) {
          (l = e), (this.hasBeenReset = !0);
        },
      },
      vertical: {
        enumerable: !0,
        get: function () {
          return u;
        },
        set: function (e) {
          e =
            "string" == typeof (e = e) &&
            !!Wn[e.toLowerCase()] &&
            e.toLowerCase();
          if (!1 === e)
            throw new SyntaxError(
              "Vertical: an invalid or illegal direction string was specified."
            );
          (u = e), (this.hasBeenReset = !0);
        },
      },
      snapToLines: {
        enumerable: !0,
        get: function () {
          return c;
        },
        set: function (e) {
          (c = !!e), (this.hasBeenReset = !0);
        },
      },
      line: {
        enumerable: !0,
        get: function () {
          return d;
        },
        set: function (e) {
          if ("number" != typeof e && "auto" !== e)
            throw new SyntaxError(
              "Line: an invalid number or illegal string was specified."
            );
          (d = e), (this.hasBeenReset = !0);
        },
      },
      lineAlign: {
        enumerable: !0,
        get: function () {
          return h;
        },
        set: function (e) {
          e = Yn(e);
          e && ((h = e), (this.hasBeenReset = !0));
        },
      },
      position: {
        enumerable: !0,
        get: function () {
          return p;
        },
        set: function (e) {
          if (e < 0 || 100 < e)
            throw new Error("Position must be between 0 and 100.");
          (p = e), (this.hasBeenReset = !0);
        },
      },
      positionAlign: {
        enumerable: !0,
        get: function () {
          return m;
        },
        set: function (e) {
          e = Yn(e);
          e && ((m = e), (this.hasBeenReset = !0));
        },
      },
      size: {
        enumerable: !0,
        get: function () {
          return f;
        },
        set: function (e) {
          if (e < 0 || 100 < e)
            throw new Error("Size must be between 0 and 100.");
          (f = e), (this.hasBeenReset = !0);
        },
      },
      align: {
        enumerable: !0,
        get: function () {
          return g;
        },
        set: function (e) {
          e = Yn(e);
          if (!e)
            throw new SyntaxError(
              "align: an invalid or illegal alignment string was specified."
            );
          (g = e), (this.hasBeenReset = !0);
        },
      },
    }),
      (this.displayState = void 0);
  }
  Kn.prototype.getCueAsHTML = function () {
    return WebVTT.convertCueToDOMTree(window, this.text);
  };
  var Qn = Kn,
    Zn = { "": !0, up: !0 };
  function Jn(e) {
    return "number" == typeof e && 0 <= e && e <= 100;
  }
  function $n() {
    var t = 100,
      n = 3,
      i = 0,
      r = 100,
      a = 0,
      s = 100,
      o = "";
    Object.defineProperties(this, {
      width: {
        enumerable: !0,
        get: function () {
          return t;
        },
        set: function (e) {
          if (!Jn(e)) throw new Error("Width must be between 0 and 100.");
          t = e;
        },
      },
      lines: {
        enumerable: !0,
        get: function () {
          return n;
        },
        set: function (e) {
          if ("number" != typeof e)
            throw new TypeError("Lines must be set to a number.");
          n = e;
        },
      },
      regionAnchorY: {
        enumerable: !0,
        get: function () {
          return r;
        },
        set: function (e) {
          if (!Jn(e))
            throw new Error("RegionAnchorX must be between 0 and 100.");
          r = e;
        },
      },
      regionAnchorX: {
        enumerable: !0,
        get: function () {
          return i;
        },
        set: function (e) {
          if (!Jn(e))
            throw new Error("RegionAnchorY must be between 0 and 100.");
          i = e;
        },
      },
      viewportAnchorY: {
        enumerable: !0,
        get: function () {
          return s;
        },
        set: function (e) {
          if (!Jn(e))
            throw new Error("ViewportAnchorY must be between 0 and 100.");
          s = e;
        },
      },
      viewportAnchorX: {
        enumerable: !0,
        get: function () {
          return a;
        },
        set: function (e) {
          if (!Jn(e))
            throw new Error("ViewportAnchorX must be between 0 and 100.");
          a = e;
        },
      },
      scroll: {
        enumerable: !0,
        get: function () {
          return o;
        },
        set: function (e) {
          e =
            "string" == typeof (e = e) &&
            !!Zn[e.toLowerCase()] &&
            e.toLowerCase();
          !1 === e || (o = e);
        },
      },
    });
  }
  var ei = K(function (e) {
    e = e.exports = { WebVTT: Hn, VTTCue: Qn, VTTRegion: $n };
    (dn.vttjs = e), (dn.WebVTT = e.WebVTT);
    var t = e.VTTCue,
      n = e.VTTRegion,
      i = dn.VTTCue,
      r = dn.VTTRegion;
    (e.shim = function () {
      (dn.VTTCue = t), (dn.VTTRegion = n);
    }),
      (e.restore = function () {
        (dn.VTTCue = i), (dn.VTTRegion = r);
      }),
      dn.VTTCue || e.shim();
  });
  ei.WebVTT, ei.VTTCue, ei.VTTRegion;
  var O = (function (i) {
    function n(t, e) {
      var n;
      return (
        void 0 === e && (e = function () {}),
        ((t = void 0 === t ? {} : t).reportTouchActivity = !1),
        ((n = i.call(this, null, t, e) || this).onDurationChange_ = function (
          e
        ) {
          return n.onDurationChange(e);
        }),
        (n.trackProgress_ = function (e) {
          return n.trackProgress(e);
        }),
        (n.trackCurrentTime_ = function (e) {
          return n.trackCurrentTime(e);
        }),
        (n.stopTrackingCurrentTime_ = function (e) {
          return n.stopTrackingCurrentTime(e);
        }),
        (n.disposeSourceHandler_ = function (e) {
          return n.disposeSourceHandler(e);
        }),
        (n.queuedHanders_ = new Set()),
        (n.hasStarted_ = !1),
        n.on("playing", function () {
          this.hasStarted_ = !0;
        }),
        n.on("loadstart", function () {
          this.hasStarted_ = !1;
        }),
        An.names.forEach(function (e) {
          e = An[e];
          t && t[e.getterName] && (n[e.privateName] = t[e.getterName]);
        }),
        n.featuresProgressEvents || n.manualProgressOn(),
        n.featuresTimeupdateEvents || n.manualTimeUpdatesOn(),
        ["Text", "Audio", "Video"].forEach(function (e) {
          !1 === t["native" + e + "Tracks"] &&
            (n["featuresNative" + e + "Tracks"] = !1);
        }),
        !1 === t.nativeCaptions || !1 === t.nativeTextTracks
          ? (n.featuresNativeTextTracks = !1)
          : (!0 !== t.nativeCaptions && !0 !== t.nativeTextTracks) ||
            (n.featuresNativeTextTracks = !0),
        n.featuresNativeTextTracks || n.emulateTextTracks(),
        (n.preloadTextTracks = !1 !== t.preloadTextTracks),
        (n.autoRemoteTextTracks_ = new An.text.ListClass()),
        n.initTrackListeners(),
        t.nativeControlsForTouch || n.emitTapEvents(),
        n.constructor && (n.name_ = n.constructor.name || "Unknown Tech"),
        n
      );
    }
    b(n, i);
    var e = n.prototype;
    return (
      (e.triggerSourceset = function (e) {
        var t = this;
        this.isReady_ ||
          this.one("ready", function () {
            return t.setTimeout(function () {
              return t.triggerSourceset(e);
            }, 1);
          }),
          this.trigger({ src: e, type: "sourceset" });
      }),
      (e.manualProgressOn = function () {
        this.on("durationchange", this.onDurationChange_),
          (this.manualProgress = !0),
          this.one("ready", this.trackProgress_);
      }),
      (e.manualProgressOff = function () {
        (this.manualProgress = !1),
          this.stopTrackingProgress(),
          this.off("durationchange", this.onDurationChange_);
      }),
      (e.trackProgress = function (e) {
        this.stopTrackingProgress(),
          (this.progressInterval = this.setInterval(
            u(this, function () {
              var e = this.bufferedPercent();
              this.bufferedPercent_ !== e && this.trigger("progress"),
                1 === (this.bufferedPercent_ = e) &&
                  this.stopTrackingProgress();
            }),
            500
          ));
      }),
      (e.onDurationChange = function (e) {
        this.duration_ = this.duration();
      }),
      (e.buffered = function () {
        return Dt(0, 0);
      }),
      (e.bufferedPercent = function () {
        return Rt(this.buffered(), this.duration_);
      }),
      (e.stopTrackingProgress = function () {
        this.clearInterval(this.progressInterval);
      }),
      (e.manualTimeUpdatesOn = function () {
        (this.manualTimeUpdates = !0),
          this.on("play", this.trackCurrentTime_),
          this.on("pause", this.stopTrackingCurrentTime_);
      }),
      (e.manualTimeUpdatesOff = function () {
        (this.manualTimeUpdates = !1),
          this.stopTrackingCurrentTime(),
          this.off("play", this.trackCurrentTime_),
          this.off("pause", this.stopTrackingCurrentTime_);
      }),
      (e.trackCurrentTime = function () {
        this.currentTimeInterval && this.stopTrackingCurrentTime(),
          (this.currentTimeInterval = this.setInterval(function () {
            this.trigger({
              type: "timeupdate",
              target: this,
              manuallyTriggered: !0,
            });
          }, 250));
      }),
      (e.stopTrackingCurrentTime = function () {
        this.clearInterval(this.currentTimeInterval),
          this.trigger({
            type: "timeupdate",
            target: this,
            manuallyTriggered: !0,
          });
      }),
      (e.dispose = function () {
        this.clearTracks(On.names),
          this.manualProgress && this.manualProgressOff(),
          this.manualTimeUpdates && this.manualTimeUpdatesOff(),
          i.prototype.dispose.call(this);
      }),
      (e.clearTracks = function (e) {
        var r = this;
        (e = [].concat(e)).forEach(function (e) {
          for (var t = r[e + "Tracks"]() || [], n = t.length; n--; ) {
            var i = t[n];
            "text" === e && r.removeRemoteTextTrack(i), t.removeTrack(i);
          }
        });
      }),
      (e.cleanupAutoTextTracks = function () {
        for (var e = this.autoRemoteTextTracks_ || [], t = e.length; t--; ) {
          var n = e[t];
          this.removeRemoteTextTrack(n);
        }
      }),
      (e.reset = function () {}),
      (e.crossOrigin = function () {}),
      (e.setCrossOrigin = function () {}),
      (e.error = function (e) {
        return (
          void 0 !== e && ((this.error_ = new Bt(e)), this.trigger("error")),
          this.error_
        );
      }),
      (e.played = function () {
        return this.hasStarted_ ? Dt(0, 0) : Dt();
      }),
      (e.play = function () {}),
      (e.setScrubbing = function () {}),
      (e.scrubbing = function () {}),
      (e.setCurrentTime = function () {
        this.manualTimeUpdates &&
          this.trigger({
            type: "timeupdate",
            target: this,
            manuallyTriggered: !0,
          });
      }),
      (e.initTrackListeners = function () {
        var r = this;
        On.names.forEach(function (e) {
          function t() {
            r.trigger(e + "trackchange");
          }
          var n = On[e],
            i = r[n.getterName]();
          i.addEventListener("removetrack", t),
            i.addEventListener("addtrack", t),
            r.on("dispose", function () {
              i.removeEventListener("removetrack", t),
                i.removeEventListener("addtrack", t);
            });
        });
      }),
      (e.addWebVttScript_ = function () {
        var e,
          t = this;
        window.WebVTT ||
          (document.body.contains(this.el())
            ? !this.options_["vtt.js"] && te(ei) && 0 < Object.keys(ei).length
              ? this.trigger("vttjsloaded")
              : (((e = document.createElement("script")).src =
                  this.options_["vtt.js"] ||
                  "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js"),
                (e.onload = function () {
                  t.trigger("vttjsloaded");
                }),
                (e.onerror = function () {
                  t.trigger("vttjserror");
                }),
                this.on("dispose", function () {
                  (e.onload = null), (e.onerror = null);
                }),
                (window.WebVTT = !0),
                this.el().parentNode.appendChild(e))
            : this.ready(this.addWebVttScript_));
      }),
      (e.emulateTextTracks = function () {
        function t(e) {
          return i.addTrack(e.track);
        }
        function n(e) {
          return i.removeTrack(e.track);
        }
        var e = this,
          i = this.textTracks(),
          r = this.remoteTextTracks();
        r.on("addtrack", t), r.on("removetrack", n), this.addWebVttScript_();
        function a() {
          return e.trigger("texttrackchange");
        }
        function s() {
          a();
          for (var e = 0; e < i.length; e++) {
            var t = i[e];
            t.removeEventListener("cuechange", a),
              "showing" === t.mode && t.addEventListener("cuechange", a);
          }
        }
        s(),
          i.addEventListener("change", s),
          i.addEventListener("addtrack", s),
          i.addEventListener("removetrack", s),
          this.on("dispose", function () {
            r.off("addtrack", t),
              r.off("removetrack", n),
              i.removeEventListener("change", s),
              i.removeEventListener("addtrack", s),
              i.removeEventListener("removetrack", s);
            for (var e = 0; e < i.length; e++)
              i[e].removeEventListener("cuechange", a);
          });
      }),
      (e.addTextTrack = function (e, t, n) {
        if (!e)
          throw new Error("TextTrack kind is required but was not provided");
        return (function (e, t, n, i, r) {
          void 0 === r && (r = {});
          var a = e.textTracks();
          return (
            (r.kind = t),
            n && (r.label = n),
            i && (r.language = i),
            (r.tech = e),
            (r = new An.text.TrackClass(r)),
            a.addTrack(r),
            r
          );
        })(this, e, t, n);
      }),
      (e.createRemoteTextTrack = function (e) {
        e = m(e, { tech: this });
        return new Sn.remoteTextEl.TrackClass(e);
      }),
      (e.addRemoteTextTrack = function (e, t) {
        var n = this,
          i = this.createRemoteTextTrack((e = void 0 === e ? {} : e));
        return (
          !0 !== t &&
            !1 !== t &&
            (d.warn(
              'Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js'
            ),
            (t = !0)),
          this.remoteTextTrackEls().addTrackElement_(i),
          this.remoteTextTracks().addTrack(i.track),
          !0 !== t &&
            this.ready(function () {
              return n.autoRemoteTextTracks_.addTrack(i.track);
            }),
          i
        );
      }),
      (e.removeRemoteTextTrack = function (e) {
        var t = this.remoteTextTrackEls().getTrackElementByTrack_(e);
        this.remoteTextTrackEls().removeTrackElement_(t),
          this.remoteTextTracks().removeTrack(e),
          this.autoRemoteTextTracks_.removeTrack(e);
      }),
      (e.getVideoPlaybackQuality = function () {
        return {};
      }),
      (e.requestPictureInPicture = function () {
        var e = this.options_.Promise || window.Promise;
        if (e) return e.reject();
      }),
      (e.disablePictureInPicture = function () {
        return !0;
      }),
      (e.setDisablePictureInPicture = function () {}),
      (e.requestVideoFrameCallback = function (e) {
        var t = this,
          n = nt++;
        return (
          !this.isReady_ || this.paused()
            ? (this.queuedHanders_.add(n),
              this.one("playing", function () {
                t.queuedHanders_.has(n) && (t.queuedHanders_.delete(n), e());
              }))
            : this.requestNamedAnimationFrame(n, e),
          n
        );
      }),
      (e.cancelVideoFrameCallback = function (e) {
        this.queuedHanders_.has(e)
          ? this.queuedHanders_.delete(e)
          : this.cancelNamedAnimationFrame(e);
      }),
      (e.setPoster = function () {}),
      (e.playsinline = function () {}),
      (e.setPlaysinline = function () {}),
      (e.overrideNativeAudioTracks = function () {}),
      (e.overrideNativeVideoTracks = function () {}),
      (e.canPlayType = function () {
        return "";
      }),
      (n.canPlayType = function () {
        return "";
      }),
      (n.canPlaySource = function (e, t) {
        return n.canPlayType(e.type);
      }),
      (n.isTech = function (e) {
        return e.prototype instanceof n || e instanceof n || e === n;
      }),
      (n.registerTech = function (e, t) {
        if ((n.techs_ || (n.techs_ = {}), !n.isTech(t)))
          throw new Error("Tech " + e + " must be a Tech");
        if (!n.canPlayType)
          throw new Error(
            "Techs must have a static canPlayType method on them"
          );
        if (!n.canPlaySource)
          throw new Error(
            "Techs must have a static canPlaySource method on them"
          );
        return (
          (e = p(e)),
          (n.techs_[e] = t),
          (n.techs_[Pt(e)] = t),
          "Tech" !== e && n.defaultTechOrder_.push(e),
          t
        );
      }),
      (n.getTech = function (e) {
        if (e)
          return n.techs_ && n.techs_[e]
            ? n.techs_[e]
            : ((e = p(e)),
              window && window.videojs && window.videojs[e]
                ? (d.warn(
                    "The " +
                      e +
                      " tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)"
                  ),
                  window.videojs[e])
                : void 0);
      }),
      n
    );
  })(g);
  An.names.forEach(function (e) {
    var t = An[e];
    O.prototype[t.getterName] = function () {
      return (
        (this[t.privateName] = this[t.privateName] || new t.ListClass()),
        this[t.privateName]
      );
    };
  }),
    (O.prototype.featuresVolumeControl = !0),
    (O.prototype.featuresMuteControl = !0),
    (O.prototype.featuresFullscreenResize = !1),
    (O.prototype.featuresPlaybackRate = !1),
    (O.prototype.featuresProgressEvents = !1),
    (O.prototype.featuresSourceset = !1),
    (O.prototype.featuresTimeupdateEvents = !1),
    (O.prototype.featuresNativeTextTracks = !1),
    (O.prototype.featuresVideoFrameCallback = !1),
    (O.withSourceHandlers = function (r) {
      (r.registerSourceHandler = function (e, t) {
        var n = (n = r.sourceHandlers) || (r.sourceHandlers = []);
        void 0 === t && (t = n.length), n.splice(t, 0, e);
      }),
        (r.canPlayType = function (e) {
          for (var t, n = r.sourceHandlers || [], i = 0; i < n.length; i++)
            if ((t = n[i].canPlayType(e))) return t;
          return "";
        }),
        (r.selectSourceHandler = function (e, t) {
          for (var n = r.sourceHandlers || [], i = 0; i < n.length; i++)
            if (n[i].canHandleSource(e, t)) return n[i];
          return null;
        }),
        (r.canPlaySource = function (e, t) {
          var n = r.selectSourceHandler(e, t);
          return n ? n.canHandleSource(e, t) : "";
        });
      ["seekable", "seeking", "duration"].forEach(function (e) {
        var t = this[e];
        "function" == typeof t &&
          (this[e] = function () {
            return this.sourceHandler_ && this.sourceHandler_[e]
              ? this.sourceHandler_[e].apply(this.sourceHandler_, arguments)
              : t.apply(this, arguments);
          });
      }, r.prototype),
        (r.prototype.setSource = function (e) {
          var t = r.selectSourceHandler(e, this.options_);
          t ||
            (r.nativeSourceHandler
              ? (t = r.nativeSourceHandler)
              : d.error("No source handler found for the current source.")),
            this.disposeSourceHandler(),
            this.off("dispose", this.disposeSourceHandler_),
            t !== r.nativeSourceHandler && (this.currentSource_ = e),
            (this.sourceHandler_ = t.handleSource(e, this, this.options_)),
            this.one("dispose", this.disposeSourceHandler_);
        }),
        (r.prototype.disposeSourceHandler = function () {
          this.currentSource_ &&
            (this.clearTracks(["audio", "video"]),
            (this.currentSource_ = null)),
            this.cleanupAutoTextTracks(),
            this.sourceHandler_ &&
              (this.sourceHandler_.dispose && this.sourceHandler_.dispose(),
              (this.sourceHandler_ = null));
        });
    }),
    g.registerComponent("Tech", O),
    O.registerTech("Tech", O),
    (O.defaultTechOrder_ = []);
  var ti = {},
    ni = {},
    ii = {};
  function ri(e, t, n) {
    e.setTimeout(function () {
      return (function n(i, e, r, a, s, o) {
        void 0 === i && (i = {});
        void 0 === e && (e = []);
        void 0 === s && (s = []);
        void 0 === o && (o = !1);
        var t = e,
          e = t[0],
          l = t.slice(1);
        if ("string" == typeof e) n(i, ti[e], r, a, s, o);
        else if (e) {
          var u = ci(a, e);
          if (!u.setSource) return s.push(u), n(i, l, r, a, s, o);
          u.setSource(h({}, i), function (e, t) {
            return e
              ? n(i, l, r, a, s, o)
              : (s.push(u),
                void n(t, i.type === t.type ? l : ti[t.type], r, a, s, o));
          });
        } else
          l.length
            ? n(i, l, r, a, s, o)
            : o
            ? r(i, s)
            : n(i, ti["*"], r, a, s, !0);
      })(t, ti[t.type], n, e);
    }, 1);
  }
  function ai(e, t, n, i) {
    void 0 === i && (i = null);
    var r = "call" + p(n),
      r = e.reduce(ui(r), i),
      i = r === ii,
      r = i ? null : t[n](r);
    return (
      (function (e, t, n, i) {
        for (var r = e.length - 1; 0 <= r; r--) {
          var a = e[r];
          a[t] && a[t](i, n);
        }
      })(e, n, r, i),
      r
    );
  }
  var si = {
      buffered: 1,
      currentTime: 1,
      duration: 1,
      muted: 1,
      played: 1,
      paused: 1,
      seekable: 1,
      volume: 1,
      ended: 1,
    },
    oi = { setCurrentTime: 1, setMuted: 1, setVolume: 1 },
    li = { play: 1, pause: 1 };
  function ui(n) {
    return function (e, t) {
      return e === ii ? ii : t[n] ? t[n](e) : e;
    };
  }
  function ci(e, t) {
    var n = ni[e.id()],
      i = null;
    if (null == n) return (i = t(e)), (ni[e.id()] = [[t, i]]), i;
    for (var r = 0; r < n.length; r++) {
      var a = n[r],
        s = a[0],
        a = a[1];
      s === t && (i = a);
    }
    return null === i && ((i = t(e)), n.push([t, i])), i;
  }
  function di(e) {
    return (e = en((e = void 0 === e ? "" : e))), pi[e.toLowerCase()] || "";
  }
  function hi(e) {
    var t;
    return (e = Array.isArray(e)
      ? ((t = []),
        e.forEach(function (e) {
          (e = hi(e)),
            Array.isArray(e) ? (t = t.concat(e)) : ee(e) && t.push(e);
        }),
        t)
      : "string" == typeof e && e.trim()
      ? [mi({ src: e })]
      : ee(e) && "string" == typeof e.src && e.src && e.src.trim()
      ? [mi(e)]
      : []);
  }
  var pi = {
    opus: "video/ogg",
    ogv: "video/ogg",
    mp4: "video/mp4",
    mov: "video/mp4",
    m4v: "video/mp4",
    mkv: "video/x-matroska",
    m4a: "audio/mp4",
    mp3: "audio/mpeg",
    aac: "audio/aac",
    caf: "audio/x-caf",
    flac: "audio/flac",
    oga: "audio/ogg",
    wav: "audio/wav",
    m3u8: "application/x-mpegURL",
    mpd: "application/dash+xml",
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    gif: "image/gif",
    png: "image/png",
    svg: "image/svg+xml",
    webp: "image/webp",
  };
  function mi(e) {
    var t;
    return e.type || ((t = di(e.src)) && (e.type = t)), e;
  }
  n = (function (l) {
    function e(e, t, n) {
      var i = m({ createEl: !1 }, t),
        n = l.call(this, e, i, n) || this;
      if (t.playerOptions.sources && 0 !== t.playerOptions.sources.length)
        e.src(t.playerOptions.sources);
      else
        for (var r = 0, a = t.playerOptions.techOrder; r < a.length; r++) {
          var s = p(a[r]),
            o = O.getTech(s);
          if ((o = !s ? g.getComponent(s) : o) && o.isSupported()) {
            e.loadTech_(s);
            break;
          }
        }
      return n;
    }
    return b(e, l), e;
  })(g);
  g.registerComponent("MediaLoader", n);
  ie = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this;
      return (
        n.options_.controlText && n.controlText(n.options_.controlText),
        (n.handleMouseOver_ = function (e) {
          return n.handleMouseOver(e);
        }),
        (n.handleMouseOut_ = function (e) {
          return n.handleMouseOut(e);
        }),
        (n.handleClick_ = function (e) {
          return n.handleClick(e);
        }),
        (n.handleKeyDown_ = function (e) {
          return n.handleKeyDown(e);
        }),
        n.emitTapEvents(),
        n.enable(),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.createEl = function (e, t, n) {
        void 0 === e && (e = "div"),
          void 0 === t && (t = {}),
          void 0 === n && (n = {}),
          (t = h({ className: this.buildCSSClass(), tabIndex: 0 }, t)),
          "button" === e &&
            d.error(
              "Creating a ClickableComponent with an HTML element of " +
                e +
                " is not supported; use a Button instead."
            ),
          (n = h({ role: "button" }, n)),
          (this.tabIndex_ = t.tabIndex);
        n = c(e, t, n);
        return (
          n.appendChild(
            c(
              "span",
              { className: "vjs-icon-placeholder" },
              { "aria-hidden": !0 }
            )
          ),
          this.createControlTextEl(n),
          n
        );
      }),
      (t.dispose = function () {
        (this.controlTextEl_ = null), i.prototype.dispose.call(this);
      }),
      (t.createControlTextEl = function (e) {
        return (
          (this.controlTextEl_ = c(
            "span",
            { className: "vjs-control-text" },
            { "aria-live": "polite" }
          )),
          e && e.appendChild(this.controlTextEl_),
          this.controlText(this.controlText_, e),
          this.controlTextEl_
        );
      }),
      (t.controlText = function (e, t) {
        if ((void 0 === t && (t = this.el()), void 0 === e))
          return this.controlText_ || "Need Text";
        var n = this.localize(e);
        (this.controlText_ = e),
          Ae(this.controlTextEl_, n),
          this.nonIconControl ||
            this.player_.options_.noUITitleAttributes ||
            t.setAttribute("title", n);
      }),
      (t.buildCSSClass = function () {
        return "vjs-control vjs-button " + i.prototype.buildCSSClass.call(this);
      }),
      (t.enable = function () {
        this.enabled_ ||
          ((this.enabled_ = !0),
          this.removeClass("vjs-disabled"),
          this.el_.setAttribute("aria-disabled", "false"),
          "undefined" != typeof this.tabIndex_ &&
            this.el_.setAttribute("tabIndex", this.tabIndex_),
          this.on(["tap", "click"], this.handleClick_),
          this.on("keydown", this.handleKeyDown_));
      }),
      (t.disable = function () {
        (this.enabled_ = !1),
          this.addClass("vjs-disabled"),
          this.el_.setAttribute("aria-disabled", "true"),
          "undefined" != typeof this.tabIndex_ &&
            this.el_.removeAttribute("tabIndex"),
          this.off("mouseover", this.handleMouseOver_),
          this.off("mouseout", this.handleMouseOut_),
          this.off(["tap", "click"], this.handleClick_),
          this.off("keydown", this.handleKeyDown_);
      }),
      (t.handleLanguagechange = function () {
        this.controlText(this.controlText_);
      }),
      (t.handleClick = function (e) {
        this.options_.clickHandler &&
          this.options_.clickHandler.call(this, arguments);
      }),
      (t.handleKeyDown = function (e) {
        f.isEventKey(e, "Space") || f.isEventKey(e, "Enter")
          ? (e.preventDefault(), e.stopPropagation(), this.trigger("click"))
          : i.prototype.handleKeyDown.call(this, e);
      }),
      e
    );
  })(g);
  g.registerComponent("ClickableComponent", ie),
    g.registerComponent(
      "PosterImage",
      (function (i) {
        function e(e, t) {
          var n = i.call(this, e, t) || this;
          return (
            n.update(),
            (n.update_ = function (e) {
              return n.update(e);
            }),
            e.on("posterchange", n.update_),
            n
          );
        }
        b(e, i);
        var t = e.prototype;
        return (
          (t.dispose = function () {
            this.player().off("posterchange", this.update_),
              i.prototype.dispose.call(this);
          }),
          (t.createEl = function () {
            return c("div", { className: "vjs-poster", tabIndex: -1 });
          }),
          (t.update = function (e) {
            var t = this.player().poster();
            this.setSrc(t), t ? this.show() : this.hide();
          }),
          (t.setSrc = function (e) {
            this.el_.style.backgroundImage = e ? 'url("' + e + '")' : "";
          }),
          (t.handleClick = function (e) {
            var t;
            this.player_.controls() &&
              ((t =
                this.player_.usingPlugin("eme") &&
                this.player_.eme.sessions &&
                0 < this.player_.eme.sessions.length),
              !this.player_.tech(!0) ||
                ((de || le) && t) ||
                this.player_.tech(!0).focus(),
              this.player_.paused()
                ? Gt(this.player_.play())
                : this.player_.pause());
          }),
          e
        );
      })(ie)
    );
  var fi = "#222",
    gi = {
      monospace: "monospace",
      sansSerif: "sans-serif",
      serif: "serif",
      monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
      monospaceSerif: '"Courier New", monospace',
      proportionalSansSerif: "sans-serif",
      proportionalSerif: "serif",
      casual: '"Comic Sans MS", Impact, fantasy',
      script: '"Monotype Corsiva", cursive',
      smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif',
    };
  function bi(e, t) {
    var n;
    if (4 === e.length) n = e[1] + e[1] + e[2] + e[2] + e[3] + e[3];
    else {
      if (7 !== e.length)
        throw new Error(
          "Invalid color code provided, " +
            e +
            "; must be formatted as e.g. #f0e or #f604e2."
        );
      n = e.slice(1);
    }
    return (
      "rgba(" +
      parseInt(n.slice(0, 2), 16) +
      "," +
      parseInt(n.slice(2, 4), 16) +
      "," +
      parseInt(n.slice(4, 6), 16) +
      "," +
      t +
      ")"
    );
  }
  function vi(e, t, n) {
    try {
      e.style[t] = n;
    } catch (e) {
      return;
    }
  }
  g.registerComponent(
    "TextTrackDisplay",
    (function (a) {
      function e(n, e, t) {
        function i(e) {
          return r.updateDisplay(e);
        }
        var r = a.call(this, n, e, t) || this;
        return (
          n.on("loadstart", function (e) {
            return r.toggleDisplay(e);
          }),
          n.on("texttrackchange", i),
          n.on("loadedmetadata", function (e) {
            return r.preselectTrack(e);
          }),
          n.ready(
            u(y(r), function () {
              if (n.tech_ && n.tech_.featuresNativeTextTracks) this.hide();
              else {
                n.on("fullscreenchange", i),
                  n.on("playerresize", i),
                  window.addEventListener("orientationchange", i),
                  n.on("dispose", function () {
                    return window.removeEventListener("orientationchange", i);
                  });
                for (
                  var e = this.options_.playerOptions.tracks || [], t = 0;
                  t < e.length;
                  t++
                )
                  this.player_.addRemoteTextTrack(e[t], !0);
                this.preselectTrack();
              }
            })
          ),
          r
        );
      }
      b(e, a);
      var t = e.prototype;
      return (
        (t.preselectTrack = function () {
          for (
            var e,
              t,
              n,
              i = { captions: 1, subtitles: 1 },
              r = this.player_.textTracks(),
              a = this.player_.cache_.selectedLanguage,
              s = 0;
            s < r.length;
            s++
          ) {
            var o = r[s];
            a &&
            a.enabled &&
            a.language &&
            a.language === o.language &&
            o.kind in i
              ? (n = (o.kind !== a.kind && n) || o)
              : a && !a.enabled
              ? (t = e = n = null)
              : o.default &&
                ("descriptions" !== o.kind || e
                  ? o.kind in i && !t && (t = o)
                  : (e = o));
          }
          n
            ? (n.mode = "showing")
            : t
            ? (t.mode = "showing")
            : e && (e.mode = "showing");
        }),
        (t.toggleDisplay = function () {
          this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks
            ? this.hide()
            : this.show();
        }),
        (t.createEl = function () {
          return a.prototype.createEl.call(
            this,
            "div",
            { className: "vjs-text-track-display" },
            { translate: "yes", "aria-live": "off", "aria-atomic": "true" }
          );
        }),
        (t.clearDisplay = function () {
          "function" == typeof window.WebVTT &&
            window.WebVTT.processCues(window, [], this.el_);
        }),
        (t.updateDisplay = function () {
          var e = this.player_.textTracks(),
            t = this.options_.allowMultipleShowingTracks;
          if ((this.clearDisplay(), t)) {
            for (var n = [], i = 0; i < e.length; ++i) {
              var r = e[i];
              "showing" === r.mode && n.push(r);
            }
            this.updateForTrack(n);
          } else {
            for (var a = null, s = null, o = e.length; o--; ) {
              var l = e[o];
              "showing" === l.mode &&
                ("descriptions" === l.kind ? (a = l) : (s = l));
            }
            s
              ? ("off" !== this.getAttribute("aria-live") &&
                  this.setAttribute("aria-live", "off"),
                this.updateForTrack(s))
              : a &&
                ("assertive" !== this.getAttribute("aria-live") &&
                  this.setAttribute("aria-live", "assertive"),
                this.updateForTrack(a));
          }
        }),
        (t.updateDisplayState = function (e) {
          for (
            var t = this.player_.textTrackSettings.getValues(),
              n = e.activeCues,
              i = n.length;
            i--;

          ) {
            var r,
              a = n[i];
            a &&
              ((r = a.displayState),
              t.color && (r.firstChild.style.color = t.color),
              t.textOpacity &&
                vi(r.firstChild, "color", bi(t.color || "#fff", t.textOpacity)),
              t.backgroundColor &&
                (r.firstChild.style.backgroundColor = t.backgroundColor),
              t.backgroundOpacity &&
                vi(
                  r.firstChild,
                  "backgroundColor",
                  bi(t.backgroundColor || "#000", t.backgroundOpacity)
                ),
              t.windowColor &&
                (t.windowOpacity
                  ? vi(r, "backgroundColor", bi(t.windowColor, t.windowOpacity))
                  : (r.style.backgroundColor = t.windowColor)),
              t.edgeStyle &&
                ("dropshadow" === t.edgeStyle
                  ? (r.firstChild.style.textShadow =
                      "2px 2px 3px #222, 2px 2px 4px #222, 2px 2px 5px " + fi)
                  : "raised" === t.edgeStyle
                  ? (r.firstChild.style.textShadow =
                      "1px 1px #222, 2px 2px #222, 3px 3px " + fi)
                  : "depressed" === t.edgeStyle
                  ? (r.firstChild.style.textShadow =
                      "1px 1px #ccc, 0 1px #ccc, -1px -1px #222, 0 -1px " + fi)
                  : "uniform" === t.edgeStyle &&
                    (r.firstChild.style.textShadow =
                      "0 0 4px #222, 0 0 4px #222, 0 0 4px #222, 0 0 4px " +
                      fi)),
              t.fontPercent &&
                1 !== t.fontPercent &&
                ((a = window.parseFloat(r.style.fontSize)),
                (r.style.fontSize = a * t.fontPercent + "px"),
                (r.style.height = "auto"),
                (r.style.top = "auto")),
              t.fontFamily &&
                "default" !== t.fontFamily &&
                ("small-caps" === t.fontFamily
                  ? (r.firstChild.style.fontVariant = "small-caps")
                  : (r.firstChild.style.fontFamily = gi[t.fontFamily])));
          }
        }),
        (t.updateForTrack = function (e) {
          if (
            (Array.isArray(e) || (e = [e]),
            "function" == typeof window.WebVTT &&
              !e.every(function (e) {
                return !e.activeCues;
              }))
          ) {
            for (var t = [], n = 0; n < e.length; ++n)
              for (var i = e[n], r = 0; r < i.activeCues.length; ++r)
                t.push(i.activeCues[r]);
            window.WebVTT.processCues(window, t, this.el_);
            for (var a = 0; a < e.length; ++a) {
              for (var s = e[a], o = 0; o < s.activeCues.length; ++o) {
                var l = s.activeCues[o].displayState;
                Ie(l, "vjs-text-track-cue"),
                  Ie(l, "vjs-text-track-cue-" + (s.language || a)),
                  s.language && Ne(l, "lang", s.language);
              }
              this.player_.textTrackSettings && this.updateDisplayState(s);
            }
          }
        }),
        e
      );
    })(g)
  ),
    g.registerComponent(
      "LoadingSpinner",
      (function (n) {
        function e() {
          return n.apply(this, arguments) || this;
        }
        return (
          b(e, n),
          (e.prototype.createEl = function () {
            var e = this.player_.isAudio(),
              t = this.localize(e ? "Audio Player" : "Video Player"),
              e = c("span", {
                className: "vjs-control-text",
                textContent: this.localize("{1} is loading.", [t]),
              }),
              t = n.prototype.createEl.call(this, "div", {
                className: "vjs-loading-spinner",
                dir: "ltr",
              });
            return t.appendChild(e), t;
          }),
          e
        );
      })(g)
    );
  var yi = (function (t) {
    function e() {
      return t.apply(this, arguments) || this;
    }
    b(e, t);
    var n = e.prototype;
    return (
      (n.createEl = function (e, t, n) {
        void 0 === t && (t = {}), void 0 === n && (n = {});
        n = c(
          "button",
          (t = h({ className: this.buildCSSClass() }, t)),
          (n = h({ type: "button" }, n))
        );
        return (
          n.appendChild(
            c(
              "span",
              { className: "vjs-icon-placeholder" },
              { "aria-hidden": !0 }
            )
          ),
          this.createControlTextEl(n),
          n
        );
      }),
      (n.addChild = function (e, t) {
        void 0 === t && (t = {});
        var n = this.constructor.name;
        return (
          d.warn(
            "Adding an actionable (user controllable) child to a Button (" +
              n +
              ") is not supported; use a ClickableComponent instead."
          ),
          g.prototype.addChild.call(this, e, t)
        );
      }),
      (n.enable = function () {
        t.prototype.enable.call(this), this.el_.removeAttribute("disabled");
      }),
      (n.disable = function () {
        t.prototype.disable.call(this),
          this.el_.setAttribute("disabled", "disabled");
      }),
      (n.handleKeyDown = function (e) {
        f.isEventKey(e, "Space") || f.isEventKey(e, "Enter")
          ? e.stopPropagation()
          : t.prototype.handleKeyDown.call(this, e);
      }),
      e
    );
  })(ie);
  g.registerComponent("Button", yi);
  nn = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this;
      return (
        (n.mouseused_ = !1),
        n.on("mousedown", function (e) {
          return n.handleMouseDown(e);
        }),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return "vjs-big-play-button";
      }),
      (t.handleClick = function (e) {
        var t = this.player_.play();
        if (this.mouseused_ && e.clientX && e.clientY) {
          var n =
            this.player_.usingPlugin("eme") &&
            this.player_.eme.sessions &&
            0 < this.player_.eme.sessions.length;
          return (
            Gt(t),
            void (
              !this.player_.tech(!0) ||
              ((de || le) && n) ||
              this.player_.tech(!0).focus()
            )
          );
        }
        var n = this.player_.getChild("controlBar"),
          i = n && n.getChild("playToggle");
        i
          ? ((n = function () {
              return i.focus();
            }),
            Ft(t) ? t.then(n, function () {}) : this.setTimeout(n, 1))
          : this.player_.tech(!0).focus();
      }),
      (t.handleKeyDown = function (e) {
        (this.mouseused_ = !1), i.prototype.handleKeyDown.call(this, e);
      }),
      (t.handleMouseDown = function (e) {
        this.mouseused_ = !0;
      }),
      e
    );
  })(yi);
  (nn.prototype.controlText_ = "Play Video"),
    g.registerComponent("BigPlayButton", nn),
    g.registerComponent(
      "CloseButton",
      (function (n) {
        function e(e, t) {
          e = n.call(this, e, t) || this;
          return e.controlText((t && t.controlText) || e.localize("Close")), e;
        }
        b(e, n);
        var t = e.prototype;
        return (
          (t.buildCSSClass = function () {
            return "vjs-close-button " + n.prototype.buildCSSClass.call(this);
          }),
          (t.handleClick = function (e) {
            this.trigger({ type: "close", bubbles: !1 });
          }),
          (t.handleKeyDown = function (e) {
            f.isEventKey(e, "Esc")
              ? (e.preventDefault(), e.stopPropagation(), this.trigger("click"))
              : n.prototype.handleKeyDown.call(this, e);
          }),
          e
        );
      })(yi)
    );
  rn = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, (t = void 0 === t ? {} : t)) || this;
      return (
        (t.replay = void 0 === t.replay || t.replay),
        n.on(e, "play", function (e) {
          return n.handlePlay(e);
        }),
        n.on(e, "pause", function (e) {
          return n.handlePause(e);
        }),
        t.replay &&
          n.on(e, "ended", function (e) {
            return n.handleEnded(e);
          }),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return "vjs-play-control " + i.prototype.buildCSSClass.call(this);
      }),
      (t.handleClick = function (e) {
        this.player_.paused() ? Gt(this.player_.play()) : this.player_.pause();
      }),
      (t.handleSeeked = function (e) {
        this.removeClass("vjs-ended"),
          this.player_.paused() ? this.handlePause(e) : this.handlePlay(e);
      }),
      (t.handlePlay = function (e) {
        this.removeClass("vjs-ended"),
          this.removeClass("vjs-paused"),
          this.addClass("vjs-playing"),
          this.controlText("Pause");
      }),
      (t.handlePause = function (e) {
        this.removeClass("vjs-playing"),
          this.addClass("vjs-paused"),
          this.controlText("Play");
      }),
      (t.handleEnded = function (e) {
        var t = this;
        this.removeClass("vjs-playing"),
          this.addClass("vjs-ended"),
          this.controlText("Replay"),
          this.one(this.player_, "seeked", function (e) {
            return t.handleSeeked(e);
          });
      }),
      e
    );
  })(yi);
  (rn.prototype.controlText_ = "Play"), g.registerComponent("PlayToggle", rn);
  function _i(e, t) {
    e = e < 0 ? 0 : e;
    var n = Math.floor(e % 60),
      i = Math.floor((e / 60) % 60),
      r = Math.floor(e / 3600),
      a = Math.floor((t / 60) % 60),
      t = Math.floor(t / 3600);
    return (
      (r =
        0 < (r = isNaN(e) || e === 1 / 0 ? (i = n = "-") : r) || 0 < t
          ? r + ":"
          : "") +
      (i = ((r || 10 <= a) && i < 10 ? "0" + i : i) + ":") +
      (n = n < 10 ? "0" + n : n)
    );
  }
  var Ti = _i;
  function Oi(e, t) {
    return Ti(e, (t = void 0 === t ? e : t));
  }
  t = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this;
      return (
        n.on(e, ["timeupdate", "ended"], function (e) {
          return n.updateContent(e);
        }),
        n.updateTextNode_(),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.createEl = function () {
        var e = this.buildCSSClass(),
          t = i.prototype.createEl.call(this, "div", {
            className: e + " vjs-time-control vjs-control",
          }),
          n = c(
            "span",
            {
              className: "vjs-control-text",
              textContent: this.localize(this.labelText_) + "Â ",
            },
            { role: "presentation" }
          );
        return (
          t.appendChild(n),
          (this.contentEl_ = c(
            "span",
            { className: e + "-display" },
            { "aria-live": "off", role: "presentation" }
          )),
          t.appendChild(this.contentEl_),
          t
        );
      }),
      (t.dispose = function () {
        (this.contentEl_ = null),
          (this.textNode_ = null),
          i.prototype.dispose.call(this);
      }),
      (t.updateTextNode_ = function (e) {
        var t = this;
        (e = Oi((e = void 0 === e ? 0 : e))),
          this.formattedTime_ !== e &&
            ((this.formattedTime_ = e),
            this.requestNamedAnimationFrame(
              "TimeDisplay#updateTextNode_",
              function () {
                var e;
                t.contentEl_ &&
                  ((e = t.textNode_) &&
                    t.contentEl_.firstChild !== e &&
                    ((e = null),
                    d.warn(
                      "TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead."
                    )),
                  (t.textNode_ = document.createTextNode(t.formattedTime_)),
                  t.textNode_ &&
                    (e
                      ? t.contentEl_.replaceChild(t.textNode_, e)
                      : t.contentEl_.appendChild(t.textNode_)));
              }
            ));
      }),
      (t.updateContent = function (e) {}),
      e
    );
  })(g);
  (t.prototype.labelText_ = "Time"),
    (t.prototype.controlText_ = "Time"),
    g.registerComponent("TimeDisplay", t);
  o = (function (e) {
    function t() {
      return e.apply(this, arguments) || this;
    }
    b(t, e);
    var n = t.prototype;
    return (
      (n.buildCSSClass = function () {
        return "vjs-current-time";
      }),
      (n.updateContent = function (e) {
        var t = this.player_.ended()
          ? this.player_.duration()
          : this.player_.scrubbing()
          ? this.player_.getCache().currentTime
          : this.player_.currentTime();
        this.updateTextNode_(t);
      }),
      t
    );
  })(t);
  (o.prototype.labelText_ = "Current Time"),
    (o.prototype.controlText_ = "Current Time"),
    g.registerComponent("CurrentTimeDisplay", o);
  a = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this,
        t = function (e) {
          return n.updateContent(e);
        };
      return (
        n.on(e, "durationchange", t),
        n.on(e, "loadstart", t),
        n.on(e, "loadedmetadata", t),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return "vjs-duration";
      }),
      (t.updateContent = function (e) {
        var t = this.player_.duration();
        this.updateTextNode_(t);
      }),
      e
    );
  })(t);
  (a.prototype.labelText_ = "Duration"),
    (a.prototype.controlText_ = "Duration"),
    g.registerComponent("DurationDisplay", a),
    g.registerComponent(
      "TimeDivider",
      (function (i) {
        function e() {
          return i.apply(this, arguments) || this;
        }
        return (
          b(e, i),
          (e.prototype.createEl = function () {
            var e = i.prototype.createEl.call(
                this,
                "div",
                { className: "vjs-time-control vjs-time-divider" },
                { "aria-hidden": !0 }
              ),
              t = i.prototype.createEl.call(this, "div"),
              n = i.prototype.createEl.call(this, "span", { textContent: "/" });
            return t.appendChild(n), e.appendChild(t), e;
          }),
          e
        );
      })(g)
    );
  e = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this;
      return (
        n.on(e, "durationchange", function (e) {
          return n.updateContent(e);
        }),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return "vjs-remaining-time";
      }),
      (t.createEl = function () {
        var e = i.prototype.createEl.call(this);
        return (
          !1 !== this.options_.displayNegative &&
            e.insertBefore(
              c("span", {}, { "aria-hidden": !0 }, "-"),
              this.contentEl_
            ),
          e
        );
      }),
      (t.updateContent = function (e) {
        var t;
        "number" == typeof this.player_.duration() &&
          ((t = this.player_.ended()
            ? 0
            : this.player_.remainingTimeDisplay
            ? this.player_.remainingTimeDisplay()
            : this.player_.remainingTime()),
          this.updateTextNode_(t));
      }),
      e
    );
  })(t);
  (e.prototype.labelText_ = "Remaining Time"),
    (e.prototype.controlText_ = "Remaining Time"),
    g.registerComponent("RemainingTimeDisplay", e),
    g.registerComponent(
      "LiveDisplay",
      (function (i) {
        function e(e, t) {
          var n = i.call(this, e, t) || this;
          return (
            n.updateShowing(),
            n.on(n.player(), "durationchange", function (e) {
              return n.updateShowing(e);
            }),
            n
          );
        }
        b(e, i);
        var t = e.prototype;
        return (
          (t.createEl = function () {
            var e = i.prototype.createEl.call(this, "div", {
              className: "vjs-live-control vjs-control",
            });
            return (
              (this.contentEl_ = c(
                "div",
                { className: "vjs-live-display" },
                { "aria-live": "off" }
              )),
              this.contentEl_.appendChild(
                c("span", {
                  className: "vjs-control-text",
                  textContent: this.localize("Stream Type") + "Â ",
                })
              ),
              this.contentEl_.appendChild(
                document.createTextNode(this.localize("LIVE"))
              ),
              e.appendChild(this.contentEl_),
              e
            );
          }),
          (t.dispose = function () {
            (this.contentEl_ = null), i.prototype.dispose.call(this);
          }),
          (t.updateShowing = function (e) {
            this.player().duration() === 1 / 0 ? this.show() : this.hide();
          }),
          e
        );
      })(g)
    );
  _ = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this;
      return (
        n.updateLiveEdgeStatus(),
        n.player_.liveTracker &&
          ((n.updateLiveEdgeStatusHandler_ = function (e) {
            return n.updateLiveEdgeStatus(e);
          }),
          n.on(
            n.player_.liveTracker,
            "liveedgechange",
            n.updateLiveEdgeStatusHandler_
          )),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.createEl = function () {
        var e = i.prototype.createEl.call(this, "button", {
          className: "vjs-seek-to-live-control vjs-control",
        });
        return (
          (this.textEl_ = c(
            "span",
            {
              className: "vjs-seek-to-live-text",
              textContent: this.localize("LIVE"),
            },
            { "aria-hidden": "true" }
          )),
          e.appendChild(this.textEl_),
          e
        );
      }),
      (t.updateLiveEdgeStatus = function () {
        !this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()
          ? (this.setAttribute("aria-disabled", !0),
            this.addClass("vjs-at-live-edge"),
            this.controlText("Seek to live, currently playing live"))
          : (this.setAttribute("aria-disabled", !1),
            this.removeClass("vjs-at-live-edge"),
            this.controlText("Seek to live, currently behind live"));
      }),
      (t.handleClick = function () {
        this.player_.liveTracker.seekToLiveEdge();
      }),
      (t.dispose = function () {
        this.player_.liveTracker &&
          this.off(
            this.player_.liveTracker,
            "liveedgechange",
            this.updateLiveEdgeStatusHandler_
          ),
          (this.textEl_ = null),
          i.prototype.dispose.call(this);
      }),
      e
    );
  })(yi);
  (_.prototype.controlText_ = "Seek to live, currently playing live"),
    g.registerComponent("SeekToLive", _);
  function Si(e, t, n) {
    return (e = Number(e)), Math.min(n, Math.max(t, isNaN(e) ? t : e));
  }
  T = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this;
      return (
        (n.handleMouseDown_ = function (e) {
          return n.handleMouseDown(e);
        }),
        (n.handleMouseUp_ = function (e) {
          return n.handleMouseUp(e);
        }),
        (n.handleKeyDown_ = function (e) {
          return n.handleKeyDown(e);
        }),
        (n.handleClick_ = function (e) {
          return n.handleClick(e);
        }),
        (n.handleMouseMove_ = function (e) {
          return n.handleMouseMove(e);
        }),
        (n.update_ = function (e) {
          return n.update(e);
        }),
        (n.bar = n.getChild(n.options_.barName)),
        n.vertical(!!n.options_.vertical),
        n.enable(),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.enabled = function () {
        return this.enabled_;
      }),
      (t.enable = function () {
        this.enabled() ||
          (this.on("mousedown", this.handleMouseDown_),
          this.on("touchstart", this.handleMouseDown_),
          this.on("keydown", this.handleKeyDown_),
          this.on("click", this.handleClick_),
          this.on(this.player_, "controlsvisible", this.update),
          this.playerEvent &&
            this.on(this.player_, this.playerEvent, this.update),
          this.removeClass("disabled"),
          this.setAttribute("tabindex", 0),
          (this.enabled_ = !0));
      }),
      (t.disable = function () {
        var e;
        this.enabled() &&
          ((e = this.bar.el_.ownerDocument),
          this.off("mousedown", this.handleMouseDown_),
          this.off("touchstart", this.handleMouseDown_),
          this.off("keydown", this.handleKeyDown_),
          this.off("click", this.handleClick_),
          this.off(this.player_, "controlsvisible", this.update_),
          this.off(e, "mousemove", this.handleMouseMove_),
          this.off(e, "mouseup", this.handleMouseUp_),
          this.off(e, "touchmove", this.handleMouseMove_),
          this.off(e, "touchend", this.handleMouseUp_),
          this.removeAttribute("tabindex"),
          this.addClass("disabled"),
          this.playerEvent &&
            this.off(this.player_, this.playerEvent, this.update),
          (this.enabled_ = !1));
      }),
      (t.createEl = function (e, t, n) {
        return (
          void 0 === n && (n = {}),
          ((t = void 0 === t ? {} : t).className = t.className + " vjs-slider"),
          (t = h({ tabIndex: 0 }, t)),
          (n = h(
            {
              role: "slider",
              "aria-valuenow": 0,
              "aria-valuemin": 0,
              "aria-valuemax": 100,
              tabIndex: 0,
            },
            n
          )),
          i.prototype.createEl.call(this, e, t, n)
        );
      }),
      (t.handleMouseDown = function (e) {
        var t = this.bar.el_.ownerDocument;
        "mousedown" === e.type && e.preventDefault(),
          "touchstart" !== e.type || ue || e.preventDefault(),
          Me(),
          this.addClass("vjs-sliding"),
          this.trigger("slideractive"),
          this.on(t, "mousemove", this.handleMouseMove_),
          this.on(t, "mouseup", this.handleMouseUp_),
          this.on(t, "touchmove", this.handleMouseMove_),
          this.on(t, "touchend", this.handleMouseUp_),
          this.handleMouseMove(e, !0);
      }),
      (t.handleMouseMove = function (e) {}),
      (t.handleMouseUp = function () {
        var e = this.bar.el_.ownerDocument;
        De(),
          this.removeClass("vjs-sliding"),
          this.trigger("sliderinactive"),
          this.off(e, "mousemove", this.handleMouseMove_),
          this.off(e, "mouseup", this.handleMouseUp_),
          this.off(e, "touchmove", this.handleMouseMove_),
          this.off(e, "touchend", this.handleMouseUp_),
          this.update();
      }),
      (t.update = function () {
        var t = this;
        if (this.el_ && this.bar) {
          var n = this.getProgress();
          return n === this.progress_
            ? n
            : ((this.progress_ = n),
              this.requestNamedAnimationFrame("Slider#update", function () {
                var e = t.vertical() ? "height" : "width";
                t.bar.el().style[e] = (100 * n).toFixed(2) + "%";
              }),
              n);
        }
      }),
      (t.getProgress = function () {
        return Number(Si(this.getPercent(), 0, 1).toFixed(4));
      }),
      (t.calculateDistance = function (e) {
        e = Ue(this.el_, e);
        return this.vertical() ? e.y : e.x;
      }),
      (t.handleKeyDown = function (e) {
        f.isEventKey(e, "Left") || f.isEventKey(e, "Down")
          ? (e.preventDefault(), e.stopPropagation(), this.stepBack())
          : f.isEventKey(e, "Right") || f.isEventKey(e, "Up")
          ? (e.preventDefault(), e.stopPropagation(), this.stepForward())
          : i.prototype.handleKeyDown.call(this, e);
      }),
      (t.handleClick = function (e) {
        e.stopPropagation(), e.preventDefault();
      }),
      (t.vertical = function (e) {
        if (void 0 === e) return this.vertical_ || !1;
        (this.vertical_ = !!e),
          this.vertical_
            ? this.addClass("vjs-slider-vertical")
            : this.addClass("vjs-slider-horizontal");
      }),
      e
    );
  })(g);
  g.registerComponent("Slider", T);
  function Ai(e, t) {
    return Si((e / t) * 100, 0, 100).toFixed(2) + "%";
  }
  g.registerComponent(
    "LoadProgressBar",
    (function (r) {
      function e(e, t) {
        var n = r.call(this, e, t) || this;
        return (
          (n.partEls_ = []),
          n.on(e, "progress", function (e) {
            return n.update(e);
          }),
          n
        );
      }
      b(e, r);
      var t = e.prototype;
      return (
        (t.createEl = function () {
          var e = r.prototype.createEl.call(this, "div", {
              className: "vjs-load-progress",
            }),
            t = c("span", { className: "vjs-control-text" }),
            n = c("span", { textContent: this.localize("Loaded") }),
            i = document.createTextNode(": ");
          return (
            (this.percentageEl_ = c("span", {
              className: "vjs-control-text-loaded-percentage",
              textContent: "0%",
            })),
            e.appendChild(t),
            t.appendChild(n),
            t.appendChild(i),
            t.appendChild(this.percentageEl_),
            e
          );
        }),
        (t.dispose = function () {
          (this.partEls_ = null),
            (this.percentageEl_ = null),
            r.prototype.dispose.call(this);
        }),
        (t.update = function (e) {
          var u = this;
          this.requestNamedAnimationFrame(
            "LoadProgressBar#update",
            function () {
              var e = u.player_.liveTracker,
                t = u.player_.buffered(),
                e = e && e.isLive() ? e.seekableEnd() : u.player_.duration(),
                n = u.player_.bufferedEnd(),
                i = u.partEls_,
                e = Ai(n, e);
              u.percent_ !== e &&
                ((u.el_.style.width = e),
                Ae(u.percentageEl_, e),
                (u.percent_ = e));
              for (var r = 0; r < t.length; r++) {
                var a = t.start(r),
                  s = t.end(r),
                  o = i[r];
                o || ((o = u.el_.appendChild(c())), (i[r] = o)),
                  (o.dataset.start === a && o.dataset.end === s) ||
                    ((o.dataset.start = a),
                    (o.dataset.end = s),
                    (o.style.left = Ai(a, n)),
                    (o.style.width = Ai(s - a, n)));
              }
              for (var l = i.length; l > t.length; l--)
                u.el_.removeChild(i[l - 1]);
              i.length = t.length;
            }
          );
        }),
        e
      );
    })(g)
  ),
    g.registerComponent(
      "TimeTooltip",
      (function (n) {
        function e(e, t) {
          t = n.call(this, e, t) || this;
          return (t.update = mt(u(y(t), t.update), 30)), t;
        }
        b(e, n);
        var t = e.prototype;
        return (
          (t.createEl = function () {
            return n.prototype.createEl.call(
              this,
              "div",
              { className: "vjs-time-tooltip" },
              { "aria-hidden": "true" }
            );
          }),
          (t.update = function (e, t, n) {
            var i = Be(this.el_),
              r = Re(this.player_.el()),
              a = e.width * t;
            r &&
              i &&
              ((t = e.left - r.left + a),
              (r = e.width - a + (r.right - e.right)),
              t < (e = i.width / 2) ? (e += e - t) : r < e && (e = r),
              e < 0 ? (e = 0) : e > i.width && (e = i.width),
              (e = Math.round(e)),
              (this.el_.style.right = "-" + e + "px"),
              this.write(n));
          }),
          (t.write = function (e) {
            Ae(this.el_, e);
          }),
          (t.updateTime = function (i, r, a, s) {
            var o = this;
            this.requestNamedAnimationFrame(
              "TimeTooltip#updateTime",
              function () {
                var e,
                  t,
                  n = o.player_.duration();
                (n =
                  o.player_.liveTracker && o.player_.liveTracker.isLive()
                    ? ((t = (e = o.player_.liveTracker.liveWindow()) - r * e) <
                      1
                        ? ""
                        : "-") + Oi(t, e)
                    : Oi(a, n)),
                  o.update(i, r, n),
                  s && s();
              }
            );
          }),
          e
        );
      })(g)
    );
  v = (function (n) {
    function e(e, t) {
      t = n.call(this, e, t) || this;
      return (t.update = mt(u(y(t), t.update), 30)), t;
    }
    b(e, n);
    var t = e.prototype;
    return (
      (t.createEl = function () {
        return n.prototype.createEl.call(
          this,
          "div",
          { className: "vjs-play-progress vjs-slider-bar" },
          { "aria-hidden": "true" }
        );
      }),
      (t.update = function (e, t) {
        var n,
          i = this.getChild("timeTooltip");
        i &&
          ((n = this.player_.scrubbing()
            ? this.player_.getCache().currentTime
            : this.player_.currentTime()),
          i.updateTime(e, t, n));
      }),
      e
    );
  })(g);
  (v.prototype.options_ = { children: [] }),
    ge || re || v.prototype.options_.children.push("timeTooltip"),
    g.registerComponent("PlayProgressBar", v);
  n = (function (n) {
    function e(e, t) {
      t = n.call(this, e, t) || this;
      return (t.update = mt(u(y(t), t.update), 30)), t;
    }
    b(e, n);
    var t = e.prototype;
    return (
      (t.createEl = function () {
        return n.prototype.createEl.call(this, "div", {
          className: "vjs-mouse-display",
        });
      }),
      (t.update = function (e, t) {
        var n = this,
          i = t * this.player_.duration();
        this.getChild("timeTooltip").updateTime(e, t, i, function () {
          n.el_.style.left = e.width * t + "px";
        });
      }),
      e
    );
  })(g);
  (n.prototype.options_ = { children: ["timeTooltip"] }),
    g.registerComponent("MouseTimeDisplay", n);
  nn = (function (a) {
    function e(e, t) {
      t = a.call(this, e, t) || this;
      return t.setEventHandlers_(), t;
    }
    b(e, a);
    var t = e.prototype;
    return (
      (t.setEventHandlers_ = function () {
        var t = this;
        (this.update_ = u(this, this.update)),
          (this.update = mt(this.update_, 30)),
          this.on(
            this.player_,
            ["ended", "durationchange", "timeupdate"],
            this.update
          ),
          this.player_.liveTracker &&
            this.on(this.player_.liveTracker, "liveedgechange", this.update),
          (this.updateInterval = null),
          (this.enableIntervalHandler_ = function (e) {
            return t.enableInterval_(e);
          }),
          (this.disableIntervalHandler_ = function (e) {
            return t.disableInterval_(e);
          }),
          this.on(this.player_, ["playing"], this.enableIntervalHandler_),
          this.on(
            this.player_,
            ["ended", "pause", "waiting"],
            this.disableIntervalHandler_
          ),
          "hidden" in document &&
            "visibilityState" in document &&
            this.on(document, "visibilitychange", this.toggleVisibility_);
      }),
      (t.toggleVisibility_ = function (e) {
        "hidden" === document.visibilityState
          ? (this.cancelNamedAnimationFrame("SeekBar#update"),
            this.cancelNamedAnimationFrame("Slider#update"),
            this.disableInterval_(e))
          : (this.player_.ended() ||
              this.player_.paused() ||
              this.enableInterval_(),
            this.update());
      }),
      (t.enableInterval_ = function () {
        this.updateInterval ||
          (this.updateInterval = this.setInterval(this.update, 30));
      }),
      (t.disableInterval_ = function (e) {
        (this.player_.liveTracker &&
          this.player_.liveTracker.isLive() &&
          e &&
          "ended" !== e.type) ||
          (this.updateInterval &&
            (this.clearInterval(this.updateInterval),
            (this.updateInterval = null)));
      }),
      (t.createEl = function () {
        return a.prototype.createEl.call(
          this,
          "div",
          { className: "vjs-progress-holder" },
          { "aria-label": this.localize("Progress Bar") }
        );
      }),
      (t.update = function (e) {
        var i = this;
        if ("hidden" !== document.visibilityState) {
          var r = a.prototype.update.call(this);
          return (
            this.requestNamedAnimationFrame("SeekBar#update", function () {
              var e = i.player_.ended()
                  ? i.player_.duration()
                  : i.getCurrentTime_(),
                t = i.player_.liveTracker,
                n = i.player_.duration();
              t && t.isLive() && (n = i.player_.liveTracker.liveCurrentTime()),
                i.percent_ !== r &&
                  (i.el_.setAttribute("aria-valuenow", (100 * r).toFixed(2)),
                  (i.percent_ = r)),
                (i.currentTime_ === e && i.duration_ === n) ||
                  (i.el_.setAttribute(
                    "aria-valuetext",
                    i.localize(
                      "progress bar timing: currentTime={1} duration={2}",
                      [Oi(e, n), Oi(n, n)],
                      "{1} of {2}"
                    )
                  ),
                  (i.currentTime_ = e),
                  (i.duration_ = n)),
                i.bar && i.bar.update(Re(i.el()), i.getProgress());
            }),
            r
          );
        }
      }),
      (t.userSeek_ = function (e) {
        this.player_.liveTracker &&
          this.player_.liveTracker.isLive() &&
          this.player_.liveTracker.nextSeekedFromUser(),
          this.player_.currentTime(e);
      }),
      (t.getCurrentTime_ = function () {
        return this.player_.scrubbing()
          ? this.player_.getCache().currentTime
          : this.player_.currentTime();
      }),
      (t.getPercent = function () {
        var e,
          t = this.getCurrentTime_(),
          n = this.player_.liveTracker;
        return (
          n && n.isLive()
            ? ((e = (t - n.seekableStart()) / n.liveWindow()),
              n.atLiveEdge() && (e = 1))
            : (e = t / this.player_.duration()),
          e
        );
      }),
      (t.handleMouseDown = function (e) {
        He(e) &&
          (e.stopPropagation(),
          (this.videoWasPlaying = !this.player_.paused()),
          this.player_.pause(),
          a.prototype.handleMouseDown.call(this, e));
      }),
      (t.handleMouseMove = function (e, t) {
        if ((void 0 === t && (t = !1), He(e))) {
          t || this.player_.scrubbing() || this.player_.scrubbing(!0);
          var n = this.calculateDistance(e),
            i = this.player_.liveTracker;
          if (i && i.isLive()) {
            if (0.99 <= n) return void i.seekToLiveEdge();
            var r,
              t = i.seekableStart(),
              e = i.liveCurrentTime();
            if (
              (r =
                (r = e <= (r = t + n * i.liveWindow()) ? e : r) <= t
                  ? t + 0.1
                  : r) ===
              1 / 0
            )
              return;
          } else
            (r = n * this.player_.duration()) === this.player_.duration() &&
              (r -= 0.1);
          this.userSeek_(r);
        }
      }),
      (t.enable = function () {
        a.prototype.enable.call(this);
        var e = this.getChild("mouseTimeDisplay");
        e && e.show();
      }),
      (t.disable = function () {
        a.prototype.disable.call(this);
        var e = this.getChild("mouseTimeDisplay");
        e && e.hide();
      }),
      (t.handleMouseUp = function (e) {
        a.prototype.handleMouseUp.call(this, e),
          e && e.stopPropagation(),
          this.player_.scrubbing(!1),
          this.player_.trigger({
            type: "timeupdate",
            target: this,
            manuallyTriggered: !0,
          }),
          this.videoWasPlaying ? Gt(this.player_.play()) : this.update_();
      }),
      (t.stepForward = function () {
        this.userSeek_(this.player_.currentTime() + 5);
      }),
      (t.stepBack = function () {
        this.userSeek_(this.player_.currentTime() - 5);
      }),
      (t.handleAction = function (e) {
        this.player_.paused() ? this.player_.play() : this.player_.pause();
      }),
      (t.handleKeyDown = function (e) {
        var t,
          n = this.player_.liveTracker;
        f.isEventKey(e, "Space") || f.isEventKey(e, "Enter")
          ? (e.preventDefault(), e.stopPropagation(), this.handleAction(e))
          : f.isEventKey(e, "Home")
          ? (e.preventDefault(), e.stopPropagation(), this.userSeek_(0))
          : f.isEventKey(e, "End")
          ? (e.preventDefault(),
            e.stopPropagation(),
            n && n.isLive()
              ? this.userSeek_(n.liveCurrentTime())
              : this.userSeek_(this.player_.duration()))
          : /^[0-9]$/.test(f(e))
          ? (e.preventDefault(),
            e.stopPropagation(),
            (t = (10 * (f.codes[f(e)] - f.codes[0])) / 100),
            n && n.isLive()
              ? this.userSeek_(n.seekableStart() + n.liveWindow() * t)
              : this.userSeek_(this.player_.duration() * t))
          : f.isEventKey(e, "PgDn")
          ? (e.preventDefault(),
            e.stopPropagation(),
            this.userSeek_(this.player_.currentTime() - 60))
          : f.isEventKey(e, "PgUp")
          ? (e.preventDefault(),
            e.stopPropagation(),
            this.userSeek_(this.player_.currentTime() + 60))
          : a.prototype.handleKeyDown.call(this, e);
      }),
      (t.dispose = function () {
        this.disableInterval_(),
          this.off(
            this.player_,
            ["ended", "durationchange", "timeupdate"],
            this.update
          ),
          this.player_.liveTracker &&
            this.off(this.player_.liveTracker, "liveedgechange", this.update),
          this.off(this.player_, ["playing"], this.enableIntervalHandler_),
          this.off(
            this.player_,
            ["ended", "pause", "waiting"],
            this.disableIntervalHandler_
          ),
          "hidden" in document &&
            "visibilityState" in document &&
            this.off(document, "visibilitychange", this.toggleVisibility_),
          a.prototype.dispose.call(this);
      }),
      e
    );
  })(T);
  (nn.prototype.options_ = {
    children: ["loadProgressBar", "playProgressBar"],
    barName: "playProgressBar",
  }),
    ge || re || nn.prototype.options_.children.splice(1, 0, "mouseTimeDisplay"),
    g.registerComponent("SeekBar", nn);
  rn = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this;
      return (
        (n.handleMouseMove = mt(u(y(n), n.handleMouseMove), 30)),
        (n.throttledHandleMouseSeek = mt(u(y(n), n.handleMouseSeek), 30)),
        (n.handleMouseUpHandler_ = function (e) {
          return n.handleMouseUp(e);
        }),
        (n.handleMouseDownHandler_ = function (e) {
          return n.handleMouseDown(e);
        }),
        n.enable(),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.createEl = function () {
        return i.prototype.createEl.call(this, "div", {
          className: "vjs-progress-control vjs-control",
        });
      }),
      (t.handleMouseMove = function (e) {
        var t,
          n,
          i,
          r,
          a = this.getChild("seekBar");
        a &&
          ((t = a.getChild("playProgressBar")),
          (n = a.getChild("mouseTimeDisplay")),
          (t || n) &&
            ((r = Be((i = a.el()))),
            (e = Ue(i, e).x),
            (e = Si(e, 0, 1)),
            n && n.update(r, e),
            t && t.update(r, a.getProgress())));
      }),
      (t.handleMouseSeek = function (e) {
        var t = this.getChild("seekBar");
        t && t.handleMouseMove(e);
      }),
      (t.enabled = function () {
        return this.enabled_;
      }),
      (t.disable = function () {
        var e;
        this.children().forEach(function (e) {
          return e.disable && e.disable();
        }),
          this.enabled() &&
            (this.off(
              ["mousedown", "touchstart"],
              this.handleMouseDownHandler_
            ),
            this.off(this.el_, "mousemove", this.handleMouseMove),
            this.removeListenersAddedOnMousedownAndTouchstart(),
            this.addClass("disabled"),
            (this.enabled_ = !1),
            this.player_.scrubbing() &&
              ((e = this.getChild("seekBar")),
              this.player_.scrubbing(!1),
              e.videoWasPlaying && Gt(this.player_.play())));
      }),
      (t.enable = function () {
        this.children().forEach(function (e) {
          return e.enable && e.enable();
        }),
          this.enabled() ||
            (this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_),
            this.on(this.el_, "mousemove", this.handleMouseMove),
            this.removeClass("disabled"),
            (this.enabled_ = !0));
      }),
      (t.removeListenersAddedOnMousedownAndTouchstart = function () {
        var e = this.el_.ownerDocument;
        this.off(e, "mousemove", this.throttledHandleMouseSeek),
          this.off(e, "touchmove", this.throttledHandleMouseSeek),
          this.off(e, "mouseup", this.handleMouseUpHandler_),
          this.off(e, "touchend", this.handleMouseUpHandler_);
      }),
      (t.handleMouseDown = function (e) {
        var t = this.el_.ownerDocument,
          n = this.getChild("seekBar");
        n && n.handleMouseDown(e),
          this.on(t, "mousemove", this.throttledHandleMouseSeek),
          this.on(t, "touchmove", this.throttledHandleMouseSeek),
          this.on(t, "mouseup", this.handleMouseUpHandler_),
          this.on(t, "touchend", this.handleMouseUpHandler_);
      }),
      (t.handleMouseUp = function (e) {
        var t = this.getChild("seekBar");
        t && t.handleMouseUp(e),
          this.removeListenersAddedOnMousedownAndTouchstart();
      }),
      e
    );
  })(g);
  (rn.prototype.options_ = { children: ["seekBar"] }),
    g.registerComponent("ProgressControl", rn);
  o = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this;
      return (
        n.on(
          e,
          ["enterpictureinpicture", "leavepictureinpicture"],
          function (e) {
            return n.handlePictureInPictureChange(e);
          }
        ),
        n.on(
          e,
          ["disablepictureinpicturechanged", "loadedmetadata"],
          function (e) {
            return n.handlePictureInPictureEnabledChange(e);
          }
        ),
        n.on(
          e,
          ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"],
          function () {
            "audio" === e.currentType().substring(0, 5) ||
            e.audioPosterMode() ||
            e.audioOnlyMode()
              ? (e.isInPictureInPicture() && e.exitPictureInPicture(), n.hide())
              : n.show();
          }
        ),
        n.disable(),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return (
          "vjs-picture-in-picture-control " +
          i.prototype.buildCSSClass.call(this)
        );
      }),
      (t.handlePictureInPictureEnabledChange = function () {
        document.pictureInPictureEnabled &&
        !1 === this.player_.disablePictureInPicture()
          ? this.enable()
          : this.disable();
      }),
      (t.handlePictureInPictureChange = function (e) {
        this.player_.isInPictureInPicture()
          ? this.controlText("Exit Picture-in-Picture")
          : this.controlText("Picture-in-Picture"),
          this.handlePictureInPictureEnabledChange();
      }),
      (t.handleClick = function (e) {
        this.player_.isInPictureInPicture()
          ? this.player_.exitPictureInPicture()
          : this.player_.requestPictureInPicture();
      }),
      e
    );
  })(yi);
  (o.prototype.controlText_ = "Picture-in-Picture"),
    g.registerComponent("PictureInPictureToggle", o);
  a = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this;
      return (
        n.on(e, "fullscreenchange", function (e) {
          return n.handleFullscreenChange(e);
        }),
        !1 === document[e.fsApi_.fullscreenEnabled] && n.disable(),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return "vjs-fullscreen-control " + i.prototype.buildCSSClass.call(this);
      }),
      (t.handleFullscreenChange = function (e) {
        this.player_.isFullscreen()
          ? this.controlText("Non-Fullscreen")
          : this.controlText("Fullscreen");
      }),
      (t.handleClick = function (e) {
        this.player_.isFullscreen()
          ? this.player_.exitFullscreen()
          : this.player_.requestFullscreen();
      }),
      e
    );
  })(yi);
  (a.prototype.controlText_ = "Fullscreen"),
    g.registerComponent("FullscreenToggle", a);
  g.registerComponent(
    "VolumeLevel",
    (function (t) {
      function e() {
        return t.apply(this, arguments) || this;
      }
      return (
        b(e, t),
        (e.prototype.createEl = function () {
          var e = t.prototype.createEl.call(this, "div", {
            className: "vjs-volume-level",
          });
          return (
            e.appendChild(
              t.prototype.createEl.call(this, "span", {
                className: "vjs-control-text",
              })
            ),
            e
          );
        }),
        e
      );
    })(g)
  ),
    g.registerComponent(
      "VolumeLevelTooltip",
      (function (n) {
        function e(e, t) {
          t = n.call(this, e, t) || this;
          return (t.update = mt(u(y(t), t.update), 30)), t;
        }
        b(e, n);
        var t = e.prototype;
        return (
          (t.createEl = function () {
            return n.prototype.createEl.call(
              this,
              "div",
              { className: "vjs-volume-tooltip" },
              { "aria-hidden": "true" }
            );
          }),
          (t.update = function (e, t, n, i) {
            if (!n) {
              var r = Re(this.el_),
                a = Re(this.player_.el()),
                n = e.width * t;
              if (!a || !r) return;
              (t = e.left - a.left + n),
                (a = e.width - n + (a.right - e.right)),
                (e = r.width / 2);
              t < e ? (e += e - t) : a < e && (e = a),
                e < 0 ? (e = 0) : e > r.width && (e = r.width),
                (this.el_.style.right = "-" + e + "px");
            }
            this.write(i + "%");
          }),
          (t.write = function (e) {
            Ae(this.el_, e);
          }),
          (t.updateVolume = function (e, t, n, i, r) {
            var a = this;
            this.requestNamedAnimationFrame(
              "VolumeLevelTooltip#updateVolume",
              function () {
                a.update(e, t, n, i.toFixed(0)), r && r();
              }
            );
          }),
          e
        );
      })(g)
    );
  t = (function (n) {
    function e(e, t) {
      t = n.call(this, e, t) || this;
      return (t.update = mt(u(y(t), t.update), 30)), t;
    }
    b(e, n);
    var t = e.prototype;
    return (
      (t.createEl = function () {
        return n.prototype.createEl.call(this, "div", {
          className: "vjs-mouse-display",
        });
      }),
      (t.update = function (e, t, n) {
        var i = this,
          r = 100 * t;
        this.getChild("volumeLevelTooltip").updateVolume(
          e,
          t,
          n,
          r,
          function () {
            n
              ? (i.el_.style.bottom = e.height * t + "px")
              : (i.el_.style.left = e.width * t + "px");
          }
        );
      }),
      e
    );
  })(g);
  (t.prototype.options_ = { children: ["volumeLevelTooltip"] }),
    g.registerComponent("MouseVolumeLevelDisplay", t);
  e = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this;
      return (
        n.on("slideractive", function (e) {
          return n.updateLastVolume_(e);
        }),
        n.on(e, "volumechange", function (e) {
          return n.updateARIAAttributes(e);
        }),
        e.ready(function () {
          return n.updateARIAAttributes();
        }),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.createEl = function () {
        return i.prototype.createEl.call(
          this,
          "div",
          { className: "vjs-volume-bar vjs-slider-bar" },
          { "aria-label": this.localize("Volume Level"), "aria-live": "polite" }
        );
      }),
      (t.handleMouseDown = function (e) {
        He(e) && i.prototype.handleMouseDown.call(this, e);
      }),
      (t.handleMouseMove = function (e) {
        var t,
          n,
          i,
          r = this.getChild("mouseVolumeLevelDisplay");
        r &&
          ((t = Re((i = this.el()))),
          (n = this.vertical()),
          (i = Ue(i, e)),
          (i = n ? i.y : i.x),
          (i = Si(i, 0, 1)),
          r.update(t, i, n)),
          He(e) &&
            (this.checkMuted(), this.player_.volume(this.calculateDistance(e)));
      }),
      (t.checkMuted = function () {
        this.player_.muted() && this.player_.muted(!1);
      }),
      (t.getPercent = function () {
        return this.player_.muted() ? 0 : this.player_.volume();
      }),
      (t.stepForward = function () {
        this.checkMuted(), this.player_.volume(this.player_.volume() + 0.1);
      }),
      (t.stepBack = function () {
        this.checkMuted(), this.player_.volume(this.player_.volume() - 0.1);
      }),
      (t.updateARIAAttributes = function (e) {
        var t = this.player_.muted() ? 0 : this.volumeAsPercentage_();
        this.el_.setAttribute("aria-valuenow", t),
          this.el_.setAttribute("aria-valuetext", t + "%");
      }),
      (t.volumeAsPercentage_ = function () {
        return Math.round(100 * this.player_.volume());
      }),
      (t.updateLastVolume_ = function () {
        var e = this,
          t = this.player_.volume();
        this.one("sliderinactive", function () {
          0 === e.player_.volume() && e.player_.lastVolume_(t);
        });
      }),
      e
    );
  })(T);
  (e.prototype.options_ = {
    children: ["volumeLevel"],
    barName: "volumeLevel",
  }),
    ge ||
      re ||
      e.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay"),
    (e.prototype.playerEvent = "volumechange"),
    g.registerComponent("VolumeBar", e);
  _ = (function (a) {
    function e(e, t) {
      var n, i, r;
      return (
        ((t = void 0 === t ? {} : t).vertical = t.vertical || !1),
        ("undefined" != typeof t.volumeBar && !te(t.volumeBar)) ||
          ((t.volumeBar = t.volumeBar || {}),
          (t.volumeBar.vertical = t.vertical)),
        (n = a.call(this, e, t) || this),
        (i = y(n)),
        (r = e).tech_ &&
          !r.tech_.featuresVolumeControl &&
          i.addClass("vjs-hidden"),
        i.on(r, "loadstart", function () {
          r.tech_.featuresVolumeControl
            ? i.removeClass("vjs-hidden")
            : i.addClass("vjs-hidden");
        }),
        (n.throttledHandleMouseMove = mt(u(y(n), n.handleMouseMove), 30)),
        (n.handleMouseUpHandler_ = function (e) {
          return n.handleMouseUp(e);
        }),
        n.on("mousedown", function (e) {
          return n.handleMouseDown(e);
        }),
        n.on("touchstart", function (e) {
          return n.handleMouseDown(e);
        }),
        n.on("mousemove", function (e) {
          return n.handleMouseMove(e);
        }),
        n.on(n.volumeBar, ["focus", "slideractive"], function () {
          n.volumeBar.addClass("vjs-slider-active"),
            n.addClass("vjs-slider-active"),
            n.trigger("slideractive");
        }),
        n.on(n.volumeBar, ["blur", "sliderinactive"], function () {
          n.volumeBar.removeClass("vjs-slider-active"),
            n.removeClass("vjs-slider-active"),
            n.trigger("sliderinactive");
        }),
        n
      );
    }
    b(e, a);
    var t = e.prototype;
    return (
      (t.createEl = function () {
        var e = "vjs-volume-horizontal";
        return (
          this.options_.vertical && (e = "vjs-volume-vertical"),
          a.prototype.createEl.call(this, "div", {
            className: "vjs-volume-control vjs-control " + e,
          })
        );
      }),
      (t.handleMouseDown = function (e) {
        var t = this.el_.ownerDocument;
        this.on(t, "mousemove", this.throttledHandleMouseMove),
          this.on(t, "touchmove", this.throttledHandleMouseMove),
          this.on(t, "mouseup", this.handleMouseUpHandler_),
          this.on(t, "touchend", this.handleMouseUpHandler_);
      }),
      (t.handleMouseUp = function (e) {
        var t = this.el_.ownerDocument;
        this.off(t, "mousemove", this.throttledHandleMouseMove),
          this.off(t, "touchmove", this.throttledHandleMouseMove),
          this.off(t, "mouseup", this.handleMouseUpHandler_),
          this.off(t, "touchend", this.handleMouseUpHandler_);
      }),
      (t.handleMouseMove = function (e) {
        this.volumeBar.handleMouseMove(e);
      }),
      e
    );
  })(g);
  (_.prototype.options_ = { children: ["volumeBar"] }),
    g.registerComponent("VolumeControl", _);
  v = (function (a) {
    function e(e, t) {
      var n,
        i,
        r = a.call(this, e, t) || this;
      return (
        (n = y(r)),
        (i = e).tech_ &&
          !i.tech_.featuresMuteControl &&
          n.addClass("vjs-hidden"),
        n.on(i, "loadstart", function () {
          i.tech_.featuresMuteControl
            ? n.removeClass("vjs-hidden")
            : n.addClass("vjs-hidden");
        }),
        r.on(e, ["loadstart", "volumechange"], function (e) {
          return r.update(e);
        }),
        r
      );
    }
    b(e, a);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return "vjs-mute-control " + a.prototype.buildCSSClass.call(this);
      }),
      (t.handleClick = function (e) {
        var t = this.player_.volume(),
          n = this.player_.lastVolume_();
        0 === t
          ? (this.player_.volume(n < 0.1 ? 0.1 : n), this.player_.muted(!1))
          : this.player_.muted(!this.player_.muted());
      }),
      (t.update = function (e) {
        this.updateIcon_(), this.updateControlText_();
      }),
      (t.updateIcon_ = function () {
        var e = this.player_.volume(),
          t = 3;
        ge &&
          this.player_.tech_ &&
          this.player_.tech_.el_ &&
          this.player_.muted(this.player_.tech_.el_.muted),
          0 === e || this.player_.muted()
            ? (t = 0)
            : e < 0.33
            ? (t = 1)
            : e < 0.67 && (t = 2);
        for (var n = 0; n < 4; n++) xe(this.el_, "vjs-vol-" + n);
        Ie(this.el_, "vjs-vol-" + t);
      }),
      (t.updateControlText_ = function () {
        var e =
          this.player_.muted() || 0 === this.player_.volume()
            ? "Unmute"
            : "Mute";
        this.controlText() !== e && this.controlText(e);
      }),
      e
    );
  })(yi);
  (v.prototype.controlText_ = "Mute"), g.registerComponent("MuteToggle", v);
  n = (function (i) {
    function e(e, t) {
      var n;
      return (
        "undefined" != typeof (t = void 0 === t ? {} : t).inline
          ? (t.inline = t.inline)
          : (t.inline = !0),
        ("undefined" != typeof t.volumeControl && !te(t.volumeControl)) ||
          ((t.volumeControl = t.volumeControl || {}),
          (t.volumeControl.vertical = !t.inline)),
        ((n = i.call(this, e, t) || this).handleKeyPressHandler_ = function (
          e
        ) {
          return n.handleKeyPress(e);
        }),
        n.on(e, ["loadstart"], function (e) {
          return n.volumePanelState_(e);
        }),
        n.on(n.muteToggle, "keyup", function (e) {
          return n.handleKeyPress(e);
        }),
        n.on(n.volumeControl, "keyup", function (e) {
          return n.handleVolumeControlKeyUp(e);
        }),
        n.on("keydown", function (e) {
          return n.handleKeyPress(e);
        }),
        n.on("mouseover", function (e) {
          return n.handleMouseOver(e);
        }),
        n.on("mouseout", function (e) {
          return n.handleMouseOut(e);
        }),
        n.on(n.volumeControl, ["slideractive"], n.sliderActive_),
        n.on(n.volumeControl, ["sliderinactive"], n.sliderInactive_),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.sliderActive_ = function () {
        this.addClass("vjs-slider-active");
      }),
      (t.sliderInactive_ = function () {
        this.removeClass("vjs-slider-active");
      }),
      (t.volumePanelState_ = function () {
        this.volumeControl.hasClass("vjs-hidden") &&
          this.muteToggle.hasClass("vjs-hidden") &&
          this.addClass("vjs-hidden"),
          this.volumeControl.hasClass("vjs-hidden") &&
            !this.muteToggle.hasClass("vjs-hidden") &&
            this.addClass("vjs-mute-toggle-only");
      }),
      (t.createEl = function () {
        var e = "vjs-volume-panel-horizontal";
        return (
          this.options_.inline || (e = "vjs-volume-panel-vertical"),
          i.prototype.createEl.call(this, "div", {
            className: "vjs-volume-panel vjs-control " + e,
          })
        );
      }),
      (t.dispose = function () {
        this.handleMouseOut(), i.prototype.dispose.call(this);
      }),
      (t.handleVolumeControlKeyUp = function (e) {
        f.isEventKey(e, "Esc") && this.muteToggle.focus();
      }),
      (t.handleMouseOver = function (e) {
        this.addClass("vjs-hover"),
          ct(document, "keyup", this.handleKeyPressHandler_);
      }),
      (t.handleMouseOut = function (e) {
        this.removeClass("vjs-hover"),
          l(document, "keyup", this.handleKeyPressHandler_);
      }),
      (t.handleKeyPress = function (e) {
        f.isEventKey(e, "Esc") && this.handleMouseOut();
      }),
      e
    );
  })(g);
  (n.prototype.options_ = { children: ["muteToggle", "volumeControl"] }),
    g.registerComponent("VolumePanel", n);
  var wi = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this;
      return (
        t && (n.menuButton_ = t.menuButton),
        (n.focusedChild_ = -1),
        n.on("keydown", function (e) {
          return n.handleKeyDown(e);
        }),
        (n.boundHandleBlur_ = function (e) {
          return n.handleBlur(e);
        }),
        (n.boundHandleTapClick_ = function (e) {
          return n.handleTapClick(e);
        }),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.addEventListenerForItem = function (e) {
        e instanceof g &&
          (this.on(e, "blur", this.boundHandleBlur_),
          this.on(e, ["tap", "click"], this.boundHandleTapClick_));
      }),
      (t.removeEventListenerForItem = function (e) {
        e instanceof g &&
          (this.off(e, "blur", this.boundHandleBlur_),
          this.off(e, ["tap", "click"], this.boundHandleTapClick_));
      }),
      (t.removeChild = function (e) {
        "string" == typeof e && (e = this.getChild(e)),
          this.removeEventListenerForItem(e),
          i.prototype.removeChild.call(this, e);
      }),
      (t.addItem = function (e) {
        e = this.addChild(e);
        e && this.addEventListenerForItem(e);
      }),
      (t.createEl = function () {
        var e = this.options_.contentElType || "ul";
        (this.contentEl_ = c(e, { className: "vjs-menu-content" })),
          this.contentEl_.setAttribute("role", "menu");
        e = i.prototype.createEl.call(this, "div", {
          append: this.contentEl_,
          className: "vjs-menu",
        });
        return (
          e.appendChild(this.contentEl_),
          ct(e, "click", function (e) {
            e.preventDefault(), e.stopImmediatePropagation();
          }),
          e
        );
      }),
      (t.dispose = function () {
        (this.contentEl_ = null),
          (this.boundHandleBlur_ = null),
          (this.boundHandleTapClick_ = null),
          i.prototype.dispose.call(this);
      }),
      (t.handleBlur = function (e) {
        var t = e.relatedTarget || document.activeElement;
        this.children().some(function (e) {
          return e.el() === t;
        }) ||
          ((e = this.menuButton_) &&
            e.buttonPressed_ &&
            t !== e.el().firstChild &&
            e.unpressButton());
      }),
      (t.handleTapClick = function (t) {
        var e;
        this.menuButton_ &&
          (this.menuButton_.unpressButton(),
          (e = this.children()),
          !Array.isArray(e) ||
            ((e = e.filter(function (e) {
              return e.el() === t.target;
            })[0]) &&
              "CaptionSettingsMenuItem" !== e.name() &&
              this.menuButton_.focus()));
      }),
      (t.handleKeyDown = function (e) {
        f.isEventKey(e, "Left") || f.isEventKey(e, "Down")
          ? (e.preventDefault(), e.stopPropagation(), this.stepForward())
          : (f.isEventKey(e, "Right") || f.isEventKey(e, "Up")) &&
            (e.preventDefault(), e.stopPropagation(), this.stepBack());
      }),
      (t.stepForward = function () {
        var e = 0;
        void 0 !== this.focusedChild_ && (e = this.focusedChild_ + 1),
          this.focus(e);
      }),
      (t.stepBack = function () {
        var e = 0;
        void 0 !== this.focusedChild_ && (e = this.focusedChild_ - 1),
          this.focus(e);
      }),
      (t.focus = function (e) {
        void 0 === e && (e = 0);
        var t = this.children().slice();
        t.length && t[0].hasClass("vjs-menu-title") && t.shift(),
          0 < t.length &&
            (e < 0 ? (e = 0) : e >= t.length && (e = t.length - 1),
            t[(this.focusedChild_ = e)].el_.focus());
      }),
      e
    );
  })(g);
  g.registerComponent("Menu", wi);
  nn = (function (i) {
    function e(e, t) {
      var n;
      ((n = i.call(this, e, (t = void 0 === t ? {} : t)) || this).menuButton_ =
        new yi(e, t)),
        n.menuButton_.controlText(n.controlText_),
        n.menuButton_.el_.setAttribute("aria-haspopup", "true");
      t = yi.prototype.buildCSSClass();
      (n.menuButton_.el_.className = n.buildCSSClass() + " " + t),
        n.menuButton_.removeClass("vjs-control"),
        n.addChild(n.menuButton_),
        n.update(),
        (n.enabled_ = !0);
      t = function (e) {
        return n.handleClick(e);
      };
      return (
        (n.handleMenuKeyUp_ = function (e) {
          return n.handleMenuKeyUp(e);
        }),
        n.on(n.menuButton_, "tap", t),
        n.on(n.menuButton_, "click", t),
        n.on(n.menuButton_, "keydown", function (e) {
          return n.handleKeyDown(e);
        }),
        n.on(n.menuButton_, "mouseenter", function () {
          n.addClass("vjs-hover"),
            n.menu.show(),
            ct(document, "keyup", n.handleMenuKeyUp_);
        }),
        n.on("mouseleave", function (e) {
          return n.handleMouseLeave(e);
        }),
        n.on("keydown", function (e) {
          return n.handleSubmenuKeyDown(e);
        }),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.update = function () {
        var e = this.createMenu();
        this.menu && (this.menu.dispose(), this.removeChild(this.menu)),
          (this.menu = e),
          this.addChild(e),
          (this.buttonPressed_ = !1),
          this.menuButton_.el_.setAttribute("aria-expanded", "false"),
          this.items && this.items.length <= this.hideThreshold_
            ? (this.hide(), this.menu.contentEl_.removeAttribute("role"))
            : (this.show(), this.menu.contentEl_.setAttribute("role", "menu"));
      }),
      (t.createMenu = function () {
        var e,
          t = new wi(this.player_, { menuButton: this });
        if (
          ((this.hideThreshold_ = 0),
          this.options_.title &&
            ((e = c("li", {
              className: "vjs-menu-title",
              textContent: p(this.options_.title),
              tabIndex: -1,
            })),
            (e = new g(this.player_, { el: e })),
            t.addItem(e)),
          (this.items = this.createItems()),
          this.items)
        )
          for (var n = 0; n < this.items.length; n++) t.addItem(this.items[n]);
        return t;
      }),
      (t.createItems = function () {}),
      (t.createEl = function () {
        return i.prototype.createEl.call(
          this,
          "div",
          { className: this.buildWrapperCSSClass() },
          {}
        );
      }),
      (t.buildWrapperCSSClass = function () {
        var e = "vjs-menu-button";
        return (
          !0 === this.options_.inline ? (e += "-inline") : (e += "-popup"),
          "vjs-menu-button " +
            e +
            " " +
            yi.prototype.buildCSSClass() +
            " " +
            i.prototype.buildCSSClass.call(this)
        );
      }),
      (t.buildCSSClass = function () {
        var e = "vjs-menu-button";
        return (
          !0 === this.options_.inline ? (e += "-inline") : (e += "-popup"),
          "vjs-menu-button " + e + " " + i.prototype.buildCSSClass.call(this)
        );
      }),
      (t.controlText = function (e, t) {
        return (
          void 0 === t && (t = this.menuButton_.el()),
          this.menuButton_.controlText(e, t)
        );
      }),
      (t.dispose = function () {
        this.handleMouseLeave(), i.prototype.dispose.call(this);
      }),
      (t.handleClick = function (e) {
        this.buttonPressed_ ? this.unpressButton() : this.pressButton();
      }),
      (t.handleMouseLeave = function (e) {
        this.removeClass("vjs-hover"),
          l(document, "keyup", this.handleMenuKeyUp_);
      }),
      (t.focus = function () {
        this.menuButton_.focus();
      }),
      (t.blur = function () {
        this.menuButton_.blur();
      }),
      (t.handleKeyDown = function (e) {
        f.isEventKey(e, "Esc") || f.isEventKey(e, "Tab")
          ? (this.buttonPressed_ && this.unpressButton(),
            f.isEventKey(e, "Tab") ||
              (e.preventDefault(), this.menuButton_.focus()))
          : (f.isEventKey(e, "Up") || f.isEventKey(e, "Down")) &&
            (this.buttonPressed_ || (e.preventDefault(), this.pressButton()));
      }),
      (t.handleMenuKeyUp = function (e) {
        (f.isEventKey(e, "Esc") || f.isEventKey(e, "Tab")) &&
          this.removeClass("vjs-hover");
      }),
      (t.handleSubmenuKeyPress = function (e) {
        this.handleSubmenuKeyDown(e);
      }),
      (t.handleSubmenuKeyDown = function (e) {
        (f.isEventKey(e, "Esc") || f.isEventKey(e, "Tab")) &&
          (this.buttonPressed_ && this.unpressButton(),
          f.isEventKey(e, "Tab") ||
            (e.preventDefault(), this.menuButton_.focus()));
      }),
      (t.pressButton = function () {
        this.enabled_ &&
          ((this.buttonPressed_ = !0),
          this.menu.show(),
          this.menu.lockShowing(),
          this.menuButton_.el_.setAttribute("aria-expanded", "true"),
          (ge && Oe()) || this.menu.focus());
      }),
      (t.unpressButton = function () {
        this.enabled_ &&
          ((this.buttonPressed_ = !1),
          this.menu.unlockShowing(),
          this.menu.hide(),
          this.menuButton_.el_.setAttribute("aria-expanded", "false"));
      }),
      (t.disable = function () {
        this.unpressButton(),
          (this.enabled_ = !1),
          this.addClass("vjs-disabled"),
          this.menuButton_.disable();
      }),
      (t.enable = function () {
        (this.enabled_ = !0),
          this.removeClass("vjs-disabled"),
          this.menuButton_.enable();
      }),
      e
    );
  })(g);
  g.registerComponent("MenuButton", nn);
  rn = (function (r) {
    function e(e, t) {
      var n = t.tracks,
        t = r.call(this, e, t) || this;
      if ((t.items.length <= 1 && t.hide(), !n)) return y(t);
      var i = u(y(t), t.update);
      return (
        n.addEventListener("removetrack", i),
        n.addEventListener("addtrack", i),
        n.addEventListener("labelchange", i),
        t.player_.on("ready", i),
        t.player_.on("dispose", function () {
          n.removeEventListener("removetrack", i),
            n.removeEventListener("addtrack", i),
            n.removeEventListener("labelchange", i);
        }),
        t
      );
    }
    return b(e, r), e;
  })(nn);
  g.registerComponent("TrackButton", rn);
  var Ci = ["Tab", "Esc", "Up", "Down", "Right", "Left"],
    o = (function (i) {
      function e(e, t) {
        e = i.call(this, e, t) || this;
        return (
          (e.selectable = t.selectable),
          (e.isSelected_ = t.selected || !1),
          (e.multiSelectable = t.multiSelectable),
          e.selected(e.isSelected_),
          e.selectable
            ? e.multiSelectable
              ? e.el_.setAttribute("role", "menuitemcheckbox")
              : e.el_.setAttribute("role", "menuitemradio")
            : e.el_.setAttribute("role", "menuitem"),
          e
        );
      }
      b(e, i);
      var t = e.prototype;
      return (
        (t.createEl = function (e, t, n) {
          this.nonIconControl = !0;
          n = i.prototype.createEl.call(
            this,
            "li",
            h({ className: "vjs-menu-item", tabIndex: -1 }, t),
            n
          );
          return (
            n.replaceChild(
              c("span", {
                className: "vjs-menu-item-text",
                textContent: this.localize(this.options_.label),
              }),
              n.querySelector(".vjs-icon-placeholder")
            ),
            n
          );
        }),
        (t.handleKeyDown = function (t) {
          Ci.some(function (e) {
            return f.isEventKey(t, e);
          }) || i.prototype.handleKeyDown.call(this, t);
        }),
        (t.handleClick = function (e) {
          this.selected(!0);
        }),
        (t.selected = function (e) {
          this.selectable &&
            (e
              ? (this.addClass("vjs-selected"),
                this.el_.setAttribute("aria-checked", "true"),
                this.controlText(", selected"),
                (this.isSelected_ = !0))
              : (this.removeClass("vjs-selected"),
                this.el_.setAttribute("aria-checked", "false"),
                this.controlText(""),
                (this.isSelected_ = !1)));
        }),
        e
      );
    })(ie);
  g.registerComponent("MenuItem", o);
  var Ii = (function (l) {
    function e(e, t) {
      var i,
        n = t.track,
        r = e.textTracks();
      (t.label = n.label || n.language || "Unknown"),
        (t.selected = "showing" === n.mode),
        ((i = l.call(this, e, t) || this).track = n),
        (i.kinds = (t.kinds || [t.kind || i.track.kind]).filter(Boolean));
      function a() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
          t[n] = arguments[n];
        i.handleTracksChange.apply(y(i), t);
      }
      function s() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
          t[n] = arguments[n];
        i.handleSelectedLanguageChange.apply(y(i), t);
      }
      var o;
      return (
        e.on(["loadstart", "texttrackchange"], a),
        r.addEventListener("change", a),
        r.addEventListener("selectedlanguagechange", s),
        i.on("dispose", function () {
          e.off(["loadstart", "texttrackchange"], a),
            r.removeEventListener("change", a),
            r.removeEventListener("selectedlanguagechange", s);
        }),
        void 0 === r.onchange &&
          i.on(["tap", "click"], function () {
            if ("object" != typeof window.Event)
              try {
                o = new window.Event("change");
              } catch (e) {}
            o ||
              (o = document.createEvent("Event")).initEvent("change", !0, !0),
              r.dispatchEvent(o);
          }),
        i.handleTracksChange(),
        i
      );
    }
    b(e, l);
    var t = e.prototype;
    return (
      (t.handleClick = function (e) {
        var t = this.track,
          n = this.player_.textTracks();
        if ((l.prototype.handleClick.call(this, e), n))
          for (var i = 0; i < n.length; i++) {
            var r = n[i];
            -1 !== this.kinds.indexOf(r.kind) &&
              (r === t
                ? "showing" !== r.mode && (r.mode = "showing")
                : "disabled" !== r.mode && (r.mode = "disabled"));
          }
      }),
      (t.handleTracksChange = function (e) {
        var t = "showing" === this.track.mode;
        t !== this.isSelected_ && this.selected(t);
      }),
      (t.handleSelectedLanguageChange = function (e) {
        var t;
        "showing" === this.track.mode &&
          (((t = this.player_.cache_.selectedLanguage) &&
            t.enabled &&
            t.language === this.track.language &&
            t.kind !== this.track.kind) ||
            (this.player_.cache_.selectedLanguage = {
              enabled: !0,
              language: this.track.language,
              kind: this.track.kind,
            }));
      }),
      (t.dispose = function () {
        (this.track = null), l.prototype.dispose.call(this);
      }),
      e
    );
  })(o);
  g.registerComponent("TextTrackMenuItem", Ii);
  var xi = (function (n) {
    function e(e, t) {
      return (
        (t.track = {
          player: e,
          kind: t.kind,
          kinds: t.kinds,
          default: !1,
          mode: "disabled",
        }),
        t.kinds || (t.kinds = [t.kind]),
        t.label
          ? (t.track.label = t.label)
          : (t.track.label = t.kinds.join(" and ") + " off"),
        (t.selectable = !0),
        (t.multiSelectable = !1),
        n.call(this, e, t) || this
      );
    }
    b(e, n);
    var t = e.prototype;
    return (
      (t.handleTracksChange = function (e) {
        for (
          var t = this.player().textTracks(), n = !0, i = 0, r = t.length;
          i < r;
          i++
        ) {
          var a = t[i];
          if (
            -1 < this.options_.kinds.indexOf(a.kind) &&
            "showing" === a.mode
          ) {
            n = !1;
            break;
          }
        }
        n !== this.isSelected_ && this.selected(n);
      }),
      (t.handleSelectedLanguageChange = function (e) {
        for (
          var t = this.player().textTracks(), n = !0, i = 0, r = t.length;
          i < r;
          i++
        ) {
          var a = t[i];
          if (
            -1 < ["captions", "descriptions", "subtitles"].indexOf(a.kind) &&
            "showing" === a.mode
          ) {
            n = !1;
            break;
          }
        }
        n && (this.player_.cache_.selectedLanguage = { enabled: !1 });
      }),
      e
    );
  })(Ii);
  g.registerComponent("OffTextTrackMenuItem", xi);
  a = (function (n) {
    function e(e, t) {
      return (
        ((t = void 0 === t ? {} : t).tracks = e.textTracks()),
        n.call(this, e, t) || this
      );
    }
    return (
      b(e, n),
      (e.prototype.createItems = function (e, t) {
        var n;
        void 0 === t && (t = Ii),
          this.label_ && (n = this.label_ + " off"),
          (e = void 0 === e ? [] : e).push(
            new xi(this.player_, {
              kinds: this.kinds_,
              kind: this.kind_,
              label: n,
            })
          ),
          (this.hideThreshold_ += 1);
        var i = this.player_.textTracks();
        Array.isArray(this.kinds_) || (this.kinds_ = [this.kind_]);
        for (var r = 0; r < i.length; r++) {
          var a,
            s = i[r];
          -1 < this.kinds_.indexOf(s.kind) &&
            ((a = new t(this.player_, {
              track: s,
              kinds: this.kinds_,
              kind: this.kind_,
              selectable: !0,
              multiSelectable: !1,
            })).addClass("vjs-" + s.kind + "-menu-item"),
            e.push(a));
        }
        return e;
      }),
      e
    );
  })(rn);
  g.registerComponent("TextTrackButton", a);
  var Ei = (function (a) {
    function e(e, t) {
      var n = t.track,
        i = t.cue,
        r = e.currentTime();
      return (
        (t.selectable = !0),
        (t.multiSelectable = !1),
        (t.label = i.text),
        (t.selected = i.startTime <= r && r < i.endTime),
        ((t = a.call(this, e, t) || this).track = n),
        (t.cue = i),
        t
      );
    }
    return (
      b(e, a),
      (e.prototype.handleClick = function (e) {
        a.prototype.handleClick.call(this),
          this.player_.currentTime(this.cue.startTime);
      }),
      e
    );
  })(o);
  g.registerComponent("ChaptersTrackMenuItem", Ei);
  t = (function (r) {
    function e(e, t, n) {
      var i = r.call(this, e, t, n) || this;
      return (
        (i.selectCurrentItem_ = function () {
          i.items.forEach(function (e) {
            e.selected(i.track_.activeCues[0] === e.cue);
          });
        }),
        i
      );
    }
    b(e, r);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return "vjs-chapters-button " + r.prototype.buildCSSClass.call(this);
      }),
      (t.buildWrapperCSSClass = function () {
        return (
          "vjs-chapters-button " + r.prototype.buildWrapperCSSClass.call(this)
        );
      }),
      (t.update = function (e) {
        (e && e.track && "chapters" !== e.track.kind) ||
          ((e = this.findChaptersTrack()) !== this.track_
            ? (this.setTrack(e), r.prototype.update.call(this))
            : (!this.items ||
                (e && e.cues && e.cues.length !== this.items.length)) &&
              r.prototype.update.call(this));
      }),
      (t.setTrack = function (e) {
        var t;
        this.track_ !== e &&
          (this.updateHandler_ ||
            (this.updateHandler_ = this.update.bind(this)),
          this.track_ &&
            ((t = this.player_
              .remoteTextTrackEls()
              .getTrackElementByTrack_(this.track_)) &&
              t.removeEventListener("load", this.updateHandler_),
            this.track_.removeEventListener(
              "cuechange",
              this.selectCurrentItem_
            ),
            (this.track_ = null)),
          (this.track_ = e),
          this.track_ &&
            ((this.track_.mode = "hidden"),
            (e = this.player_
              .remoteTextTrackEls()
              .getTrackElementByTrack_(this.track_)) &&
              e.addEventListener("load", this.updateHandler_),
            this.track_.addEventListener(
              "cuechange",
              this.selectCurrentItem_
            )));
      }),
      (t.findChaptersTrack = function () {
        for (
          var e = this.player_.textTracks() || [], t = e.length - 1;
          0 <= t;
          t--
        ) {
          var n = e[t];
          if (n.kind === this.kind_) return n;
        }
      }),
      (t.getMenuCaption = function () {
        return this.track_ && this.track_.label
          ? this.track_.label
          : this.localize(p(this.kind_));
      }),
      (t.createMenu = function () {
        return (
          (this.options_.title = this.getMenuCaption()),
          r.prototype.createMenu.call(this)
        );
      }),
      (t.createItems = function () {
        var e = [];
        if (!this.track_) return e;
        var t = this.track_.cues;
        if (!t) return e;
        for (var n = 0, i = t.length; n < i; n++) {
          var r = t[n],
            r = new Ei(this.player_, { track: this.track_, cue: r });
          e.push(r);
        }
        return e;
      }),
      e
    );
  })(a);
  (t.prototype.kind_ = "chapters"),
    (t.prototype.controlText_ = "Chapters"),
    g.registerComponent("ChaptersButton", t);
  T = (function (a) {
    function e(e, t, n) {
      var n = a.call(this, e, t, n) || this,
        i = e.textTracks(),
        r = u(y(n), n.handleTracksChange);
      return (
        i.addEventListener("change", r),
        n.on("dispose", function () {
          i.removeEventListener("change", r);
        }),
        n
      );
    }
    b(e, a);
    var t = e.prototype;
    return (
      (t.handleTracksChange = function (e) {
        for (
          var t = this.player().textTracks(), n = !1, i = 0, r = t.length;
          i < r;
          i++
        ) {
          var a = t[i];
          if (a.kind !== this.kind_ && "showing" === a.mode) {
            n = !0;
            break;
          }
        }
        n ? this.disable() : this.enable();
      }),
      (t.buildCSSClass = function () {
        return (
          "vjs-descriptions-button " + a.prototype.buildCSSClass.call(this)
        );
      }),
      (t.buildWrapperCSSClass = function () {
        return (
          "vjs-descriptions-button " +
          a.prototype.buildWrapperCSSClass.call(this)
        );
      }),
      e
    );
  })(a);
  (T.prototype.kind_ = "descriptions"),
    (T.prototype.controlText_ = "Descriptions"),
    g.registerComponent("DescriptionsButton", T);
  e = (function (i) {
    function e(e, t, n) {
      return i.call(this, e, t, n) || this;
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return "vjs-subtitles-button " + i.prototype.buildCSSClass.call(this);
      }),
      (t.buildWrapperCSSClass = function () {
        return (
          "vjs-subtitles-button " + i.prototype.buildWrapperCSSClass.call(this)
        );
      }),
      e
    );
  })(a);
  (e.prototype.kind_ = "subtitles"),
    (e.prototype.controlText_ = "Subtitles"),
    g.registerComponent("SubtitlesButton", e);
  var ki = (function (n) {
    function e(e, t) {
      return (
        (t.track = {
          player: e,
          kind: t.kind,
          label: t.kind + " settings",
          selectable: !1,
          default: !1,
          mode: "disabled",
        }),
        (t.selectable = !1),
        (t.name = "CaptionSettingsMenuItem"),
        (e = n.call(this, e, t) || this).addClass("vjs-texttrack-settings"),
        e.controlText(", opens " + t.kind + " settings dialog"),
        e
      );
    }
    return (
      b(e, n),
      (e.prototype.handleClick = function (e) {
        this.player().getChild("textTrackSettings").open();
      }),
      e
    );
  })(Ii);
  g.registerComponent("CaptionSettingsMenuItem", ki);
  _ = (function (i) {
    function e(e, t, n) {
      return i.call(this, e, t, n) || this;
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return "vjs-captions-button " + i.prototype.buildCSSClass.call(this);
      }),
      (t.buildWrapperCSSClass = function () {
        return (
          "vjs-captions-button " + i.prototype.buildWrapperCSSClass.call(this)
        );
      }),
      (t.createItems = function () {
        var e = [];
        return (
          (this.player().tech_ &&
            this.player().tech_.featuresNativeTextTracks) ||
            !this.player().getChild("textTrackSettings") ||
            (e.push(new ki(this.player_, { kind: this.kind_ })),
            (this.hideThreshold_ += 1)),
          i.prototype.createItems.call(this, e)
        );
      }),
      e
    );
  })(a);
  (_.prototype.kind_ = "captions"),
    (_.prototype.controlText_ = "Captions"),
    g.registerComponent("CaptionsButton", _);
  var Pi = (function (i) {
    function e() {
      return i.apply(this, arguments) || this;
    }
    return (
      b(e, i),
      (e.prototype.createEl = function (e, t, n) {
        (t = i.prototype.createEl.call(this, e, t, n)),
          (n = t.querySelector(".vjs-menu-item-text"));
        return (
          "captions" === this.options_.track.kind &&
            (n.appendChild(
              c(
                "span",
                { className: "vjs-icon-placeholder" },
                { "aria-hidden": !0 }
              )
            ),
            n.appendChild(
              c("span", {
                className: "vjs-control-text",
                textContent: " " + this.localize("Captions"),
              })
            )),
          t
        );
      }),
      e
    );
  })(Ii);
  g.registerComponent("SubsCapsMenuItem", Pi);
  v = (function (n) {
    function e(e, t) {
      return (
        ((t = n.call(this, e, (t = void 0 === t ? {} : t)) || this).label_ =
          "subtitles"),
        -1 < ["en", "en-us", "en-ca", "fr-ca"].indexOf(t.player_.language_) &&
          (t.label_ = "captions"),
        t.menuButton_.controlText(p(t.label_)),
        t
      );
    }
    b(e, n);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return "vjs-subs-caps-button " + n.prototype.buildCSSClass.call(this);
      }),
      (t.buildWrapperCSSClass = function () {
        return (
          "vjs-subs-caps-button " + n.prototype.buildWrapperCSSClass.call(this)
        );
      }),
      (t.createItems = function () {
        var e = [];
        return (
          (this.player().tech_ &&
            this.player().tech_.featuresNativeTextTracks) ||
            !this.player().getChild("textTrackSettings") ||
            (e.push(new ki(this.player_, { kind: this.label_ })),
            (this.hideThreshold_ += 1)),
          (e = n.prototype.createItems.call(this, e, Pi))
        );
      }),
      e
    );
  })(a);
  (v.prototype.kinds_ = ["captions", "subtitles"]),
    (v.prototype.controlText_ = "Subtitles"),
    g.registerComponent("SubsCapsButton", v);
  var ji = (function (s) {
    function e(e, t) {
      var i,
        n = t.track,
        r = e.audioTracks();
      (t.label = n.label || n.language || "Unknown"),
        (t.selected = n.enabled),
        ((i = s.call(this, e, t) || this).track = n),
        i.addClass("vjs-" + n.kind + "-menu-item");
      function a() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
          t[n] = arguments[n];
        i.handleTracksChange.apply(y(i), t);
      }
      return (
        r.addEventListener("change", a),
        i.on("dispose", function () {
          r.removeEventListener("change", a);
        }),
        i
      );
    }
    b(e, s);
    var t = e.prototype;
    return (
      (t.createEl = function (e, t, n) {
        (t = s.prototype.createEl.call(this, e, t, n)),
          (n = t.querySelector(".vjs-menu-item-text"));
        return (
          "main-desc" === this.options_.track.kind &&
            (n.appendChild(
              c(
                "span",
                { className: "vjs-icon-placeholder" },
                { "aria-hidden": !0 }
              )
            ),
            n.appendChild(
              c("span", {
                className: "vjs-control-text",
                textContent: " " + this.localize("Descriptions"),
              })
            )),
          t
        );
      }),
      (t.handleClick = function (e) {
        if (
          (s.prototype.handleClick.call(this, e),
          (this.track.enabled = !0),
          this.player_.tech_.featuresNativeAudioTracks)
        )
          for (var t = this.player_.audioTracks(), n = 0; n < t.length; n++) {
            var i = t[n];
            i !== this.track && (i.enabled = i === this.track);
          }
      }),
      (t.handleTracksChange = function (e) {
        this.selected(this.track.enabled);
      }),
      e
    );
  })(o);
  g.registerComponent("AudioTrackMenuItem", ji);
  n = (function (n) {
    function e(e, t) {
      return (
        ((t = void 0 === t ? {} : t).tracks = e.audioTracks()),
        n.call(this, e, t) || this
      );
    }
    b(e, n);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return "vjs-audio-button " + n.prototype.buildCSSClass.call(this);
      }),
      (t.buildWrapperCSSClass = function () {
        return (
          "vjs-audio-button " + n.prototype.buildWrapperCSSClass.call(this)
        );
      }),
      (t.createItems = function (e) {
        void 0 === e && (e = []), (this.hideThreshold_ = 1);
        for (var t = this.player_.audioTracks(), n = 0; n < t.length; n++) {
          var i = t[n];
          e.push(
            new ji(this.player_, {
              track: i,
              selectable: !0,
              multiSelectable: !1,
            })
          );
        }
        return e;
      }),
      e
    );
  })(rn);
  (n.prototype.controlText_ = "Audio Track"),
    g.registerComponent("AudioTrackButton", n);
  var Ni = (function (a) {
    function e(e, t) {
      var n,
        i = t.rate,
        r = parseFloat(i, 10);
      return (
        (t.label = i),
        (t.selected = r === e.playbackRate()),
        (t.selectable = !0),
        (t.multiSelectable = !1),
        ((n = a.call(this, e, t) || this).label = i),
        (n.rate = r),
        n.on(e, "ratechange", function (e) {
          return n.update(e);
        }),
        n
      );
    }
    b(e, a);
    var t = e.prototype;
    return (
      (t.handleClick = function (e) {
        a.prototype.handleClick.call(this),
          this.player().playbackRate(this.rate);
      }),
      (t.update = function (e) {
        this.selected(this.player().playbackRate() === this.rate);
      }),
      e
    );
  })(o);
  (Ni.prototype.contentElType = "button"),
    g.registerComponent("PlaybackRateMenuItem", Ni);
  ie = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this;
      return (
        n.menuButton_.el_.setAttribute("aria-describedby", n.labelElId_),
        n.updateVisibility(),
        n.updateLabel(),
        n.on(e, "loadstart", function (e) {
          return n.updateVisibility(e);
        }),
        n.on(e, "ratechange", function (e) {
          return n.updateLabel(e);
        }),
        n.on(e, "playbackrateschange", function (e) {
          return n.handlePlaybackRateschange(e);
        }),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.createEl = function () {
        var e = i.prototype.createEl.call(this);
        return (
          (this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_),
          (this.labelEl_ = c("div", {
            className: "vjs-playback-rate-value",
            id: this.labelElId_,
            textContent: "1x",
          })),
          e.appendChild(this.labelEl_),
          e
        );
      }),
      (t.dispose = function () {
        (this.labelEl_ = null), i.prototype.dispose.call(this);
      }),
      (t.buildCSSClass = function () {
        return "vjs-playback-rate " + i.prototype.buildCSSClass.call(this);
      }),
      (t.buildWrapperCSSClass = function () {
        return (
          "vjs-playback-rate " + i.prototype.buildWrapperCSSClass.call(this)
        );
      }),
      (t.createItems = function () {
        for (
          var e = this.playbackRates(), t = [], n = e.length - 1;
          0 <= n;
          n--
        )
          t.push(new Ni(this.player(), { rate: e[n] + "x" }));
        return t;
      }),
      (t.updateARIAAttributes = function () {
        this.el().setAttribute("aria-valuenow", this.player().playbackRate());
      }),
      (t.handleClick = function (e) {
        var t = this.player().playbackRate(),
          n = this.playbackRates(),
          t = (n.indexOf(t) + 1) % n.length;
        this.player().playbackRate(n[t]);
      }),
      (t.handlePlaybackRateschange = function (e) {
        this.update();
      }),
      (t.playbackRates = function () {
        var e = this.player();
        return (e.playbackRates && e.playbackRates()) || [];
      }),
      (t.playbackRateSupported = function () {
        return (
          this.player().tech_ &&
          this.player().tech_.featuresPlaybackRate &&
          this.playbackRates() &&
          0 < this.playbackRates().length
        );
      }),
      (t.updateVisibility = function (e) {
        this.playbackRateSupported()
          ? this.removeClass("vjs-hidden")
          : this.addClass("vjs-hidden");
      }),
      (t.updateLabel = function (e) {
        this.playbackRateSupported() &&
          (this.labelEl_.textContent = this.player().playbackRate() + "x");
      }),
      e
    );
  })(nn);
  (ie.prototype.controlText_ = "Playback Rate"),
    g.registerComponent("PlaybackRateMenuButton", ie);
  t = (function (i) {
    function e() {
      return i.apply(this, arguments) || this;
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return "vjs-spacer " + i.prototype.buildCSSClass.call(this);
      }),
      (t.createEl = function (e, t, n) {
        return (
          void 0 === e && (e = "div"),
          void 0 === n && (n = {}),
          (t = void 0 === t ? {} : t).className ||
            (t.className = this.buildCSSClass()),
          i.prototype.createEl.call(this, e, t, n)
        );
      }),
      e
    );
  })(g);
  g.registerComponent("Spacer", t),
    g.registerComponent(
      "CustomControlSpacer",
      (function (e) {
        function t() {
          return e.apply(this, arguments) || this;
        }
        b(t, e);
        var n = t.prototype;
        return (
          (n.buildCSSClass = function () {
            return (
              "vjs-custom-control-spacer " +
              e.prototype.buildCSSClass.call(this)
            );
          }),
          (n.createEl = function () {
            return e.prototype.createEl.call(this, "div", {
              className: this.buildCSSClass(),
              textContent: "Â ",
            });
          }),
          t
        );
      })(t)
    );
  T = (function (e) {
    function t() {
      return e.apply(this, arguments) || this;
    }
    return (
      b(t, e),
      (t.prototype.createEl = function () {
        return e.prototype.createEl.call(this, "div", {
          className: "vjs-control-bar",
          dir: "ltr",
        });
      }),
      t
    );
  })(g);
  (T.prototype.options_ = {
    children: [
      "playToggle",
      "volumePanel",
      "currentTimeDisplay",
      "timeDivider",
      "durationDisplay",
      "progressControl",
      "liveDisplay",
      "seekToLive",
      "remainingTimeDisplay",
      "customControlSpacer",
      "playbackRateMenuButton",
      "chaptersButton",
      "descriptionsButton",
      "subsCapsButton",
      "audioTrackButton",
      "fullscreenToggle",
    ],
  }),
    "exitPictureInPicture" in document &&
      T.prototype.options_.children.splice(
        T.prototype.options_.children.length - 1,
        0,
        "pictureInPictureToggle"
      ),
    g.registerComponent("ControlBar", T);
  e = (function (i) {
    function e(e, t) {
      var n = i.call(this, e, t) || this;
      return (
        n.on(e, "error", function (e) {
          return n.open(e);
        }),
        n
      );
    }
    b(e, i);
    var t = e.prototype;
    return (
      (t.buildCSSClass = function () {
        return "vjs-error-display " + i.prototype.buildCSSClass.call(this);
      }),
      (t.content = function () {
        var e = this.player().error();
        return e ? this.localize(e.message) : "";
      }),
      e
    );
  })(Xt);
  (e.prototype.options_ = Q({}, Xt.prototype.options_, {
    pauseOnOpen: !1,
    fillAlways: !0,
    temporary: !1,
    uncloseable: !0,
  })),
    g.registerComponent("ErrorDisplay", e);
  var Li = "vjs-text-track-settings",
    _ = ["#000", "Black"],
    a = ["#00F", "Blue"],
    v = ["#0FF", "Cyan"],
    rn = ["#0F0", "Green"],
    n = ["#F0F", "Magenta"],
    o = ["#F00", "Red"],
    nn = ["#FFF", "White"],
    ie = ["#FF0", "Yellow"],
    t = ["1", "Opaque"],
    T = ["0.5", "Semi-Transparent"],
    e = ["0", "Transparent"],
    Mi = {
      backgroundColor: {
        selector: ".vjs-bg-color > select",
        id: "captions-background-color-%s",
        label: "Color",
        options: [_, nn, o, rn, a, ie, n, v],
      },
      backgroundOpacity: {
        selector: ".vjs-bg-opacity > select",
        id: "captions-background-opacity-%s",
        label: "Transparency",
        options: [t, T, e],
      },
      color: {
        selector: ".vjs-fg-color > select",
        id: "captions-foreground-color-%s",
        label: "Color",
        options: [nn, _, o, rn, a, ie, n, v],
      },
      edgeStyle: {
        selector: ".vjs-edge-style > select",
        id: "%s",
        label: "Text Edge Style",
        options: [
          ["none", "None"],
          ["raised", "Raised"],
          ["depressed", "Depressed"],
          ["uniform", "Uniform"],
          ["dropshadow", "Dropshadow"],
        ],
      },
      fontFamily: {
        selector: ".vjs-font-family > select",
        id: "captions-font-family-%s",
        label: "Font Family",
        options: [
          ["proportionalSansSerif", "Proportional Sans-Serif"],
          ["monospaceSansSerif", "Monospace Sans-Serif"],
          ["proportionalSerif", "Proportional Serif"],
          ["monospaceSerif", "Monospace Serif"],
          ["casual", "Casual"],
          ["script", "Script"],
          ["small-caps", "Small Caps"],
        ],
      },
      fontPercent: {
        selector: ".vjs-font-percent > select",
        id: "captions-font-size-%s",
        label: "Font Size",
        options: [
          ["0.50", "50%"],
          ["0.75", "75%"],
          ["1.00", "100%"],
          ["1.25", "125%"],
          ["1.50", "150%"],
          ["1.75", "175%"],
          ["2.00", "200%"],
          ["3.00", "300%"],
          ["4.00", "400%"],
        ],
        default: 2,
        parser: function (e) {
          return "1.00" === e ? null : Number(e);
        },
      },
      textOpacity: {
        selector: ".vjs-text-opacity > select",
        id: "captions-foreground-opacity-%s",
        label: "Transparency",
        options: [t, T],
      },
      windowColor: {
        selector: ".vjs-window-color > select",
        id: "captions-window-color-%s",
        label: "Color",
      },
      windowOpacity: {
        selector: ".vjs-window-opacity > select",
        id: "captions-window-opacity-%s",
        label: "Transparency",
        options: [e, T, t],
      },
    };
  function Di(e, t) {
    if ((e = t ? t(e) : e) && "none" !== e) return e;
  }
  (Mi.windowColor.options = Mi.backgroundColor.options),
    g.registerComponent(
      "TextTrackSettings",
      (function (i) {
        function e(e, t) {
          var n;
          return (
            (t.temporary = !1),
            ((n = i.call(this, e, t) || this).updateDisplay =
              n.updateDisplay.bind(y(n))),
            n.fill(),
            (n.hasBeenOpened_ = n.hasBeenFilled_ = !0),
            (n.endDialog = c("p", {
              className: "vjs-control-text",
              textContent: n.localize("End of dialog window."),
            })),
            n.el().appendChild(n.endDialog),
            n.setDefaults(),
            void 0 === t.persistTextTrackSettings &&
              (n.options_.persistTextTrackSettings =
                n.options_.playerOptions.persistTextTrackSettings),
            n.on(n.$(".vjs-done-button"), "click", function () {
              n.saveSettings(), n.close();
            }),
            n.on(n.$(".vjs-default-button"), "click", function () {
              n.setDefaults(), n.updateDisplay();
            }),
            $(Mi, function (e) {
              n.on(n.$(e.selector), "change", n.updateDisplay);
            }),
            n.options_.persistTextTrackSettings && n.restoreSettings(),
            n
          );
        }
        b(e, i);
        var t = e.prototype;
        return (
          (t.dispose = function () {
            (this.endDialog = null), i.prototype.dispose.call(this);
          }),
          (t.createElSelect_ = function (e, t, n) {
            var i = this;
            void 0 === t && (t = ""), void 0 === n && (n = "label");
            var e = Mi[e],
              r = e.id.replace("%s", this.id_),
              a = [t, r].join(" ").trim();
            return [
              "<" +
                n +
                ' id="' +
                r +
                '" class="' +
                ("label" === n ? "vjs-label" : "") +
                '">',
              this.localize(e.label),
              "</" + n + ">",
              '<select aria-labelledby="' + a + '">',
            ]
              .concat(
                e.options.map(function (e) {
                  var t = r + "-" + e[1].replace(/\W+/g, "");
                  return [
                    '<option id="' + t + '" value="' + e[0] + '" ',
                    'aria-labelledby="' + a + " " + t + '">',
                    i.localize(e[1]),
                    "</option>",
                  ].join("");
                })
              )
              .concat("</select>")
              .join("");
          }),
          (t.createElFgColor_ = function () {
            var e = "captions-text-legend-" + this.id_;
            return [
              '<fieldset class="vjs-fg-color vjs-track-setting">',
              '<legend id="' + e + '">',
              this.localize("Text"),
              "</legend>",
              this.createElSelect_("color", e),
              '<span class="vjs-text-opacity vjs-opacity">',
              this.createElSelect_("textOpacity", e),
              "</span>",
              "</fieldset>",
            ].join("");
          }),
          (t.createElBgColor_ = function () {
            var e = "captions-background-" + this.id_;
            return [
              '<fieldset class="vjs-bg-color vjs-track-setting">',
              '<legend id="' + e + '">',
              this.localize("Background"),
              "</legend>",
              this.createElSelect_("backgroundColor", e),
              '<span class="vjs-bg-opacity vjs-opacity">',
              this.createElSelect_("backgroundOpacity", e),
              "</span>",
              "</fieldset>",
            ].join("");
          }),
          (t.createElWinColor_ = function () {
            var e = "captions-window-" + this.id_;
            return [
              '<fieldset class="vjs-window-color vjs-track-setting">',
              '<legend id="' + e + '">',
              this.localize("Window"),
              "</legend>",
              this.createElSelect_("windowColor", e),
              '<span class="vjs-window-opacity vjs-opacity">',
              this.createElSelect_("windowOpacity", e),
              "</span>",
              "</fieldset>",
            ].join("");
          }),
          (t.createElColors_ = function () {
            return c("div", {
              className: "vjs-track-settings-colors",
              innerHTML: [
                this.createElFgColor_(),
                this.createElBgColor_(),
                this.createElWinColor_(),
              ].join(""),
            });
          }),
          (t.createElFont_ = function () {
            return c("div", {
              className: "vjs-track-settings-font",
              innerHTML: [
                '<fieldset class="vjs-font-percent vjs-track-setting">',
                this.createElSelect_("fontPercent", "", "legend"),
                "</fieldset>",
                '<fieldset class="vjs-edge-style vjs-track-setting">',
                this.createElSelect_("edgeStyle", "", "legend"),
                "</fieldset>",
                '<fieldset class="vjs-font-family vjs-track-setting">',
                this.createElSelect_("fontFamily", "", "legend"),
                "</fieldset>",
              ].join(""),
            });
          }),
          (t.createElControls_ = function () {
            var e = this.localize("restore all settings to the default values");
            return c("div", {
              className: "vjs-track-settings-controls",
              innerHTML: [
                '<button type="button" class="vjs-default-button" title="' +
                  e +
                  '">',
                this.localize("Reset"),
                '<span class="vjs-control-text"> ' + e + "</span>",
                "</button>",
                '<button type="button" class="vjs-done-button">' +
                  this.localize("Done") +
                  "</button>",
              ].join(""),
            });
          }),
          (t.content = function () {
            return [
              this.createElColors_(),
              this.createElFont_(),
              this.createElControls_(),
            ];
          }),
          (t.label = function () {
            return this.localize("Caption Settings Dialog");
          }),
          (t.description = function () {
            return this.localize(
              "Beginning of dialog window. Escape will cancel and close the window."
            );
          }),
          (t.buildCSSClass = function () {
            return (
              i.prototype.buildCSSClass.call(this) + " vjs-text-track-settings"
            );
          }),
          (t.getValues = function () {
            var n,
              i,
              e,
              r = this;
            return (
              (i = function (e, t, n) {
                var i,
                  t =
                    ((i = r.$(t.selector)),
                    (t = t.parser),
                    Di(i.options[i.options.selectedIndex].value, t));
                return void 0 !== t && (e[n] = t), e;
              }),
              void 0 === (e = {}) && (e = 0),
              J((n = Mi)).reduce(function (e, t) {
                return i(e, n[t], t);
              }, e)
            );
          }),
          (t.setValues = function (n) {
            var i = this;
            $(Mi, function (e, t) {
              !(function (e, t, n) {
                if (t)
                  for (var i = 0; i < e.options.length; i++)
                    if (Di(e.options[i].value, n) === t) {
                      e.selectedIndex = i;
                      break;
                    }
              })(i.$(e.selector), n[t], e.parser);
            });
          }),
          (t.setDefaults = function () {
            var n = this;
            $(Mi, function (e) {
              var t = e.hasOwnProperty("default") ? e.default : 0;
              n.$(e.selector).selectedIndex = t;
            });
          }),
          (t.restoreSettings = function () {
            var e;
            try {
              e = JSON.parse(window.localStorage.getItem(Li));
            } catch (e) {
              d.warn(e);
            }
            e && this.setValues(e);
          }),
          (t.saveSettings = function () {
            if (this.options_.persistTextTrackSettings) {
              var e = this.getValues();
              try {
                Object.keys(e).length
                  ? window.localStorage.setItem(Li, JSON.stringify(e))
                  : window.localStorage.removeItem(Li);
              } catch (e) {
                d.warn(e);
              }
            }
          }),
          (t.updateDisplay = function () {
            var e = this.player_.getChild("textTrackDisplay");
            e && e.updateDisplay();
          }),
          (t.conditionalBlur_ = function () {
            this.previouslyActiveEl_ = null;
            var e = this.player_.controlBar,
              t = e && e.subsCapsButton,
              e = e && e.captionsButton;
            t ? t.focus() : e && e.focus();
          }),
          e
        );
      })(Xt)
    ),
    g.registerComponent(
      "ResizeManager",
      (function (a) {
        function e(e, t) {
          var n,
            i = t.ResizeObserver || window.ResizeObserver,
            r = m(
              {
                createEl: !(i = null === t.ResizeObserver ? !1 : i),
                reportTouchActivity: !1,
              },
              t
            );
          return (
            ((n = a.call(this, e, r) || this).ResizeObserver =
              t.ResizeObserver || window.ResizeObserver),
            (n.loadListener_ = null),
            (n.resizeObserver_ = null),
            (n.debouncedHandler_ = ft(
              function () {
                n.resizeHandler();
              },
              100,
              !1,
              y(n)
            )),
            i
              ? ((n.resizeObserver_ = new n.ResizeObserver(
                  n.debouncedHandler_
                )),
                n.resizeObserver_.observe(e.el()))
              : ((n.loadListener_ = function () {
                  var e, t;
                  n.el_ &&
                    n.el_.contentWindow &&
                    ((e = n.debouncedHandler_),
                    (t = n.unloadListener_ =
                      function () {
                        l(this, "resize", e), l(this, "unload", t), (t = null);
                      }),
                    ct(n.el_.contentWindow, "unload", t),
                    ct(n.el_.contentWindow, "resize", e));
                }),
                n.one("load", n.loadListener_)),
            n
          );
        }
        b(e, a);
        var t = e.prototype;
        return (
          (t.createEl = function () {
            return a.prototype.createEl.call(
              this,
              "iframe",
              {
                className: "vjs-resize-manager",
                tabIndex: -1,
                title: this.localize("No content"),
              },
              { "aria-hidden": "true" }
            );
          }),
          (t.resizeHandler = function () {
            this.player_ &&
              this.player_.trigger &&
              this.player_.trigger("playerresize");
          }),
          (t.dispose = function () {
            this.debouncedHandler_ && this.debouncedHandler_.cancel(),
              this.resizeObserver_ &&
                (this.player_.el() &&
                  this.resizeObserver_.unobserve(this.player_.el()),
                this.resizeObserver_.disconnect()),
              this.loadListener_ && this.off("load", this.loadListener_),
              this.el_ &&
                this.el_.contentWindow &&
                this.unloadListener_ &&
                this.unloadListener_.call(this.el_.contentWindow),
              (this.ResizeObserver = null),
              (this.resizeObserver = null),
              (this.debouncedHandler_ = null),
              (this.loadListener_ = null),
              a.prototype.dispose.call(this);
          }),
          e
        );
      })(g)
    );
  var Ri = { trackingThreshold: 20, liveTolerance: 15 };
  g.registerComponent(
    "LiveTracker",
    (function (i) {
      function e(e, t) {
        var t = m(Ri, t, { createEl: !1 }),
          n = i.call(this, e, t) || this;
        return (
          (n.handleVisibilityChange_ = function (e) {
            return n.handleVisibilityChange(e);
          }),
          (n.trackLiveHandler_ = function () {
            return n.trackLive_();
          }),
          (n.handlePlay_ = function (e) {
            return n.handlePlay(e);
          }),
          (n.handleFirstTimeupdate_ = function (e) {
            return n.handleFirstTimeupdate(e);
          }),
          (n.handleSeeked_ = function (e) {
            return n.handleSeeked(e);
          }),
          (n.seekToLiveEdge_ = function (e) {
            return n.seekToLiveEdge(e);
          }),
          n.reset_(),
          n.on(n.player_, "durationchange", function (e) {
            return n.handleDurationchange(e);
          }),
          n.on(n.player_, "canplay", function () {
            return n.toggleTracking();
          }),
          de &&
            "hidden" in document &&
            "visibilityState" in document &&
            n.on(document, "visibilitychange", n.handleVisibilityChange_),
          n
        );
      }
      b(e, i);
      var t = e.prototype;
      return (
        (t.handleVisibilityChange = function () {
          this.player_.duration() === 1 / 0 &&
            (document.hidden ? this.stopTracking() : this.startTracking());
        }),
        (t.trackLive_ = function () {
          var e,
            t = this.player_.seekable();
          t &&
            t.length &&
            ((e = Number(window.performance.now().toFixed(4))),
            (t = -1 === this.lastTime_ ? 0 : (e - this.lastTime_) / 1e3),
            (this.lastTime_ = e),
            (this.pastSeekEnd_ = this.pastSeekEnd() + t),
            (e = this.liveCurrentTime()),
            (t = this.player_.currentTime()),
            (t =
              this.player_.paused() ||
              this.seekedBehindLive_ ||
              Math.abs(e - t) > this.options_.liveTolerance),
            (t = !this.timeupdateSeen_ || e === 1 / 0 ? !1 : t) !==
              this.behindLiveEdge_ &&
              ((this.behindLiveEdge_ = t), this.trigger("liveedgechange")));
        }),
        (t.handleDurationchange = function () {
          this.toggleTracking();
        }),
        (t.toggleTracking = function () {
          this.player_.duration() === 1 / 0 &&
          this.liveWindow() >= this.options_.trackingThreshold
            ? (this.player_.options_.liveui &&
                this.player_.addClass("vjs-liveui"),
              this.startTracking())
            : (this.player_.removeClass("vjs-liveui"), this.stopTracking());
        }),
        (t.startTracking = function () {
          this.isTracking() ||
            (this.timeupdateSeen_ ||
              (this.timeupdateSeen_ = this.player_.hasStarted()),
            (this.trackingInterval_ = this.setInterval(
              this.trackLiveHandler_,
              30
            )),
            this.trackLive_(),
            this.on(this.player_, ["play", "pause"], this.trackLiveHandler_),
            this.timeupdateSeen_
              ? this.on(this.player_, "seeked", this.handleSeeked_)
              : (this.one(this.player_, "play", this.handlePlay_),
                this.one(
                  this.player_,
                  "timeupdate",
                  this.handleFirstTimeupdate_
                )));
        }),
        (t.handleFirstTimeupdate = function () {
          (this.timeupdateSeen_ = !0),
            this.on(this.player_, "seeked", this.handleSeeked_);
        }),
        (t.handleSeeked = function () {
          var e = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
          (this.seekedBehindLive_ = this.nextSeekedFromUser_ && 2 < e),
            (this.nextSeekedFromUser_ = !1),
            this.trackLive_();
        }),
        (t.handlePlay = function () {
          this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
        }),
        (t.reset_ = function () {
          (this.lastTime_ = -1),
            (this.pastSeekEnd_ = 0),
            (this.lastSeekEnd_ = -1),
            (this.behindLiveEdge_ = !0),
            (this.timeupdateSeen_ = !1),
            (this.seekedBehindLive_ = !1),
            (this.nextSeekedFromUser_ = !1),
            this.clearInterval(this.trackingInterval_),
            (this.trackingInterval_ = null),
            this.off(this.player_, ["play", "pause"], this.trackLiveHandler_),
            this.off(this.player_, "seeked", this.handleSeeked_),
            this.off(this.player_, "play", this.handlePlay_),
            this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_),
            this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
        }),
        (t.nextSeekedFromUser = function () {
          this.nextSeekedFromUser_ = !0;
        }),
        (t.stopTracking = function () {
          this.isTracking() && (this.reset_(), this.trigger("liveedgechange"));
        }),
        (t.seekableEnd = function () {
          for (
            var e = this.player_.seekable(), t = [], n = e ? e.length : 0;
            n--;

          )
            t.push(e.end(n));
          return t.length ? t.sort()[t.length - 1] : 1 / 0;
        }),
        (t.seekableStart = function () {
          for (
            var e = this.player_.seekable(), t = [], n = e ? e.length : 0;
            n--;

          )
            t.push(e.start(n));
          return t.length ? t.sort()[0] : 0;
        }),
        (t.liveWindow = function () {
          var e = this.liveCurrentTime();
          return e === 1 / 0 ? 0 : e - this.seekableStart();
        }),
        (t.isLive = function () {
          return this.isTracking();
        }),
        (t.atLiveEdge = function () {
          return !this.behindLiveEdge();
        }),
        (t.liveCurrentTime = function () {
          return this.pastSeekEnd() + this.seekableEnd();
        }),
        (t.pastSeekEnd = function () {
          var e = this.seekableEnd();
          return (
            -1 !== this.lastSeekEnd_ &&
              e !== this.lastSeekEnd_ &&
              (this.pastSeekEnd_ = 0),
            (this.lastSeekEnd_ = e),
            this.pastSeekEnd_
          );
        }),
        (t.behindLiveEdge = function () {
          return this.behindLiveEdge_;
        }),
        (t.isTracking = function () {
          return "number" == typeof this.trackingInterval_;
        }),
        (t.seekToLiveEdge = function () {
          (this.seekedBehindLive_ = !1),
            this.atLiveEdge() ||
              ((this.nextSeekedFromUser_ = !1),
              this.player_.currentTime(this.liveCurrentTime()));
        }),
        (t.dispose = function () {
          this.off(document, "visibilitychange", this.handleVisibilityChange_),
            this.stopTracking(),
            i.prototype.dispose.call(this);
        }),
        e
      );
    })(g)
  );
  function Bi(e) {
    if ((i = e.el()).hasAttribute("src")) return e.triggerSourceset(i.src), 1;
    var t = e.$$("source"),
      n = [],
      i = "";
    if (t.length) {
      for (var r = 0; r < t.length; r++) {
        var a = t[r].src;
        a && -1 === n.indexOf(a) && n.push(a);
      }
      return (
        !!n.length && (1 === n.length && (i = n[0]), e.triggerSourceset(i), !0)
      );
    }
  }
  function Ui(e, t) {
    for (
      var n = {}, i = 0;
      i < e.length &&
      !((n = Object.getOwnPropertyDescriptor(e[i], t)) && n.set && n.get);
      i++
    );
    return (n.enumerable = !0), (n.configurable = !0), n;
  }
  function Vi(a) {
    var t,
      e,
      n,
      s = a.el();
    s.resetSourceWatch_ ||
      ((t = {}),
      (e = Ui(
        [
          a.el(),
          window.HTMLMediaElement.prototype,
          window.Element.prototype,
          zi,
        ],
        "innerHTML"
      )),
      (n = function (r) {
        return function () {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          var i = r.apply(s, t);
          return Bi(a), i;
        };
      }),
      ["append", "appendChild", "insertAdjacentHTML"].forEach(function (e) {
        s[e] && ((t[e] = s[e]), (s[e] = n(t[e])));
      }),
      Object.defineProperty(s, "innerHTML", m(e, { set: n(e.set) })),
      (s.resetSourceWatch_ = function () {
        (s.resetSourceWatch_ = null),
          Object.keys(t).forEach(function (e) {
            s[e] = t[e];
          }),
          Object.defineProperty(s, "innerHTML", e);
      }),
      a.one("sourceset", s.resetSourceWatch_));
  }
  function Fi(n) {
    var i, t, r, a;
    n.featuresSourceset &&
      ((i = n.el()).resetSourceset_ ||
        ((t = Ui([n.el(), window.HTMLMediaElement.prototype, Hi], "src")),
        (r = i.setAttribute),
        (a = i.load),
        Object.defineProperty(
          i,
          "src",
          m(t, {
            set: function (e) {
              e = t.set.call(i, e);
              return n.triggerSourceset(i.src), e;
            },
          })
        ),
        (i.setAttribute = function (e, t) {
          t = r.call(i, e, t);
          return /src/i.test(e) && n.triggerSourceset(i.src), t;
        }),
        (i.load = function () {
          var e = a.call(i);
          return Bi(n) || (n.triggerSourceset(""), Vi(n)), e;
        }),
        i.currentSrc ? n.triggerSourceset(i.currentSrc) : Bi(n) || Vi(n),
        (i.resetSourceset_ = function () {
          (i.resetSourceset_ = null),
            (i.load = a),
            (i.setAttribute = r),
            Object.defineProperty(i, "src", t),
            i.resetSourceWatch_ && i.resetSourceWatch_();
        })));
  }
  function Gi(t, n, i, e) {
    function r(e) {
      return Object.defineProperty(t, n, {
        value: e,
        enumerable: !0,
        writable: !0,
      });
    }
    var a = {
      configurable: !0,
      enumerable: !0,
      get: function () {
        var e = i();
        return r(e), e;
      },
    };
    return (
      (e = void 0 === e ? !0 : e) && (a.set = r), Object.defineProperty(t, n, a)
    );
  }
  var qi,
    zi = Object.defineProperty({}, "innerHTML", {
      get: function () {
        return this.cloneNode(!0).innerHTML;
      },
      set: function (e) {
        var t = document.createElement(this.nodeName.toLowerCase());
        t.innerHTML = e;
        for (var n = document.createDocumentFragment(); t.childNodes.length; )
          n.appendChild(t.childNodes[0]);
        return (
          (this.innerText = ""),
          window.Element.prototype.appendChild.call(this, n),
          this.innerHTML
        );
      },
    }),
    Hi = Object.defineProperty({}, "src", {
      get: function () {
        return this.hasAttribute("src")
          ? $t(window.Element.prototype.getAttribute.call(this, "src"))
          : "";
      },
      set: function (e) {
        return window.Element.prototype.setAttribute.call(this, "src", e), e;
      },
    }),
    S = (function (u) {
      function s(e, t) {
        var n = u.call(this, e, t) || this,
          t = e.source,
          i = !1;
        if (
          ((n.featuresVideoFrameCallback =
            n.featuresVideoFrameCallback && "VIDEO" === n.el_.tagName),
          t &&
          (n.el_.currentSrc !== t.src ||
            (e.tag && 3 === e.tag.initNetworkState_))
            ? n.setSource(t)
            : n.handleLateInit_(n.el_),
          e.enableSourceset && n.setupSourcesetHandling_(),
          (n.isScrubbing_ = !1),
          n.el_.hasChildNodes())
        ) {
          for (var r = n.el_.childNodes, a = r.length, s = []; a--; ) {
            var o = r[a];
            "track" === o.nodeName.toLowerCase() &&
              (n.featuresNativeTextTracks
                ? (n.remoteTextTrackEls().addTrackElement_(o),
                  n.remoteTextTracks().addTrack(o.track),
                  n.textTracks().addTrack(o.track),
                  i ||
                    n.el_.hasAttribute("crossorigin") ||
                    !tn(o.src) ||
                    (i = !0))
                : s.push(o));
          }
          for (var l = 0; l < s.length; l++) n.el_.removeChild(s[l]);
        }
        return (
          n.proxyNativeTracks_(),
          n.featuresNativeTextTracks &&
            i &&
            d.warn(
              "Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\nThis may prevent text tracks from loading."
            ),
          n.restoreMetadataTracksInIOSNativePlayer_(),
          (me || fe || se) &&
            !0 === e.nativeControlsForTouch &&
            n.setControls(!0),
          n.proxyWebkitFullscreen_(),
          n.triggerReady(),
          n
        );
      }
      b(s, u);
      var e = s.prototype;
      return (
        (e.dispose = function () {
          this.el_ && this.el_.resetSourceset_ && this.el_.resetSourceset_(),
            s.disposeMediaElement(this.el_),
            (this.options_ = null),
            u.prototype.dispose.call(this);
        }),
        (e.setupSourcesetHandling_ = function () {
          Fi(this);
        }),
        (e.restoreMetadataTracksInIOSNativePlayer_ = function () {
          function e() {
            n = [];
            for (var e = 0; e < i.length; e++) {
              var t = i[e];
              "metadata" === t.kind && n.push({ track: t, storedMode: t.mode });
            }
          }
          var n,
            i = this.textTracks();
          e(),
            i.addEventListener("change", e),
            this.on("dispose", function () {
              return i.removeEventListener("change", e);
            });
          function r() {
            for (var e = 0; e < n.length; e++) {
              var t = n[e];
              "disabled" === t.track.mode &&
                t.track.mode !== t.storedMode &&
                (t.track.mode = t.storedMode);
            }
            i.removeEventListener("change", r);
          }
          this.on("webkitbeginfullscreen", function () {
            i.removeEventListener("change", e),
              i.removeEventListener("change", r),
              i.addEventListener("change", r);
          }),
            this.on("webkitendfullscreen", function () {
              i.removeEventListener("change", e),
                i.addEventListener("change", e),
                i.removeEventListener("change", r);
            });
        }),
        (e.overrideNative_ = function (e, t) {
          var n,
            i = this;
          t === this["featuresNative" + e + "Tracks"] &&
            (this[(n = e.toLowerCase()) + "TracksListeners_"] &&
              Object.keys(this[n + "TracksListeners_"]).forEach(function (e) {
                i.el()[n + "Tracks"].removeEventListener(
                  e,
                  i[n + "TracksListeners_"][e]
                );
              }),
            (this["featuresNative" + e + "Tracks"] = !t),
            (this[n + "TracksListeners_"] = null),
            this.proxyNativeTracksForType_(n));
        }),
        (e.overrideNativeAudioTracks = function (e) {
          this.overrideNative_("Audio", e);
        }),
        (e.overrideNativeVideoTracks = function (e) {
          this.overrideNative_("Video", e);
        }),
        (e.proxyNativeTracksForType_ = function (n) {
          var e,
            t,
            i = this,
            r = On[n],
            a = this.el()[r.getterName],
            s = this[r.getterName]();
          this["featuresNative" + r.capitalName + "Tracks"] &&
            a &&
            a.addEventListener &&
            ((t = function () {
              for (var e = [], t = 0; t < s.length; t++) {
                for (var n = !1, i = 0; i < a.length; i++)
                  if (a[i] === s[t]) {
                    n = !0;
                    break;
                  }
                n || e.push(s[t]);
              }
              for (; e.length; ) s.removeTrack(e.shift());
            }),
            (this[r.getterName + "Listeners_"] = e =
              {
                change: function (e) {
                  var t = {
                    type: "change",
                    target: s,
                    currentTarget: s,
                    srcElement: s,
                  };
                  s.trigger(t),
                    "text" === n && i[Sn.remoteText.getterName]().trigger(t);
                },
                addtrack: function (e) {
                  s.addTrack(e.track);
                },
                removetrack: function (e) {
                  s.removeTrack(e.track);
                },
              }),
            Object.keys(e).forEach(function (t) {
              var n = e[t];
              a.addEventListener(t, n),
                i.on("dispose", function (e) {
                  return a.removeEventListener(t, n);
                });
            }),
            this.on("loadstart", t),
            this.on("dispose", function (e) {
              return i.off("loadstart", t);
            }));
        }),
        (e.proxyNativeTracks_ = function () {
          var t = this;
          On.names.forEach(function (e) {
            t.proxyNativeTracksForType_(e);
          });
        }),
        (e.createEl = function () {
          var e,
            t = this.options_.tag;
          (t &&
            (this.options_.playerElIngest || this.movingMediaElementInDOM)) ||
            (t
              ? ((e = t.cloneNode(!0)),
                t.parentNode && t.parentNode.insertBefore(e, t),
                s.disposeMediaElement(t),
                (t = e))
              : ((t = document.createElement("video")),
                (e = m({}, this.options_.tag && Pe(this.options_.tag))),
                (me && !0 === this.options_.nativeControlsForTouch) ||
                  delete e.controls,
                ke(t, h(e, { id: this.options_.techId, class: "vjs-tech" }))),
            (t.playerId = this.options_.playerId)),
            "undefined" != typeof this.options_.preload &&
              Ne(t, "preload", this.options_.preload),
            void 0 !== this.options_.disablePictureInPicture &&
              (t.disablePictureInPicture =
                this.options_.disablePictureInPicture);
          for (
            var n = ["loop", "muted", "playsinline", "autoplay"], i = 0;
            i < n.length;
            i++
          ) {
            var r = n[i],
              a = this.options_[r];
            "undefined" != typeof a && (a ? Ne(t, r, r) : Le(t, r), (t[r] = a));
          }
          return t;
        }),
        (e.handleLateInit_ = function (e) {
          if (0 !== e.networkState && 3 !== e.networkState) {
            if (0 === e.readyState) {
              var t = !1,
                n = function () {
                  t = !0;
                };
              this.on("loadstart", n);
              var i = function () {
                t || this.trigger("loadstart");
              };
              return (
                this.on("loadedmetadata", i),
                void this.ready(function () {
                  this.off("loadstart", n),
                    this.off("loadedmetadata", i),
                    t || this.trigger("loadstart");
                })
              );
            }
            var r = ["loadstart"];
            r.push("loadedmetadata"),
              2 <= e.readyState && r.push("loadeddata"),
              3 <= e.readyState && r.push("canplay"),
              4 <= e.readyState && r.push("canplaythrough"),
              this.ready(function () {
                r.forEach(function (e) {
                  this.trigger(e);
                }, this);
              });
          }
        }),
        (e.setScrubbing = function (e) {
          this.isScrubbing_ = e;
        }),
        (e.scrubbing = function () {
          return this.isScrubbing_;
        }),
        (e.setCurrentTime = function (e) {
          try {
            this.isScrubbing_ && this.el_.fastSeek && be
              ? this.el_.fastSeek(e)
              : (this.el_.currentTime = e);
          } catch (e) {
            d(e, "Video is not ready. (Video.js)");
          }
        }),
        (e.duration = function () {
          var t = this;
          return this.el_.duration === 1 / 0 &&
            re &&
            ue &&
            0 === this.el_.currentTime
            ? (this.on("timeupdate", function e() {
                0 < t.el_.currentTime &&
                  (t.el_.duration === 1 / 0 && t.trigger("durationchange"),
                  t.off("timeupdate", e));
              }),
              NaN)
            : this.el_.duration || NaN;
        }),
        (e.width = function () {
          return this.el_.offsetWidth;
        }),
        (e.height = function () {
          return this.el_.offsetHeight;
        }),
        (e.proxyWebkitFullscreen_ = function () {
          var e,
            t,
            n = this;
          "webkitDisplayingFullscreen" in this.el_ &&
            ((e = function () {
              this.trigger("fullscreenchange", { isFullscreen: !1 }),
                this.el_.controls &&
                  !this.options_.nativeControlsForTouch &&
                  this.controls() &&
                  (this.el_.controls = !1);
            }),
            (t = function () {
              "webkitPresentationMode" in this.el_ &&
                "picture-in-picture" !== this.el_.webkitPresentationMode &&
                (this.one("webkitendfullscreen", e),
                this.trigger("fullscreenchange", {
                  isFullscreen: !0,
                  nativeIOSFullscreen: !0,
                }));
            }),
            this.on("webkitbeginfullscreen", t),
            this.on("dispose", function () {
              n.off("webkitbeginfullscreen", t),
                n.off("webkitendfullscreen", e);
            }));
        }),
        (e.supportsFullScreen = function () {
          if ("function" == typeof this.el_.webkitEnterFullScreen) {
            var e = (window.navigator && window.navigator.userAgent) || "";
            if (/Android/.test(e) || !/Chrome|Mac OS X 10.5/.test(e)) return !0;
          }
          return !1;
        }),
        (e.enterFullScreen = function () {
          var e = this.el_;
          if (e.paused && e.networkState <= e.HAVE_METADATA)
            Gt(this.el_.play()),
              this.setTimeout(function () {
                e.pause();
                try {
                  e.webkitEnterFullScreen();
                } catch (e) {
                  this.trigger("fullscreenerror", e);
                }
              }, 0);
          else
            try {
              e.webkitEnterFullScreen();
            } catch (e) {
              this.trigger("fullscreenerror", e);
            }
        }),
        (e.exitFullScreen = function () {
          this.el_.webkitDisplayingFullscreen
            ? this.el_.webkitExitFullScreen()
            : this.trigger(
                "fullscreenerror",
                new Error("The video is not fullscreen")
              );
        }),
        (e.requestPictureInPicture = function () {
          return this.el_.requestPictureInPicture();
        }),
        (e.requestVideoFrameCallback = function (e) {
          return this.featuresVideoFrameCallback && !this.el_.webkitKeys
            ? this.el_.requestVideoFrameCallback(e)
            : u.prototype.requestVideoFrameCallback.call(this, e);
        }),
        (e.cancelVideoFrameCallback = function (e) {
          this.featuresVideoFrameCallback && !this.el_.webkitKeys
            ? this.el_.cancelVideoFrameCallback(e)
            : u.prototype.cancelVideoFrameCallback.call(this, e);
        }),
        (e.src = function (e) {
          if (void 0 === e) return this.el_.src;
          this.setSrc(e);
        }),
        (e.reset = function () {
          s.resetMediaElement(this.el_);
        }),
        (e.currentSrc = function () {
          return this.currentSource_
            ? this.currentSource_.src
            : this.el_.currentSrc;
        }),
        (e.setControls = function (e) {
          this.el_.controls = !!e;
        }),
        (e.addTextTrack = function (e, t, n) {
          return this.featuresNativeTextTracks
            ? this.el_.addTextTrack(e, t, n)
            : u.prototype.addTextTrack.call(this, e, t, n);
        }),
        (e.createRemoteTextTrack = function (e) {
          if (!this.featuresNativeTextTracks)
            return u.prototype.createRemoteTextTrack.call(this, e);
          var t = document.createElement("track");
          return (
            e.kind && (t.kind = e.kind),
            e.label && (t.label = e.label),
            (e.language || e.srclang) && (t.srclang = e.language || e.srclang),
            e.default && (t.default = e.default),
            e.id && (t.id = e.id),
            e.src && (t.src = e.src),
            t
          );
        }),
        (e.addRemoteTextTrack = function (e, t) {
          t = u.prototype.addRemoteTextTrack.call(this, e, t);
          return this.featuresNativeTextTracks && this.el().appendChild(t), t;
        }),
        (e.removeRemoteTextTrack = function (e) {
          if (
            (u.prototype.removeRemoteTextTrack.call(this, e),
            this.featuresNativeTextTracks)
          )
            for (var t = this.$$("track"), n = t.length; n--; )
              (e !== t[n] && e !== t[n].track) || this.el().removeChild(t[n]);
        }),
        (e.getVideoPlaybackQuality = function () {
          if ("function" == typeof this.el().getVideoPlaybackQuality)
            return this.el().getVideoPlaybackQuality();
          var e = {};
          return (
            "undefined" != typeof this.el().webkitDroppedFrameCount &&
              "undefined" != typeof this.el().webkitDecodedFrameCount &&
              ((e.droppedVideoFrames = this.el().webkitDroppedFrameCount),
              (e.totalVideoFrames = this.el().webkitDecodedFrameCount)),
            window.performance && "function" == typeof window.performance.now
              ? (e.creationTime = window.performance.now())
              : window.performance &&
                window.performance.timing &&
                "number" == typeof window.performance.timing.navigationStart &&
                (e.creationTime =
                  window.Date.now() -
                  window.performance.timing.navigationStart),
            e
          );
        }),
        s
      );
    })(O);
  Gi(S, "TEST_VID", function () {
    if (_e()) {
      var e = document.createElement("video"),
        t = document.createElement("track");
      return (
        (t.kind = "captions"),
        (t.srclang = "en"),
        (t.label = "English"),
        e.appendChild(t),
        e
      );
    }
  }),
    (S.isSupported = function () {
      try {
        S.TEST_VID.volume = 0.5;
      } catch (e) {
        return !1;
      }
      return !(!S.TEST_VID || !S.TEST_VID.canPlayType);
    }),
    (S.canPlayType = function (e) {
      return S.TEST_VID.canPlayType(e);
    }),
    (S.canPlaySource = function (e, t) {
      return S.canPlayType(e.type);
    }),
    (S.canControlVolume = function () {
      try {
        var e = S.TEST_VID.volume;
        S.TEST_VID.volume = e / 2 + 0.1;
        var t = e !== S.TEST_VID.volume;
        return t && ge
          ? (window.setTimeout(function () {
              S &&
                S.prototype &&
                (S.prototype.featuresVolumeControl = e !== S.TEST_VID.volume);
            }),
            !1)
          : t;
      } catch (e) {
        return !1;
      }
    }),
    (S.canMuteVolume = function () {
      try {
        var e = S.TEST_VID.muted;
        return (
          (S.TEST_VID.muted = !e),
          S.TEST_VID.muted
            ? Ne(S.TEST_VID, "muted", "muted")
            : Le(S.TEST_VID, "muted"),
          e !== S.TEST_VID.muted
        );
      } catch (e) {
        return !1;
      }
    }),
    (S.canControlPlaybackRate = function () {
      if (re && ue && ce < 58) return !1;
      try {
        var e = S.TEST_VID.playbackRate;
        return (
          (S.TEST_VID.playbackRate = e / 2 + 0.1), e !== S.TEST_VID.playbackRate
        );
      } catch (e) {
        return !1;
      }
    }),
    (S.canOverrideAttributes = function () {
      try {
        var e = function () {};
        Object.defineProperty(document.createElement("video"), "src", {
          get: e,
          set: e,
        }),
          Object.defineProperty(document.createElement("audio"), "src", {
            get: e,
            set: e,
          }),
          Object.defineProperty(document.createElement("video"), "innerHTML", {
            get: e,
            set: e,
          }),
          Object.defineProperty(document.createElement("audio"), "innerHTML", {
            get: e,
            set: e,
          });
      } catch (e) {
        return !1;
      }
      return !0;
    }),
    (S.supportsNativeTextTracks = function () {
      return be || (ge && ue);
    }),
    (S.supportsNativeVideoTracks = function () {
      return !(!S.TEST_VID || !S.TEST_VID.videoTracks);
    }),
    (S.supportsNativeAudioTracks = function () {
      return !(!S.TEST_VID || !S.TEST_VID.audioTracks);
    }),
    (S.Events = [
      "loadstart",
      "suspend",
      "abort",
      "error",
      "emptied",
      "stalled",
      "loadedmetadata",
      "loadeddata",
      "canplay",
      "canplaythrough",
      "playing",
      "waiting",
      "seeking",
      "seeked",
      "ended",
      "durationchange",
      "timeupdate",
      "progress",
      "play",
      "pause",
      "ratechange",
      "resize",
      "volumechange",
    ]),
    [
      ["featuresMuteControl", "canMuteVolume"],
      ["featuresPlaybackRate", "canControlPlaybackRate"],
      ["featuresSourceset", "canOverrideAttributes"],
      ["featuresNativeTextTracks", "supportsNativeTextTracks"],
      ["featuresNativeVideoTracks", "supportsNativeVideoTracks"],
      ["featuresNativeAudioTracks", "supportsNativeAudioTracks"],
    ].forEach(function (e) {
      var t = e[0],
        n = e[1];
      Gi(
        S.prototype,
        t,
        function () {
          return S[n]();
        },
        !0
      );
    }),
    (S.prototype.featuresVolumeControl = S.canControlVolume()),
    (S.prototype.movingMediaElementInDOM = !ge),
    (S.prototype.featuresFullscreenResize = !0),
    (S.prototype.featuresProgressEvents = !0),
    (S.prototype.featuresTimeupdateEvents = !0),
    (S.prototype.featuresVideoFrameCallback = !(
      !S.TEST_VID || !S.TEST_VID.requestVideoFrameCallback
    )),
    (S.patchCanPlayType = function () {
      4 <= ae &&
        !oe &&
        !ue &&
        ((qi = S.TEST_VID && S.TEST_VID.constructor.prototype.canPlayType),
        (S.TEST_VID.constructor.prototype.canPlayType = function (e) {
          return e && /^application\/(?:x-|vnd\.apple\.)mpegurl/i.test(e)
            ? "maybe"
            : qi.call(this, e);
        }));
    }),
    (S.unpatchCanPlayType = function () {
      var e = S.TEST_VID.constructor.prototype.canPlayType;
      return qi && (S.TEST_VID.constructor.prototype.canPlayType = qi), e;
    }),
    S.patchCanPlayType(),
    (S.disposeMediaElement = function (e) {
      if (e) {
        for (e.parentNode && e.parentNode.removeChild(e); e.hasChildNodes(); )
          e.removeChild(e.firstChild);
        e.removeAttribute("src"),
          "function" == typeof e.load &&
            (function () {
              try {
                e.load();
              } catch (e) {}
            })();
      }
    }),
    (S.resetMediaElement = function (e) {
      if (e) {
        for (var t = e.querySelectorAll("source"), n = t.length; n--; )
          e.removeChild(t[n]);
        e.removeAttribute("src"),
          "function" == typeof e.load &&
            (function () {
              try {
                e.load();
              } catch (e) {}
            })();
      }
    }),
    [
      "muted",
      "defaultMuted",
      "autoplay",
      "controls",
      "loop",
      "playsinline",
    ].forEach(function (e) {
      S.prototype[e] = function () {
        return this.el_[e] || this.el_.hasAttribute(e);
      };
    }),
    ["muted", "defaultMuted", "autoplay", "loop", "playsinline"].forEach(
      function (t) {
        S.prototype["set" + p(t)] = function (e) {
          (this.el_[t] = e)
            ? this.el_.setAttribute(t, t)
            : this.el_.removeAttribute(t);
        };
      }
    ),
    [
      "paused",
      "currentTime",
      "buffered",
      "volume",
      "poster",
      "preload",
      "error",
      "seeking",
      "seekable",
      "ended",
      "playbackRate",
      "defaultPlaybackRate",
      "disablePictureInPicture",
      "played",
      "networkState",
      "readyState",
      "videoWidth",
      "videoHeight",
      "crossOrigin",
    ].forEach(function (e) {
      S.prototype[e] = function () {
        return this.el_[e];
      };
    }),
    [
      "volume",
      "src",
      "poster",
      "preload",
      "playbackRate",
      "defaultPlaybackRate",
      "disablePictureInPicture",
      "crossOrigin",
    ].forEach(function (t) {
      S.prototype["set" + p(t)] = function (e) {
        this.el_[t] = e;
      };
    }),
    ["pause", "load", "play"].forEach(function (e) {
      S.prototype[e] = function () {
        return this.el_[e]();
      };
    }),
    O.withSourceHandlers(S),
    (S.nativeSourceHandler = {}),
    (S.nativeSourceHandler.canPlayType = function (e) {
      try {
        return S.TEST_VID.canPlayType(e);
      } catch (e) {
        return "";
      }
    }),
    (S.nativeSourceHandler.canHandleSource = function (e, t) {
      if (e.type) return S.nativeSourceHandler.canPlayType(e.type);
      if (e.src) {
        e = en(e.src);
        return S.nativeSourceHandler.canPlayType("video/" + e);
      }
      return "";
    }),
    (S.nativeSourceHandler.handleSource = function (e, t, n) {
      t.setSrc(e.src);
    }),
    (S.nativeSourceHandler.dispose = function () {}),
    S.registerSourceHandler(S.nativeSourceHandler),
    O.registerTech("Html5", S);
  var Wi = [
      "progress",
      "abort",
      "suspend",
      "emptied",
      "stalled",
      "loadedmetadata",
      "loadeddata",
      "timeupdate",
      "resize",
      "volumechange",
      "texttrackchange",
    ],
    Xi = {
      canplay: "CanPlay",
      canplaythrough: "CanPlayThrough",
      playing: "Playing",
      seeked: "Seeked",
    },
    Yi = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"],
    Ki = {};
  Yi.forEach(function (e) {
    var t = "x" === e.charAt(0) ? "x-" + e.substring(1) : e;
    Ki[e] = "vjs-layout-" + t;
  });
  var Qi = {
      tiny: 210,
      xsmall: 320,
      small: 425,
      medium: 768,
      large: 1440,
      xlarge: 2560,
      huge: 1 / 0,
    },
    A = (function (c) {
      function o(e, t, n) {
        var i, r;
        if (
          ((e.id = e.id || t.id || "vjs_video_" + nt++),
          ((t = h(o.getTagSettings(e), t)).initChildren = !1),
          (t.createEl = !1),
          (t.evented = !1),
          (t.reportTouchActivity = !1),
          !t.language)
        )
          if ("function" == typeof e.closest) {
            var a = e.closest("[lang]");
            a && a.getAttribute && (t.language = a.getAttribute("lang"));
          } else
            for (var s = e; s && 1 === s.nodeType; ) {
              if (Pe(s).hasOwnProperty("lang")) {
                t.language = s.getAttribute("lang");
                break;
              }
              s = s.parentNode;
            }
        if (
          (((i =
            c.call(this, null, t, n) || this).boundDocumentFullscreenChange_ =
            function (e) {
              return i.documentFullscreenChange_(e);
            }),
          (i.boundFullWindowOnEscKey_ = function (e) {
            return i.fullWindowOnEscKey(e);
          }),
          (i.boundUpdateStyleEl_ = function (e) {
            return i.updateStyleEl_(e);
          }),
          (i.boundApplyInitTime_ = function (e) {
            return i.applyInitTime_(e);
          }),
          (i.boundUpdateCurrentBreakpoint_ = function (e) {
            return i.updateCurrentBreakpoint_(e);
          }),
          (i.boundHandleTechClick_ = function (e) {
            return i.handleTechClick_(e);
          }),
          (i.boundHandleTechDoubleClick_ = function (e) {
            return i.handleTechDoubleClick_(e);
          }),
          (i.boundHandleTechTouchStart_ = function (e) {
            return i.handleTechTouchStart_(e);
          }),
          (i.boundHandleTechTouchMove_ = function (e) {
            return i.handleTechTouchMove_(e);
          }),
          (i.boundHandleTechTouchEnd_ = function (e) {
            return i.handleTechTouchEnd_(e);
          }),
          (i.boundHandleTechTap_ = function (e) {
            return i.handleTechTap_(e);
          }),
          (i.isFullscreen_ = !1),
          (i.log = Y(i.id_)),
          (i.fsApi_ = F),
          (i.isPosterFromTech_ = !1),
          (i.queuedCallbacks_ = []),
          (i.isReady_ = !1),
          (i.hasStarted_ = !1),
          (i.userActive_ = !1),
          (i.debugEnabled_ = !1),
          (i.audioOnlyMode_ = !1),
          (i.audioPosterMode_ = !1),
          (i.audioOnlyCache_ = { playerHeight: null, hiddenChildren: [] }),
          !i.options_ || !i.options_.techOrder || !i.options_.techOrder.length)
        )
          throw new Error(
            "No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?"
          );
        (i.tag = e),
          (i.tagAttributes = e && Pe(e)),
          i.language(i.options_.language),
          t.languages
            ? ((r = {}),
              Object.getOwnPropertyNames(t.languages).forEach(function (e) {
                r[e.toLowerCase()] = t.languages[e];
              }),
              (i.languages_ = r))
            : (i.languages_ = o.prototype.options_.languages),
          i.resetCache_(),
          (i.poster_ = t.poster || ""),
          (i.controls_ = !!t.controls),
          (e.controls = !1),
          e.removeAttribute("controls"),
          (i.changingSrc_ = !1),
          (i.playCallbacks_ = []),
          (i.playTerminatedQueue_ = []),
          e.hasAttribute("autoplay")
            ? i.autoplay(!0)
            : i.autoplay(i.options_.autoplay),
          t.plugins &&
            Object.keys(t.plugins).forEach(function (e) {
              if ("function" != typeof i[e])
                throw new Error('plugin "' + e + '" does not exist');
            }),
          (i.scrubbing_ = !1),
          (i.el_ = i.createEl()),
          xt(y(i), { eventBusKey: "el_" }),
          i.fsApi_.requestFullscreen &&
            (ct(
              document,
              i.fsApi_.fullscreenchange,
              i.boundDocumentFullscreenChange_
            ),
            i.on(i.fsApi_.fullscreenchange, i.boundDocumentFullscreenChange_)),
          i.fluid_ && i.on(["playerreset", "resize"], i.boundUpdateStyleEl_);
        n = m(i.options_);
        t.plugins &&
          Object.keys(t.plugins).forEach(function (e) {
            i[e](t.plugins[e]);
          }),
          t.debug && i.debug(!0),
          (i.options_.playerOptions = n),
          (i.middleware_ = []),
          i.playbackRates(t.playbackRates),
          i.initChildren(),
          i.isAudio("audio" === e.nodeName.toLowerCase()),
          i.controls()
            ? i.addClass("vjs-controls-enabled")
            : i.addClass("vjs-controls-disabled"),
          i.el_.setAttribute("role", "region"),
          i.isAudio()
            ? i.el_.setAttribute("aria-label", i.localize("Audio Player"))
            : i.el_.setAttribute("aria-label", i.localize("Video Player")),
          i.isAudio() && i.addClass("vjs-audio"),
          i.flexNotSupported_() && i.addClass("vjs-no-flex"),
          me && i.addClass("vjs-touch-enabled"),
          ge || i.addClass("vjs-workinghover"),
          (o.players[i.id_] = y(i));
        e = R.split(".")[0];
        return (
          i.addClass("vjs-v" + e),
          i.userActive(!0),
          i.reportUserActivity(),
          i.one("play", function (e) {
            return i.listenForUserActivity_(e);
          }),
          i.on("stageclick", function (e) {
            return i.handleStageClick_(e);
          }),
          i.on("keydown", function (e) {
            return i.handleKeyDown(e);
          }),
          i.on("languagechange", function (e) {
            return i.handleLanguagechange(e);
          }),
          i.breakpoints(i.options_.breakpoints),
          i.responsive(i.options_.responsive),
          i.on("ready", function () {
            i.audioPosterMode(i.options_.audioPosterMode),
              i.audioOnlyMode(i.options_.audioOnlyMode);
          }),
          i
        );
      }
      b(o, c);
      var e = o.prototype;
      return (
        (e.dispose = function () {
          var t = this;
          this.trigger("dispose"),
            this.off("dispose"),
            l(
              document,
              this.fsApi_.fullscreenchange,
              this.boundDocumentFullscreenChange_
            ),
            l(document, "keydown", this.boundFullWindowOnEscKey_),
            this.styleEl_ &&
              this.styleEl_.parentNode &&
              (this.styleEl_.parentNode.removeChild(this.styleEl_),
              (this.styleEl_ = null)),
            (o.players[this.id_] = null),
            this.tag && this.tag.player && (this.tag.player = null),
            this.el_ && this.el_.player && (this.el_.player = null),
            this.tech_ &&
              (this.tech_.dispose(),
              (this.isPosterFromTech_ = !1),
              (this.poster_ = "")),
            this.playerElIngest_ && (this.playerElIngest_ = null),
            this.tag && (this.tag = null),
            (ni[this.id()] = null),
            An.names.forEach(function (e) {
              (e = An[e]), (e = t[e.getterName]());
              e && e.off && e.off();
            }),
            c.prototype.dispose.call(this, {
              restoreEl: this.options_.restoreEl,
            });
        }),
        (e.createEl = function () {
          var t,
            n = this.tag,
            e = (this.playerElIngest_ =
              n.parentNode &&
              n.parentNode.hasAttribute &&
              n.parentNode.hasAttribute("data-vjs-player")),
            i = "video-js" === this.tag.tagName.toLowerCase();
          e
            ? (t = this.el_ = n.parentNode)
            : i || (t = this.el_ = c.prototype.createEl.call(this, "div"));
          var r,
            a,
            s = Pe(n);
          if (i) {
            for (
              t = this.el_ = n, n = this.tag = document.createElement("video");
              t.children.length;

            )
              n.appendChild(t.firstChild);
            Ce(t, "video-js") || Ie(t, "video-js"),
              t.appendChild(n),
              (e = this.playerElIngest_ = t),
              Object.keys(t).forEach(function (e) {
                try {
                  n[e] = t[e];
                } catch (e) {}
              });
          }
          n.setAttribute("tabindex", "-1"),
            (s.tabindex = "-1"),
            (de || (ue && pe)) &&
              (n.setAttribute("role", "application"), (s.role = "application")),
            n.removeAttribute("width"),
            n.removeAttribute("height"),
            "width" in s && delete s.width,
            "height" in s && delete s.height,
            Object.getOwnPropertyNames(s).forEach(function (e) {
              (i && "class" === e) || t.setAttribute(e, s[e]),
                i && n.setAttribute(e, s[e]);
            }),
            (n.playerId = n.id),
            (n.id += "_html5_api"),
            (n.className = "vjs-tech"),
            (n.player = t.player = this).addClass("vjs-paused"),
            !0 !== window.VIDEOJS_NO_DYNAMIC_STYLE &&
              ((this.styleEl_ = et("vjs-styles-dimensions")),
              (r = Xe(".vjs-styles-defaults")),
              (a = Xe("head")).insertBefore(
                this.styleEl_,
                r ? r.nextSibling : a.firstChild
              )),
            (this.fill_ = !1),
            (this.fluid_ = !1),
            this.width(this.options_.width),
            this.height(this.options_.height),
            this.fill(this.options_.fill),
            this.fluid(this.options_.fluid),
            this.aspectRatio(this.options_.aspectRatio),
            this.crossOrigin(
              this.options_.crossOrigin || this.options_.crossorigin
            );
          for (var o = n.getElementsByTagName("a"), l = 0; l < o.length; l++) {
            var u = o.item(l);
            Ie(u, "vjs-hidden"), u.setAttribute("hidden", "hidden");
          }
          return (
            (n.initNetworkState_ = n.networkState),
            n.parentNode && !e && n.parentNode.insertBefore(t, n),
            we(n, t),
            this.children_.unshift(n),
            this.el_.setAttribute("lang", this.language_),
            this.el_.setAttribute("translate", "no"),
            (this.el_ = t)
          );
        }),
        (e.crossOrigin = function (e) {
          if (!e) return this.techGet_("crossOrigin");
          "anonymous" === e || "use-credentials" === e
            ? this.techCall_("setCrossOrigin", e)
            : d.warn(
                'crossOrigin must be "anonymous" or "use-credentials", given "' +
                  e +
                  '"'
              );
        }),
        (e.width = function (e) {
          return this.dimension("width", e);
        }),
        (e.height = function (e) {
          return this.dimension("height", e);
        }),
        (e.dimension = function (e, t) {
          var n = e + "_";
          if (void 0 === t) return this[n] || 0;
          if ("" === t || "auto" === t)
            return (this[n] = void 0), void this.updateStyleEl_();
          var i = parseFloat(t);
          isNaN(i)
            ? d.error('Improper value "' + t + '" supplied for for ' + e)
            : ((this[n] = i), this.updateStyleEl_());
        }),
        (e.fluid = function (e) {
          var t,
            n = this;
          if (void 0 === e) return !!this.fluid_;
          (this.fluid_ = !!e),
            Ct(this) &&
              this.off(["playerreset", "resize"], this.boundUpdateStyleEl_),
            e
              ? (this.addClass("vjs-fluid"),
                this.fill(!1),
                (t = function () {
                  n.on(["playerreset", "resize"], n.boundUpdateStyleEl_);
                }),
                Ct((e = this))
                  ? t()
                  : (e.eventedCallbacks || (e.eventedCallbacks = []),
                    e.eventedCallbacks.push(t)))
              : this.removeClass("vjs-fluid"),
            this.updateStyleEl_();
        }),
        (e.fill = function (e) {
          if (void 0 === e) return !!this.fill_;
          (this.fill_ = !!e),
            e
              ? (this.addClass("vjs-fill"), this.fluid(!1))
              : this.removeClass("vjs-fill");
        }),
        (e.aspectRatio = function (e) {
          if (void 0 === e) return this.aspectRatio_;
          if (!/^\d+\:\d+$/.test(e))
            throw new Error(
              "Improper value supplied for aspect ratio. The format should be width:height, for example 16:9."
            );
          (this.aspectRatio_ = e), this.fluid(!0), this.updateStyleEl_();
        }),
        (e.updateStyleEl_ = function () {
          var e, t, n, i;
          !0 !== window.VIDEOJS_NO_DYNAMIC_STYLE
            ? ((i =
                (n = (
                  void 0 !== this.aspectRatio_ && "auto" !== this.aspectRatio_
                    ? this.aspectRatio_
                    : 0 < this.videoWidth()
                    ? this.videoWidth() + ":" + this.videoHeight()
                    : "16:9"
                ).split(":"))[1] / n[0]),
              (e =
                void 0 !== this.width_
                  ? this.width_
                  : void 0 !== this.height_
                  ? this.height_ / i
                  : this.videoWidth() || 300),
              (t = void 0 !== this.height_ ? this.height_ : e * i),
              (n = /^[^a-zA-Z]/.test(this.id())
                ? "dimensions-" + this.id()
                : this.id() + "-dimensions"),
              this.addClass(n),
              tt(
                this.styleEl_,
                "\n      ." +
                  n +
                  " {\n        width: " +
                  e +
                  "px;\n        height: " +
                  t +
                  "px;\n      }\n\n      ." +
                  n +
                  ".vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: " +
                  100 * i +
                  "%;\n      }\n    "
              ))
            : ((t =
                "number" == typeof this.width_
                  ? this.width_
                  : this.options_.width),
              (n =
                "number" == typeof this.height_
                  ? this.height_
                  : this.options_.height),
              (i = this.tech_ && this.tech_.el()) &&
                (0 <= t && (i.width = t), 0 <= n && (i.height = n)));
        }),
        (e.loadTech_ = function (e, t) {
          var n = this;
          this.tech_ && this.unloadTech_();
          var i = p(e),
            r = e.charAt(0).toLowerCase() + e.slice(1);
          "Html5" !== i &&
            this.tag &&
            (O.getTech("Html5").disposeMediaElement(this.tag),
            (this.tag.player = null),
            (this.tag = null)),
            (this.techName_ = i),
            (this.isReady_ = !1);
          var a = this.autoplay(),
            s = {
              source: t,
              autoplay: (a =
                "string" == typeof this.autoplay() ||
                (!0 === this.autoplay() && this.options_.normalizeAutoplay)
                  ? !1
                  : a),
              nativeControlsForTouch: this.options_.nativeControlsForTouch,
              playerId: this.id(),
              techId: this.id() + "_" + r + "_api",
              playsinline: this.options_.playsinline,
              preload: this.options_.preload,
              loop: this.options_.loop,
              disablePictureInPicture: this.options_.disablePictureInPicture,
              muted: this.options_.muted,
              poster: this.poster(),
              language: this.language(),
              playerElIngest: this.playerElIngest_ || !1,
              "vtt.js": this.options_["vtt.js"],
              canOverridePoster: !!this.options_.techCanOverridePoster,
              enableSourceset: this.options_.enableSourceset,
              Promise: this.options_.Promise,
            };
          An.names.forEach(function (e) {
            e = An[e];
            s[e.getterName] = n[e.privateName];
          }),
            h(s, this.options_[i]),
            h(s, this.options_[r]),
            h(s, this.options_[e.toLowerCase()]),
            this.tag && (s.tag = this.tag),
            t &&
              t.src === this.cache_.src &&
              0 < this.cache_.currentTime &&
              (s.startTime = this.cache_.currentTime);
          e = O.getTech(e);
          if (!e)
            throw new Error(
              "No Tech named '" +
                i +
                "' exists! '" +
                i +
                "' should be registered using videojs.registerTech()'"
            );
          (this.tech_ = new e(s)),
            this.tech_.ready(u(this, this.handleTechReady_), !0),
            Ht(this.textTracksJson_ || [], this.tech_),
            Wi.forEach(function (t) {
              n.on(n.tech_, t, function (e) {
                return n["handleTech" + p(t) + "_"](e);
              });
            }),
            Object.keys(Xi).forEach(function (t) {
              n.on(n.tech_, t, function (e) {
                0 === n.tech_.playbackRate() && n.tech_.seeking()
                  ? n.queuedCallbacks_.push({
                      callback: n["handleTech" + Xi[t] + "_"].bind(n),
                      event: e,
                    })
                  : n["handleTech" + Xi[t] + "_"](e);
              });
            }),
            this.on(this.tech_, "loadstart", function (e) {
              return n.handleTechLoadStart_(e);
            }),
            this.on(this.tech_, "sourceset", function (e) {
              return n.handleTechSourceset_(e);
            }),
            this.on(this.tech_, "waiting", function (e) {
              return n.handleTechWaiting_(e);
            }),
            this.on(this.tech_, "ended", function (e) {
              return n.handleTechEnded_(e);
            }),
            this.on(this.tech_, "seeking", function (e) {
              return n.handleTechSeeking_(e);
            }),
            this.on(this.tech_, "play", function (e) {
              return n.handleTechPlay_(e);
            }),
            this.on(this.tech_, "firstplay", function (e) {
              return n.handleTechFirstPlay_(e);
            }),
            this.on(this.tech_, "pause", function (e) {
              return n.handleTechPause_(e);
            }),
            this.on(this.tech_, "durationchange", function (e) {
              return n.handleTechDurationChange_(e);
            }),
            this.on(this.tech_, "fullscreenchange", function (e, t) {
              return n.handleTechFullscreenChange_(e, t);
            }),
            this.on(this.tech_, "fullscreenerror", function (e, t) {
              return n.handleTechFullscreenError_(e, t);
            }),
            this.on(this.tech_, "enterpictureinpicture", function (e) {
              return n.handleTechEnterPictureInPicture_(e);
            }),
            this.on(this.tech_, "leavepictureinpicture", function (e) {
              return n.handleTechLeavePictureInPicture_(e);
            }),
            this.on(this.tech_, "error", function (e) {
              return n.handleTechError_(e);
            }),
            this.on(this.tech_, "posterchange", function (e) {
              return n.handleTechPosterChange_(e);
            }),
            this.on(this.tech_, "textdata", function (e) {
              return n.handleTechTextData_(e);
            }),
            this.on(this.tech_, "ratechange", function (e) {
              return n.handleTechRateChange_(e);
            }),
            this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_),
            this.usingNativeControls(this.techGet_("controls")),
            this.controls() &&
              !this.usingNativeControls() &&
              this.addTechControlsListeners_(),
            this.tech_.el().parentNode === this.el() ||
              ("Html5" === i && this.tag) ||
              we(this.tech_.el(), this.el()),
            this.tag && ((this.tag.player = null), (this.tag = null));
        }),
        (e.unloadTech_ = function () {
          var t = this;
          An.names.forEach(function (e) {
            e = An[e];
            t[e.privateName] = t[e.getterName]();
          }),
            (this.textTracksJson_ = zt(this.tech_)),
            (this.isReady_ = !1),
            this.tech_.dispose(),
            (this.tech_ = !1),
            this.isPosterFromTech_ &&
              ((this.poster_ = ""), this.trigger("posterchange")),
            (this.isPosterFromTech_ = !1);
        }),
        (e.tech = function (e) {
          return (
            void 0 === e &&
              d.warn(
                "Using the tech directly can be dangerous. I hope you know what you're doing.\nSee https://github.com/videojs/video.js/issues/2617 for more info.\n"
              ),
            this.tech_
          );
        }),
        (e.addTechControlsListeners_ = function () {
          this.removeTechControlsListeners_(),
            this.on(this.tech_, "click", this.boundHandleTechClick_),
            this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_),
            this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_),
            this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_),
            this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_),
            this.on(this.tech_, "tap", this.boundHandleTechTap_);
        }),
        (e.removeTechControlsListeners_ = function () {
          this.off(this.tech_, "tap", this.boundHandleTechTap_),
            this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_),
            this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_),
            this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_),
            this.off(this.tech_, "click", this.boundHandleTechClick_),
            this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
        }),
        (e.handleTechReady_ = function () {
          this.triggerReady(),
            this.cache_.volume &&
              this.techCall_("setVolume", this.cache_.volume),
            this.handleTechPosterChange_(),
            this.handleTechDurationChange_();
        }),
        (e.handleTechLoadStart_ = function () {
          this.removeClass("vjs-ended"),
            this.removeClass("vjs-seeking"),
            this.error(null),
            this.handleTechDurationChange_(),
            this.paused()
              ? (this.hasStarted(!1), this.trigger("loadstart"))
              : (this.trigger("loadstart"), this.trigger("firstplay")),
            this.manualAutoplay_(
              !0 === this.autoplay() && this.options_.normalizeAutoplay
                ? "play"
                : this.autoplay()
            );
        }),
        (e.manualAutoplay_ = function (e) {
          var i = this;
          if (this.tech_ && "string" == typeof e) {
            var t,
              n = function () {
                var e = i.muted();
                i.muted(!0);
                function t() {
                  i.muted(e);
                }
                i.playTerminatedQueue_.push(t);
                var n = i.play();
                if (Ft(n))
                  return n.catch(function (e) {
                    throw (
                      (t(),
                      new Error(
                        "Rejection at manualAutoplay. Restoring muted value. " +
                          (e || "")
                      ))
                    );
                  });
              };
            if (
              ("any" !== e || this.muted()
                ? (t = "muted" !== e || this.muted() ? this.play() : n())
                : Ft((t = this.play())) && (t = t.catch(n)),
              Ft(t))
            )
              return t
                .then(function () {
                  i.trigger({ type: "autoplay-success", autoplay: e });
                })
                .catch(function () {
                  i.trigger({ type: "autoplay-failure", autoplay: e });
                });
          }
        }),
        (e.updateSourceCaches_ = function (e) {
          var t = (e = void 0 === e ? "" : e),
            n = "";
          "string" != typeof t && ((t = e.src), (n = e.type)),
            (this.cache_.source = this.cache_.source || {}),
            (this.cache_.sources = this.cache_.sources || []),
            t &&
              !n &&
              (n = (function (e, t) {
                if (!t) return "";
                if (e.cache_.source.src === t && e.cache_.source.type)
                  return e.cache_.source.type;
                var n = e.cache_.sources.filter(function (e) {
                  return e.src === t;
                });
                if (n.length) return n[0].type;
                for (var i = e.$$("source"), r = 0; r < i.length; r++) {
                  var a = i[r];
                  if (a.type && a.src && a.src === t) return a.type;
                }
                return di(t);
              })(this, t)),
            (this.cache_.source = m({}, e, { src: t, type: n }));
          for (
            var n = this.cache_.sources.filter(function (e) {
                return e.src && e.src === t;
              }),
              i = [],
              r = this.$$("source"),
              a = [],
              s = 0;
            s < r.length;
            s++
          ) {
            var o = Pe(r[s]);
            i.push(o), o.src && o.src === t && a.push(o.src);
          }
          a.length && !n.length
            ? (this.cache_.sources = i)
            : n.length || (this.cache_.sources = [this.cache_.source]),
            (this.cache_.src = t);
        }),
        (e.handleTechSourceset_ = function (e) {
          var t,
            n,
            i,
            r = this;
          this.changingSrc_ ||
            ((t = function (e) {
              return r.updateSourceCaches_(e);
            }),
            (n = this.currentSource().src),
            (i = e.src),
            n &&
              !/^blob:/.test(n) &&
              /^blob:/.test(i) &&
              ((this.lastSource_ &&
                (this.lastSource_.tech === i ||
                  this.lastSource_.player === n)) ||
                (t = function () {})),
            t(i),
            e.src ||
              this.tech_.any(["sourceset", "loadstart"], function (e) {
                "sourceset" !== e.type &&
                  ((e = r.techGet("currentSrc")),
                  (r.lastSource_.tech = e),
                  r.updateSourceCaches_(e));
              })),
            (this.lastSource_ = {
              player: this.currentSource().src,
              tech: e.src,
            }),
            this.trigger({ src: e.src, type: "sourceset" });
        }),
        (e.hasStarted = function (e) {
          if (void 0 === e) return this.hasStarted_;
          e !== this.hasStarted_ &&
            ((this.hasStarted_ = e),
            this.hasStarted_
              ? (this.addClass("vjs-has-started"), this.trigger("firstplay"))
              : this.removeClass("vjs-has-started"));
        }),
        (e.handleTechPlay_ = function () {
          this.removeClass("vjs-ended"),
            this.removeClass("vjs-paused"),
            this.addClass("vjs-playing"),
            this.hasStarted(!0),
            this.trigger("play");
        }),
        (e.handleTechRateChange_ = function () {
          0 < this.tech_.playbackRate() &&
            0 === this.cache_.lastPlaybackRate &&
            (this.queuedCallbacks_.forEach(function (e) {
              return e.callback(e.event);
            }),
            (this.queuedCallbacks_ = [])),
            (this.cache_.lastPlaybackRate = this.tech_.playbackRate()),
            this.trigger("ratechange");
        }),
        (e.handleTechWaiting_ = function () {
          var t = this;
          this.addClass("vjs-waiting"), this.trigger("waiting");
          var n = this.currentTime();
          this.on("timeupdate", function e() {
            n !== t.currentTime() &&
              (t.removeClass("vjs-waiting"), t.off("timeupdate", e));
          });
        }),
        (e.handleTechCanPlay_ = function () {
          this.removeClass("vjs-waiting"), this.trigger("canplay");
        }),
        (e.handleTechCanPlayThrough_ = function () {
          this.removeClass("vjs-waiting"), this.trigger("canplaythrough");
        }),
        (e.handleTechPlaying_ = function () {
          this.removeClass("vjs-waiting"), this.trigger("playing");
        }),
        (e.handleTechSeeking_ = function () {
          this.addClass("vjs-seeking"), this.trigger("seeking");
        }),
        (e.handleTechSeeked_ = function () {
          this.removeClass("vjs-seeking"),
            this.removeClass("vjs-ended"),
            this.trigger("seeked");
        }),
        (e.handleTechFirstPlay_ = function () {
          this.options_.starttime &&
            (d.warn(
              "Passing the `starttime` option to the player will be deprecated in 6.0"
            ),
            this.currentTime(this.options_.starttime)),
            this.addClass("vjs-has-started"),
            this.trigger("firstplay");
        }),
        (e.handleTechPause_ = function () {
          this.removeClass("vjs-playing"),
            this.addClass("vjs-paused"),
            this.trigger("pause");
        }),
        (e.handleTechEnded_ = function () {
          this.addClass("vjs-ended"),
            this.removeClass("vjs-waiting"),
            this.options_.loop
              ? (this.currentTime(0), this.play())
              : this.paused() || this.pause(),
            this.trigger("ended");
        }),
        (e.handleTechDurationChange_ = function () {
          this.duration(this.techGet_("duration"));
        }),
        (e.handleTechClick_ = function (e) {
          this.controls_ &&
            ((void 0 !== this.options_ &&
              void 0 !== this.options_.userActions &&
              void 0 !== this.options_.userActions.click &&
              !1 === this.options_.userActions.click) ||
              (void 0 !== this.options_ &&
              void 0 !== this.options_.userActions &&
              "function" == typeof this.options_.userActions.click
                ? this.options_.userActions.click.call(this, e)
                : this.paused()
                ? Gt(this.play())
                : this.pause()));
        }),
        (e.handleTechDoubleClick_ = function (t) {
          this.controls_ &&
            (Array.prototype.some.call(
              this.$$(".vjs-control-bar, .vjs-modal-dialog"),
              function (e) {
                return e.contains(t.target);
              }
            ) ||
              (void 0 !== this.options_ &&
                void 0 !== this.options_.userActions &&
                void 0 !== this.options_.userActions.doubleClick &&
                !1 === this.options_.userActions.doubleClick) ||
              (void 0 !== this.options_ &&
              void 0 !== this.options_.userActions &&
              "function" == typeof this.options_.userActions.doubleClick
                ? this.options_.userActions.doubleClick.call(this, t)
                : this.isFullscreen()
                ? this.exitFullscreen()
                : this.requestFullscreen()));
        }),
        (e.handleTechTap_ = function () {
          this.userActive(!this.userActive());
        }),
        (e.handleTechTouchStart_ = function () {
          this.userWasActive = this.userActive();
        }),
        (e.handleTechTouchMove_ = function () {
          this.userWasActive && this.reportUserActivity();
        }),
        (e.handleTechTouchEnd_ = function (e) {
          e.cancelable && e.preventDefault();
        }),
        (e.handleStageClick_ = function () {
          this.reportUserActivity();
        }),
        (e.toggleFullscreenClass_ = function () {
          this.isFullscreen()
            ? this.addClass("vjs-fullscreen")
            : this.removeClass("vjs-fullscreen");
        }),
        (e.documentFullscreenChange_ = function (e) {
          var t = e.target.player;
          (t && t !== this) ||
            ((e = this.el()),
            !(t = document[this.fsApi_.fullscreenElement] === e) && e.matches
              ? (t = e.matches(":" + this.fsApi_.fullscreen))
              : !t &&
                e.msMatchesSelector &&
                (t = e.msMatchesSelector(":" + this.fsApi_.fullscreen)),
            this.isFullscreen(t));
        }),
        (e.handleTechFullscreenChange_ = function (e, t) {
          var n = this;
          t &&
            (t.nativeIOSFullscreen &&
              (this.addClass("vjs-ios-native-fs"),
              this.tech_.one("webkitendfullscreen", function () {
                n.removeClass("vjs-ios-native-fs");
              })),
            this.isFullscreen(t.isFullscreen));
        }),
        (e.handleTechFullscreenError_ = function (e, t) {
          this.trigger("fullscreenerror", t);
        }),
        (e.togglePictureInPictureClass_ = function () {
          this.isInPictureInPicture()
            ? this.addClass("vjs-picture-in-picture")
            : this.removeClass("vjs-picture-in-picture");
        }),
        (e.handleTechEnterPictureInPicture_ = function (e) {
          this.isInPictureInPicture(!0);
        }),
        (e.handleTechLeavePictureInPicture_ = function (e) {
          this.isInPictureInPicture(!1);
        }),
        (e.handleTechError_ = function () {
          var e = this.tech_.error();
          this.error(e);
        }),
        (e.handleTechTextData_ = function () {
          this.trigger("textdata", 1 < arguments.length ? arguments[1] : null);
        }),
        (e.getCache = function () {
          return this.cache_;
        }),
        (e.resetCache_ = function () {
          this.cache_ = {
            currentTime: 0,
            initTime: 0,
            inactivityTimeout: this.options_.inactivityTimeout,
            duration: NaN,
            lastVolume: 1,
            lastPlaybackRate: this.defaultPlaybackRate(),
            media: null,
            src: "",
            source: {},
            sources: [],
            playbackRates: [],
            volume: 1,
          };
        }),
        (e.techCall_ = function (i, r) {
          this.ready(function () {
            if (i in oi)
              return (
                (e = this.middleware_),
                (t = this.tech_),
                (n = r),
                t[(t = i)](e.reduce(ui(t), n))
              );
            if (i in li) return ai(this.middleware_, this.tech_, i, r);
            var e, t, n;
            try {
              this.tech_ && this.tech_[i](r);
            } catch (e) {
              throw (d(e), e);
            }
          }, !0);
        }),
        (e.techGet_ = function (e) {
          if (this.tech_ && this.tech_.isReady_) {
            if (e in si)
              return (
                (t = this.middleware_),
                (n = this.tech_),
                (i = e),
                t.reduceRight(ui(i), n[i]())
              );
            if (e in li) return ai(this.middleware_, this.tech_, e);
            var t, n, i;
            try {
              return this.tech_[e]();
            } catch (t) {
              if (void 0 === this.tech_[e])
                throw (
                  (d(
                    "Video.js: " +
                      e +
                      " method not defined for " +
                      this.techName_ +
                      " playback technology.",
                    t
                  ),
                  t)
                );
              if ("TypeError" === t.name)
                throw (
                  (d(
                    "Video.js: " +
                      e +
                      " unavailable on " +
                      this.techName_ +
                      " playback technology element.",
                    t
                  ),
                  (this.tech_.isReady_ = !1),
                  t)
                );
              throw (d(t), t);
            }
          }
        }),
        (e.play = function () {
          var t = this,
            e = this.options_.Promise || window.Promise;
          return e
            ? new e(function (e) {
                t.play_(e);
              })
            : this.play_();
        }),
        (e.play_ = function (e) {
          var t = this;
          this.playCallbacks_.push((e = void 0 === e ? Gt : e));
          e = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
          if (
            (this.waitToPlay_ &&
              (this.off(["ready", "loadstart"], this.waitToPlay_),
              (this.waitToPlay_ = null)),
            !this.isReady_ || !e)
          )
            return (
              (this.waitToPlay_ = function (e) {
                t.play_();
              }),
              this.one(["ready", "loadstart"], this.waitToPlay_),
              void (e || (!be && !ge) || this.load())
            );
          e = this.techGet_("play");
          null === e
            ? this.runPlayTerminatedQueue_()
            : this.runPlayCallbacks_(e);
        }),
        (e.runPlayTerminatedQueue_ = function () {
          var e = this.playTerminatedQueue_.slice(0);
          (this.playTerminatedQueue_ = []),
            e.forEach(function (e) {
              e();
            });
        }),
        (e.runPlayCallbacks_ = function (t) {
          var e = this.playCallbacks_.slice(0);
          (this.playCallbacks_ = []),
            (this.playTerminatedQueue_ = []),
            e.forEach(function (e) {
              e(t);
            });
        }),
        (e.pause = function () {
          this.techCall_("pause");
        }),
        (e.paused = function () {
          return !1 !== this.techGet_("paused");
        }),
        (e.played = function () {
          return this.techGet_("played") || Dt(0, 0);
        }),
        (e.scrubbing = function (e) {
          if ("undefined" == typeof e) return this.scrubbing_;
          (this.scrubbing_ = !!e),
            this.techCall_("setScrubbing", this.scrubbing_),
            e
              ? this.addClass("vjs-scrubbing")
              : this.removeClass("vjs-scrubbing");
        }),
        (e.currentTime = function (e) {
          return "undefined" != typeof e
            ? (e < 0 && (e = 0),
              this.isReady_ &&
              !this.changingSrc_ &&
              this.tech_ &&
              this.tech_.isReady_
                ? (this.techCall_("setCurrentTime", e),
                  void (this.cache_.initTime = 0))
                : ((this.cache_.initTime = e),
                  this.off("canplay", this.boundApplyInitTime_),
                  void this.one("canplay", this.boundApplyInitTime_)))
            : ((this.cache_.currentTime = this.techGet_("currentTime") || 0),
              this.cache_.currentTime);
        }),
        (e.applyInitTime_ = function () {
          this.currentTime(this.cache_.initTime);
        }),
        (e.duration = function (e) {
          if (void 0 === e)
            return void 0 !== this.cache_.duration ? this.cache_.duration : NaN;
          (e = (e = parseFloat(e)) < 0 ? 1 / 0 : e) !== this.cache_.duration &&
            ((this.cache_.duration = e) === 1 / 0
              ? this.addClass("vjs-live")
              : this.removeClass("vjs-live"),
            isNaN(e) || this.trigger("durationchange"));
        }),
        (e.remainingTime = function () {
          return this.duration() - this.currentTime();
        }),
        (e.remainingTimeDisplay = function () {
          return Math.floor(this.duration()) - Math.floor(this.currentTime());
        }),
        (e.buffered = function () {
          var e;
          return (e =
            !(e = this.techGet_("buffered")) || !e.length ? Dt(0, 0) : e);
        }),
        (e.bufferedPercent = function () {
          return Rt(this.buffered(), this.duration());
        }),
        (e.bufferedEnd = function () {
          var e = this.buffered(),
            t = this.duration(),
            e = e.end(e.length - 1);
          return (e = t < e ? t : e);
        }),
        (e.volume = function (e) {
          var t;
          return void 0 !== e
            ? ((t = Math.max(0, Math.min(1, parseFloat(e)))),
              (this.cache_.volume = t),
              this.techCall_("setVolume", t),
              void (0 < t && this.lastVolume_(t)))
            : ((t = parseFloat(this.techGet_("volume"))), isNaN(t) ? 1 : t);
        }),
        (e.muted = function (e) {
          if (void 0 === e) return this.techGet_("muted") || !1;
          this.techCall_("setMuted", e);
        }),
        (e.defaultMuted = function (e) {
          return void 0 !== e
            ? this.techCall_("setDefaultMuted", e)
            : this.techGet_("defaultMuted") || !1;
        }),
        (e.lastVolume_ = function (e) {
          if (void 0 === e || 0 === e) return this.cache_.lastVolume;
          this.cache_.lastVolume = e;
        }),
        (e.supportsFullScreen = function () {
          return this.techGet_("supportsFullScreen") || !1;
        }),
        (e.isFullscreen = function (e) {
          if (void 0 === e) return this.isFullscreen_;
          var t = this.isFullscreen_;
          (this.isFullscreen_ = Boolean(e)),
            this.isFullscreen_ !== t &&
              this.fsApi_.prefixed &&
              this.trigger("fullscreenchange"),
            this.toggleFullscreenClass_();
        }),
        (e.requestFullscreen = function (s) {
          var e = this.options_.Promise || window.Promise;
          if (e) {
            var o = this;
            return new e(function (e, n) {
              function i() {
                o.off("fullscreenerror", r), o.off("fullscreenchange", t);
              }
              function t() {
                i(), e();
              }
              function r(e, t) {
                i(), n(t);
              }
              o.one("fullscreenchange", t), o.one("fullscreenerror", r);
              var a = o.requestFullscreenHelper_(s);
              a && (a.then(i, i), a.then(e, n));
            });
          }
          return this.requestFullscreenHelper_();
        }),
        (e.requestFullscreenHelper_ = function (e) {
          var t = this;
          if (
            (this.fsApi_.prefixed ||
              ((n =
                (this.options_.fullscreen &&
                  this.options_.fullscreen.options) ||
                {}),
              void 0 !== e && (n = e)),
            this.fsApi_.requestFullscreen)
          ) {
            var n = this.el_[this.fsApi_.requestFullscreen](n);
            return (
              n &&
                n.then(
                  function () {
                    return t.isFullscreen(!0);
                  },
                  function () {
                    return t.isFullscreen(!1);
                  }
                ),
              n
            );
          }
          this.tech_.supportsFullScreen() &&
          !0 == !this.options_.preferFullWindow
            ? this.techCall_("enterFullScreen")
            : this.enterFullWindow();
        }),
        (e.exitFullscreen = function () {
          var e = this.options_.Promise || window.Promise;
          if (e) {
            var s = this;
            return new e(function (e, n) {
              function i() {
                s.off("fullscreenerror", r), s.off("fullscreenchange", t);
              }
              function t() {
                i(), e();
              }
              function r(e, t) {
                i(), n(t);
              }
              s.one("fullscreenchange", t), s.one("fullscreenerror", r);
              var a = s.exitFullscreenHelper_();
              a && (a.then(i, i), a.then(e, n));
            });
          }
          return this.exitFullscreenHelper_();
        }),
        (e.exitFullscreenHelper_ = function () {
          var e = this;
          if (this.fsApi_.requestFullscreen) {
            var t = document[this.fsApi_.exitFullscreen]();
            return (
              t &&
                Gt(
                  t.then(function () {
                    return e.isFullscreen(!1);
                  })
                ),
              t
            );
          }
          this.tech_.supportsFullScreen() &&
          !0 == !this.options_.preferFullWindow
            ? this.techCall_("exitFullScreen")
            : this.exitFullWindow();
        }),
        (e.enterFullWindow = function () {
          this.isFullscreen(!0),
            (this.isFullWindow = !0),
            (this.docOrigOverflow = document.documentElement.style.overflow),
            ct(document, "keydown", this.boundFullWindowOnEscKey_),
            (document.documentElement.style.overflow = "hidden"),
            Ie(document.body, "vjs-full-window"),
            this.trigger("enterFullWindow");
        }),
        (e.fullWindowOnEscKey = function (e) {
          f.isEventKey(e, "Esc") &&
            !0 === this.isFullscreen() &&
            (this.isFullWindow ? this.exitFullWindow() : this.exitFullscreen());
        }),
        (e.exitFullWindow = function () {
          this.isFullscreen(!1),
            (this.isFullWindow = !1),
            l(document, "keydown", this.boundFullWindowOnEscKey_),
            (document.documentElement.style.overflow = this.docOrigOverflow),
            xe(document.body, "vjs-full-window"),
            this.trigger("exitFullWindow");
        }),
        (e.disablePictureInPicture = function (e) {
          if (void 0 === e) return this.techGet_("disablePictureInPicture");
          this.techCall_("setDisablePictureInPicture", e),
            (this.options_.disablePictureInPicture = e),
            this.trigger("disablepictureinpicturechanged");
        }),
        (e.isInPictureInPicture = function (e) {
          return void 0 !== e
            ? ((this.isInPictureInPicture_ = !!e),
              void this.togglePictureInPictureClass_())
            : !!this.isInPictureInPicture_;
        }),
        (e.requestPictureInPicture = function () {
          if (
            "pictureInPictureEnabled" in document &&
            !1 === this.disablePictureInPicture()
          )
            return this.techGet_("requestPictureInPicture");
        }),
        (e.exitPictureInPicture = function () {
          if ("pictureInPictureEnabled" in document)
            return document.exitPictureInPicture();
        }),
        (e.handleKeyDown = function (e) {
          var t = this.options_.userActions;
          t &&
            t.hotkeys &&
            ((function (e) {
              var t = e.tagName.toLowerCase();
              if (e.isContentEditable) return !0;
              if ("input" === t)
                return (
                  -1 ===
                  [
                    "button",
                    "checkbox",
                    "hidden",
                    "radio",
                    "reset",
                    "submit",
                  ].indexOf(e.type)
                );
              return -1 !== ["textarea"].indexOf(t);
            })(this.el_.ownerDocument.activeElement) ||
              ("function" == typeof t.hotkeys
                ? t.hotkeys.call(this, e)
                : this.handleHotkeys(e)));
        }),
        (e.handleHotkeys = function (e) {
          var t = this.options_.userActions
              ? this.options_.userActions.hotkeys
              : {},
            n = t.fullscreenKey,
            i = t.muteKey,
            i =
              void 0 === i
                ? function (e) {
                    return f.isEventKey(e, "m");
                  }
                : i,
            t = t.playPauseKey,
            t =
              void 0 === t
                ? function (e) {
                    return f.isEventKey(e, "k") || f.isEventKey(e, "Space");
                  }
                : t;
          (void 0 === n
            ? function (e) {
                return f.isEventKey(e, "f");
              }
            : n
          ).call(this, e)
            ? (e.preventDefault(),
              e.stopPropagation(),
              (n = g.getComponent("FullscreenToggle")),
              !1 !== document[this.fsApi_.fullscreenEnabled] &&
                n.prototype.handleClick.call(this, e))
            : i.call(this, e)
            ? (e.preventDefault(),
              e.stopPropagation(),
              g.getComponent("MuteToggle").prototype.handleClick.call(this, e))
            : t.call(this, e) &&
              (e.preventDefault(),
              e.stopPropagation(),
              g.getComponent("PlayToggle").prototype.handleClick.call(this, e));
        }),
        (e.canPlayType = function (e) {
          for (var t, n = 0, i = this.options_.techOrder; n < i.length; n++) {
            var r = i[n],
              a = O.getTech(r);
            if ((a = a || g.getComponent(r))) {
              if (a.isSupported() && (t = a.canPlayType(e))) return t;
            } else
              d.error(
                'The "' +
                  r +
                  '" tech is undefined. Skipped browser support check for that tech.'
              );
          }
          return "";
        }),
        (e.selectSource = function (e) {
          function t(e, n, i) {
            var r;
            return (
              e.some(function (t) {
                return n.some(function (e) {
                  if ((r = i(t, e))) return !0;
                });
              }),
              r
            );
          }
          var n,
            i = this,
            r = this.options_.techOrder
              .map(function (e) {
                return [e, O.getTech(e)];
              })
              .filter(function (e) {
                var t = e[0],
                  e = e[1];
                return e
                  ? e.isSupported()
                  : (d.error(
                      'The "' +
                        t +
                        '" tech is undefined. Skipped browser support check for that tech.'
                    ),
                    !1);
              }),
            a = function (e, t) {
              var n = e[0];
              if (e[1].canPlaySource(t, i.options_[n.toLowerCase()]))
                return { source: t, tech: n };
            },
            a = this.options_.sourceOrder
              ? t(
                  e,
                  r,
                  ((n = a),
                  function (e, t) {
                    return n(t, e);
                  })
                )
              : t(r, e, a);
          return a || !1;
        }),
        (e.handleSrc_ = function (e, i) {
          var r = this;
          if ("undefined" == typeof e) return this.cache_.src || "";
          this.resetRetryOnError_ && this.resetRetryOnError_();
          var t,
            n,
            a = hi(e);
          a.length
            ? ((this.changingSrc_ = !0),
              i || (this.cache_.sources = a),
              this.updateSourceCaches_(a[0]),
              ri(this, a[0], function (e, t) {
                var n;
                return (
                  (r.middleware_ = t),
                  i || (r.cache_.sources = a),
                  r.updateSourceCaches_(e),
                  r.src_(e)
                    ? 1 < a.length
                      ? r.handleSrc_(a.slice(1))
                      : ((r.changingSrc_ = !1),
                        r.setTimeout(function () {
                          this.error({
                            code: 4,
                            message: this.options_.notSupportedMessage,
                          });
                        }, 0),
                        void r.triggerReady())
                    : ((t = t),
                      (n = r.tech_),
                      void t.forEach(function (e) {
                        return e.setTech && e.setTech(n);
                      }))
                );
              }),
              this.options_.retryOnError &&
                1 < a.length &&
                ((n = function () {
                  r.off("error", t);
                }),
                this.one(
                  "error",
                  (t = function () {
                    r.error(null), r.handleSrc_(a.slice(1), !0);
                  })
                ),
                this.one("playing", n),
                (this.resetRetryOnError_ = function () {
                  r.off("error", t), r.off("playing", n);
                })))
            : this.setTimeout(function () {
                this.error({
                  code: 4,
                  message: this.options_.notSupportedMessage,
                });
              }, 0);
        }),
        (e.src = function (e) {
          return this.handleSrc_(e, !1);
        }),
        (e.src_ = function (e) {
          var t,
            n,
            i = this,
            r = this.selectSource([e]);
          return (
            !r ||
            ((t = r.tech),
            (n = this.techName_),
            p(t) !== p(n)
              ? ((this.changingSrc_ = !0),
                this.loadTech_(r.tech, r.source),
                this.tech_.ready(function () {
                  i.changingSrc_ = !1;
                }))
              : this.ready(function () {
                  this.tech_.constructor.prototype.hasOwnProperty("setSource")
                    ? this.techCall_("setSource", e)
                    : this.techCall_("src", e.src),
                    (this.changingSrc_ = !1);
                }, !0),
            !1)
          );
        }),
        (e.load = function () {
          this.techCall_("load");
        }),
        (e.reset = function () {
          var e = this,
            t = this.options_.Promise || window.Promise;
          this.paused() || !t
            ? this.doReset_()
            : Gt(
                this.play().then(function () {
                  return e.doReset_();
                })
              );
        }),
        (e.doReset_ = function () {
          this.tech_ && this.tech_.clearTracks("text"),
            this.resetCache_(),
            this.poster(""),
            this.loadTech_(this.options_.techOrder[0], null),
            this.techCall_("reset"),
            this.resetControlBarUI_(),
            Ct(this) && this.trigger("playerreset");
        }),
        (e.resetControlBarUI_ = function () {
          this.resetProgressBar_(),
            this.resetPlaybackRate_(),
            this.resetVolumeBar_();
        }),
        (e.resetProgressBar_ = function () {
          this.currentTime(0);
          var e = this.controlBar || {},
            t = e.durationDisplay,
            e = e.remainingTimeDisplay;
          t && t.updateContent(), e && e.updateContent();
        }),
        (e.resetPlaybackRate_ = function () {
          this.playbackRate(this.defaultPlaybackRate()),
            this.handleTechRateChange_();
        }),
        (e.resetVolumeBar_ = function () {
          this.volume(1), this.trigger("volumechange");
        }),
        (e.currentSources = function () {
          var e = this.currentSource(),
            t = [];
          return (
            0 !== Object.keys(e).length && t.push(e), this.cache_.sources || t
          );
        }),
        (e.currentSource = function () {
          return this.cache_.source || {};
        }),
        (e.currentSrc = function () {
          return (this.currentSource() && this.currentSource().src) || "";
        }),
        (e.currentType = function () {
          return (this.currentSource() && this.currentSource().type) || "";
        }),
        (e.preload = function (e) {
          return void 0 !== e
            ? (this.techCall_("setPreload", e),
              void (this.options_.preload = e))
            : this.techGet_("preload");
        }),
        (e.autoplay = function (e) {
          if (void 0 === e) return this.options_.autoplay || !1;
          var t;
          ("string" == typeof e && /(any|play|muted)/.test(e)) ||
          (!0 === e && this.options_.normalizeAutoplay)
            ? ((this.options_.autoplay = e),
              this.manualAutoplay_("string" == typeof e ? e : "play"),
              (t = !1))
            : (this.options_.autoplay = !!e),
            (t = "undefined" == typeof t ? this.options_.autoplay : t),
            this.tech_ && this.techCall_("setAutoplay", t);
        }),
        (e.playsinline = function (e) {
          return void 0 !== e
            ? (this.techCall_("setPlaysinline", e),
              (this.options_.playsinline = e),
              this)
            : this.techGet_("playsinline");
        }),
        (e.loop = function (e) {
          return void 0 !== e
            ? (this.techCall_("setLoop", e), void (this.options_.loop = e))
            : this.techGet_("loop");
        }),
        (e.poster = function (e) {
          if (void 0 === e) return this.poster_;
          (e = e || "") !== this.poster_ &&
            ((this.poster_ = e),
            this.techCall_("setPoster", e),
            (this.isPosterFromTech_ = !1),
            this.trigger("posterchange"));
        }),
        (e.handleTechPosterChange_ = function () {
          var e;
          (this.poster_ && !this.options_.techCanOverridePoster) ||
            !this.tech_ ||
            !this.tech_.poster ||
            ((e = this.tech_.poster() || "") !== this.poster_ &&
              ((this.poster_ = e),
              (this.isPosterFromTech_ = !0),
              this.trigger("posterchange")));
        }),
        (e.controls = function (e) {
          if (void 0 === e) return !!this.controls_;
          this.controls_ !== (e = !!e) &&
            ((this.controls_ = e),
            this.usingNativeControls() && this.techCall_("setControls", e),
            this.controls_
              ? (this.removeClass("vjs-controls-disabled"),
                this.addClass("vjs-controls-enabled"),
                this.trigger("controlsenabled"),
                this.usingNativeControls() || this.addTechControlsListeners_())
              : (this.removeClass("vjs-controls-enabled"),
                this.addClass("vjs-controls-disabled"),
                this.trigger("controlsdisabled"),
                this.usingNativeControls() ||
                  this.removeTechControlsListeners_()));
        }),
        (e.usingNativeControls = function (e) {
          if (void 0 === e) return !!this.usingNativeControls_;
          this.usingNativeControls_ !== (e = !!e) &&
            ((this.usingNativeControls_ = e),
            this.usingNativeControls_
              ? (this.addClass("vjs-using-native-controls"),
                this.trigger("usingnativecontrols"))
              : (this.removeClass("vjs-using-native-controls"),
                this.trigger("usingcustomcontrols")));
        }),
        (e.error = function (t) {
          var n = this;
          if (void 0 === t) return this.error_ || null;
          if (
            (U("beforeerror").forEach(function (e) {
              e = e(n, t);
              (ee(e) && !Array.isArray(e)) ||
              "string" == typeof e ||
              "number" == typeof e ||
              null === e
                ? (t = e)
                : n.log.error(
                    "please return a value that MediaError expects in beforeerror hooks"
                  );
            }),
            this.options_.suppressNotSupportedError && t && 4 === t.code)
          ) {
            var e = function () {
              this.error(t);
            };
            return (
              (this.options_.suppressNotSupportedError = !1),
              this.any(["click", "touchstart"], e),
              void this.one("loadstart", function () {
                this.off(["click", "touchstart"], e);
              })
            );
          }
          if (null === t)
            return (
              (this.error_ = t),
              this.removeClass("vjs-error"),
              void (this.errorDisplay && this.errorDisplay.close())
            );
          (this.error_ = new Bt(t)),
            this.addClass("vjs-error"),
            d.error(
              "(CODE:" +
                this.error_.code +
                " " +
                Bt.errorTypes[this.error_.code] +
                ")",
              this.error_.message,
              this.error_
            ),
            this.trigger("error"),
            U("error").forEach(function (e) {
              return e(n, n.error_);
            });
        }),
        (e.reportUserActivity = function (e) {
          this.userActivity_ = !0;
        }),
        (e.userActive = function (e) {
          if (void 0 === e) return this.userActive_;
          if ((e = !!e) !== this.userActive_) {
            if (((this.userActive_ = e), this.userActive_))
              return (
                (this.userActivity_ = !0),
                this.removeClass("vjs-user-inactive"),
                this.addClass("vjs-user-active"),
                void this.trigger("useractive")
              );
            this.tech_ &&
              this.tech_.one("mousemove", function (e) {
                e.stopPropagation(), e.preventDefault();
              }),
              (this.userActivity_ = !1),
              this.removeClass("vjs-user-active"),
              this.addClass("vjs-user-inactive"),
              this.trigger("userinactive");
          }
        }),
        (e.listenForUserActivity_ = function () {
          var t,
            n,
            i,
            r = u(this, this.reportUserActivity),
            e = function (e) {
              r(), this.clearInterval(t);
            };
          this.on("mousedown", function () {
            r(), this.clearInterval(t), (t = this.setInterval(r, 250));
          }),
            this.on("mousemove", function (e) {
              (e.screenX === n && e.screenY === i) ||
                ((n = e.screenX), (i = e.screenY), r());
            }),
            this.on("mouseup", e),
            this.on("mouseleave", e);
          var a,
            e = this.getChild("controlBar");
          !e ||
            ge ||
            re ||
            (e.on("mouseenter", function (e) {
              0 !== this.player().options_.inactivityTimeout &&
                (this.player().cache_.inactivityTimeout =
                  this.player().options_.inactivityTimeout),
                (this.player().options_.inactivityTimeout = 0);
            }),
            e.on("mouseleave", function (e) {
              this.player().options_.inactivityTimeout =
                this.player().cache_.inactivityTimeout;
            })),
            this.on("keydown", r),
            this.on("keyup", r),
            this.setInterval(function () {
              var e;
              this.userActivity_ &&
                ((this.userActivity_ = !1),
                this.userActive(!0),
                this.clearTimeout(a),
                (e = this.options_.inactivityTimeout) <= 0 ||
                  (a = this.setTimeout(function () {
                    this.userActivity_ || this.userActive(!1);
                  }, e)));
            }, 250);
        }),
        (e.playbackRate = function (e) {
          if (void 0 === e)
            return this.tech_ && this.tech_.featuresPlaybackRate
              ? this.cache_.lastPlaybackRate || this.techGet_("playbackRate")
              : 1;
          this.techCall_("setPlaybackRate", e);
        }),
        (e.defaultPlaybackRate = function (e) {
          return void 0 !== e
            ? this.techCall_("setDefaultPlaybackRate", e)
            : this.tech_ && this.tech_.featuresPlaybackRate
            ? this.techGet_("defaultPlaybackRate")
            : 1;
        }),
        (e.isAudio = function (e) {
          if (void 0 === e) return !!this.isAudio_;
          this.isAudio_ = !!e;
        }),
        (e.enableAudioOnlyUI_ = function () {
          var t = this;
          this.addClass("vjs-audio-only-mode");
          var e = this.children(),
            n = this.getChild("ControlBar"),
            i = n && n.currentHeight();
          e.forEach(function (e) {
            e !== n &&
              e.el_ &&
              !e.hasClass("vjs-hidden") &&
              (e.hide(), t.audioOnlyCache_.hiddenChildren.push(e));
          }),
            (this.audioOnlyCache_.playerHeight = this.currentHeight()),
            this.height(i),
            this.trigger("audioonlymodechange");
        }),
        (e.disableAudioOnlyUI_ = function () {
          this.removeClass("vjs-audio-only-mode"),
            this.audioOnlyCache_.hiddenChildren.forEach(function (e) {
              return e.show();
            }),
            this.height(this.audioOnlyCache_.playerHeight),
            this.trigger("audioonlymodechange");
        }),
        (e.audioOnlyMode = function (e) {
          var t = this;
          if ("boolean" != typeof e || e === this.audioOnlyMode_)
            return this.audioOnlyMode_;
          this.audioOnlyMode_ = e;
          var n = this.options_.Promise || window.Promise;
          if (n) {
            if (e) {
              var i = [];
              return (
                this.isInPictureInPicture() &&
                  i.push(this.exitPictureInPicture()),
                this.isFullscreen() && i.push(this.exitFullscreen()),
                this.audioPosterMode() && i.push(this.audioPosterMode(!1)),
                n.all(i).then(function () {
                  return t.enableAudioOnlyUI_();
                })
              );
            }
            return n.resolve().then(function () {
              return t.disableAudioOnlyUI_();
            });
          }
          e
            ? (this.isInPictureInPicture() && this.exitPictureInPicture(),
              this.isFullscreen() && this.exitFullscreen(),
              this.enableAudioOnlyUI_())
            : this.disableAudioOnlyUI_();
        }),
        (e.enablePosterModeUI_ = function () {
          (this.tech_ && this.tech_).hide(),
            this.addClass("vjs-audio-poster-mode"),
            this.trigger("audiopostermodechange");
        }),
        (e.disablePosterModeUI_ = function () {
          (this.tech_ && this.tech_).show(),
            this.removeClass("vjs-audio-poster-mode"),
            this.trigger("audiopostermodechange");
        }),
        (e.audioPosterMode = function (e) {
          var t = this;
          if ("boolean" != typeof e || e === this.audioPosterMode_)
            return this.audioPosterMode_;
          this.audioPosterMode_ = e;
          var n = this.options_.Promise || window.Promise;
          return n
            ? e
              ? (this.audioOnlyMode()
                  ? this.audioOnlyMode(!1)
                  : n.resolve()
                ).then(function () {
                  t.enablePosterModeUI_();
                })
              : n.resolve().then(function () {
                  t.disablePosterModeUI_();
                })
            : e
            ? (this.audioOnlyMode() && this.audioOnlyMode(!1),
              void this.enablePosterModeUI_())
            : void this.disablePosterModeUI_();
        }),
        (e.addTextTrack = function (e, t, n) {
          if (this.tech_) return this.tech_.addTextTrack(e, t, n);
        }),
        (e.addRemoteTextTrack = function (e, t) {
          if (this.tech_) return this.tech_.addRemoteTextTrack(e, t);
        }),
        (e.removeRemoteTextTrack = function (e) {
          var t = (t = (e = void 0 === e ? {} : e).track) || e;
          if (this.tech_) return this.tech_.removeRemoteTextTrack(t);
        }),
        (e.getVideoPlaybackQuality = function () {
          return this.techGet_("getVideoPlaybackQuality");
        }),
        (e.videoWidth = function () {
          return (
            (this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth()) ||
            0
          );
        }),
        (e.videoHeight = function () {
          return (
            (this.tech_ &&
              this.tech_.videoHeight &&
              this.tech_.videoHeight()) ||
            0
          );
        }),
        (e.language = function (e) {
          if (void 0 === e) return this.language_;
          this.language_ !== String(e).toLowerCase() &&
            ((this.language_ = String(e).toLowerCase()),
            Ct(this) && this.trigger("languagechange"));
        }),
        (e.languages = function () {
          return m(o.prototype.options_.languages, this.languages_);
        }),
        (e.toJSON = function () {
          var e = m(this.options_),
            t = e.tracks;
          e.tracks = [];
          for (var n = 0; n < t.length; n++) {
            var i = t[n];
            ((i = m(i)).player = void 0), (e.tracks[n] = i);
          }
          return e;
        }),
        (e.createModal = function (e, t) {
          var n = this;
          (t = t || {}).content = e || "";
          var i = new Xt(this, t);
          return (
            this.addChild(i),
            i.on("dispose", function () {
              n.removeChild(i);
            }),
            i.open(),
            i
          );
        }),
        (e.updateCurrentBreakpoint_ = function () {
          if (this.responsive())
            for (
              var e = this.currentBreakpoint(), t = this.currentWidth(), n = 0;
              n < Yi.length;
              n++
            ) {
              var i = Yi[n];
              if (t <= this.breakpoints_[i]) {
                if (e === i) return;
                e && this.removeClass(Ki[e]),
                  this.addClass(Ki[i]),
                  (this.breakpoint_ = i);
                break;
              }
            }
        }),
        (e.removeCurrentBreakpoint_ = function () {
          var e = this.currentBreakpointClass();
          (this.breakpoint_ = ""), e && this.removeClass(e);
        }),
        (e.breakpoints = function (e) {
          return (
            void 0 === e ||
              ((this.breakpoint_ = ""),
              (this.breakpoints_ = h({}, Qi, e)),
              this.updateCurrentBreakpoint_()),
            h(this.breakpoints_)
          );
        }),
        (e.responsive = function (e) {
          return void 0 === e
            ? this.responsive_
            : (e = Boolean(e)) !== this.responsive_
            ? ((this.responsive_ = e)
                ? (this.on("playerresize", this.boundUpdateCurrentBreakpoint_),
                  this.updateCurrentBreakpoint_())
                : (this.off("playerresize", this.boundUpdateCurrentBreakpoint_),
                  this.removeCurrentBreakpoint_()),
              e)
            : void 0;
        }),
        (e.currentBreakpoint = function () {
          return this.breakpoint_;
        }),
        (e.currentBreakpointClass = function () {
          return Ki[this.breakpoint_] || "";
        }),
        (e.loadMedia = function (e, t) {
          var n,
            i,
            r,
            a = this;
          e &&
            "object" == typeof e &&
            (this.reset(),
            (this.cache_.media = m(e)),
            (n = (r = this.cache_.media).artwork),
            (i = r.poster),
            (e = r.src),
            (r = r.textTracks),
            !n && i && (this.cache_.media.artwork = [{ src: i, type: di(i) }]),
            e && this.src(e),
            i && this.poster(i),
            Array.isArray(r) &&
              r.forEach(function (e) {
                return a.addRemoteTextTrack(e, !1);
              }),
            this.ready(t));
        }),
        (e.getMedia = function () {
          if (this.cache_.media) return m(this.cache_.media);
          var e = this.poster(),
            t = {
              src: this.currentSources(),
              textTracks: Array.prototype.map.call(
                this.remoteTextTracks(),
                function (e) {
                  return {
                    kind: e.kind,
                    label: e.label,
                    language: e.language,
                    src: e.src,
                  };
                }
              ),
            };
          return (
            e &&
              ((t.poster = e),
              (t.artwork = [{ src: t.poster, type: di(t.poster) }])),
            t
          );
        }),
        (o.getTagSettings = function (e) {
          var t,
            n = { sources: [], tracks: [] },
            i = Pe(e),
            r = i["data-setup"];
          if (
            (Ce(e, "vjs-fill") && (i.fill = !0),
            Ce(e, "vjs-fluid") && (i.fluid = !0),
            null !== r &&
              ((r = (t = Vt(r || "{}"))[0]),
              (t = t[1]),
              r && d.error(r),
              h(i, t)),
            h(n, i),
            e.hasChildNodes())
          )
            for (var a = e.childNodes, s = 0, o = a.length; s < o; s++) {
              var l = a[s],
                u = l.nodeName.toLowerCase();
              "source" === u
                ? n.sources.push(Pe(l))
                : "track" === u && n.tracks.push(Pe(l));
            }
          return n;
        }),
        (e.flexNotSupported_ = function () {
          var e = document.createElement("i");
          return !(
            "flexBasis" in e.style ||
            "webkitFlexBasis" in e.style ||
            "mozFlexBasis" in e.style ||
            "msFlexBasis" in e.style ||
            "msFlexOrder" in e.style
          );
        }),
        (e.debug = function (e) {
          if (void 0 === e) return this.debugEnabled_;
          e
            ? (this.trigger("debugon"),
              (this.previousLogLevel_ = this.log.level),
              this.log.level("debug"),
              (this.debugEnabled_ = !0))
            : (this.trigger("debugoff"),
              this.log.level(this.previousLogLevel_),
              (this.previousLogLevel_ = void 0),
              (this.debugEnabled_ = !1));
        }),
        (e.playbackRates = function (e) {
          if (void 0 === e) return this.cache_.playbackRates;
          Array.isArray(e) &&
            e.every(function (e) {
              return "number" == typeof e;
            }) &&
            ((this.cache_.playbackRates = e),
            this.trigger("playbackrateschange"));
        }),
        o
      );
    })(g);
  An.names.forEach(function (e) {
    var t = An[e];
    A.prototype[t.getterName] = function () {
      return this.tech_
        ? this.tech_[t.getterName]()
        : ((this[t.privateName] = this[t.privateName] || new t.ListClass()),
          this[t.privateName]);
    };
  }),
    (A.prototype.crossorigin = A.prototype.crossOrigin),
    (A.players = {});
  t = window.navigator;
  (A.prototype.options_ = {
    techOrder: O.defaultTechOrder_,
    html5: {},
    inactivityTimeout: 2e3,
    playbackRates: [],
    liveui: !1,
    children: [
      "mediaLoader",
      "posterImage",
      "textTrackDisplay",
      "loadingSpinner",
      "bigPlayButton",
      "liveTracker",
      "controlBar",
      "errorDisplay",
      "textTrackSettings",
      "resizeManager",
    ],
    language:
      (t &&
        ((t.languages && t.languages[0]) || t.userLanguage || t.language)) ||
      "en",
    languages: {},
    notSupportedMessage: "No compatible source was found for this media.",
    normalizeAutoplay: !1,
    fullscreen: { options: { navigationUI: "hide" } },
    breakpoints: {},
    responsive: !1,
    audioOnlyMode: !1,
    audioPosterMode: !1,
  }),
    ["ended", "seeking", "seekable", "networkState", "readyState"].forEach(
      function (e) {
        A.prototype[e] = function () {
          return this.techGet_(e);
        };
      }
    ),
    Wi.forEach(function (e) {
      A.prototype["handleTech" + p(e) + "_"] = function () {
        return this.trigger(e);
      };
    }),
    g.registerComponent("Player", A);
  var Zi = K(function (n) {
    function i(e, t) {
      return (
        (n.exports = i =
          Object.setPrototypeOf ||
          function (e, t) {
            return (e.__proto__ = t), e;
          }),
        i(e, t)
      );
    }
    n.exports = i;
  });
  function Ji(e) {
    return or.hasOwnProperty(e);
  }
  function $i(e) {
    return Ji(e) ? or[e] : void 0;
  }
  function er(e, t, n) {
    (n = (n ? "before" : "") + "pluginsetup"),
      e.trigger(n, t),
      e.trigger(n + ":" + t.name, t);
  }
  function tr(t, n) {
    function i() {
      er(this, { name: t, plugin: n, instance: null }, !0);
      var e = n.apply(this, arguments);
      return lr(this, t), er(this, { name: t, plugin: n, instance: e }), e;
    }
    return (
      Object.keys(n).forEach(function (e) {
        i[e] = n[e];
      }),
      i
    );
  }
  function nr(r, a) {
    return (
      (a.prototype.name = r),
      function () {
        er(this, { name: r, plugin: a, instance: null }, !0);
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
          t[n] = arguments[n];
        var i = rr(a, [this].concat(t));
        return (
          (this[r] = function () {
            return i;
          }),
          er(this, i.getEventHash()),
          i
        );
      }
    );
  }
  var ir = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return (
          Date.prototype.toString.call(
            Reflect.construct(Date, [], function () {})
          ),
          !0
        );
      } catch (e) {
        return !1;
      }
    },
    rr = K(function (i) {
      function r(e, t, n) {
        return (
          ir()
            ? (i.exports = r = Reflect.construct)
            : (i.exports = r =
                function (e, t, n) {
                  var i = [null];
                  i.push.apply(i, t);
                  i = new (Function.bind.apply(e, i))();
                  return n && Zi(i, n.prototype), i;
                }),
          r.apply(null, arguments)
        );
      }
      i.exports = r;
    }),
    ar = "plugin",
    sr = "activePlugins_",
    or = {},
    lr = function (e, t) {
      (e[sr] = e[sr] || {}), (e[sr][t] = !0);
    },
    ur = (function () {
      function n(e) {
        if (this.constructor === n)
          throw new Error(
            "Plugin must be sub-classed; not directly instantiated."
          );
        (this.player = e),
          this.log || (this.log = this.player.log.createLogger(this.name)),
          xt(this),
          delete this.trigger,
          kt(this, this.constructor.defaultState),
          lr(e, this.name),
          (this.dispose = this.dispose.bind(this)),
          e.on("dispose", this.dispose);
      }
      var e = n.prototype;
      return (
        (e.version = function () {
          return this.constructor.VERSION;
        }),
        (e.getEventHash = function (e) {
          return (
            ((e = void 0 === e ? {} : e).name = this.name),
            (e.plugin = this.constructor),
            (e.instance = this),
            e
          );
        }),
        (e.trigger = function (e, t) {
          return dt(
            this.eventBusEl_,
            e,
            this.getEventHash((t = void 0 === t ? {} : t))
          );
        }),
        (e.handleStateChanged = function (e) {}),
        (e.dispose = function () {
          var e = this.name,
            t = this.player;
          this.trigger("dispose"),
            this.off(),
            t.off("dispose", this.dispose),
            (t[sr][e] = !1),
            (this.player = this.state = null),
            (t[e] = nr(e, or[e]));
        }),
        (n.isBasic = function (e) {
          e = "string" == typeof e ? $i(e) : e;
          return (
            "function" == typeof e && !n.prototype.isPrototypeOf(e.prototype)
          );
        }),
        (n.registerPlugin = function (e, t) {
          if ("string" != typeof e)
            throw new Error(
              'Illegal plugin name, "' +
                e +
                '", must be a string, was ' +
                typeof e +
                "."
            );
          if (Ji(e))
            d.warn(
              'A plugin named "' +
                e +
                '" already exists. You may want to avoid re-registering plugins!'
            );
          else if (A.prototype.hasOwnProperty(e))
            throw new Error(
              'Illegal plugin name, "' +
                e +
                '", cannot share a name with an existing player method!'
            );
          if ("function" != typeof t)
            throw new Error(
              'Illegal plugin for "' +
                e +
                '", must be a function, was ' +
                typeof t +
                "."
            );
          return (
            (or[e] = t),
            e !== ar &&
              (n.isBasic(t)
                ? (A.prototype[e] = tr(e, t))
                : (A.prototype[e] = nr(e, t))),
            t
          );
        }),
        (n.deregisterPlugin = function (e) {
          if (e === ar) throw new Error("Cannot de-register base plugin.");
          Ji(e) && (delete or[e], delete A.prototype[e]);
        }),
        (n.getPlugins = function (e) {
          var n;
          return (
            (e = void 0 === e ? Object.keys(or) : e).forEach(function (e) {
              var t = $i(e);
              t && ((n = n || {})[e] = t);
            }),
            n
          );
        }),
        (n.getPluginVersion = function (e) {
          e = $i(e);
          return (e && e.VERSION) || "";
        }),
        n
      );
    })();
  (ur.getPlugin = $i),
    (ur.BASE_PLUGIN_NAME = ar),
    ur.registerPlugin(ar, ur),
    (A.prototype.usingPlugin = function (e) {
      return !!this[sr] && !0 === this[sr][e];
    }),
    (A.prototype.hasPlugin = function (e) {
      return !!Ji(e);
    });
  var cr = function (e, t) {
      if ("function" != typeof t && null !== t)
        throw new TypeError(
          "Super expression must either be null or a function"
        );
      (e.prototype = Object.create(t && t.prototype, {
        constructor: { value: e, writable: !0, configurable: !0 },
      })),
        t && Zi(e, t);
    },
    dr = function (e) {
      return 0 === e.indexOf("#") ? e.slice(1) : e;
    };
  function w(e, t, n) {
    if ((r = w.getPlayer(e)))
      return (
        t &&
          d.warn(
            'Player "' +
              e +
              '" is already initialised. Options will not be applied.'
          ),
        n && r.ready(n),
        r
      );
    var i = "string" == typeof e ? Xe("#" + dr(e)) : e;
    if (!Te(i))
      throw new TypeError("The element or ID supplied is not valid. (videojs)");
    (i.ownerDocument.defaultView && i.ownerDocument.body.contains(i)) ||
      d.warn("The element supplied is not included in the DOM"),
      !0 === (t = t || {}).restoreEl &&
        (t.restoreEl = (
          i.parentNode && i.parentNode.hasAttribute("data-vjs-player")
            ? i.parentNode
            : i
        ).cloneNode(!0)),
      U("beforesetup").forEach(function (e) {
        e = e(i, m(t));
        ee(e) && !Array.isArray(e)
          ? (t = m(t, e))
          : d.error("please return an object in beforesetup hooks");
      });
    var r = new (g.getComponent("Player"))(i, t, n);
    return (
      U("setup").forEach(function (e) {
        return e(r);
      }),
      r
    );
  }
  (w.hooks_ = B),
    (w.hooks = U),
    (w.hook = function (e, t) {
      U(e, t);
    }),
    (w.hookOnce = function (n, e) {
      U(
        n,
        [].concat(e).map(function (t) {
          return function e() {
            return V(n, e), t.apply(void 0, arguments);
          };
        })
      );
    }),
    (w.removeHook = V),
    !0 !== window.VIDEOJS_NO_DYNAMIC_STYLE &&
      _e() &&
      ((mr = Xe(".vjs-styles-defaults")) ||
        ((mr = et("vjs-styles-defaults")),
        (t = Xe("head")) && t.insertBefore(mr, t.firstChild),
        tt(
          mr,
          "\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: 56.25%\n      }\n    "
        ))),
    Je(1, w),
    (w.VERSION = R),
    (w.options = A.prototype.options_),
    (w.getPlayers = function () {
      return A.players;
    }),
    (w.getPlayer = function (e) {
      var t = A.players;
      if ("string" == typeof e) {
        var n = dr(e),
          i = t[n];
        if (i) return i;
        n = Xe("#" + n);
      } else n = e;
      if (Te(n)) {
        (e = n.player), (n = n.playerId);
        if (e || t[n]) return e || t[n];
      }
    }),
    (w.getAllPlayers = function () {
      return Object.keys(A.players)
        .map(function (e) {
          return A.players[e];
        })
        .filter(Boolean);
    }),
    (w.players = A.players),
    (w.getComponent = g.getComponent),
    (w.registerComponent = function (e, t) {
      O.isTech(t) &&
        d.warn(
          "The " +
            e +
            " tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)"
        ),
        g.registerComponent.call(g, e, t);
    }),
    (w.getTech = O.getTech),
    (w.registerTech = O.registerTech),
    (w.use = function (e, t) {
      (ti[e] = ti[e] || []), ti[e].push(t);
    }),
    Object.defineProperty(w, "middleware", {
      value: {},
      writeable: !1,
      enumerable: !0,
    }),
    Object.defineProperty(w.middleware, "TERMINATOR", {
      value: ii,
      writeable: !1,
      enumerable: !0,
    }),
    (w.browser = s),
    (w.TOUCH_ENABLED = me),
    (w.extend = function (e, t) {
      var n,
        i = function () {
          e.apply(this, arguments);
        },
        r = {};
      for (n in ("object" == typeof (t = void 0 === t ? {} : t)
        ? (t.constructor !== Object.prototype.constructor &&
            (i = t.constructor),
          (r = t))
        : "function" == typeof t && (i = t),
      cr(i, e),
      e && (i.super_ = e),
      r))
        r.hasOwnProperty(n) && (i.prototype[n] = r[n]);
      return i;
    }),
    (w.mergeOptions = m),
    (w.bind = u),
    (w.registerPlugin = ur.registerPlugin),
    (w.deregisterPlugin = ur.deregisterPlugin),
    (w.plugin = function (e, t) {
      return (
        d.warn(
          "videojs.plugin() is deprecated; use videojs.registerPlugin() instead"
        ),
        ur.registerPlugin(e, t)
      );
    }),
    (w.getPlugins = ur.getPlugins),
    (w.getPlugin = ur.getPlugin),
    (w.getPluginVersion = ur.getPluginVersion),
    (w.addLanguage = function (e, t) {
      var n;
      return (
        (e = ("" + e).toLowerCase()),
        (w.options.languages = m(w.options.languages, (((n = {})[e] = t), n))),
        w.options.languages[e]
      );
    }),
    (w.log = d),
    (w.createLogger = Y),
    (w.createTimeRange = w.createTimeRanges = Dt),
    (w.formatTime = Oi),
    (w.setFormatTime = function (e) {
      Ti = e;
    }),
    (w.resetFormatTime = function () {
      Ti = _i;
    }),
    (w.parseUrl = Jt),
    (w.isCrossOrigin = tn),
    (w.EventTarget = gt),
    (w.on = ct),
    (w.one = ht),
    (w.off = l),
    (w.trigger = dt),
    (w.xhr = fn),
    (w.TextTrack = Tn),
    (w.AudioTrack = r),
    (w.VideoTrack = he),
    [
      "isEl",
      "isTextNode",
      "createEl",
      "hasClass",
      "addClass",
      "removeClass",
      "toggleClass",
      "setAttributes",
      "getAttributes",
      "emptyEl",
      "appendContent",
      "insertContent",
    ].forEach(function (e) {
      w[e] = function () {
        return (
          d.warn(
            "videojs." +
              e +
              "() is deprecated; use videojs.dom." +
              e +
              "() instead"
          ),
          Ke[e].apply(null, arguments)
        );
      };
    }),
    (w.computedStyle = ne),
    (w.dom = Ke),
    (w.url = cn),
    (w.defineLazyProperty = Gi),
    w.addLanguage("en", { "Non-Fullscreen": "Exit Fullscreen" });
  var hr = K(function (e, t) {
      var n, a, i, r, s;
      (n =
        /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/?#]*\/)*[^;?#]*)?(;[^?#]*)?(\?[^#]*)?(#[^]*)?$/),
        (a = /^([^\/?#]*)([^]*)$/),
        (i = /(?:\/|^)\.(?=\/)/g),
        (r = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g),
        (s = {
          buildAbsoluteURL: function (e, t, n) {
            if (((n = n || {}), (e = e.trim()), !(t = t.trim()))) {
              if (!n.alwaysNormalize) return e;
              var i = s.parseURL(e);
              if (!i) throw new Error("Error trying to parse base URL.");
              return (i.path = s.normalizePath(i.path)), s.buildURLFromParts(i);
            }
            i = s.parseURL(t);
            if (!i) throw new Error("Error trying to parse relative URL.");
            if (i.scheme)
              return n.alwaysNormalize
                ? ((i.path = s.normalizePath(i.path)), s.buildURLFromParts(i))
                : t;
            t = s.parseURL(e);
            if (!t) throw new Error("Error trying to parse base URL.");
            !t.netLoc &&
              t.path &&
              "/" !== t.path[0] &&
              ((r = a.exec(t.path)), (t.netLoc = r[1]), (t.path = r[2])),
              t.netLoc && !t.path && (t.path = "/");
            var r,
              e = {
                scheme: t.scheme,
                netLoc: i.netLoc,
                path: null,
                params: i.params,
                query: i.query,
                fragment: i.fragment,
              };
            return (
              i.netLoc ||
                ((e.netLoc = t.netLoc),
                "/" !== i.path[0] &&
                  (i.path
                    ? ((r =
                        (r = t.path).substring(0, r.lastIndexOf("/") + 1) +
                        i.path),
                      (e.path = s.normalizePath(r)))
                    : ((e.path = t.path),
                      i.params ||
                        ((e.params = t.params),
                        i.query || (e.query = t.query))))),
              null === e.path &&
                (e.path = n.alwaysNormalize ? s.normalizePath(i.path) : i.path),
              s.buildURLFromParts(e)
            );
          },
          parseURL: function (e) {
            e = n.exec(e);
            return e
              ? {
                  scheme: e[1] || "",
                  netLoc: e[2] || "",
                  path: e[3] || "",
                  params: e[4] || "",
                  query: e[5] || "",
                  fragment: e[6] || "",
                }
              : null;
          },
          normalizePath: function (e) {
            for (
              e = e.split("").reverse().join("").replace(i, "");
              e.length !== (e = e.replace(r, "")).length;

            );
            return e.split("").reverse().join("");
          },
          buildURLFromParts: function (e) {
            return (
              e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment
            );
          },
        }),
        (e.exports = s);
    }),
    pr = "http://example.com",
    mr = (function () {
      function e() {
        this.listeners = {};
      }
      var t = e.prototype;
      return (
        (t.on = function (e, t) {
          this.listeners[e] || (this.listeners[e] = []),
            this.listeners[e].push(t);
        }),
        (t.off = function (e, t) {
          if (!this.listeners[e]) return !1;
          t = this.listeners[e].indexOf(t);
          return (
            (this.listeners[e] = this.listeners[e].slice(0)),
            this.listeners[e].splice(t, 1),
            -1 < t
          );
        }),
        (t.trigger = function (e) {
          var t = this.listeners[e];
          if (t)
            if (2 === arguments.length)
              for (var n = t.length, i = 0; i < n; ++i)
                t[i].call(this, arguments[1]);
            else
              for (
                var r = Array.prototype.slice.call(arguments, 1),
                  a = t.length,
                  s = 0;
                s < a;
                ++s
              )
                t[s].apply(this, r);
        }),
        (t.dispose = function () {
          this.listeners = {};
        }),
        (t.pipe = function (t) {
          this.on("data", function (e) {
            t.push(e);
          });
        }),
        e
      );
    })(),
    fr = function (e) {
      return window.atob
        ? window.atob(e)
        : Buffer.from(e, "base64").toString("binary");
    };
  function gr(e) {
    var t = /([0-9.]*)?@?([0-9.]*)?/.exec(e || ""),
      e = {};
    return (
      t[1] && (e.length = parseInt(t[1], 10)),
      t[2] && (e.offset = parseInt(t[2], 10)),
      e
    );
  }
  function br(e) {
    for (
      var t,
        n = e.split(new RegExp('(?:^|,)((?:[^=]*)=(?:"[^"]*"|[^,]*))')),
        i = {},
        r = n.length;
      r--;

    )
      "" !== n[r] &&
        (((t = /([^=]*)=(.*)/.exec(n[r]).slice(1))[0] = t[0].replace(
          /^\s+|\s+$/g,
          ""
        )),
        (t[1] = t[1].replace(/^\s+|\s+$/g, "")),
        (t[1] = t[1].replace(/^['"](.*)['"]$/g, "$1")),
        (i[t[0]] = t[1]));
    return i;
  }
  function vr(t) {
    var n = {};
    return (
      Object.keys(t).forEach(function (e) {
        n[
          e.toLowerCase().replace(/-(\w)/g, function (e) {
            return e[1].toUpperCase();
          })
        ] = t[e];
      }),
      n
    );
  }
  function yr(e) {
    var t,
      n,
      i,
      r,
      a = e.serverControl,
      s = e.targetDuration,
      o = e.partTargetDuration;
    a &&
      ((t = "#EXT-X-SERVER-CONTROL"),
      (n = "holdBack"),
      (i = "partHoldBack"),
      (r = s && 3 * s),
      (e = o && 2 * o),
      s &&
        !a.hasOwnProperty(n) &&
        ((a[n] = r),
        this.trigger("info", {
          message:
            t + " defaulting HOLD-BACK to targetDuration * 3 (" + r + ").",
        })),
      r &&
        a[n] < r &&
        (this.trigger("warn", {
          message:
            t +
            " clamping HOLD-BACK (" +
            a[n] +
            ") to targetDuration * 3 (" +
            r +
            ")",
        }),
        (a[n] = r)),
      o &&
        !a.hasOwnProperty(i) &&
        ((a[i] = 3 * o),
        this.trigger("info", {
          message:
            t +
            " defaulting PART-HOLD-BACK to partTargetDuration * 3 (" +
            a[i] +
            ").",
        })),
      o &&
        a[i] < e &&
        (this.trigger("warn", {
          message:
            t +
            " clamping PART-HOLD-BACK (" +
            a[i] +
            ") to partTargetDuration * 2 (" +
            e +
            ").",
        }),
        (a[i] = e)));
  }
  function _r(e) {
    return (
      e &&
      e.replace(/avc1\.(\d+)\.(\d+)/i, function (e, t, n) {
        return (
          "avc1." +
          ("00" + Number(t).toString(16)).slice(-2) +
          "00" +
          ("00" + Number(n).toString(16)).slice(-2)
        );
      })
    );
  }
  function Tr(e) {
    var e = (e = void 0 === e ? "" : e).split(","),
      a = [];
    return (
      e.forEach(function (i) {
        var r;
        (i = i.trim()),
          Dr.forEach(function (e) {
            var t,
              n = Mr[e].exec(i.toLowerCase());
            !n ||
              n.length <= 1 ||
              ((r = e),
              (t = i.substring(0, n[1].length)),
              (n = i.replace(t, "")),
              a.push({ type: t, details: n, mediaType: e }));
          }),
          r || a.push({ type: i, details: "", mediaType: "unknown" });
      }),
      a
    );
  }
  function Or(e) {
    return Mr.audio.test((e = void 0 === e ? "" : e).trim().toLowerCase());
  }
  function Sr(e) {
    if (e && "string" == typeof e) {
      var t = e
          .toLowerCase()
          .split(",")
          .map(function (e) {
            return _r(e.trim());
          }),
        n = "video";
      1 === t.length && Or(t[0])
        ? (n = "audio")
        : 1 === t.length &&
          ((i = t[0]),
          Mr.text.test((i = void 0 === i ? "" : i).trim().toLowerCase())) &&
          (n = "application");
      var i = "mp4";
      return (
        t.every(function (e) {
          return Mr.mp4.test(e);
        })
          ? (i = "mp4")
          : t.every(function (e) {
              return Mr.webm.test(e);
            })
          ? (i = "webm")
          : t.every(function (e) {
              return Mr.ogg.test(e);
            }) && (i = "ogg"),
        n + "/" + i + ';codecs="' + e + '"'
      );
    }
  }
  function Ar(e) {
    return (
      void 0 === e && (e = ""),
      (window.MediaSource &&
        window.MediaSource.isTypeSupported &&
        window.MediaSource.isTypeSupported(Sr(e))) ||
        !1
    );
  }
  function wr(e) {
    return (e = void 0 === e ? "" : e)
      .toLowerCase()
      .split(",")
      .every(function (e) {
        e = e.trim();
        for (var t = 0; t < Rr.length; t++)
          if (Mr["muxer" + Rr[t]].test(e)) return !0;
        return !1;
      });
  }
  function Cr(e) {
    return Ur.test(e)
      ? "hls"
      : Vr.test(e)
      ? "dash"
      : "application/vnd.videojs.vhs+json" === e
      ? "vhs-json"
      : null;
  }
  function Ir(e) {
    return "function" === ArrayBuffer.isView
      ? ArrayBuffer.isView(e)
      : e && e.buffer instanceof ArrayBuffer;
  }
  function C(e) {
    return e instanceof Uint8Array
      ? e
      : (Array.isArray(e) ||
          Fr(e) ||
          e instanceof ArrayBuffer ||
          (e =
            "number" != typeof e || ("number" == typeof e && e != e) ? 0 : [e]),
        new Uint8Array(
          (e && e.buffer) || e,
          (e && e.byteOffset) || 0,
          (e && e.byteLength) || 0
        ));
  }
  function xr(e, t) {
    var n = void 0 !== (t = (void 0 === t ? {} : t).le) && t;
    e = x(
      (e =
        ("bigint" != typeof e && "number" != typeof e) ||
        ("number" == typeof e && e != e)
          ? 0
          : e)
    );
    for (
      var i = ((t = e), Math.ceil(t.toString(2).length / 8)),
        r = new Uint8Array(new ArrayBuffer(i)),
        a = 0;
      a < i;
      a++
    ) {
      var s = n ? a : Math.abs(a + 1 - r.length);
      (r[s] = Number((e / Gr[a]) & x(255))),
        e < 0 && ((r[s] = Math.abs(~r[s])), (r[s] -= 0 === a ? 1 : 2));
    }
    return r;
  }
  function Er(e, t) {
    if (
      "string" !=
      typeof (e =
        "string" != typeof e && e && "function" == typeof e.toString
          ? e.toString()
          : e)
    )
      return new Uint8Array();
    t || (e = unescape(encodeURIComponent(e)));
    for (var n = new Uint8Array(e.length), i = 0; i < e.length; i++)
      n[i] = e.charCodeAt(i);
    return n;
  }
  function I(n, e, t) {
    var i = void 0 === t ? {} : t,
      r = void 0 === (t = i.offset) ? 0 : t,
      a = void 0 === (i = i.mask) ? [] : i;
    return (
      (n = C(n)),
      (i = (e = C(e)).every || Array.prototype.every),
      e.length &&
        n.length - r >= e.length &&
        i.call(e, function (e, t) {
          return e === (a[t] ? a[t] & n[r + t] : n[r + t]);
        })
    );
  }
  function kr(e, t) {
    if (/^[a-z]+:/i.test(t)) return t;
    /^data:/.test(e) && (e = (window.location && window.location.href) || "");
    var n = "function" == typeof window.URL,
      i = /^\/\//.test(e),
      r = !window.location && !/\/\//i.test(e);
    if (
      (n
        ? (e = new window.URL(e, window.location || qr))
        : /\/\//i.test(e) ||
          (e = hr.buildAbsoluteURL(
            (window.location && window.location.href) || "",
            e
          )),
      n)
    ) {
      n = new URL(t, e);
      return r
        ? n.href.slice(qr.length)
        : i
        ? n.href.slice(n.protocol.length)
        : n.href;
    }
    return hr.buildAbsoluteURL(e, t);
  }
  var Pr = (function (t) {
      function e() {
        var e = t.call(this) || this;
        return (e.buffer = ""), e;
      }
      return (
        b(e, t),
        (e.prototype.push = function (e) {
          var t;
          for (
            this.buffer += e, t = this.buffer.indexOf("\n");
            -1 < t;
            t = this.buffer.indexOf("\n")
          )
            this.trigger("data", this.buffer.substring(0, t)),
              (this.buffer = this.buffer.substring(t + 1));
        }),
        e
      );
    })(mr),
    jr = String.fromCharCode(9),
    Nr = (function (t) {
      function e() {
        var e = t.call(this) || this;
        return (e.customParsers = []), (e.tagMappers = []), e;
      }
      b(e, t);
      var n = e.prototype;
      return (
        (n.push = function (n) {
          var r,
            a,
            s = this;
          0 !== (n = n.trim()).length &&
            ("#" === n[0]
              ? this.tagMappers
                  .reduce(
                    function (e, t) {
                      t = t(n);
                      return t === n ? e : e.concat([t]);
                    },
                    [n]
                  )
                  .forEach(function (e) {
                    for (var t, n, i = 0; i < s.customParsers.length; i++)
                      if (s.customParsers[i].call(s, e)) return;
                    if (0 === e.indexOf("#EXT"))
                      if (((e = e.replace("\r", "")), (r = /^#EXTM3U/.exec(e))))
                        s.trigger("data", { type: "tag", tagType: "m3u" });
                      else {
                        if ((r = /^#EXTINF:?([0-9\.]*)?,?(.*)?$/.exec(e)))
                          return (
                            (a = { type: "tag", tagType: "inf" }),
                            r[1] && (a.duration = parseFloat(r[1])),
                            r[2] && (a.title = r[2]),
                            void s.trigger("data", a)
                          );
                        if ((r = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(e)))
                          return (
                            (a = { type: "tag", tagType: "targetduration" }),
                            r[1] && (a.duration = parseInt(r[1], 10)),
                            void s.trigger("data", a)
                          );
                        if ((r = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(e)))
                          return (
                            (a = { type: "tag", tagType: "version" }),
                            r[1] && (a.version = parseInt(r[1], 10)),
                            void s.trigger("data", a)
                          );
                        if (
                          (r = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(e))
                        )
                          return (
                            (a = { type: "tag", tagType: "media-sequence" }),
                            r[1] && (a.number = parseInt(r[1], 10)),
                            void s.trigger("data", a)
                          );
                        if (
                          (r =
                            /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/.exec(
                              e
                            ))
                        )
                          return (
                            (a = {
                              type: "tag",
                              tagType: "discontinuity-sequence",
                            }),
                            r[1] && (a.number = parseInt(r[1], 10)),
                            void s.trigger("data", a)
                          );
                        if ((r = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(e)))
                          return (
                            (a = { type: "tag", tagType: "playlist-type" }),
                            r[1] && (a.playlistType = r[1]),
                            void s.trigger("data", a)
                          );
                        if ((r = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(e)))
                          return (
                            (a = Q(gr(r[1]), {
                              type: "tag",
                              tagType: "byterange",
                            })),
                            void s.trigger("data", a)
                          );
                        if ((r = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(e)))
                          return (
                            (a = { type: "tag", tagType: "allow-cache" }),
                            r[1] && (a.allowed = !/NO/.test(r[1])),
                            void s.trigger("data", a)
                          );
                        if ((r = /^#EXT-X-MAP:?(.*)$/.exec(e)))
                          return (
                            (a = { type: "tag", tagType: "map" }),
                            r[1] &&
                              ((t = br(r[1])).URI && (a.uri = t.URI),
                              t.BYTERANGE && (a.byterange = gr(t.BYTERANGE))),
                            void s.trigger("data", a)
                          );
                        if ((r = /^#EXT-X-STREAM-INF:?(.*)$/.exec(e)))
                          return (
                            (a = { type: "tag", tagType: "stream-inf" }),
                            r[1] &&
                              ((a.attributes = br(r[1])),
                              a.attributes.RESOLUTION &&
                                ((n = {}),
                                (t = a.attributes.RESOLUTION.split("x"))[0] &&
                                  (n.width = parseInt(t[0], 10)),
                                t[1] && (n.height = parseInt(t[1], 10)),
                                (a.attributes.RESOLUTION = n)),
                              a.attributes.BANDWIDTH &&
                                (a.attributes.BANDWIDTH = parseInt(
                                  a.attributes.BANDWIDTH,
                                  10
                                )),
                              a.attributes["PROGRAM-ID"] &&
                                (a.attributes["PROGRAM-ID"] = parseInt(
                                  a.attributes["PROGRAM-ID"],
                                  10
                                ))),
                            void s.trigger("data", a)
                          );
                        if ((r = /^#EXT-X-MEDIA:?(.*)$/.exec(e)))
                          return (
                            (a = { type: "tag", tagType: "media" }),
                            r[1] && (a.attributes = br(r[1])),
                            void s.trigger("data", a)
                          );
                        if ((r = /^#EXT-X-ENDLIST/.exec(e)))
                          s.trigger("data", {
                            type: "tag",
                            tagType: "endlist",
                          });
                        else {
                          if (!(r = /^#EXT-X-DISCONTINUITY/.exec(e)))
                            return (r = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(
                              e
                            ))
                              ? ((a = {
                                  type: "tag",
                                  tagType: "program-date-time",
                                }),
                                r[1] &&
                                  ((a.dateTimeString = r[1]),
                                  (a.dateTimeObject = new Date(r[1]))),
                                void s.trigger("data", a))
                              : (r = /^#EXT-X-KEY:?(.*)$/.exec(e))
                              ? ((a = { type: "tag", tagType: "key" }),
                                r[1] &&
                                  ((a.attributes = br(r[1])),
                                  a.attributes.IV &&
                                    ("0x" ===
                                      a.attributes.IV.substring(
                                        0,
                                        2
                                      ).toLowerCase() &&
                                      (a.attributes.IV =
                                        a.attributes.IV.substring(2)),
                                    (a.attributes.IV =
                                      a.attributes.IV.match(/.{8}/g)),
                                    (a.attributes.IV[0] = parseInt(
                                      a.attributes.IV[0],
                                      16
                                    )),
                                    (a.attributes.IV[1] = parseInt(
                                      a.attributes.IV[1],
                                      16
                                    )),
                                    (a.attributes.IV[2] = parseInt(
                                      a.attributes.IV[2],
                                      16
                                    )),
                                    (a.attributes.IV[3] = parseInt(
                                      a.attributes.IV[3],
                                      16
                                    )),
                                    (a.attributes.IV = new Uint32Array(
                                      a.attributes.IV
                                    )))),
                                void s.trigger("data", a))
                              : (r = /^#EXT-X-START:?(.*)$/.exec(e))
                              ? ((a = { type: "tag", tagType: "start" }),
                                r[1] &&
                                  ((a.attributes = br(r[1])),
                                  (a.attributes["TIME-OFFSET"] = parseFloat(
                                    a.attributes["TIME-OFFSET"]
                                  )),
                                  (a.attributes.PRECISE = /YES/.test(
                                    a.attributes.PRECISE
                                  ))),
                                void s.trigger("data", a))
                              : (r = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(e))
                              ? ((a = { type: "tag", tagType: "cue-out-cont" }),
                                r[1] ? (a.data = r[1]) : (a.data = ""),
                                void s.trigger("data", a))
                              : (r = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(e))
                              ? ((a = { type: "tag", tagType: "cue-out" }),
                                r[1] ? (a.data = r[1]) : (a.data = ""),
                                void s.trigger("data", a))
                              : (r = /^#EXT-X-CUE-IN:?(.*)?$/.exec(e))
                              ? ((a = { type: "tag", tagType: "cue-in" }),
                                r[1] ? (a.data = r[1]) : (a.data = ""),
                                void s.trigger("data", a))
                              : (r = /^#EXT-X-SKIP:(.*)$/.exec(e)) && r[1]
                              ? (((a = {
                                  type: "tag",
                                  tagType: "skip",
                                }).attributes = br(r[1])),
                                a.attributes.hasOwnProperty(
                                  "SKIPPED-SEGMENTS"
                                ) &&
                                  (a.attributes["SKIPPED-SEGMENTS"] = parseInt(
                                    a.attributes["SKIPPED-SEGMENTS"],
                                    10
                                  )),
                                a.attributes.hasOwnProperty(
                                  "RECENTLY-REMOVED-DATERANGES"
                                ) &&
                                  (a.attributes["RECENTLY-REMOVED-DATERANGES"] =
                                    a.attributes[
                                      "RECENTLY-REMOVED-DATERANGES"
                                    ].split(jr)),
                                void s.trigger("data", a))
                              : (r = /^#EXT-X-PART:(.*)$/.exec(e)) && r[1]
                              ? (((a = {
                                  type: "tag",
                                  tagType: "part",
                                }).attributes = br(r[1])),
                                ["DURATION"].forEach(function (e) {
                                  a.attributes.hasOwnProperty(e) &&
                                    (a.attributes[e] = parseFloat(
                                      a.attributes[e]
                                    ));
                                }),
                                ["INDEPENDENT", "GAP"].forEach(function (e) {
                                  a.attributes.hasOwnProperty(e) &&
                                    (a.attributes[e] = /YES/.test(
                                      a.attributes[e]
                                    ));
                                }),
                                a.attributes.hasOwnProperty("BYTERANGE") &&
                                  (a.attributes.byterange = gr(
                                    a.attributes.BYTERANGE
                                  )),
                                void s.trigger("data", a))
                              : (r = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(e)) &&
                                r[1]
                              ? (((a = {
                                  type: "tag",
                                  tagType: "server-control",
                                }).attributes = br(r[1])),
                                [
                                  "CAN-SKIP-UNTIL",
                                  "PART-HOLD-BACK",
                                  "HOLD-BACK",
                                ].forEach(function (e) {
                                  a.attributes.hasOwnProperty(e) &&
                                    (a.attributes[e] = parseFloat(
                                      a.attributes[e]
                                    ));
                                }),
                                [
                                  "CAN-SKIP-DATERANGES",
                                  "CAN-BLOCK-RELOAD",
                                ].forEach(function (e) {
                                  a.attributes.hasOwnProperty(e) &&
                                    (a.attributes[e] = /YES/.test(
                                      a.attributes[e]
                                    ));
                                }),
                                void s.trigger("data", a))
                              : (r = /^#EXT-X-PART-INF:(.*)$/.exec(e)) && r[1]
                              ? (((a = {
                                  type: "tag",
                                  tagType: "part-inf",
                                }).attributes = br(r[1])),
                                ["PART-TARGET"].forEach(function (e) {
                                  a.attributes.hasOwnProperty(e) &&
                                    (a.attributes[e] = parseFloat(
                                      a.attributes[e]
                                    ));
                                }),
                                void s.trigger("data", a))
                              : (r = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(e)) &&
                                r[1]
                              ? (((a = {
                                  type: "tag",
                                  tagType: "preload-hint",
                                }).attributes = br(r[1])),
                                ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(
                                  function (e) {
                                    var t;
                                    a.attributes.hasOwnProperty(e) &&
                                      ((a.attributes[e] = parseInt(
                                        a.attributes[e],
                                        10
                                      )),
                                      (t =
                                        "BYTERANGE-LENGTH" === e
                                          ? "length"
                                          : "offset"),
                                      (a.attributes.byterange =
                                        a.attributes.byterange || {}),
                                      (a.attributes.byterange[t] =
                                        a.attributes[e]),
                                      delete a.attributes[e]);
                                  }
                                ),
                                void s.trigger("data", a))
                              : (r = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(
                                  e
                                )) && r[1]
                              ? (((a = {
                                  type: "tag",
                                  tagType: "rendition-report",
                                }).attributes = br(r[1])),
                                ["LAST-MSN", "LAST-PART"].forEach(function (e) {
                                  a.attributes.hasOwnProperty(e) &&
                                    (a.attributes[e] = parseInt(
                                      a.attributes[e],
                                      10
                                    ));
                                }),
                                void s.trigger("data", a))
                              : void s.trigger("data", {
                                  type: "tag",
                                  data: e.slice(4),
                                });
                          s.trigger("data", {
                            type: "tag",
                            tagType: "discontinuity",
                          });
                        }
                      }
                    else
                      s.trigger("data", { type: "comment", text: e.slice(1) });
                  })
              : this.trigger("data", { type: "uri", uri: n }));
        }),
        (n.addParser = function (e) {
          var t = this,
            n = e.expression,
            i = e.customType,
            r = e.dataParser,
            a = e.segment;
          "function" != typeof r &&
            (r = function (e) {
              return e;
            }),
            this.customParsers.push(function (e) {
              if (n.exec(e))
                return (
                  t.trigger("data", {
                    type: "custom",
                    data: r(e),
                    customType: i,
                    segment: a,
                  }),
                  !0
                );
            });
        }),
        (n.addTagMapper = function (e) {
          var t = e.expression,
            n = e.map;
          this.tagMappers.push(function (e) {
            return t.test(e) ? n(e) : e;
          });
        }),
        e
      );
    })(mr),
    Lr = (function (t) {
      function e() {
        var e = t.call(this) || this;
        (e.lineStream = new Pr()),
          (e.parseStream = new Nr()),
          e.lineStream.pipe(e.parseStream);
        var i,
          r,
          a = y(e),
          o = [],
          l = {},
          u = !1,
          c = { AUDIO: {}, VIDEO: {}, "CLOSED-CAPTIONS": {}, SUBTITLES: {} },
          d = 0;
        e.manifest = { allowCache: !0, discontinuityStarts: [], segments: [] };
        var h = 0,
          p = 0;
        return (
          e.on("end", function () {
            l.uri ||
              (!l.parts && !l.preloadHints) ||
              (!l.map && i && (l.map = i),
              !l.key && r && (l.key = r),
              l.timeline || "number" != typeof d || (l.timeline = d),
              (e.manifest.preloadSegment = l));
          }),
          e.parseStream.on("data", function (s) {
            var t, n;
            ({
              tag: function () {
                (
                  ({
                    version: function () {
                      s.version && (this.manifest.version = s.version);
                    },
                    "allow-cache": function () {
                      (this.manifest.allowCache = s.allowed),
                        "allowed" in s ||
                          (this.trigger("info", {
                            message: "defaulting allowCache to YES",
                          }),
                          (this.manifest.allowCache = !0));
                    },
                    byterange: function () {
                      var e = {};
                      "length" in s &&
                        (((l.byterange = e).length = s.length),
                        "offset" in s || (s.offset = h)),
                        "offset" in s && ((l.byterange = e).offset = s.offset),
                        (h = e.offset + e.length);
                    },
                    endlist: function () {
                      this.manifest.endList = !0;
                    },
                    inf: function () {
                      "mediaSequence" in this.manifest ||
                        ((this.manifest.mediaSequence = 0),
                        this.trigger("info", {
                          message: "defaulting media sequence to zero",
                        })),
                        "discontinuitySequence" in this.manifest ||
                          ((this.manifest.discontinuitySequence = 0),
                          this.trigger("info", {
                            message:
                              "defaulting discontinuity sequence to zero",
                          })),
                        0 < s.duration && (l.duration = s.duration),
                        0 === s.duration &&
                          ((l.duration = 0.01),
                          this.trigger("info", {
                            message:
                              "updating zero segment duration to a small value",
                          })),
                        (this.manifest.segments = o);
                    },
                    key: function () {
                      if (s.attributes)
                        if ("NONE" !== s.attributes.METHOD)
                          if (s.attributes.URI) {
                            if (
                              "com.apple.streamingkeydelivery" ===
                              s.attributes.KEYFORMAT
                            )
                              return (
                                (this.manifest.contentProtection =
                                  this.manifest.contentProtection || {}),
                                void (this.manifest.contentProtection[
                                  "com.apple.fps.1_0"
                                ] = { attributes: s.attributes })
                              );
                            if (
                              "com.microsoft.playready" ===
                              s.attributes.KEYFORMAT
                            )
                              return (
                                (this.manifest.contentProtection =
                                  this.manifest.contentProtection || {}),
                                void (this.manifest.contentProtection[
                                  "com.microsoft.playready"
                                ] = { uri: s.attributes.URI })
                              );
                            if (
                              "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed" ===
                              s.attributes.KEYFORMAT
                            )
                              return -1 ===
                                [
                                  "SAMPLE-AES",
                                  "SAMPLE-AES-CTR",
                                  "SAMPLE-AES-CENC",
                                ].indexOf(s.attributes.METHOD)
                                ? void this.trigger("warn", {
                                    message:
                                      "invalid key method provided for Widevine",
                                  })
                                : ("SAMPLE-AES-CENC" === s.attributes.METHOD &&
                                    this.trigger("warn", {
                                      message:
                                        "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead",
                                    }),
                                  "data:text/plain;base64," !==
                                  s.attributes.URI.substring(0, 23)
                                    ? void this.trigger("warn", {
                                        message:
                                          "invalid key URI provided for Widevine",
                                      })
                                    : s.attributes.KEYID &&
                                      "0x" ===
                                        s.attributes.KEYID.substring(0, 2)
                                    ? ((this.manifest.contentProtection =
                                        this.manifest.contentProtection || {}),
                                      void (this.manifest.contentProtection[
                                        "com.widevine.alpha"
                                      ] = {
                                        attributes: {
                                          schemeIdUri: s.attributes.KEYFORMAT,
                                          keyId:
                                            s.attributes.KEYID.substring(2),
                                        },
                                        pssh: (function (e) {
                                          for (
                                            var t = fr(e),
                                              n = new Uint8Array(t.length),
                                              i = 0;
                                            i < t.length;
                                            i++
                                          )
                                            n[i] = t.charCodeAt(i);
                                          return n;
                                        })(s.attributes.URI.split(",")[1]),
                                      }))
                                    : void this.trigger("warn", {
                                        message:
                                          "invalid key ID provided for Widevine",
                                      }));
                            s.attributes.METHOD ||
                              this.trigger("warn", {
                                message: "defaulting key method to AES-128",
                              }),
                              (r = {
                                method: s.attributes.METHOD || "AES-128",
                                uri: s.attributes.URI,
                              }),
                              "undefined" != typeof s.attributes.IV &&
                                (r.iv = s.attributes.IV);
                          } else
                            this.trigger("warn", {
                              message: "ignoring key declaration without URI",
                            });
                        else r = null;
                      else
                        this.trigger("warn", {
                          message:
                            "ignoring key declaration without attribute list",
                        });
                    },
                    "media-sequence": function () {
                      isFinite(s.number)
                        ? (this.manifest.mediaSequence = s.number)
                        : this.trigger("warn", {
                            message:
                              "ignoring invalid media sequence: " + s.number,
                          });
                    },
                    "discontinuity-sequence": function () {
                      isFinite(s.number)
                        ? ((this.manifest.discontinuitySequence = s.number),
                          (d = s.number))
                        : this.trigger("warn", {
                            message:
                              "ignoring invalid discontinuity sequence: " +
                              s.number,
                          });
                    },
                    "playlist-type": function () {
                      /VOD|EVENT/.test(s.playlistType)
                        ? (this.manifest.playlistType = s.playlistType)
                        : this.trigger("warn", {
                            message:
                              "ignoring unknown playlist type: " + s.playlist,
                          });
                    },
                    map: function () {
                      (i = {}),
                        s.uri && (i.uri = s.uri),
                        s.byterange && (i.byterange = s.byterange),
                        r && (i.key = r);
                    },
                    "stream-inf": function () {
                      (this.manifest.playlists = o),
                        (this.manifest.mediaGroups =
                          this.manifest.mediaGroups || c),
                        s.attributes
                          ? (l.attributes || (l.attributes = {}),
                            Q(l.attributes, s.attributes))
                          : this.trigger("warn", {
                              message: "ignoring empty stream-inf attributes",
                            });
                    },
                    media: function () {
                      var e;
                      (this.manifest.mediaGroups =
                        this.manifest.mediaGroups || c),
                        s.attributes &&
                        s.attributes.TYPE &&
                        s.attributes["GROUP-ID"] &&
                        s.attributes.NAME
                          ? (((e =
                              this.manifest.mediaGroups[s.attributes.TYPE])[
                              s.attributes["GROUP-ID"]
                            ] = e[s.attributes["GROUP-ID"]] || {}),
                            (t = e[s.attributes["GROUP-ID"]]),
                            (n = { default: /yes/i.test(s.attributes.DEFAULT) })
                              .default
                              ? (n.autoselect = !0)
                              : (n.autoselect = /yes/i.test(
                                  s.attributes.AUTOSELECT
                                )),
                            s.attributes.LANGUAGE &&
                              (n.language = s.attributes.LANGUAGE),
                            s.attributes.URI && (n.uri = s.attributes.URI),
                            s.attributes["INSTREAM-ID"] &&
                              (n.instreamId = s.attributes["INSTREAM-ID"]),
                            s.attributes.CHARACTERISTICS &&
                              (n.characteristics =
                                s.attributes.CHARACTERISTICS),
                            s.attributes.FORCED &&
                              (n.forced = /yes/i.test(s.attributes.FORCED)),
                            (t[s.attributes.NAME] = n))
                          : this.trigger("warn", {
                              message:
                                "ignoring incomplete or missing media group",
                            });
                    },
                    discontinuity: function () {
                      (d += 1),
                        (l.discontinuity = !0),
                        this.manifest.discontinuityStarts.push(o.length);
                    },
                    "program-date-time": function () {
                      "undefined" == typeof this.manifest.dateTimeString &&
                        ((this.manifest.dateTimeString = s.dateTimeString),
                        (this.manifest.dateTimeObject = s.dateTimeObject)),
                        (l.dateTimeString = s.dateTimeString),
                        (l.dateTimeObject = s.dateTimeObject);
                    },
                    targetduration: function () {
                      !isFinite(s.duration) || s.duration < 0
                        ? this.trigger("warn", {
                            message:
                              "ignoring invalid target duration: " + s.duration,
                          })
                        : ((this.manifest.targetDuration = s.duration),
                          yr.call(this, this.manifest));
                    },
                    start: function () {
                      s.attributes && !isNaN(s.attributes["TIME-OFFSET"])
                        ? (this.manifest.start = {
                            timeOffset: s.attributes["TIME-OFFSET"],
                            precise: s.attributes.PRECISE,
                          })
                        : this.trigger("warn", {
                            message:
                              "ignoring start declaration without appropriate attribute list",
                          });
                    },
                    "cue-out": function () {
                      l.cueOut = s.data;
                    },
                    "cue-out-cont": function () {
                      l.cueOutCont = s.data;
                    },
                    "cue-in": function () {
                      l.cueIn = s.data;
                    },
                    skip: function () {
                      (this.manifest.skip = vr(s.attributes)),
                        this.warnOnMissingAttributes_(
                          "#EXT-X-SKIP",
                          s.attributes,
                          ["SKIPPED-SEGMENTS"]
                        );
                    },
                    part: function () {
                      var n = this;
                      u = !0;
                      var e = this.manifest.segments.length,
                        t = vr(s.attributes);
                      (l.parts = l.parts || []),
                        l.parts.push(t),
                        t.byterange &&
                          (t.byterange.hasOwnProperty("offset") ||
                            (t.byterange.offset = p),
                          (p = t.byterange.offset + t.byterange.length));
                      var i = l.parts.length - 1;
                      this.warnOnMissingAttributes_(
                        "#EXT-X-PART #" + i + " for segment #" + e,
                        s.attributes,
                        ["URI", "DURATION"]
                      ),
                        this.manifest.renditionReports &&
                          this.manifest.renditionReports.forEach(function (
                            e,
                            t
                          ) {
                            e.hasOwnProperty("lastPart") ||
                              n.trigger("warn", {
                                message:
                                  "#EXT-X-RENDITION-REPORT #" +
                                  t +
                                  " lacks required attribute(s): LAST-PART",
                              });
                          });
                    },
                    "server-control": function () {
                      var e = (this.manifest.serverControl = vr(s.attributes));
                      e.hasOwnProperty("canBlockReload") ||
                        ((e.canBlockReload = !1),
                        this.trigger("info", {
                          message:
                            "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false",
                        })),
                        yr.call(this, this.manifest),
                        e.canSkipDateranges &&
                          !e.hasOwnProperty("canSkipUntil") &&
                          this.trigger("warn", {
                            message:
                              "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set",
                          });
                    },
                    "preload-hint": function () {
                      var e = this.manifest.segments.length,
                        t = vr(s.attributes),
                        n = t.type && "PART" === t.type;
                      (l.preloadHints = l.preloadHints || []),
                        l.preloadHints.push(t),
                        t.byterange &&
                          (t.byterange.hasOwnProperty("offset") ||
                            ((t.byterange.offset = n ? p : 0),
                            n &&
                              (p = t.byterange.offset + t.byterange.length)));
                      var i = l.preloadHints.length - 1;
                      if (
                        (this.warnOnMissingAttributes_(
                          "#EXT-X-PRELOAD-HINT #" + i + " for segment #" + e,
                          s.attributes,
                          ["TYPE", "URI"]
                        ),
                        t.type)
                      )
                        for (var r = 0; r < l.preloadHints.length - 1; r++) {
                          var a = l.preloadHints[r];
                          a.type &&
                            a.type === t.type &&
                            this.trigger("warn", {
                              message:
                                "#EXT-X-PRELOAD-HINT #" +
                                i +
                                " for segment #" +
                                e +
                                " has the same TYPE " +
                                t.type +
                                " as preload hint #" +
                                r,
                            });
                        }
                    },
                    "rendition-report": function () {
                      var e = vr(s.attributes);
                      (this.manifest.renditionReports =
                        this.manifest.renditionReports || []),
                        this.manifest.renditionReports.push(e);
                      var t = this.manifest.renditionReports.length - 1,
                        e = ["LAST-MSN", "URI"];
                      u && e.push("LAST-PART"),
                        this.warnOnMissingAttributes_(
                          "#EXT-X-RENDITION-REPORT #" + t,
                          s.attributes,
                          e
                        );
                    },
                    "part-inf": function () {
                      (this.manifest.partInf = vr(s.attributes)),
                        this.warnOnMissingAttributes_(
                          "#EXT-X-PART-INF",
                          s.attributes,
                          ["PART-TARGET"]
                        ),
                        this.manifest.partInf.partTarget &&
                          (this.manifest.partTargetDuration =
                            this.manifest.partInf.partTarget),
                        yr.call(this, this.manifest);
                    },
                  })[s.tagType] || function () {}
                ).call(a);
              },
              uri: function () {
                (l.uri = s.uri),
                  o.push(l),
                  !this.manifest.targetDuration ||
                    "duration" in l ||
                    (this.trigger("warn", {
                      message:
                        "defaulting segment duration to the target duration",
                    }),
                    (l.duration = this.manifest.targetDuration)),
                  r && (l.key = r),
                  (l.timeline = d),
                  i && (l.map = i),
                  (p = 0),
                  (l = {});
              },
              comment: function () {},
              custom: function () {
                s.segment
                  ? ((l.custom = l.custom || {}),
                    (l.custom[s.customType] = s.data))
                  : ((this.manifest.custom = this.manifest.custom || {}),
                    (this.manifest.custom[s.customType] = s.data));
              },
            })[s.type].call(a);
          }),
          e
        );
      }
      b(e, t);
      var n = e.prototype;
      return (
        (n.warnOnMissingAttributes_ = function (e, t, n) {
          var i = [];
          n.forEach(function (e) {
            t.hasOwnProperty(e) || i.push(e);
          }),
            i.length &&
              this.trigger("warn", {
                message: e + " lacks required attribute(s): " + i.join(", "),
              });
        }),
        (n.push = function (e) {
          this.lineStream.push(e);
        }),
        (n.end = function () {
          this.lineStream.push("\n"), this.trigger("end");
        }),
        (n.addParser = function (e) {
          this.parseStream.addParser(e);
        }),
        (n.addTagMapper = function (e) {
          this.parseStream.addTagMapper(e);
        }),
        e
      );
    })(mr),
    Mr = {
      mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
      webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
      ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
      video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
      audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
      text: /^(stpp.ttml.im1t)/,
      muxerVideo: /^(avc0?1)/,
      muxerAudio: /^(mp4a)/,
      muxerText: /a^/,
    },
    Dr = ["video", "audio", "text"],
    Rr = ["Video", "Audio", "Text"],
    Br = "mp4a.40.2",
    Ur = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i,
    Vr = /^application\/dash\+xml/i,
    Fr = Ir,
    x = window.BigInt || Number,
    Gr = [
      x("0x1"),
      x("0x100"),
      x("0x10000"),
      x("0x1000000"),
      x("0x100000000"),
      x("0x10000000000"),
      x("0x1000000000000"),
      x("0x100000000000000"),
      x("0x10000000000000000"),
    ],
    qr = "http://example.com";
  function zr(e) {
    for (
      var t =
          ((e = e),
          window.atob
            ? window.atob(e)
            : Buffer.from(e, "base64").toString("binary")),
        n = new Uint8Array(t.length),
        i = 0;
      i < t.length;
      i++
    )
      n[i] = t.charCodeAt(i);
    return n;
  }
  function Hr(e, t) {
    return (t = void 0 === t ? Object : t) && "function" == typeof t.freeze
      ? t.freeze(e)
      : e;
  }
  var Wr = Hr({
      HTML: "text/html",
      isHTML: function (e) {
        return e === Wr.HTML;
      },
      XML_APPLICATION: "application/xml",
      XML_TEXT: "text/xml",
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      XML_SVG_IMAGE: "image/svg+xml",
    }),
    Xr = Hr({
      HTML: "http://www.w3.org/1999/xhtml",
      isHTML: function (e) {
        return e === Xr.HTML;
      },
      SVG: "http://www.w3.org/2000/svg",
      XML: "http://www.w3.org/XML/1998/namespace",
      XMLNS: "http://www.w3.org/2000/xmlns/",
    }),
    Yr = { freeze: Hr, MIME_TYPE: Wr, NAMESPACE: Xr },
    Kr = Yr.NAMESPACE;
  function Qr(e) {
    return "" !== e;
  }
  function Zr(e, t) {
    return e.hasOwnProperty(t) || (e[t] = !0), e;
  }
  function Jr(e) {
    if (!e) return [];
    e = (e = e) ? e.split(/[\t\n\f\r ]+/).filter(Qr) : [];
    return Object.keys(e.reduce(Zr, {}));
  }
  function $r(e, t) {
    for (var n in e) t[n] = e[n];
  }
  function ea(e, t) {
    var n,
      i = e.prototype;
    i instanceof t ||
      (((n = function () {}).prototype = t.prototype),
      $r(i, (n = new n())),
      (e.prototype = i = n)),
      i.constructor != e && (i.constructor = e);
  }
  var s = {},
    ta = (s.ELEMENT_NODE = 1),
    na = (s.ATTRIBUTE_NODE = 2),
    ia = (s.TEXT_NODE = 3),
    ra = (s.CDATA_SECTION_NODE = 4),
    aa = (s.ENTITY_REFERENCE_NODE = 5),
    sa = ((s.ENTITY_NODE = 6), (s.PROCESSING_INSTRUCTION_NODE = 7)),
    oa = (s.COMMENT_NODE = 8),
    la = (s.DOCUMENT_NODE = 9),
    ua = (s.DOCUMENT_TYPE_NODE = 10),
    ca = (s.DOCUMENT_FRAGMENT_NODE = 11),
    r = ((s.NOTATION_NODE = 12), {}),
    E = {};
  (r.INDEX_SIZE_ERR = ((E[1] = "Index size error"), 1)),
    (r.DOMSTRING_SIZE_ERR = ((E[2] = "DOMString size error"), 2));
  r.HIERARCHY_REQUEST_ERR = ((E[3] = "Hierarchy request error"), 3);
  (r.WRONG_DOCUMENT_ERR = ((E[4] = "Wrong document"), 4)),
    (r.INVALID_CHARACTER_ERR = ((E[5] = "Invalid character"), 5)),
    (r.NO_DATA_ALLOWED_ERR = ((E[6] = "No data allowed"), 6)),
    (r.NO_MODIFICATION_ALLOWED_ERR = ((E[7] = "No modification allowed"), 7));
  r.NOT_FOUND_ERR = ((E[8] = "Not found"), 8);
  r.NOT_SUPPORTED_ERR = ((E[9] = "Not supported"), 9);
  var da;
  r.INUSE_ATTRIBUTE_ERR = ((E[10] = "Attribute in use"), 10);
  function ha(e, t) {
    var n;
    return (
      t instanceof Error
        ? (n = t)
        : ((n = this),
          Error.call(this, E[e]),
          (this.message = E[e]),
          Error.captureStackTrace && Error.captureStackTrace(this, ha)),
      (n.code = e),
      t && (this.message = this.message + ": " + t),
      n
    );
  }
  function pa() {}
  function ma(e, t) {
    (this._node = e), (this._refresh = t), fa(this);
  }
  function fa(e) {
    var t,
      n = e._node._inc || e._node.ownerDocument._inc;
    e._inc != n &&
      ((t = e._refresh(e._node)),
      Ha(e, "length", t.length),
      $r(t, e),
      (e._inc = n));
  }
  function ga() {}
  function ba(e, t) {
    for (var n = e.length; n--; ) if (e[n] === t) return n;
  }
  function va(e, t, n, i) {
    i ? (t[ba(t, i)] = n) : (t[t.length++] = n),
      !e ||
        ((t = (n.ownerElement = e).ownerDocument) &&
          (i && Aa(t, e, i),
          (e = e),
          (n = n),
          (t = t) && t._inc++,
          n.namespaceURI === Kr.XMLNS &&
            (e._nsMap[n.prefix ? n.localName : ""] = n.value)));
  }
  function ya(e, t, n) {
    var i = ba(t, n);
    if (!(0 <= i)) throw ha(8, new Error(e.tagName + "@" + n));
    for (var r, a = t.length - 1; i < a; ) t[i] = t[++i];
    (t.length = a),
      !e || ((r = e.ownerDocument) && (Aa(r, e, n), (n.ownerElement = null)));
  }
  function _a() {}
  function k() {}
  function Ta(e) {
    return (
      ("<" == e ? "&lt;" : ">" == e && "&gt;") ||
      ("&" == e && "&amp;") ||
      ('"' == e && "&quot;") ||
      "&#" + e.charCodeAt() + ";"
    );
  }
  function Oa(e, t) {
    if (t(e)) return 1;
    if ((e = e.firstChild))
      do {
        if (Oa(e, t)) return 1;
      } while ((e = e.nextSibling));
  }
  function Sa() {}
  function Aa(e, t, n) {
    e && e._inc++,
      n.namespaceURI === Kr.XMLNS &&
        delete t._nsMap[n.prefix ? n.localName : ""];
  }
  function wa(e, t, n) {
    if (e && e._inc) {
      e._inc++;
      var i = t.childNodes;
      if (n) i[i.length++] = n;
      else {
        for (var r = t.firstChild, a = 0; r; ) r = (i[a++] = r).nextSibling;
        i.length = a;
      }
    }
  }
  function Ca(e, t) {
    var n = t.previousSibling,
      i = t.nextSibling;
    return (
      n ? (n.nextSibling = i) : (e.firstChild = i),
      i ? (i.previousSibling = n) : (e.lastChild = n),
      wa(e.ownerDocument, e),
      t
    );
  }
  function Ia(e, t, n) {
    var i = t.parentNode;
    if ((i && i.removeChild(t), t.nodeType === ca)) {
      var r = t.firstChild;
      if (null == r) return t;
      var a = t.lastChild;
    } else r = a = t;
    i = n ? n.previousSibling : e.lastChild;
    for (
      r.previousSibling = i,
        a.nextSibling = n,
        i ? (i.nextSibling = r) : (e.firstChild = r),
        null == n ? (e.lastChild = a) : (n.previousSibling = a);
      (r.parentNode = e), r !== a && (r = r.nextSibling);

    );
    return (
      wa(e.ownerDocument || e, e),
      t.nodeType == ca && (t.firstChild = t.lastChild = null),
      t
    );
  }
  function xa() {
    this._nsMap = {};
  }
  function Ea() {}
  function ka() {}
  function Pa() {}
  function ja() {}
  function Na() {}
  function La() {}
  function Ma() {}
  function Da() {}
  function Ra() {}
  function Ba() {}
  function Ua() {}
  function Va() {}
  function Fa(e, t) {
    var n,
      i = [],
      r = (9 == this.nodeType && this.documentElement) || this,
      a = r.prefix,
      s = r.namespaceURI;
    return (
      za(
        this,
        i,
        e,
        t,
        (n =
          s && null == a && null == (a = r.lookupPrefix(s))
            ? [{ namespace: s, prefix: null }]
            : n)
      ),
      i.join("")
    );
  }
  function Ga(e, t, n) {
    var i = e.prefix || "",
      r = e.namespaceURI;
    if (r && ("xml" !== i || r !== Kr.XML) && r !== Kr.XMLNS) {
      for (var a = n.length; a--; ) {
        var s = n[a];
        if (s.prefix === i) return s.namespace !== r;
      }
      return 1;
    }
  }
  function qa(e, t, n) {
    e.push(" ", t, '="', n.replace(/[<&"]/g, Ta), '"');
  }
  function za(e, t, n, i, r) {
    if (((r = r || []), i)) {
      if (!(e = i(e))) return;
      if ("string" == typeof e) return void t.push(e);
    }
    switch (e.nodeType) {
      case ta:
        var a = e.attributes,
          s = a.length,
          o = e.firstChild,
          l = e.tagName,
          u = l;
        if (
          !(n = Kr.isHTML(e.namespaceURI) || n) &&
          !e.prefix &&
          e.namespaceURI
        ) {
          for (var c, d = 0; d < a.length; d++)
            if ("xmlns" === a.item(d).name) {
              c = a.item(d).value;
              break;
            }
          if (!c)
            for (var h = r.length - 1; 0 <= h; h--)
              if ("" === (p = r[h]).prefix && p.namespace === e.namespaceURI) {
                c = p.namespace;
                break;
              }
          if (c !== e.namespaceURI)
            for (var p, h = r.length - 1; 0 <= h; h--)
              if ((p = r[h]).namespace === e.namespaceURI) {
                p.prefix && (u = p.prefix + ":" + l);
                break;
              }
        }
        t.push("<", u);
        for (var m = 0; m < s; m++)
          "xmlns" == (f = a.item(m)).prefix
            ? r.push({ prefix: f.localName, namespace: f.value })
            : "xmlns" == f.nodeName &&
              r.push({ prefix: "", namespace: f.value });
        for (var f, g, b, m = 0; m < s; m++)
          Ga((f = a.item(m)), 0, r) &&
            (qa(
              t,
              (g = f.prefix || "") ? "xmlns:" + g : "xmlns",
              (b = f.namespaceURI)
            ),
            r.push({ prefix: g, namespace: b })),
            za(f, t, n, i, r);
        if (
          (l === u &&
            Ga(e, 0, r) &&
            (qa(
              t,
              (g = e.prefix || "") ? "xmlns:" + g : "xmlns",
              (b = e.namespaceURI)
            ),
            r.push({ prefix: g, namespace: b })),
          o || (n && !/^(?:meta|link|img|br|hr|input)$/i.test(l)))
        ) {
          if ((t.push(">"), n && /^script$/i.test(l)))
            for (; o; )
              o.data ? t.push(o.data) : za(o, t, n, i, r.slice()),
                (o = o.nextSibling);
          else for (; o; ) za(o, t, n, i, r.slice()), (o = o.nextSibling);
          t.push("</", u, ">");
        } else t.push("/>");
        return;
      case la:
      case ca:
        for (o = e.firstChild; o; )
          za(o, t, n, i, r.slice()), (o = o.nextSibling);
        return;
      case na:
        return qa(t, e.name, e.value), 0;
      case ia:
        return t.push(e.data.replace(/[<&]/g, Ta).replace(/]]>/g, "]]&gt;"));
      case ra:
        return t.push("<![CDATA[", e.data, "]]>");
      case oa:
        return t.push("\x3c!--", e.data, "--\x3e");
      case ua:
        var v = e.publicId,
          y = e.systemId;
        return (
          t.push("<!DOCTYPE ", e.name),
          void (v
            ? (t.push(" PUBLIC ", v),
              y && "." != y && t.push(" ", y),
              t.push(">"))
            : y && "." != y
            ? t.push(" SYSTEM ", y, ">")
            : ((y = e.internalSubset) && t.push(" [", y, "]"), t.push(">")))
        );
      case sa:
        return t.push("<?", e.target, " ", e.data, "?>");
      case aa:
        return t.push("&", e.nodeName, ";");
      default:
        t.push("??", e.nodeName);
    }
  }
  function Ha(e, t, n) {
    e[t] = n;
  }
  (r.INVALID_STATE_ERR = ((E[11] = "Invalid state"), 11)),
    (r.SYNTAX_ERR = ((E[12] = "Syntax error"), 12)),
    (r.INVALID_MODIFICATION_ERR = ((E[13] = "Invalid modification"), 13)),
    (r.NAMESPACE_ERR = ((E[14] = "Invalid namespace"), 14)),
    (r.INVALID_ACCESS_ERR = ((E[15] = "Invalid access"), 15)),
    (ha.prototype = Error.prototype),
    $r(r, ha),
    (pa.prototype = {
      length: 0,
      item: function (e) {
        return this[e] || null;
      },
      toString: function (e, t) {
        for (var n = [], i = 0; i < this.length; i++) za(this[i], n, e, t);
        return n.join("");
      },
    }),
    (ma.prototype.item = function (e) {
      return fa(this), this[e];
    }),
    ea(ma, pa),
    (ga.prototype = {
      length: 0,
      item: pa.prototype.item,
      getNamedItem: function (e) {
        for (var t = this.length; t--; ) {
          var n = this[t];
          if (n.nodeName == e) return n;
        }
      },
      setNamedItem: function (e) {
        var t = e.ownerElement;
        if (t && t != this._ownerElement) throw new ha(10);
        t = this.getNamedItem(e.nodeName);
        return va(this._ownerElement, this, e, t), t;
      },
      setNamedItemNS: function (e) {
        var t = e.ownerElement;
        if (t && t != this._ownerElement) throw new ha(10);
        return (
          (t = this.getNamedItemNS(e.namespaceURI, e.localName)),
          va(this._ownerElement, this, e, t),
          t
        );
      },
      removeNamedItem: function (e) {
        e = this.getNamedItem(e);
        return ya(this._ownerElement, this, e), e;
      },
      removeNamedItemNS: function (e, t) {
        t = this.getNamedItemNS(e, t);
        return ya(this._ownerElement, this, t), t;
      },
      getNamedItemNS: function (e, t) {
        for (var n = this.length; n--; ) {
          var i = this[n];
          if (i.localName == t && i.namespaceURI == e) return i;
        }
        return null;
      },
    }),
    (_a.prototype = {
      hasFeature: function (e, t) {
        return !0;
      },
      createDocument: function (e, t, n) {
        var i = new Sa();
        return (
          (i.implementation = this),
          (i.childNodes = new pa()),
          (i.doctype = n || null),
          n && i.appendChild(n),
          t && ((t = i.createElementNS(e, t)), i.appendChild(t)),
          i
        );
      },
      createDocumentType: function (e, t, n) {
        var i = new La();
        return (
          (i.name = e),
          (i.nodeName = e),
          (i.publicId = t || ""),
          (i.systemId = n || ""),
          i
        );
      },
    }),
    (k.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      insertBefore: function (e, t) {
        return Ia(this, e, t);
      },
      replaceChild: function (e, t) {
        this.insertBefore(e, t), t && this.removeChild(t);
      },
      removeChild: function (e) {
        return Ca(this, e);
      },
      appendChild: function (e) {
        return this.insertBefore(e, null);
      },
      hasChildNodes: function () {
        return null != this.firstChild;
      },
      cloneNode: function (e) {
        return (function e(t, n, i) {
          var r = new n.constructor();
          for (var a in n) {
            var s = n[a];
            "object" != typeof s && s != r[a] && (r[a] = s);
          }
          n.childNodes && (r.childNodes = new pa());
          r.ownerDocument = t;
          switch (r.nodeType) {
            case ta:
              var o = n.attributes,
                l = (r.attributes = new ga()),
                u = o.length;
              l._ownerElement = r;
              for (var c = 0; c < u; c++)
                r.setAttributeNode(e(t, o.item(c), !0));
              break;
            case na:
              i = !0;
          }
          if (i)
            for (var d = n.firstChild; d; )
              r.appendChild(e(t, d, i)), (d = d.nextSibling);
          return r;
        })(this.ownerDocument || this, this, e);
      },
      normalize: function () {
        for (var e = this.firstChild; e; ) {
          var t = e.nextSibling;
          t && t.nodeType == ia && e.nodeType == ia
            ? (this.removeChild(t), e.appendData(t.data))
            : (e.normalize(), (e = t));
        }
      },
      isSupported: function (e, t) {
        return this.ownerDocument.implementation.hasFeature(e, t);
      },
      hasAttributes: function () {
        return 0 < this.attributes.length;
      },
      lookupPrefix: function (e) {
        for (var t = this; t; ) {
          var n = t._nsMap;
          if (n) for (var i in n) if (n[i] == e) return i;
          t = t.nodeType == na ? t.ownerDocument : t.parentNode;
        }
        return null;
      },
      lookupNamespaceURI: function (e) {
        for (var t = this; t; ) {
          var n = t._nsMap;
          if (n && e in n) return n[e];
          t = t.nodeType == na ? t.ownerDocument : t.parentNode;
        }
        return null;
      },
      isDefaultNamespace: function (e) {
        return null == this.lookupPrefix(e);
      },
    }),
    $r(s, k),
    $r(s, k.prototype),
    (Sa.prototype = {
      nodeName: "#document",
      nodeType: la,
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function (e, t) {
        if (e.nodeType != ca)
          return (
            null == this.documentElement &&
              e.nodeType == ta &&
              (this.documentElement = e),
            Ia(this, e, t),
            (e.ownerDocument = this),
            e
          );
        for (var n = e.firstChild; n; ) {
          var i = n.nextSibling;
          this.insertBefore(n, t), (n = i);
        }
        return e;
      },
      removeChild: function (e) {
        return (
          this.documentElement == e && (this.documentElement = null),
          Ca(this, e)
        );
      },
      importNode: function (e, t) {
        return (function e(t, n, i) {
          var r;
          switch (n.nodeType) {
            case ta:
              (r = n.cloneNode(!1)).ownerDocument = t;
            case ca:
              break;
            case na:
              i = !0;
          }
          r = r || n.cloneNode(!1);
          r.ownerDocument = t;
          r.parentNode = null;
          if (i)
            for (var a = n.firstChild; a; )
              r.appendChild(e(t, a, i)), (a = a.nextSibling);
          return r;
        })(this, e, t);
      },
      getElementById: function (t) {
        var n = null;
        return (
          Oa(this.documentElement, function (e) {
            if (e.nodeType == ta && e.getAttribute("id") == t)
              return (n = e), !0;
          }),
          n
        );
      },
      getElementsByClassName: function (s) {
        var o = Jr(s);
        return new ma(this, function (r) {
          var a = [];
          return (
            0 < o.length &&
              Oa(r.documentElement, function (e) {
                var t, n, i;
                e === r ||
                  e.nodeType !== ta ||
                  ((t = e.getAttribute("class")) &&
                    ((n = s === t) ||
                      ((t = Jr(t)),
                      (n = o.every(
                        ((i = t),
                        function (e) {
                          return i && -1 !== i.indexOf(e);
                        })
                      ))),
                    n && a.push(e)));
              }),
            a
          );
        });
      },
      createElement: function (e) {
        var t = new xa();
        return (
          (t.ownerDocument = this),
          (t.nodeName = e),
          (t.tagName = e),
          (t.localName = e),
          (t.childNodes = new pa()),
          ((t.attributes = new ga())._ownerElement = t)
        );
      },
      createDocumentFragment: function () {
        var e = new Ba();
        return (e.ownerDocument = this), (e.childNodes = new pa()), e;
      },
      createTextNode: function (e) {
        var t = new Pa();
        return (t.ownerDocument = this), t.appendData(e), t;
      },
      createComment: function (e) {
        var t = new ja();
        return (t.ownerDocument = this), t.appendData(e), t;
      },
      createCDATASection: function (e) {
        var t = new Na();
        return (t.ownerDocument = this), t.appendData(e), t;
      },
      createProcessingInstruction: function (e, t) {
        var n = new Ua();
        return (
          (n.ownerDocument = this),
          (n.tagName = n.target = e),
          (n.nodeValue = n.data = t),
          n
        );
      },
      createAttribute: function (e) {
        var t = new Ea();
        return (
          (t.ownerDocument = this),
          (t.name = e),
          (t.nodeName = e),
          (t.localName = e),
          (t.specified = !0),
          t
        );
      },
      createEntityReference: function (e) {
        var t = new Ra();
        return (t.ownerDocument = this), (t.nodeName = e), t;
      },
      createElementNS: function (e, t) {
        var n = new xa(),
          i = t.split(":"),
          r = (n.attributes = new ga());
        return (
          (n.childNodes = new pa()),
          (n.ownerDocument = this),
          (n.nodeName = t),
          (n.tagName = t),
          (n.namespaceURI = e),
          2 == i.length
            ? ((n.prefix = i[0]), (n.localName = i[1]))
            : (n.localName = t),
          (r._ownerElement = n)
        );
      },
      createAttributeNS: function (e, t) {
        var n = new Ea(),
          i = t.split(":");
        return (
          (n.ownerDocument = this),
          (n.nodeName = t),
          (n.name = t),
          (n.namespaceURI = e),
          (n.specified = !0),
          2 == i.length
            ? ((n.prefix = i[0]), (n.localName = i[1]))
            : (n.localName = t),
          n
        );
      },
    }),
    ea(Sa, k),
    (Sa.prototype.getElementsByTagName = (xa.prototype = {
      nodeType: ta,
      hasAttribute: function (e) {
        return null != this.getAttributeNode(e);
      },
      getAttribute: function (e) {
        e = this.getAttributeNode(e);
        return (e && e.value) || "";
      },
      getAttributeNode: function (e) {
        return this.attributes.getNamedItem(e);
      },
      setAttribute: function (e, t) {
        e = this.ownerDocument.createAttribute(e);
        (e.value = e.nodeValue = "" + t), this.setAttributeNode(e);
      },
      removeAttribute: function (e) {
        e = this.getAttributeNode(e);
        e && this.removeAttributeNode(e);
      },
      appendChild: function (e) {
        return e.nodeType === ca
          ? this.insertBefore(e, null)
          : (function (e, t) {
              var n = t.parentNode;
              n && ((i = e.lastChild), n.removeChild(t), (i = e.lastChild));
              var i = e.lastChild;
              return (
                (t.parentNode = e),
                (t.previousSibling = i),
                (t.nextSibling = null),
                i ? (i.nextSibling = t) : (e.firstChild = t),
                (e.lastChild = t),
                wa(e.ownerDocument, e, t),
                t
              );
            })(this, e);
      },
      setAttributeNode: function (e) {
        return this.attributes.setNamedItem(e);
      },
      setAttributeNodeNS: function (e) {
        return this.attributes.setNamedItemNS(e);
      },
      removeAttributeNode: function (e) {
        return this.attributes.removeNamedItem(e.nodeName);
      },
      removeAttributeNS: function (e, t) {
        t = this.getAttributeNodeNS(e, t);
        t && this.removeAttributeNode(t);
      },
      hasAttributeNS: function (e, t) {
        return null != this.getAttributeNodeNS(e, t);
      },
      getAttributeNS: function (e, t) {
        t = this.getAttributeNodeNS(e, t);
        return (t && t.value) || "";
      },
      setAttributeNS: function (e, t, n) {
        t = this.ownerDocument.createAttributeNS(e, t);
        (t.value = t.nodeValue = "" + n), this.setAttributeNode(t);
      },
      getAttributeNodeNS: function (e, t) {
        return this.attributes.getNamedItemNS(e, t);
      },
      getElementsByTagName: function (i) {
        return new ma(this, function (t) {
          var n = [];
          return (
            Oa(t, function (e) {
              e === t ||
                e.nodeType != ta ||
                ("*" !== i && e.tagName != i) ||
                n.push(e);
            }),
            n
          );
        });
      },
      getElementsByTagNameNS: function (i, r) {
        return new ma(this, function (t) {
          var n = [];
          return (
            Oa(t, function (e) {
              e === t ||
                e.nodeType !== ta ||
                ("*" !== i && e.namespaceURI !== i) ||
                ("*" !== r && e.localName != r) ||
                n.push(e);
            }),
            n
          );
        });
      },
    }).getElementsByTagName),
    (Sa.prototype.getElementsByTagNameNS = xa.prototype.getElementsByTagNameNS),
    ea(xa, k),
    (Ea.prototype.nodeType = na),
    ea(Ea, k),
    (ka.prototype = {
      data: "",
      substringData: function (e, t) {
        return this.data.substring(e, e + t);
      },
      appendData: function (e) {
        (e = this.data + e),
          (this.nodeValue = this.data = e),
          (this.length = e.length);
      },
      insertData: function (e, t) {
        this.replaceData(e, 0, t);
      },
      appendChild: function (e) {
        throw new Error(E[3]);
      },
      deleteData: function (e, t) {
        this.replaceData(e, t, "");
      },
      replaceData: function (e, t, n) {
        var i = this.data.substring(0, e),
          t = this.data.substring(e + t);
        (this.nodeValue = this.data = n = i + n + t), (this.length = n.length);
      },
    }),
    ea(ka, k),
    (Pa.prototype = {
      nodeName: "#text",
      nodeType: ia,
      splitText: function (e) {
        var t = (n = this.data).substring(e),
          n = n.substring(0, e);
        (this.data = this.nodeValue = n), (this.length = n.length);
        t = this.ownerDocument.createTextNode(t);
        return (
          this.parentNode && this.parentNode.insertBefore(t, this.nextSibling),
          t
        );
      },
    }),
    ea(Pa, ka),
    (ja.prototype = { nodeName: "#comment", nodeType: oa }),
    ea(ja, ka),
    (Na.prototype = { nodeName: "#cdata-section", nodeType: ra }),
    ea(Na, ka),
    (La.prototype.nodeType = ua),
    ea(La, k),
    (Ma.prototype.nodeType = 12),
    ea(Ma, k),
    (Da.prototype.nodeType = 6),
    ea(Da, k),
    (Ra.prototype.nodeType = aa),
    ea(Ra, k),
    (Ba.prototype.nodeName = "#document-fragment"),
    (Ba.prototype.nodeType = ca),
    ea(Ba, k),
    (Ua.prototype.nodeType = sa),
    ea(Ua, k),
    (Va.prototype.serializeToString = function (e, t, n) {
      return Fa.call(e, t, n);
    }),
    (k.prototype.toString = Fa);
  try {
    Object.defineProperty &&
      ((da = function e(t) {
        switch (t.nodeType) {
          case ta:
          case ca:
            var n = [];
            for (t = t.firstChild; t; )
              7 !== t.nodeType && 8 !== t.nodeType && n.push(e(t)),
                (t = t.nextSibling);
            return n.join("");
          default:
            return t.nodeValue;
        }
      }),
      Object.defineProperty(ma.prototype, "length", {
        get: function () {
          return fa(this), this.$$length;
        },
      }),
      Object.defineProperty(k.prototype, "textContent", {
        get: function () {
          return da(this);
        },
        set: function (e) {
          switch (this.nodeType) {
            case ta:
            case ca:
              for (; this.firstChild; ) this.removeChild(this.firstChild);
              (e || String(e)) &&
                this.appendChild(this.ownerDocument.createTextNode(e));
              break;
            default:
              (this.data = e), (this.value = e), (this.nodeValue = e);
          }
        },
      }),
      (Ha = function (e, t, n) {
        e["$$" + t] = n;
      }));
  } catch (D) {}
  var he = {
      DocumentType: La,
      DOMException: ha,
      DOMImplementation: _a,
      Element: xa,
      Node: k,
      NodeList: pa,
      XMLSerializer: Va,
    },
    Wa = K(function (e, t) {
      var n = Yr.freeze;
      (t.XML_ENTITIES = n({
        amp: "&",
        apos: "'",
        gt: ">",
        lt: "<",
        quot: '"',
      })),
        (t.HTML_ENTITIES = n({
          lt: "<",
          gt: ">",
          amp: "&",
          quot: '"',
          apos: "'",
          Agrave: "Ã€",
          Aacute: "Ã",
          Acirc: "Ã‚",
          Atilde: "Ãƒ",
          Auml: "Ã„",
          Aring: "Ã…",
          AElig: "Ã†",
          Ccedil: "Ã‡",
          Egrave: "Ãˆ",
          Eacute: "Ã‰",
          Ecirc: "ÃŠ",
          Euml: "Ã‹",
          Igrave: "ÃŒ",
          Iacute: "Ã",
          Icirc: "ÃŽ",
          Iuml: "Ã",
          ETH: "Ã",
          Ntilde: "Ã‘",
          Ograve: "Ã’",
          Oacute: "Ã“",
          Ocirc: "Ã”",
          Otilde: "Ã•",
          Ouml: "Ã–",
          Oslash: "Ã˜",
          Ugrave: "Ã™",
          Uacute: "Ãš",
          Ucirc: "Ã›",
          Uuml: "Ãœ",
          Yacute: "Ã",
          THORN: "Ãž",
          szlig: "ÃŸ",
          agrave: "Ã ",
          aacute: "Ã¡",
          acirc: "Ã¢",
          atilde: "Ã£",
          auml: "Ã¤",
          aring: "Ã¥",
          aelig: "Ã¦",
          ccedil: "Ã§",
          egrave: "Ã¨",
          eacute: "Ã©",
          ecirc: "Ãª",
          euml: "Ã«",
          igrave: "Ã¬",
          iacute: "Ã­",
          icirc: "Ã®",
          iuml: "Ã¯",
          eth: "Ã°",
          ntilde: "Ã±",
          ograve: "Ã²",
          oacute: "Ã³",
          ocirc: "Ã´",
          otilde: "Ãµ",
          ouml: "Ã¶",
          oslash: "Ã¸",
          ugrave: "Ã¹",
          uacute: "Ãº",
          ucirc: "Ã»",
          uuml: "Ã¼",
          yacute: "Ã½",
          thorn: "Ã¾",
          yuml: "Ã¿",
          nbsp: "Â ",
          iexcl: "Â¡",
          cent: "Â¢",
          pound: "Â£",
          curren: "Â¤",
          yen: "Â¥",
          brvbar: "Â¦",
          sect: "Â§",
          uml: "Â¨",
          copy: "Â©",
          ordf: "Âª",
          laquo: "Â«",
          not: "Â¬",
          shy: "Â­Â­",
          reg: "Â®",
          macr: "Â¯",
          deg: "Â°",
          plusmn: "Â±",
          sup2: "Â²",
          sup3: "Â³",
          acute: "Â´",
          micro: "Âµ",
          para: "Â¶",
          middot: "Â·",
          cedil: "Â¸",
          sup1: "Â¹",
          ordm: "Âº",
          raquo: "Â»",
          frac14: "Â¼",
          frac12: "Â½",
          frac34: "Â¾",
          iquest: "Â¿",
          times: "Ã—",
          divide: "Ã·",
          forall: "âˆ€",
          part: "âˆ‚",
          exist: "âˆƒ",
          empty: "âˆ…",
          nabla: "âˆ‡",
          isin: "âˆˆ",
          notin: "âˆ‰",
          ni: "âˆ‹",
          prod: "âˆ",
          sum: "âˆ‘",
          minus: "âˆ’",
          lowast: "âˆ—",
          radic: "âˆš",
          prop: "âˆ",
          infin: "âˆž",
          ang: "âˆ ",
          and: "âˆ§",
          or: "âˆ¨",
          cap: "âˆ©",
          cup: "âˆª",
          int: "âˆ«",
          there4: "âˆ´",
          sim: "âˆ¼",
          cong: "â‰…",
          asymp: "â‰ˆ",
          ne: "â‰ ",
          equiv: "â‰¡",
          le: "â‰¤",
          ge: "â‰¥",
          sub: "âŠ‚",
          sup: "âŠƒ",
          nsub: "âŠ„",
          sube: "âŠ†",
          supe: "âŠ‡",
          oplus: "âŠ•",
          otimes: "âŠ—",
          perp: "âŠ¥",
          sdot: "â‹…",
          Alpha: "Î‘",
          Beta: "Î’",
          Gamma: "Î“",
          Delta: "Î”",
          Epsilon: "Î•",
          Zeta: "Î–",
          Eta: "Î—",
          Theta: "Î˜",
          Iota: "Î™",
          Kappa: "Îš",
          Lambda: "Î›",
          Mu: "Îœ",
          Nu: "Î",
          Xi: "Îž",
          Omicron: "ÎŸ",
          Pi: "Î ",
          Rho: "Î¡",
          Sigma: "Î£",
          Tau: "Î¤",
          Upsilon: "Î¥",
          Phi: "Î¦",
          Chi: "Î§",
          Psi: "Î¨",
          Omega: "Î©",
          alpha: "Î±",
          beta: "Î²",
          gamma: "Î³",
          delta: "Î´",
          epsilon: "Îµ",
          zeta: "Î¶",
          eta: "Î·",
          theta: "Î¸",
          iota: "Î¹",
          kappa: "Îº",
          lambda: "Î»",
          mu: "Î¼",
          nu: "Î½",
          xi: "Î¾",
          omicron: "Î¿",
          pi: "Ï€",
          rho: "Ï",
          sigmaf: "Ï‚",
          sigma: "Ïƒ",
          tau: "Ï„",
          upsilon: "Ï…",
          phi: "Ï†",
          chi: "Ï‡",
          psi: "Ïˆ",
          omega: "Ï‰",
          thetasym: "Ï‘",
          upsih: "Ï’",
          piv: "Ï–",
          OElig: "Å’",
          oelig: "Å“",
          Scaron: "Å ",
          scaron: "Å¡",
          Yuml: "Å¸",
          fnof: "Æ’",
          circ: "Ë†",
          tilde: "Ëœ",
          ensp: "â€‚",
          emsp: "â€ƒ",
          thinsp: "â€‰",
          zwnj: "â€Œ",
          zwj: "â€",
          lrm: "â€Ž",
          rlm: "â€",
          ndash: "â€“",
          mdash: "â€”",
          lsquo: "â€˜",
          rsquo: "â€™",
          sbquo: "â€š",
          ldquo: "â€œ",
          rdquo: "â€",
          bdquo: "â€ž",
          dagger: "â€ ",
          Dagger: "â€¡",
          bull: "â€¢",
          hellip: "â€¦",
          permil: "â€°",
          prime: "â€²",
          Prime: "â€³",
          lsaquo: "â€¹",
          rsaquo: "â€º",
          oline: "â€¾",
          euro: "â‚¬",
          trade: "â„¢",
          larr: "â†",
          uarr: "â†‘",
          rarr: "â†’",
          darr: "â†“",
          harr: "â†”",
          crarr: "â†µ",
          lceil: "âŒˆ",
          rceil: "âŒ‰",
          lfloor: "âŒŠ",
          rfloor: "âŒ‹",
          loz: "â—Š",
          spades: "â™ ",
          clubs: "â™£",
          hearts: "â™¥",
          diams: "â™¦",
        })),
        (t.entityMap = t.HTML_ENTITIES);
    });
  Wa.XML_ENTITIES, Wa.HTML_ENTITIES, Wa.entityMap;
  var Xa = Yr.NAMESPACE,
    cn =
      /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,
    mr = new RegExp(
      "[\\-\\.0-9" +
        cn.source.slice(1, -1) +
        "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"
    ),
    Ya = new RegExp(
      "^" + cn.source + mr.source + "*(?::" + cn.source + mr.source + "*)?$"
    ),
    Ka = 0,
    Qa = 1,
    Za = 2,
    Ja = 3,
    $a = 4,
    es = 5,
    ts = 6,
    ns = 7;
  function is(e, t) {
    (this.message = e),
      (this.locator = t),
      Error.captureStackTrace && Error.captureStackTrace(this, is);
  }
  function rs() {}
  function as(e, t) {
    return (t.lineNumber = e.lineNumber), (t.columnNumber = e.columnNumber), t;
  }
  function ss(e, t, n) {
    for (var i = e.tagName, r = null, a = e.length; a--; ) {
      var s = e[a],
        o = s.qName,
        l = s.value,
        o =
          0 < (c = o.indexOf(":"))
            ? ((u = s.prefix = o.slice(0, c)),
              (d = o.slice(c + 1)),
              "xmlns" === u && d)
            : ((u = null), "xmlns" === (d = o) && "");
      (s.localName = d),
        !1 !== o &&
          (null == r && ((r = {}), os(n, (n = {}))),
          (n[o] = r[o] = l),
          (s.uri = Xa.XMLNS),
          t.startPrefixMapping(o, l));
    }
    for (var u, a = e.length; a--; )
      (u = (s = e[a]).prefix) &&
        ("xml" === u && (s.uri = Xa.XML),
        "xmlns" !== u && (s.uri = n[u || ""]));
    var c,
      d =
        0 < (c = i.indexOf(":"))
          ? ((u = e.prefix = i.slice(0, c)), (e.localName = i.slice(c + 1)))
          : ((u = null), (e.localName = i)),
      h = (e.uri = n[u || ""]);
    if ((t.startElement(h, d, i, e), !e.closed))
      return (e.currentNSMap = n), (e.localNSMap = r), 1;
    if ((t.endElement(h, d, i), r)) for (u in r) t.endPrefixMapping(u);
  }
  function os(e, t) {
    for (var n in e) t[n] = e[n];
  }
  function ls() {
    this.attributeNames = {};
  }
  ((is.prototype = new Error()).name = is.name),
    (rs.prototype = {
      parse: function (e, t, n) {
        var i = this.domBuilder;
        i.startDocument(),
          os(t, (t = {})),
          (function (n, e, i, r, a) {
            function s(e) {
              var t = e.slice(1, -1);
              return t in i
                ? i[t]
                : "#" === t.charAt(0)
                ? 65535 < (t = parseInt(t.substr(1).replace("x", "0x")))
                  ? ((t -= 65536),
                    String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t)))
                  : String.fromCharCode(t)
                : (a.error("entity not found:" + e), e);
            }
            function t(e) {
              var t;
              m < e &&
                ((t = n.substring(m, e).replace(/&#?\w+;/g, s)),
                d && o(m),
                r.characters(t, 0, e - m),
                (m = e));
            }
            function o(e, t) {
              for (; u <= e && (t = c.exec(n)); )
                (l = t.index), (u = l + t[0].length), d.lineNumber++;
              d.columnNumber = e - l + 1;
            }
            var l = 0,
              u = 0,
              c = /.*(?:\r\n?|\n)|.*$/g,
              d = r.locator,
              h = [{ currentNSMap: e }],
              p = {},
              m = 0;
            for (;;) {
              try {
                var f,
                  g,
                  b = n.indexOf("<", m);
                if (b < 0)
                  return (
                    n.substr(m).match(/^\s*$/) ||
                    ((f = r.doc),
                    (g = f.createTextNode(n.substr(m))),
                    f.appendChild(g),
                    (r.currentElement = g))
                  );
                switch ((m < b && t(b), n.charAt(b + 1))) {
                  case "/":
                    var v = n.indexOf(">", b + 3),
                      y = n.substring(b + 2, v).replace(/[ \t\n\r]+$/g, ""),
                      _ = h.pop();
                    v < 0
                      ? ((y = n.substring(b + 2).replace(/[\s<].*/, "")),
                        a.error(
                          "end tag name: " + y + " is not complete:" + _.tagName
                        ),
                        (v = b + 1 + y.length))
                      : y.match(/\s</) &&
                        ((y = y.replace(/[\s<].*/, "")),
                        a.error("end tag name: " + y + " maybe not complete"),
                        (v = b + 1 + y.length));
                    var T = _.localNSMap,
                      O = _.tagName == y;
                    if (
                      O ||
                      (_.tagName && _.tagName.toLowerCase() == y.toLowerCase())
                    ) {
                      if ((r.endElement(_.uri, _.localName, y), T))
                        for (var S in T) r.endPrefixMapping(S);
                      O ||
                        a.fatalError(
                          "end tag name: " +
                            y +
                            " is not match the current start tagName:" +
                            _.tagName
                        );
                    } else h.push(_);
                    v++;
                    break;
                  case "?":
                    d && o(b),
                      (v = (function (e, t, n) {
                        var i = e.indexOf("?>", t);
                        if (i) {
                          t = e
                            .substring(t, i)
                            .match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
                          return t
                            ? (t[0].length,
                              n.processingInstruction(t[1], t[2]),
                              i + 2)
                            : -1;
                        }
                        return -1;
                      })(n, b, r));
                    break;
                  case "!":
                    d && o(b),
                      (v = (function (e, t, n, i) {
                        {
                          if ("-" === e.charAt(t + 2)) {
                            if ("-" !== e.charAt(t + 3)) return -1;
                            var r = e.indexOf("--\x3e", t + 4);
                            return t < r
                              ? (n.comment(e, t + 4, r - t - 4), r + 3)
                              : (i.error("Unclosed comment"), -1);
                          }
                          if ("CDATA[" == e.substr(t + 3, 6)) {
                            r = e.indexOf("]]>", t + 9);
                            return (
                              n.startCDATA(),
                              n.characters(e, t + 9, r - t - 9),
                              n.endCDATA(),
                              r + 3
                            );
                          }
                          var a = (function (e, t) {
                              var n,
                                i = [],
                                r =
                                  /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
                              (r.lastIndex = t), r.exec(e);
                              for (; (n = r.exec(e)); )
                                if ((i.push(n), n[1])) return i;
                            })(e, t),
                            i = a.length;
                          if (1 < i && /!doctype/i.test(a[0][0])) {
                            (r = a[1][0]), (e = !1), (t = !1);
                            3 < i &&
                              (/^public$/i.test(a[2][0])
                                ? ((e = a[3][0]), (t = 4 < i && a[4][0]))
                                : /^system$/i.test(a[2][0]) && (t = a[3][0]));
                            i = a[i - 1];
                            return (
                              n.startDTD(r, e, t),
                              n.endDTD(),
                              i.index + i[0].length
                            );
                          }
                        }
                        return -1;
                      })(n, b, r, a));
                    break;
                  default:
                    d && o(b);
                    var A = new ls(),
                      w = h[h.length - 1].currentNSMap,
                      v = (function (e, t, i, n, r, a) {
                        function s(e, t, n) {
                          i.attributeNames.hasOwnProperty(e) &&
                            a.fatalError("Attribute " + e + " redefined"),
                            i.addValue(e, t, n);
                        }
                        var o,
                          l = ++t,
                          u = Ka;
                        for (;;) {
                          var c = e.charAt(l);
                          switch (c) {
                            case "=":
                              if (u === Qa) (o = e.slice(t, l)), (u = Ja);
                              else {
                                if (u !== Za)
                                  throw new Error(
                                    "attribute equal must after attrName"
                                  );
                                u = Ja;
                              }
                              break;
                            case "'":
                            case '"':
                              if (u === Ja || u === Qa) {
                                if (
                                  (u === Qa &&
                                    (a.warning(
                                      'attribute value must after "="'
                                    ),
                                    (o = e.slice(t, l))),
                                  (t = l + 1),
                                  !(0 < (l = e.indexOf(c, t))))
                                )
                                  throw new Error(
                                    "attribute value no end '" + c + "' match"
                                  );
                                (d = e.slice(t, l).replace(/&#?\w+;/g, r)),
                                  s(o, d, t - 1),
                                  (u = es);
                              } else {
                                if (u != $a)
                                  throw new Error(
                                    'attribute value must after "="'
                                  );
                                (d = e.slice(t, l).replace(/&#?\w+;/g, r)),
                                  s(o, d, t),
                                  a.warning(
                                    'attribute "' +
                                      o +
                                      '" missed start quot(' +
                                      c +
                                      ")!!"
                                  ),
                                  (t = l + 1),
                                  (u = es);
                              }
                              break;
                            case "/":
                              switch (u) {
                                case Ka:
                                  i.setTagName(e.slice(t, l));
                                case es:
                                case ts:
                                case ns:
                                  (u = ns), (i.closed = !0);
                                case $a:
                                case Qa:
                                case Za:
                                  break;
                                default:
                                  throw new Error(
                                    "attribute invalid close char('/')"
                                  );
                              }
                              break;
                            case "":
                              return (
                                a.error("unexpected end of input"),
                                u == Ka && i.setTagName(e.slice(t, l)),
                                l
                              );
                            case ">":
                              switch (u) {
                                case Ka:
                                  i.setTagName(e.slice(t, l));
                                case es:
                                case ts:
                                case ns:
                                  break;
                                case $a:
                                case Qa:
                                  "/" === (d = e.slice(t, l)).slice(-1) &&
                                    ((i.closed = !0), (d = d.slice(0, -1)));
                                case Za:
                                  u === Za && (d = o),
                                    u == $a
                                      ? (a.warning(
                                          'attribute "' +
                                            d +
                                            '" missed quot(")!'
                                        ),
                                        s(o, d.replace(/&#?\w+;/g, r), t))
                                      : ((Xa.isHTML(n[""]) &&
                                          d.match(
                                            /^(?:disabled|checked|selected)$/i
                                          )) ||
                                          a.warning(
                                            'attribute "' +
                                              d +
                                              '" missed value!! "' +
                                              d +
                                              '" instead!!'
                                          ),
                                        s(d, d, t));
                                  break;
                                case Ja:
                                  throw new Error("attribute value missed!!");
                              }
                              return l;
                            case "Â€":
                              c = " ";
                            default:
                              if (c <= " ")
                                switch (u) {
                                  case Ka:
                                    i.setTagName(e.slice(t, l)), (u = ts);
                                    break;
                                  case Qa:
                                    (o = e.slice(t, l)), (u = Za);
                                    break;
                                  case $a:
                                    var d = e
                                      .slice(t, l)
                                      .replace(/&#?\w+;/g, r);
                                    a.warning(
                                      'attribute "' + d + '" missed quot(")!!'
                                    ),
                                      s(o, d, t);
                                  case es:
                                    u = ts;
                                }
                              else
                                switch (u) {
                                  case Za:
                                    i.tagName,
                                      (Xa.isHTML(n[""]) &&
                                        o.match(
                                          /^(?:disabled|checked|selected)$/i
                                        )) ||
                                        a.warning(
                                          'attribute "' +
                                            o +
                                            '" missed value!! "' +
                                            o +
                                            '" instead2!!'
                                        ),
                                      s(o, o, t),
                                      (t = l),
                                      (u = Qa);
                                    break;
                                  case es:
                                    a.warning(
                                      'attribute space is required"' + o + '"!!'
                                    );
                                  case ts:
                                    (u = Qa), (t = l);
                                    break;
                                  case Ja:
                                    (u = $a), (t = l);
                                    break;
                                  case ns:
                                    throw new Error(
                                      "elements closed character '/' and '>' must be connected to"
                                    );
                                }
                          }
                          l++;
                        }
                      })(n, b, A, w, s, a),
                      C = A.length;
                    if (
                      (!A.closed &&
                        (function (e, t, n, i) {
                          var r = i[n];
                          null == r &&
                            ((r = e.lastIndexOf("</" + n + ">")) < t &&
                              (r = e.lastIndexOf("</" + n)),
                            (i[n] = r));
                          return r < t;
                        })(n, v, A.tagName, p) &&
                        ((A.closed = !0),
                        i.nbsp || a.warning("unclosed xml attribute")),
                      d && C)
                    ) {
                      for (var I = as(d, {}), x = 0; x < C; x++) {
                        var E = A[x];
                        o(E.offset), (E.locator = as(d, {}));
                      }
                      (r.locator = I),
                        ss(A, r, w) && h.push(A),
                        (r.locator = d);
                    } else ss(A, r, w) && h.push(A);
                    Xa.isHTML(A.uri) && !A.closed
                      ? (v = (function (e, t, n, i, r) {
                          if (/^(?:script|textarea)$/i.test(n)) {
                            var a = e.indexOf("</" + n + ">", t),
                              e = e.substring(t + 1, a);
                            if (/[&<]/.test(e))
                              return (
                                /^script$/i.test(n) ||
                                  (e = e.replace(/&#?\w+;/g, i)),
                                r.characters(e, 0, e.length),
                                a
                              );
                          }
                          return t + 1;
                        })(n, v, A.tagName, s, r))
                      : v++;
                }
              } catch (e) {
                if (e instanceof is) throw e;
                a.error("element parse error: " + e), (v = -1);
              }
              m < v ? (m = v) : t(Math.max(b, m) + 1);
            }
          })(e, t, n, i, this.errorHandler),
          i.endDocument();
      },
    }),
    (ls.prototype = {
      setTagName: function (e) {
        if (!Ya.test(e)) throw new Error("invalid tagName:" + e);
        this.tagName = e;
      },
      addValue: function (e, t, n) {
        if (!Ya.test(e)) throw new Error("invalid attribute:" + e);
        (this.attributeNames[e] = this.length),
          (this[this.length++] = { qName: e, value: t, offset: n });
      },
      length: 0,
      getLocalName: function (e) {
        return this[e].localName;
      },
      getLocator: function (e) {
        return this[e].locator;
      },
      getQName: function (e) {
        return this[e].qName;
      },
      getURI: function (e) {
        return this[e].uri;
      },
      getValue: function (e) {
        return this[e].value;
      },
    });
  var r = { XMLReader: rs, ParseError: is },
    us = he.DOMImplementation,
    cs = Yr.NAMESPACE,
    ds = r.ParseError,
    hs = r.XMLReader;
  function ps(e) {
    this.options = e || { locator: {} };
  }
  function ms() {
    this.cdata = !1;
  }
  function fs(e, t) {
    (t.lineNumber = e.lineNumber), (t.columnNumber = e.columnNumber);
  }
  function gs(e) {
    if (e)
      return (
        "\n@" +
        (e.systemId || "") +
        "#[line:" +
        e.lineNumber +
        ",col:" +
        e.columnNumber +
        "]"
      );
  }
  function bs(e, t, n) {
    return "string" == typeof e
      ? e.substr(t, n)
      : e.length >= t + n || t
      ? new java.lang.String(e, t, n) + ""
      : e;
  }
  function vs(e, t) {
    (e.currentElement || e.doc).appendChild(t);
  }
  (ps.prototype.parseFromString = function (e, t) {
    var n = this.options,
      i = new hs(),
      r = n.domBuilder || new ms(),
      a = n.errorHandler,
      s = n.locator,
      o = n.xmlns || {},
      l = /\/x?html?$/.test(t),
      t = l ? Wa.HTML_ENTITIES : Wa.XML_ENTITIES;
    return (
      s && r.setDocumentLocator(s),
      (i.errorHandler = (function (i, e, r) {
        if (!i) {
          if (e instanceof ms) return e;
          i = e;
        }
        var a = {},
          s = i instanceof Function;
        function t(t) {
          var n = i[t];
          !n &&
            s &&
            (n =
              2 == i.length
                ? function (e) {
                    i(t, e);
                  }
                : i),
            (a[t] = n
              ? function (e) {
                  n("[xmldom " + t + "]\t" + e + gs(r));
                }
              : function () {});
        }
        return (r = r || {}), t("warning"), t("error"), t("fatalError"), a;
      })(a, r, s)),
      (i.domBuilder = n.domBuilder || r),
      l && (o[""] = cs.HTML),
      (o.xml = o.xml || cs.XML),
      e && "string" == typeof e
        ? i.parse(e, o, t)
        : i.errorHandler.error("invalid doc source"),
      r.doc
    );
  }),
    (ms.prototype = {
      startDocument: function () {
        (this.doc = new us().createDocument(null, null, null)),
          this.locator && (this.doc.documentURI = this.locator.systemId);
      },
      startElement: function (e, t, n, i) {
        var r = this.doc,
          a = r.createElementNS(e, n || t),
          s = i.length;
        vs(this, a),
          (this.currentElement = a),
          this.locator && fs(this.locator, a);
        for (var o = 0; o < s; o++) {
          var e = i.getURI(o),
            l = i.getValue(o),
            n = i.getQName(o),
            u = r.createAttributeNS(e, n);
          this.locator && fs(i.getLocator(o), u),
            (u.value = u.nodeValue = l),
            a.setAttributeNode(u);
        }
      },
      endElement: function (e, t, n) {
        var i = this.currentElement;
        i.tagName, (this.currentElement = i.parentNode);
      },
      startPrefixMapping: function (e, t) {},
      endPrefixMapping: function (e) {},
      processingInstruction: function (e, t) {
        t = this.doc.createProcessingInstruction(e, t);
        this.locator && fs(this.locator, t), vs(this, t);
      },
      ignorableWhitespace: function (e, t, n) {},
      characters: function (e, t, n) {
        var i;
        (e = bs.apply(this, arguments)) &&
          ((i = this.cdata
            ? this.doc.createCDATASection(e)
            : this.doc.createTextNode(e)),
          this.currentElement
            ? this.currentElement.appendChild(i)
            : /^\s*$/.test(e) && this.doc.appendChild(i),
          this.locator && fs(this.locator, i));
      },
      skippedEntity: function (e) {},
      endDocument: function () {
        this.doc.normalize();
      },
      setDocumentLocator: function (e) {
        (this.locator = e) && (e.lineNumber = 0);
      },
      comment: function (e, t, n) {
        e = bs.apply(this, arguments);
        e = this.doc.createComment(e);
        this.locator && fs(this.locator, e), vs(this, e);
      },
      startCDATA: function () {
        this.cdata = !0;
      },
      endCDATA: function () {
        this.cdata = !1;
      },
      startDTD: function (e, t, n) {
        var i = this.doc.implementation;
        i &&
          i.createDocumentType &&
          ((n = i.createDocumentType(e, t, n)),
          this.locator && fs(this.locator, n),
          vs(this, n),
          (this.doc.doctype = n));
      },
      warning: function (e) {},
      error: function (e) {},
      fatalError: function (e) {
        throw new ds(e, this.locator);
      },
    }),
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(
      /\w+/g,
      function (e) {
        ms.prototype[e] = function () {
          return null;
        };
      }
    );
  function ys(e) {
    return !!e && "object" == typeof e;
  }
  function P() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return t.reduce(function (t, n) {
      return (
        "object" != typeof n ||
          Object.keys(n).forEach(function (e) {
            Array.isArray(t[e]) && Array.isArray(n[e])
              ? (t[e] = t[e].concat(n[e]))
              : ys(t[e]) && ys(n[e])
              ? (t[e] = P(t[e], n[e]))
              : (t[e] = n[e]);
          }),
        t
      );
    }, {});
  }
  function _s(t) {
    return Object.keys(t).map(function (e) {
      return t[e];
    });
  }
  function Ts(e) {
    return e.reduce(function (e, t) {
      return e.concat(t);
    }, []);
  }
  function Os(e) {
    if (!e.length) return [];
    for (var t = [], n = 0; n < e.length; n++) t.push(e[n]);
    return t;
  }
  function Ss(e, t) {
    for (var n = 0; n < e.length; n++) if (t(e[n])) return n;
    return -1;
  }
  function As(e) {
    var t = e.baseUrl,
      n = void 0 === (i = e.source) ? "" : i,
      i = void 0 === (i = e.range) ? "" : i,
      e = void 0 === (e = e.indexRange) ? "" : e,
      n = { uri: n, resolvedUri: kr((void 0 === t ? "" : t) || "", n) };
    return (
      (i || e) &&
        ((i = (i || e).split("-")),
        (e = window.BigInt ? window.BigInt(i[0]) : parseInt(i[0], 10)),
        (i = window.BigInt ? window.BigInt(i[1]) : parseInt(i[1], 10)),
        e < Number.MAX_SAFE_INTEGER && "bigint" == typeof e && (e = Number(e)),
        "bigint" ==
          typeof (i =
            "bigint" ==
              typeof (i =
                i < Number.MAX_SAFE_INTEGER && "bigint" == typeof i
                  ? Number(i)
                  : i) || "bigint" == typeof e
              ? window.BigInt(i) - window.BigInt(e) + window.BigInt(1)
              : i - e + 1) &&
          i < Number.MAX_SAFE_INTEGER &&
          (i = Number(i)),
        (n.byterange = { length: i, offset: e })),
      n
    );
  }
  function ws(e) {
    return (
      e && "number" != typeof e && (e = parseInt(e, 10)), isNaN(e) ? null : e
    );
  }
  function Cs(e) {
    var a,
      t = e.type,
      n = e.duration,
      i = e.timescale,
      r = void 0 === i ? 1 : i,
      s = e.periodDuration,
      o = e.sourceDuration,
      e = (function (e, t) {
        for (var n = [], i = e; i < t; i++) n.push(i);
        return n;
      })((i = yo[t](e)).start, i.end).map(
        ((a = e),
        function (e) {
          var t = a.duration,
            n = a.timescale,
            i = a.periodStart,
            r = a.startNumber;
          return {
            number: (void 0 === r ? 1 : r) + e,
            duration: t / (void 0 === n ? 1 : n),
            timeline: i,
            time: e * t,
          };
        })
      );
    return (
      "static" === t &&
        (e[(t = e.length - 1)].duration =
          ("number" == typeof s ? s : o) - (n / r) * t),
      e
    );
  }
  function Is(e) {
    var t = e.baseUrl,
      n = void 0 === (l = e.initialization) ? {} : l,
      i = e.sourceDuration,
      r = void 0 === (o = e.indexRange) ? "" : o,
      a = e.periodStart,
      s = e.presentationTime,
      o = void 0 === (l = e.number) ? 0 : l,
      l = e.duration;
    if (!t) throw new Error(go);
    return (
      (n = As({ baseUrl: t, source: n.sourceURL, range: n.range })),
      ((r = As({ baseUrl: t, source: t, indexRange: r })).map = n),
      l
        ? (e = Cs(e)).length &&
          ((r.duration = e[0].duration), (r.timeline = e[0].timeline))
        : i && ((r.duration = i), (r.timeline = a)),
      (r.presentationTime = s || a),
      (r.number = o),
      [r]
    );
  }
  function xs(e, t, n) {
    for (
      var i = e.sidx.map || null,
        r = e.sidx.duration,
        a = e.timeline || 0,
        s = (s = e.sidx.byterange).offset + s.length,
        o = t.timescale,
        l = t.references.filter(function (e) {
          return 1 !== e.referenceType;
        }),
        u = [],
        c = e.endList ? "static" : "dynamic",
        d = e.sidx.timeline,
        h = d,
        p = e.mediaSequence || 0,
        m =
          "bigint" == typeof t.firstOffset
            ? window.BigInt(s) + t.firstOffset
            : s + t.firstOffset,
        f = 0;
      f < l.length;
      f++
    ) {
      var g = t.references[f],
        b = g.referencedSize,
        v = g.subsegmentDuration,
        g = void 0,
        g =
          "bigint" == typeof m
            ? m + window.BigInt(b) - window.BigInt(1)
            : m + b - 1,
        g = Is({
          baseUrl: n,
          timescale: o,
          timeline: a,
          periodStart: d,
          presentationTime: h,
          number: p,
          duration: v,
          sourceDuration: r,
          indexRange: m + "-" + g,
          type: c,
        })[0];
      i && (g.map = i),
        u.push(g),
        (m += "bigint" == typeof m ? window.BigInt(b) : b),
        (h += v / o),
        p++;
    }
    return (e.segments = u), e;
  }
  function Es(e) {
    return (
      (n = function (e) {
        return e.timeline;
      }),
      _s(
        e.reduce(function (t, e) {
          return (
            e.forEach(function (e) {
              t[n(e)] = e;
            }),
            t
          );
        }, {})
      ).sort(function (e, t) {
        return e.timeline > t.timeline ? 1 : -1;
      })
    );
    var n;
  }
  function ks(e) {
    var r,
      a,
      s = [];
    return (
      (r = e),
      (a = function (e, t, n, i) {
        s = s.concat(e.playlists || []);
      }),
      _o.forEach(function (e) {
        for (var t in r.mediaGroups[e])
          for (var n in r.mediaGroups[e][t]) {
            var i = r.mediaGroups[e][t][n];
            a(i, e, t, n);
          }
      }),
      s
    );
  }
  function Ps(e) {
    var n = e.playlist,
      e = e.mediaSequence;
    (n.mediaSequence = e),
      n.segments.forEach(function (e, t) {
        e.number = n.mediaSequence + t;
      });
  }
  function js(e) {
    var r,
      a,
      t = e.oldManifest,
      n = e.newManifest,
      i = t.playlists.concat(ks(t)),
      e = n.playlists.concat(ks(n));
    return (
      (n.timelineStarts = Es([t.timelineStarts, n.timelineStarts])),
      (i = {
        oldPlaylists: i,
        newPlaylists: e,
        timelineStarts: n.timelineStarts,
      }),
      (r = i.oldPlaylists),
      (e = i.newPlaylists),
      (a = i.timelineStarts),
      e.forEach(function (t) {
        t.discontinuitySequence = Ss(a, function (e) {
          return e.timeline === t.timeline;
        });
        var e = (function (e, t) {
          for (var n = 0; n < e.length; n++)
            if (e[n].attributes.NAME === t) return e[n];
          return null;
        })(r, t.attributes.NAME);
        if (e && !t.sidx) {
          var n = t.segments[0],
            i = Ss(e.segments, function (e) {
              return Math.abs(e.presentationTime - n.presentationTime) < 1 / 60;
            });
          if (-1 === i)
            return (
              Ps({
                playlist: t,
                mediaSequence: e.mediaSequence + e.segments.length,
              }),
              (t.segments[0].discontinuity = !0),
              t.discontinuityStarts.unshift(0),
              void (
                ((!e.segments.length && t.timeline > e.timeline) ||
                  (e.segments.length &&
                    t.timeline > e.segments[e.segments.length - 1].timeline)) &&
                t.discontinuitySequence--
              )
            );
          e.segments[i].discontinuity &&
            !n.discontinuity &&
            ((n.discontinuity = !0),
            t.discontinuityStarts.unshift(0),
            t.discontinuitySequence--),
            Ps({ playlist: t, mediaSequence: e.segments[i].number });
        }
      }),
      n
    );
  }
  function Ns(e) {
    return (
      e &&
      e.uri +
        "-" +
        ((t = e.byterange),
        (e =
          "bigint" == typeof t.offset || "bigint" == typeof t.length
            ? window.BigInt(t.offset) +
              window.BigInt(t.length) -
              window.BigInt(1)
            : t.offset + t.length - 1),
        t.offset + "-" + e)
    );
    var t;
  }
  function Ls(e) {
    return _s(
      e.reduce(function (e, t) {
        var n,
          i = t.attributes.id + (t.attributes.lang || "");
        return (
          e[i]
            ? (t.segments &&
                (t.segments[0] && (t.segments[0].discontinuity = !0),
                (n = e[i].segments).push.apply(n, t.segments)),
              t.attributes.contentProtection &&
                (e[i].attributes.contentProtection =
                  t.attributes.contentProtection))
            : ((e[i] = t), (e[i].attributes.timelineStarts = [])),
          e[i].attributes.timelineStarts.push({
            start: t.attributes.periodStart,
            timeline: t.attributes.periodStart,
          }),
          e
        );
      }, {})
    ).map(function (e) {
      var t, i;
      return (
        (e.discontinuityStarts =
          ((t = e.segments || []),
          (i = "discontinuity"),
          t.reduce(function (e, t, n) {
            return t[i] && e.push(n), e;
          }, []))),
        e
      );
    });
  }
  function Ms(e, t) {
    var n = Ns(e.sidx);
    return (n = n && t[n] && t[n].sidx) && xs(e, n, e.sidx.resolvedUri), e;
  }
  function Ds(e, h, p) {
    var m;
    return (
      void 0 === h && (h = {}),
      void 0 === p && (p = !1),
      (e = e.reduce(function (e, t) {
        var n = (t.attributes.role && t.attributes.role.value) || "",
          i = t.attributes.lang || "",
          r = t.attributes.label || "main";
        e[
          (r =
            i && !t.attributes.label
              ? t.attributes.lang + (n ? " (" + n + ")" : "")
              : r)
        ] ||
          (e[r] = {
            language: i,
            autoselect: !0,
            default: "main" === n,
            playlists: [],
            uri: "",
          });
        var a,
          s,
          o,
          l,
          u,
          c,
          d,
          l = Ms(
            ((s = p),
            (o = (a = t).attributes),
            (l = a.segments),
            (u = a.sidx),
            (c = a.mediaSequence),
            (d = a.discontinuitySequence),
            (i = a.discontinuityStarts),
            (l = {
              attributes:
                (((a = {
                  NAME: o.id,
                  BANDWIDTH: o.bandwidth,
                  CODECS: o.codecs,
                })["PROGRAM-ID"] = 1),
                a),
              uri: "",
              endList: "static" === o.type,
              timeline: o.periodStart,
              resolvedUri: "",
              targetDuration: o.duration,
              discontinuitySequence: d,
              discontinuityStarts: i,
              timelineStarts: o.timelineStarts,
              mediaSequence: c,
              segments: l,
            }),
            o.contentProtection && (l.contentProtection = o.contentProtection),
            u && (l.sidx = u),
            s &&
              ((l.attributes.AUDIO = "audio"),
              (l.attributes.SUBTITLES = "subs")),
            l),
            h
          );
        return (
          e[r].playlists.push(l),
          "undefined" == typeof m && "main" === n && ((m = t).default = !0),
          e
        );
      }, {})),
      m || (e[Object.keys(e)[0]].default = !0),
      e
    );
  }
  function Rs(e) {
    var t = e.attributes,
      n = e.segments,
      i = e.sidx,
      r = e.discontinuityStarts,
      n = {
        attributes:
          (((e = {
            NAME: t.id,
            AUDIO: "audio",
            SUBTITLES: "subs",
            RESOLUTION: { width: t.width, height: t.height },
            CODECS: t.codecs,
            BANDWIDTH: t.bandwidth,
          })["PROGRAM-ID"] = 1),
          e),
        uri: "",
        endList: "static" === t.type,
        timeline: t.periodStart,
        resolvedUri: "",
        targetDuration: t.duration,
        discontinuityStarts: r,
        timelineStarts: t.timelineStarts,
        segments: n,
      };
    return (
      t.contentProtection && (n.contentProtection = t.contentProtection),
      i && (n.sidx = i),
      n
    );
  }
  function Bs(e) {
    return (
      "video/mp4" === (e = e.attributes).mimeType ||
      "video/webm" === e.mimeType ||
      "video" === e.contentType
    );
  }
  function Us(e) {
    return (
      "audio/mp4" === (e = e.attributes).mimeType ||
      "audio/webm" === e.mimeType ||
      "audio" === e.contentType
    );
  }
  function Vs(e) {
    return (
      "text/vtt" === (e = e.attributes).mimeType || "text" === e.contentType
    );
  }
  function Fs(n) {
    return n
      ? Object.keys(n).reduce(function (e, t) {
          t = n[t];
          return e.concat(t.playlists);
        }, [])
      : [];
  }
  function Gs(e) {
    var t = e.dashPlaylists,
      n = e.locations,
      i = void 0 === (c = e.sidxMapping) ? {} : c,
      r = e.previousManifest;
    if (!t.length) return {};
    var a = (d = t[0].attributes).sourceDuration,
      s = d.type,
      o = d.suggestedPresentationDelay,
      l = d.minimumUpdatePeriod,
      u = Ls(t.filter(Bs)).map(Rs),
      c = Ls(t.filter(Us)),
      e = Ls(t.filter(Vs)),
      d = t
        .map(function (e) {
          return e.attributes.captionServices;
        })
        .filter(Boolean),
      a = {
        allowCache: !0,
        discontinuityStarts: [],
        segments: [],
        endList: !0,
        mediaGroups:
          (((t = { AUDIO: {}, VIDEO: {} })["CLOSED-CAPTIONS"] = {}),
          (t.SUBTITLES = {}),
          t),
        uri: "",
        duration: a,
        playlists: (function (e, t) {
          if ((void 0 === t && (t = {}), !Object.keys(t).length)) return e;
          for (var n in e) e[n] = Ms(e[n], t);
          return e;
        })(u, i),
      };
    0 <= l && (a.minimumUpdatePeriod = 1e3 * l),
      n && (a.locations = n),
      "dynamic" === s && (a.suggestedPresentationDelay = o);
    var h,
      p,
      o = 0 === a.playlists.length,
      o = c.length ? Ds(c, i, o) : null,
      i = e.length
        ? (void 0 === (h = i) && (h = {}),
          e.reduce(function (e, t) {
            var n = t.attributes.lang || "text";
            return (
              e[n] ||
                (e[n] = {
                  language: n,
                  default: !1,
                  autoselect: !1,
                  playlists: [],
                  uri: "",
                }),
              e[n].playlists.push(
                Ms(
                  (function (e) {
                    var t = e.attributes,
                      n = e.segments,
                      i = e.mediaSequence,
                      r = e.discontinuityStarts,
                      a = e.discontinuitySequence;
                    "undefined" == typeof n &&
                      ((n = [
                        {
                          uri: t.baseUrl,
                          timeline: t.periodStart,
                          resolvedUri: t.baseUrl || "",
                          duration: t.sourceDuration,
                          number: 0,
                        },
                      ]),
                      (t.duration = t.sourceDuration));
                    (e = { NAME: t.id, BANDWIDTH: t.bandwidth })[
                      "PROGRAM-ID"
                    ] = 1;
                    return (
                      t.codecs && (e.CODECS = t.codecs),
                      {
                        attributes: e,
                        uri: "",
                        endList: "static" === t.type,
                        timeline: t.periodStart,
                        resolvedUri: t.baseUrl || "",
                        targetDuration: t.duration,
                        timelineStarts: t.timelineStarts,
                        discontinuityStarts: r,
                        discontinuitySequence: a,
                        mediaSequence: i,
                        segments: n,
                      }
                    );
                  })(t),
                  h
                )
              ),
              e
            );
          }, {}))
        : null,
      u = (e = u.concat(Fs(o), Fs(i))).map(function (e) {
        return e.timelineStarts;
      });
    return (
      (a.timelineStarts = Es(u)),
      (e = e),
      (p = a.timelineStarts),
      e.forEach(function (t) {
        (t.mediaSequence = 0),
          (t.discontinuitySequence = Ss(p, function (e) {
            return e.timeline === t.timeline;
          })),
          t.segments &&
            t.segments.forEach(function (e, t) {
              e.number = t;
            });
      }),
      o && (a.mediaGroups.AUDIO.audio = o),
      i && (a.mediaGroups.SUBTITLES.subs = i),
      d.length &&
        (a.mediaGroups["CLOSED-CAPTIONS"].cc = d.reduce(function (i, e) {
          return (
            e &&
              e.forEach(function (e) {
                var t = e.channel,
                  n = e.language;
                (i[n] = {
                  autoselect: !1,
                  default: !1,
                  instreamId: t,
                  language: n,
                }),
                  e.hasOwnProperty("aspectRatio") &&
                    (i[n].aspectRatio = e.aspectRatio),
                  e.hasOwnProperty("easyReader") &&
                    (i[n].easyReader = e.easyReader),
                  e.hasOwnProperty("3D") && (i[n]["3D"] = e["3D"]);
              }),
            i
          );
        }, {})),
      r ? js({ oldManifest: r, newManifest: a }) : a
    );
  }
  function qs(e, t) {
    for (
      var n,
        i,
        r,
        a,
        s,
        o,
        l = e.type,
        u = e.minimumUpdatePeriod,
        c = void 0 === u ? 0 : u,
        d = void 0 === (u = e.media) ? "" : u,
        h = e.sourceDuration,
        p = void 0 === (u = e.timescale) ? 1 : u,
        m = void 0 === (u = e.startNumber) ? 1 : u,
        f = e.periodStart,
        g = [],
        b = -1,
        v = 0;
      v < t.length;
      v++
    ) {
      var y = t[v],
        _ = y.d,
        T = y.r || 0,
        O = y.t || 0;
      b < 0 && (b = O), O && b < O && (b = O);
      var S,
        A = void 0;
      A =
        T < 0
          ? (S = v + 1) === t.length
            ? "dynamic" === l && 0 < c && 0 < d.indexOf("$Number$")
              ? ((n = b),
                (i = _),
                (y = o = s = a = r = void 0),
                (r = (O = e).NOW),
                (a = O.clientOffset),
                (s = O.availabilityStartTime),
                (o = O.timescale),
                (y = O.periodStart),
                (O = O.minimumUpdatePeriod),
                Math.ceil(
                  (((r + a) / 1e3 +
                    (void 0 === O ? 0 : O) -
                    (s + (void 0 === y ? 0 : y))) *
                    (void 0 === o ? 1 : o) -
                    n) /
                    i
                ))
              : (h * p - b) / _
            : (t[S].t - b) / _
          : T + 1;
      for (var w = m + g.length + A, C = m + g.length; C < w; )
        g.push({ number: C, duration: _ / p, time: b, timeline: f }),
          (b += _),
          C++;
    }
    return g;
  }
  function zs(e, t) {
    return e.replace(
      To,
      ((r = t),
      function (e, t, n, i) {
        if ("$$" === e) return "$";
        if ("undefined" == typeof r[t]) return e;
        e = "" + r[t];
        return "RepresentationID" === t ||
          (i = n ? parseInt(i, 10) : 1) <= e.length
          ? e
          : new Array(i - e.length + 1).join("0") + e;
      })
    );
    var r;
  }
  function Hs(r, e) {
    var a = { RepresentationID: r.id, Bandwidth: r.bandwidth || 0 },
      t = void 0 === (t = r.initialization) ? { sourceURL: "", range: "" } : t,
      s = As({
        baseUrl: r.baseUrl,
        source: zs(t.sourceURL, a),
        range: t.range,
      });
    return ((t = e),
    (e = r).duration || t
      ? e.duration
        ? Cs(e)
        : qs(e, t)
      : [
          {
            number: e.startNumber || 1,
            duration: e.sourceDuration,
            time: 0,
            timeline: e.periodStart,
          },
        ]).map(function (e) {
      (a.Number = e.number), (a.Time = e.time);
      var t = zs(r.media || "", a),
        n = r.timescale || 1,
        i = r.presentationTimeOffset || 0,
        n = r.periodStart + (e.time - i) / n;
      return {
        uri: t,
        timeline: e.timeline,
        duration: e.duration,
        resolvedUri: kr(r.baseUrl || "", t),
        map: s,
        number: e.number,
        presentationTime: n,
      };
    });
  }
  function Ws(r, e) {
    var t = r.duration,
      n = void 0 === (n = r.segmentUrls) ? [] : n,
      a = r.periodStart;
    if ((!t && !e) || (t && e)) throw new Error(bo);
    var i,
      s = n.map(function (e) {
        return (
          (n = e),
          (e = (t = r).baseUrl),
          (t = t.initialization),
          (t = As({
            baseUrl: e,
            source: (t = void 0 === t ? {} : t).sourceURL,
            range: t.range,
          })),
          ((n = As({ baseUrl: e, source: n.media, range: n.mediaRange })).map =
            t),
          n
        );
        var t, n;
      });
    return (
      t && (i = Cs(r)),
      (i = e ? qs(r, e) : i)
        .map(function (e, t) {
          if (s[t]) {
            var n = s[t],
              i = r.timescale || 1,
              t = r.presentationTimeOffset || 0;
            return (
              (n.timeline = e.timeline),
              (n.duration = e.duration),
              (n.number = e.number),
              (n.presentationTime = a + (e.time - t) / i),
              n
            );
          }
        })
        .filter(function (e) {
          return e;
        })
    );
  }
  function Xs(e) {
    var t,
      n = e.attributes,
      i = e.segmentInfo;
    i.template
      ? ((a = Hs), (t = P(n, i.template)))
      : i.base
      ? ((a = Is), (t = P(n, i.base)))
      : i.list && ((a = Ws), (t = P(n, i.list)));
    var r = { attributes: n };
    if (!a) return r;
    var a,
      e = a(t, i.segmentTimeline);
    return (
      t.duration
        ? ((n = t.duration),
          (a = t.timescale),
          (t.duration = n / (void 0 === a ? 1 : a)))
        : e.length
        ? (t.duration = e.reduce(function (e, t) {
            return Math.max(e, Math.ceil(t.duration));
          }, 0))
        : (t.duration = 0),
      (r.attributes = t),
      (r.segments = e),
      i.base && t.indexRange && ((r.sidx = e[0]), (r.segments = [])),
      r
    );
  }
  function j(e, t) {
    return Os(e.childNodes).filter(function (e) {
      return e.tagName === t;
    });
  }
  function Ys(e) {
    return e.textContent.trim();
  }
  function Ks(e) {
    if (
      !(r =
        /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/.exec(
          e
        ))
    )
      return 0;
    var t = (a = r.slice(1))[0],
      n = a[1],
      i = a[2],
      e = a[3],
      r = a[4],
      a = a[5];
    return (
      31536e3 * parseFloat(t || 0) +
      2592e3 * parseFloat(n || 0) +
      86400 * parseFloat(i || 0) +
      3600 * parseFloat(e || 0) +
      60 * parseFloat(r || 0) +
      parseFloat(a || 0)
    );
  }
  function N(e) {
    return e && e.attributes
      ? Os(e.attributes).reduce(function (e, t) {
          var n = Oo[t.name] || Oo.DEFAULT;
          return (e[t.name] = n(t.value)), e;
        }, {})
      : {};
  }
  function Qs(e, n) {
    return n.length
      ? Ts(
          e.map(function (t) {
            return n.map(function (e) {
              return kr(t, Ys(e));
            });
          })
        )
      : e;
  }
  function Zs(e) {
    var t = j(e, "SegmentTemplate")[0],
      n = j(e, "SegmentList")[0],
      i =
        n &&
        j(n, "SegmentURL").map(function (e) {
          return P({ tag: "SegmentURL" }, N(e));
        }),
      r = j(e, "SegmentBase")[0],
      e = (a = n || t) && j(a, "SegmentTimeline")[0],
      a = (a = n || r || t) && j(a, "Initialization")[0];
    (t = t && N(t)) && a
      ? (t.initialization = a && N(a))
      : t &&
        t.initialization &&
        (t.initialization = { sourceURL: t.initialization });
    var s = {
      template: t,
      segmentTimeline: e && j(e, "S").map(N),
      list: n && P(N(n), { segmentUrls: i, initialization: N(a) }),
      base: r && P(N(r), { initialization: N(a) }),
    };
    return (
      Object.keys(s).forEach(function (e) {
        s[e] || delete s[e];
      }),
      s
    );
  }
  function Js(l, u, c) {
    return function (e) {
      var t = N(e),
        n = Qs(u, j(e, "BaseURL")),
        i = j(e, "Role")[0],
        i = { role: N(i) },
        t = P(l, t, i),
        i = j(e, "Accessibility")[0],
        i =
          "urn:scte:dash:cc:cea-608:2015" === (i = N(i)).schemeIdUri
            ? ("string" != typeof i.value ? [] : i.value.split(";")).map(
                function (e) {
                  var t, n, i;
                  return (
                    /^CC\d=/.test((i = e))
                      ? ((n = (t = e.split("="))[0]), (i = t[1]))
                      : /^CC\d$/.test(e) && (n = e),
                    { channel: n, language: i }
                  );
                }
              )
            : "urn:scte:dash:cc:cea-708:2015" === i.schemeIdUri
            ? ("string" != typeof i.value ? [] : i.value.split(";")).map(
                function (e) {
                  var t,
                    n,
                    i = {
                      channel: void 0,
                      language: void 0,
                      aspectRatio: 1,
                      easyReader: 0,
                      "3D": 0,
                    };
                  return (
                    /=/.test(e)
                      ? ((t = (n = e.split("="))[0]),
                        (n = void 0 === (n = n[1]) ? "" : n),
                        (i.channel = t),
                        (i.language = e),
                        n.split(",").forEach(function (e) {
                          var t = e.split(":"),
                            e = t[0],
                            t = t[1];
                          "lang" === e
                            ? (i.language = t)
                            : "er" === e
                            ? (i.easyReader = Number(t))
                            : "war" === e
                            ? (i.aspectRatio = Number(t))
                            : "3D" === e && (i["3D"] = Number(t));
                        }))
                      : (i.language = e),
                    i.channel && (i.channel = "SERVICE" + i.channel),
                    i
                  );
                }
              )
            : void 0;
      i && (t = P(t, { captionServices: i }));
      i = j(e, "Label")[0];
      i &&
        i.childNodes.length &&
        ((r = i.childNodes[0].nodeValue.trim()), (t = P(t, { label: r })));
      var r = j(e, "ContentProtection").reduce(function (e, t) {
        var n = N(t);
        n.schemeIdUri && (n.schemeIdUri = n.schemeIdUri.toLowerCase());
        var i = So[n.schemeIdUri];
        return (
          i &&
            ((e[i] = { attributes: n }),
            (t = j(t, "cenc:pssh")[0]) &&
              ((t = Ys(t)), (e[i].pssh = t && zr(t)))),
          e
        );
      }, {});
      Object.keys(r).length && (t = P(t, { contentProtection: r }));
      var a,
        s,
        o,
        r = Zs(e),
        e = j(e, "Representation"),
        r = P(c, r);
      return Ts(
        e.map(
          ((a = t),
          (s = n),
          (o = r),
          function (e) {
            var t = j(e, "BaseURL"),
              t = Qs(s, t),
              n = P(a, N(e)),
              i = Zs(e);
            return t.map(function (e) {
              return { segmentInfo: P(o, i), attributes: P(n, { baseUrl: e }) };
            });
          })
        )
      );
    };
  }
  function $s(e, t) {
    var n = (t = void 0 === t ? {} : t),
      i = void 0 === (a = n.manifestUri) ? "" : a,
      t = void 0 === (r = n.NOW) ? Date.now() : r,
      r = void 0 === (a = n.clientOffset) ? 0 : a;
    if (!(n = j(e, "Period")).length) throw new Error(po);
    var a = j(e, "Location"),
      s = N(e),
      e = Qs([i], j(e, "BaseURL"));
    (s.type = s.type || "static"),
      (s.sourceDuration = s.mediaPresentationDuration || 0),
      (s.NOW = t),
      (s.clientOffset = r),
      a.length && (s.locations = a.map(Ys));
    var o,
      l,
      u = [];
    return (
      n.forEach(function (e, t) {
        var n,
          i = N(e),
          r = u[t - 1];
        (i.start =
          ((n = {
            attributes: i,
            priorPeriodAttributes: r ? r.attributes : null,
            mpdType: s.type,
          }),
          (t = n.attributes),
          (r = n.priorPeriodAttributes),
          (n = n.mpdType),
          "number" == typeof t.start
            ? t.start
            : r && "number" == typeof r.start && "number" == typeof r.duration
            ? r.start + r.duration
            : r || "static" !== n
            ? null
            : 0)),
          u.push({ node: e, attributes: i });
      }),
      {
        locations: s.locations,
        representationInfo: Ts(
          u.map(
            ((o = s),
            (l = e),
            function (e, t) {
              var n = Qs(l, j(e.node, "BaseURL")),
                i = P(o, { periodStart: e.attributes.start });
              "number" == typeof e.attributes.duration &&
                (i.periodDuration = e.attributes.duration);
              var r = j(e.node, "AdaptationSet"),
                e = Zs(e.node);
              return Ts(r.map(Js(i, n, e)));
            })
          )
        ),
      }
    );
  }
  function eo(e) {
    if ("" === e) throw new Error(mo);
    var t,
      n,
      i = new ho();
    try {
      n =
        (t = i.parseFromString(e, "application/xml")) &&
        "MPD" === t.documentElement.tagName
          ? t.documentElement
          : null;
    } catch (e) {}
    if (!n || (n && 0 < n.getElementsByTagName("parsererror").length))
      throw new Error(fo);
    return n;
  }
  function to(e, t) {
    void 0 === t && (t = {});
    var n = $s(eo(e), t),
      e = n.representationInfo.map(Xs);
    return Gs({
      dashPlaylists: e,
      locations: n.locations,
      sidxMapping: t.sidxMapping,
      previousManifest: t.previousManifest,
    });
  }
  function no(e) {
    return (function (e) {
      e = j(e, "UTCTiming")[0];
      if (!e) return null;
      var t = N(e);
      switch (t.schemeIdUri) {
        case "urn:mpeg:dash:utc:http-head:2014":
        case "urn:mpeg:dash:utc:http-head:2012":
          t.method = "HEAD";
          break;
        case "urn:mpeg:dash:utc:http-xsdate:2014":
        case "urn:mpeg:dash:utc:http-iso:2014":
        case "urn:mpeg:dash:utc:http-xsdate:2012":
        case "urn:mpeg:dash:utc:http-iso:2012":
          t.method = "GET";
          break;
        case "urn:mpeg:dash:utc:direct:2014":
        case "urn:mpeg:dash:utc:direct:2012":
          (t.method = "DIRECT"), (t.value = Date.parse(t.value));
          break;
        case "urn:mpeg:dash:utc:http-ntp:2014":
        case "urn:mpeg:dash:utc:ntp:2014":
        case "urn:mpeg:dash:utc:sntp:2014":
        default:
          throw new Error(vo);
      }
      return t;
    })(eo(e));
  }
  function io(e, t) {
    return (
      void 0 === t && (t = 0),
      (e = C(e)).length - t < 10 || !I(e, Io, { offset: t })
        ? t
        : io(
            e,
            (t += (function (e, t) {
              void 0 === t && (t = 0);
              var n = (e = C(e))[t + 5],
                t =
                  (e[t + 6] << 21) |
                  (e[t + 7] << 14) |
                  (e[t + 8] << 7) |
                  e[t + 9];
              return (16 & n) >> 4 ? 20 + t : 10 + t;
            })(e, t))
          )
    );
  }
  function ro(e) {
    return "string" == typeof e ? Er(e) : e;
  }
  function ao(e, t, n) {
    var i;
    void 0 === n && (n = !1),
      (i = t),
      (t = Array.isArray(i) ? i.map(ro) : [ro(i)]),
      (e = C(e));
    var r = [];
    if (!t.length) return r;
    for (var a = 0; a < e.length; ) {
      var s =
          ((e[a] << 24) | (e[a + 1] << 16) | (e[a + 2] << 8) | e[a + 3]) >>> 0,
        o = e.subarray(a + 4, a + 8);
      if (0 == s) break;
      var l = a + s;
      if (l > e.length) {
        if (n) break;
        l = e.length;
      }
      s = e.subarray(a + 8, l);
      I(o, t[0]) &&
        (1 === t.length ? r.push(s) : r.push.apply(r, ao(s, t.slice(1), n))),
        (a = l);
    }
    return r;
  }
  function so(e, t, n, i) {
    void 0 === n && (n = !0), void 0 === i && (i = !1);
    var r = (function (e) {
        for (var t = 1, n = 0; n < Eo.length && !(e & Eo[n]); n++) t++;
        return t;
      })(e[t]),
      a = e.subarray(t, t + r);
    return (
      n && ((a = Array.prototype.slice.call(e, t, t + r))[0] ^= Eo[r - 1]),
      {
        length: r,
        value: (function (i, e) {
          var t = void 0 === e ? {} : e,
            e = t.signed,
            e = void 0 !== e && e,
            t = t.le,
            r = void 0 !== t && t;
          i = C(i);
          (t = r ? "reduce" : "reduceRight"),
            (t = (i[t] || Array.prototype[t]).call(
              i,
              function (e, t, n) {
                n = r ? n : Math.abs(n + 1 - i.length);
                return e + x(t) * Gr[n];
              },
              x(0)
            ));
          return (
            !e ||
              ((e = Gr[i.length] / x(2) - x(1)) < (t = x(t)) &&
                ((t -= e), (t -= e), (t -= x(2)))),
            Number(t)
          );
        })(a, { signed: i }),
        bytes: a,
      }
    );
  }
  function oo(e) {
    return "string" == typeof e
      ? e.match(/.{1,2}/g).map(oo)
      : "number" == typeof e
      ? xr(e)
      : e;
  }
  function lo(e, t, n) {
    if (n >= t.length) return t.length;
    var i = so(t, n, !1);
    if (I(e.bytes, i.bytes)) return n;
    var r = so(t, n + i.length);
    return lo(e, t, n + r.length + r.value + i.length);
  }
  function uo(e, t) {
    var n;
    (n = t), (t = Array.isArray(n) ? n.map(oo) : [oo(n)]), (e = C(e));
    var i = [];
    if (!t.length) return i;
    for (var r = 0; r < e.length; ) {
      var a = so(e, r, !1),
        s = so(e, r + a.length),
        o = r + a.length + s.length;
      127 === s.value &&
        ((s.value = lo(a, e, o)), s.value !== e.length && (s.value -= o));
      var l = o + s.value > e.length ? e.length : o + s.value,
        l = e.subarray(o, l);
      I(t[0], a.bytes) &&
        (1 === t.length ? i.push(l) : (i = i.concat(uo(l, t.slice(1))))),
        (r += a.length + s.length + l.length);
    }
    return i;
  }
  function co(e, t, n, i) {
    void 0 === i && (i = 1 / 0), (e = C(e)), (n = [].concat(n));
    for (var r, a = 0, s = 0; a < e.length && (s < i || r); ) {
      var o = void 0;
      if (
        (I(e.subarray(a), ko) ? (o = 4) : I(e.subarray(a), Po) && (o = 3), o)
      ) {
        if ((s++, r))
          return (function (e) {
            for (var t = [], n = 1; n < e.length - 2; )
              I(e.subarray(n, n + 3), jo) && (t.push(n + 2), n++), n++;
            if (0 === t.length) return e;
            for (
              var i = e.length - t.length, r = new Uint8Array(i), a = 0, n = 0;
              n < i;
              a++, n++
            )
              a === t[0] && (a++, t.shift()), (r[n] = e[a]);
            return r;
          })(e.subarray(r, a));
        var l = void 0;
        "h264" === t
          ? (l = 31 & e[a + o])
          : "h265" === t && (l = (e[a + o] >> 1) & 63),
          -1 !== n.indexOf(l) && (r = a + o),
          (a += o + ("h264" === t ? 1 : 2));
      } else a++;
    }
    return e.subarray(0, 0);
  }
  var ho = {
      __DOMHandler: ms,
      DOMParser: ps,
      DOMImplementation: he.DOMImplementation,
      XMLSerializer: he.XMLSerializer,
    }.DOMParser,
    po = "INVALID_NUMBER_OF_PERIOD",
    mo = "DASH_EMPTY_MANIFEST",
    fo = "DASH_INVALID_XML",
    go = "NO_BASE_URL",
    bo = "SEGMENT_TIME_UNSPECIFIED",
    vo = "UNSUPPORTED_UTC_TIMING_SCHEME",
    yo = {
      static: function (e) {
        var t = e.duration,
          n = e.timescale,
          i = void 0 === n ? 1 : n,
          r = e.sourceDuration,
          n = e.periodDuration,
          e = ws(e.endNumber),
          i = t / i;
        return "number" == typeof e
          ? { start: 0, end: e }
          : "number" == typeof n
          ? { start: 0, end: n / i }
          : { start: 0, end: r / i };
      },
      dynamic: function (e) {
        var t = e.NOW,
          n = e.clientOffset,
          i = e.availabilityStartTime,
          r = e.timescale,
          a = void 0 === r ? 1 : r,
          s = e.duration,
          o = e.periodStart,
          l = void 0 === o ? 0 : o,
          r = e.minimumUpdatePeriod,
          o = void 0 === r ? 0 : r,
          r = e.timeShiftBufferDepth,
          r = void 0 === r ? 1 / 0 : r,
          e = ws(e.endNumber),
          n = (t + n) / 1e3,
          l = i + l,
          o = Math.ceil(((n + o - l) * a) / s),
          r = Math.floor(((n - l - r) * a) / s),
          s = Math.floor(((n - l) * a) / s);
        return {
          start: Math.max(0, r),
          end: "number" == typeof e ? e : Math.min(o, s),
        };
      },
    },
    _o = ["AUDIO", "SUBTITLES"],
    To = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g,
    Oo = {
      mediaPresentationDuration: Ks,
      availabilityStartTime: function (e) {
        return (
          /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/.test((e = e)) && (e += "Z"),
          Date.parse(e) / 1e3
        );
      },
      minimumUpdatePeriod: Ks,
      suggestedPresentationDelay: Ks,
      type: function (e) {
        return e;
      },
      timeShiftBufferDepth: Ks,
      start: Ks,
      width: function (e) {
        return parseInt(e, 10);
      },
      height: function (e) {
        return parseInt(e, 10);
      },
      bandwidth: function (e) {
        return parseInt(e, 10);
      },
      startNumber: function (e) {
        return parseInt(e, 10);
      },
      timescale: function (e) {
        return parseInt(e, 10);
      },
      presentationTimeOffset: function (e) {
        return parseInt(e, 10);
      },
      duration: function (e) {
        var t = parseInt(e, 10);
        return isNaN(t) ? Ks(e) : t;
      },
      d: function (e) {
        return parseInt(e, 10);
      },
      t: function (e) {
        return parseInt(e, 10);
      },
      r: function (e) {
        return parseInt(e, 10);
      },
      DEFAULT: function (e) {
        return e;
      },
    },
    So = {
      "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
      "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
      "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95":
        "com.microsoft.playready",
      "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime",
    },
    Ao = Math.pow(2, 32),
    wo = function (e) {
      var t = new DataView(e.buffer, e.byteOffset, e.byteLength);
      return t.getBigUint64
        ? (e = t.getBigUint64(0)) < Number.MAX_SAFE_INTEGER
          ? Number(e)
          : e
        : t.getUint32(0) * Ao + t.getUint32(4);
    },
    Co = function (e) {
      var t = new DataView(e.buffer, e.byteOffset, e.byteLength),
        n = {
          version: e[0],
          flags: new Uint8Array(e.subarray(1, 4)),
          references: [],
          referenceId: t.getUint32(4),
          timescale: t.getUint32(8),
        },
        i = 12;
      0 === n.version
        ? ((n.earliestPresentationTime = t.getUint32(i)),
          (n.firstOffset = t.getUint32(i + 4)),
          (i += 8))
        : ((n.earliestPresentationTime = wo(e.subarray(i))),
          (n.firstOffset = wo(e.subarray(i + 8))),
          (i += 16));
      var r = t.getUint16((i += 2));
      for (i += 2; 0 < r; i += 12, r--)
        n.references.push({
          referenceType: (128 & e[i]) >>> 7,
          referencedSize: 2147483647 & t.getUint32(i),
          subsegmentDuration: t.getUint32(i + 4),
          startsWithSap: !!(128 & e[i + 8]),
          sapType: (112 & e[i + 8]) >>> 4,
          sapDeltaTime: 268435455 & t.getUint32(i + 8),
        });
      return n;
    },
    Io = C([73, 68, 51]),
    xo = {
      EBML: C([26, 69, 223, 163]),
      DocType: C([66, 130]),
      Segment: C([24, 83, 128, 103]),
      SegmentInfo: C([21, 73, 169, 102]),
      Tracks: C([22, 84, 174, 107]),
      Track: C([174]),
      TrackNumber: C([215]),
      DefaultDuration: C([35, 227, 131]),
      TrackEntry: C([174]),
      TrackType: C([131]),
      FlagDefault: C([136]),
      CodecID: C([134]),
      CodecPrivate: C([99, 162]),
      VideoTrack: C([224]),
      AudioTrack: C([225]),
      Cluster: C([31, 67, 182, 117]),
      Timestamp: C([231]),
      TimestampScale: C([42, 215, 177]),
      BlockGroup: C([160]),
      BlockDuration: C([155]),
      Block: C([161]),
      SimpleBlock: C([163]),
    },
    Eo = [128, 64, 32, 16, 8, 4, 2, 1],
    ko = C([0, 0, 0, 1]),
    Po = C([0, 0, 1]),
    jo = C([0, 0, 3]),
    No = {
      webm: C([119, 101, 98, 109]),
      matroska: C([109, 97, 116, 114, 111, 115, 107, 97]),
      flac: C([102, 76, 97, 67]),
      ogg: C([79, 103, 103, 83]),
      ac3: C([11, 119]),
      riff: C([82, 73, 70, 70]),
      avi: C([65, 86, 73]),
      wav: C([87, 65, 86, 69]),
      "3gp": C([102, 116, 121, 112, 51, 103]),
      mp4: C([102, 116, 121, 112]),
      fmp4: C([115, 116, 121, 112]),
      mov: C([102, 116, 121, 112, 113, 116]),
      moov: C([109, 111, 111, 118]),
      moof: C([109, 111, 111, 102]),
    },
    Lo = {
      aac: function (e) {
        var t = io(e);
        return I(e, [255, 16], { offset: t, mask: [255, 22] });
      },
      mp3: function (e) {
        var t = io(e);
        return I(e, [255, 2], { offset: t, mask: [255, 6] });
      },
      webm: function (e) {
        e = uo(e, [xo.EBML, xo.DocType])[0];
        return I(e, No.webm);
      },
      mkv: function (e) {
        e = uo(e, [xo.EBML, xo.DocType])[0];
        return I(e, No.matroska);
      },
      mp4: function (e) {
        return (
          !Lo["3gp"](e) &&
          !Lo.mov(e) &&
          (!(!I(e, No.mp4, { offset: 4 }) && !I(e, No.fmp4, { offset: 4 })) ||
            !(!I(e, No.moof, { offset: 4 }) && !I(e, No.moov, { offset: 4 })) ||
            void 0)
        );
      },
      mov: function (e) {
        return I(e, No.mov, { offset: 4 });
      },
      "3gp": function (e) {
        return I(e, No["3gp"], { offset: 4 });
      },
      ac3: function (e) {
        var t = io(e);
        return I(e, No.ac3, { offset: t });
      },
      ts: function (e) {
        if (e.length < 189 && 1 <= e.length) return 71 === e[0];
        for (var t = 0; t + 188 < e.length && t < 188; ) {
          if (71 === e[t] && 71 === e[t + 188]) return !0;
          t += 1;
        }
        return !1;
      },
      flac: function (e) {
        var t = io(e);
        return I(e, No.flac, { offset: t });
      },
      ogg: function (e) {
        return I(e, No.ogg);
      },
      avi: function (e) {
        return I(e, No.riff) && I(e, No.avi, { offset: 8 });
      },
      wav: function (e) {
        return I(e, No.riff) && I(e, No.wav, { offset: 8 });
      },
      h264: function (e) {
        return co(e, "h264", 7, 3).length;
      },
      h265: function (e) {
        return co(e, "h265", [32, 33], 3).length;
      },
    },
    Mo = Object.keys(Lo)
      .filter(function (e) {
        return "ts" !== e && "h264" !== e && "h265" !== e;
      })
      .concat(["ts", "h264", "h265"]);
  Mo.forEach(function (e) {
    var t = Lo[e];
    Lo[e] = function (e) {
      return t(C(e));
    };
  });
  function Do(e) {
    e = C(e);
    for (var t = 0; t < Mo.length; t++) {
      var n = Mo[t];
      if (mu[n](e)) return n;
    }
    return "";
  }
  function Ro(e, t, n) {
    return e && n && n.responseURL && t !== n.responseURL ? n.responseURL : t;
  }
  function Bo(e) {
    return w.log.debug ? w.log.debug.bind(w, "VHS:", e + " >") : function () {};
  }
  function Uo(e, t) {
    var n,
      i = [];
    if (e && e.length)
      for (n = 0; n < e.length; n++)
        t(e.start(n), e.end(n)) && i.push([e.start(n), e.end(n)]);
    return w.createTimeRanges(i);
  }
  function Vo(e, n) {
    return Uo(e, function (e, t) {
      return e - 0.1 <= n && n <= t + 0.1;
    });
  }
  function Fo(e, t) {
    return Uo(e, function (e) {
      return t <= e - bu;
    });
  }
  function Go(e) {
    var t = [];
    if (!e || !e.length) return "";
    for (var n = 0; n < e.length; n++) t.push(e.start(n) + " => " + e.end(n));
    return t.join(", ");
  }
  function qo(e) {
    for (var t = [], n = 0; n < e.length; n++)
      t.push({ start: e.start(n), end: e.end(n) });
    return t;
  }
  function zo(e) {
    if (e && e.length && e.end) return e.end(e.length - 1);
  }
  function Ho(e, t) {
    var n = 0;
    if (!e || !e.length) return n;
    for (var i = 0; i < e.length; i++) {
      var r = e.start(i),
        a = e.end(i);
      a < t || (n += r < t && t <= a ? a - t : a - r);
    }
    return n;
  }
  function Wo(t, e) {
    if (!e.preload) return e.duration;
    var n = 0;
    return (
      (e.parts || []).forEach(function (e) {
        n += e.duration;
      }),
      (e.preloadHints || []).forEach(function (e) {
        "PART" === e.type && (n += t.partTargetDuration);
      }),
      n
    );
  }
  function Xo(e) {
    return (e.segments || []).reduce(function (n, i, r) {
      return (
        i.parts
          ? i.parts.forEach(function (e, t) {
              n.push({
                duration: e.duration,
                segmentIndex: r,
                partIndex: t,
                part: e,
                segment: i,
              });
            })
          : n.push({
              duration: i.duration,
              segmentIndex: r,
              partIndex: null,
              segment: i,
              part: null,
            }),
        n
      );
    }, []);
  }
  function Yo(e) {
    return (
      ((e =
        e.segments && e.segments.length && e.segments[e.segments.length - 1]) &&
        e.parts) ||
      []
    );
  }
  function Ko(e) {
    var t = e.preloadSegment;
    if (t) {
      (e = t.parts),
        (t = (t.preloadHints || []).reduce(function (e, t) {
          return e + ("PART" === t.type ? 1 : 0);
        }, 0));
      return (t += e && e.length ? e.length : 0);
    }
  }
  function Qo(e, t) {
    return t.endList
      ? 0
      : e && e.suggestedPresentationDelay
      ? e.suggestedPresentationDelay
      : (e = 0 < Yo(t).length) &&
        t.serverControl &&
        t.serverControl.partHoldBack
      ? t.serverControl.partHoldBack
      : e && t.partTargetDuration
      ? 3 * t.partTargetDuration
      : t.serverControl && t.serverControl.holdBack
      ? t.serverControl.holdBack
      : t.targetDuration
      ? 3 * t.targetDuration
      : 0;
  }
  function Zo(e, t, n) {
    if (
      (t = "undefined" == typeof t ? e.mediaSequence + e.segments.length : t) <
      e.mediaSequence
    )
      return 0;
    var i = (function (e, t) {
      var n = 0,
        i = t - e.mediaSequence,
        r = e.segments[i];
      if (r) {
        if ("undefined" != typeof r.start)
          return { result: r.start, precise: !0 };
        if ("undefined" != typeof r.end)
          return { result: r.end - r.duration, precise: !0 };
      }
      for (; i--; ) {
        if ("undefined" != typeof (r = e.segments[i]).end)
          return { result: n + r.end, precise: !0 };
        if (((n += Wo(e, r)), "undefined" != typeof r.start))
          return { result: n + r.start, precise: !0 };
      }
      return { result: n, precise: !1 };
    })(e, t);
    return i.precise
      ? i.result
      : (t = (function (e, t) {
          for (
            var n, i = 0, r = t - e.mediaSequence;
            r < e.segments.length;
            r++
          ) {
            if ("undefined" != typeof (n = e.segments[r]).start)
              return { result: n.start - i, precise: !0 };
            if (((i += Wo(e, n)), "undefined" != typeof n.end))
              return { result: n.end - i, precise: !0 };
          }
          return { result: -1, precise: !1 };
        })(e, t)).precise
      ? t.result
      : i.result + n;
  }
  function Jo(e, t, n) {
    if (!e) return 0;
    if (("number" != typeof n && (n = 0), "undefined" == typeof t)) {
      if (e.totalDuration) return e.totalDuration;
      if (!e.endList) return window.Infinity;
    }
    return Zo(e, t, n);
  }
  function $o(e) {
    var t = e.defaultDuration,
      n = e.durationList,
      i = e.startIndex,
      r = e.endIndex,
      a = 0;
    if ((r < i && ((i = (e = [r, i])[0]), (r = e[1])), i < 0)) {
      for (var s = i; s < Math.min(0, r); s++) a += t;
      i = 0;
    }
    for (var o = i; o < r; o++) a += n[o].duration;
    return a;
  }
  function el(e, t, n, i) {
    return e && e.segments
      ? e.endList
        ? Jo(e)
        : null === t
        ? null
        : ((t = Zo(e, e.mediaSequence + e.segments.length, (t = t || 0))),
          n && (t -= i = "number" == typeof i ? i : Qo(null, e)),
          Math.max(0, t))
      : null;
  }
  function tl(e) {
    return e.excludeUntil && e.excludeUntil > Date.now();
  }
  function nl(e) {
    return e.excludeUntil && e.excludeUntil === 1 / 0;
  }
  function il(e) {
    var t = tl(e);
    return !e.disabled && !t;
  }
  function rl(e, t) {
    return t.attributes && t.attributes[e];
  }
  function al(e, t) {
    if (1 === e.playlists.length) return !0;
    var n = t.attributes.BANDWIDTH || Number.MAX_VALUE;
    return (
      0 ===
      e.playlists.filter(function (e) {
        return !!il(e) && (e.attributes.BANDWIDTH || 0) < n;
      }).length
    );
  }
  function sl(e, t) {
    return (
      !((!e && !t) || (!e && t) || (e && !t)) &&
      (e === t ||
        !(!e.id || !t.id || e.id !== t.id) ||
        !(
          !e.resolvedUri ||
          !t.resolvedUri ||
          e.resolvedUri !== t.resolvedUri
        ) ||
        !(!e.uri || !t.uri || e.uri !== t.uri))
    );
  }
  function ol(e, t) {
    var n,
      i = (e && e.mediaGroups && e.mediaGroups.AUDIO) || {},
      r = !1;
    for (n in i) {
      for (var a in i[n]) if ((r = t(i[n][a]))) break;
      if (r) break;
    }
    return !!r;
  }
  function ll(n) {
    if (!n || !n.playlists || !n.playlists.length)
      return ol(n, function (e) {
        return (e.playlists && e.playlists.length) || e.uri;
      });
    for (var e = 0; e < n.playlists.length; e++) {
      var t = (function (e) {
        var t = n.playlists[e],
          e = t.attributes && t.attributes.CODECS;
        return (e && e.split(",").every(Or)) ||
          ol(n, function (e) {
            return sl(t, e);
          })
          ? "continue"
          : { v: !1 };
      })(e);
      if ("continue" !== t && "object" == typeof t) return t.v;
    }
    return !0;
  }
  function ul(e, t) {
    return e + "-" + t;
  }
  function cl(r, a) {
    r.mediaGroups &&
      ["AUDIO", "SUBTITLES"].forEach(function (e) {
        if (r.mediaGroups[e])
          for (var t in r.mediaGroups[e])
            for (var n in r.mediaGroups[e][t]) {
              var i = r.mediaGroups[e][t][n];
              a(i, e, t, n);
            }
      });
  }
  function dl(e) {
    var t = e.playlist,
      n = e.uri,
      e = e.id;
    (t.id = e),
      (t.playlistErrors_ = 0),
      n && (t.uri = n),
      (t.attributes = t.attributes || {});
  }
  function hl(o, e) {
    o.uri = e;
    for (var t = 0; t < o.playlists.length; t++)
      o.playlists[t].uri || (o.playlists[t].uri = "placeholder-uri-" + t);
    var n,
      l = ll(o);
    cl(o, function (e, t, n, i) {
      var r = "placeholder-uri-" + t + "-" + n + "-" + i;
      if (!e.playlists || !e.playlists.length) {
        if (l && "AUDIO" === t && !e.uri)
          for (var a = 0; a < o.playlists.length; a++) {
            var s = o.playlists[a];
            if (s.attributes && s.attributes.AUDIO && s.attributes.AUDIO === n)
              return;
          }
        e.playlists = [Q({}, e)];
      }
      e.playlists.forEach(function (e, t) {
        var n = ul(t, r);
        e.uri
          ? (e.resolvedUri = e.resolvedUri || gu(o.uri, e.uri))
          : ((e.uri = 0 === t ? r : n), (e.resolvedUri = e.uri)),
          (e.id = e.id || n),
          (e.attributes = e.attributes || {}),
          (o.playlists[e.id] = e),
          (o.playlists[e.uri] = e);
      });
    }),
      (function (e) {
        for (var t = e.playlists.length; t--; ) {
          var n = e.playlists[t];
          dl({ playlist: n, id: ul(t, n.uri) }),
            (n.resolvedUri = gu(e.uri, n.uri)),
            (e.playlists[n.id] = n),
            (e.playlists[n.uri] = n).attributes.BANDWIDTH ||
              _u.warn(
                "Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute."
              );
        }
      })(o),
      cl((n = o), function (e) {
        e.uri && (e.resolvedUri = gu(n.uri, e.uri));
      });
  }
  function pl(e, t, n) {
    var i = e.slice(),
      r = t.slice();
    n = n || 0;
    for (var a, s = [], o = 0; o < r.length; o++) {
      var l = i[o + n],
        u = r[o];
      l
        ? ((a = l.map || a),
          s.push(
            (function (e, t) {
              if (!e) return t;
              var n = Tu(e, t);
              if (
                (e.preloadHints && !t.preloadHints && delete n.preloadHints,
                e.parts && !t.parts)
              )
                delete n.parts;
              else if (e.parts && t.parts)
                for (var i = 0; i < t.parts.length; i++)
                  e.parts &&
                    e.parts[i] &&
                    (n.parts[i] = Tu(e.parts[i], t.parts[i]));
              return (
                !e.skipped && t.skipped && (n.skipped = !1),
                e.preload && !t.preload && (n.preload = !1),
                n
              );
            })(l, u)
          ))
        : (a && !u.map && (u.map = a), s.push(u));
    }
    return s;
  }
  function ml(e, t) {
    !e.resolvedUri && e.uri && (e.resolvedUri = gu(t, e.uri)),
      e.key && !e.key.resolvedUri && (e.key.resolvedUri = gu(t, e.key.uri)),
      e.map && !e.map.resolvedUri && (e.map.resolvedUri = gu(t, e.map.uri)),
      e.map &&
        e.map.key &&
        !e.map.key.resolvedUri &&
        (e.map.key.resolvedUri = gu(t, e.map.key.uri)),
      e.parts &&
        e.parts.length &&
        e.parts.forEach(function (e) {
          e.resolvedUri || (e.resolvedUri = gu(t, e.uri));
        }),
      e.preloadHints &&
        e.preloadHints.length &&
        e.preloadHints.forEach(function (e) {
          e.resolvedUri || (e.resolvedUri = gu(t, e.uri));
        });
  }
  function fl(e) {
    var t = e.segments || [],
      n = e.preloadSegment;
    if (n && n.parts && n.parts.length) {
      if (n.preloadHints)
        for (var i = 0; i < n.preloadHints.length; i++)
          if ("MAP" === n.preloadHints[i].type) return t;
      (n.duration = e.targetDuration), (n.preload = !0), t.push(n);
    }
    return t;
  }
  function gl(e, t) {
    return (
      e === t ||
      (e.segments &&
        t.segments &&
        e.segments.length === t.segments.length &&
        e.endList === t.endList &&
        e.mediaSequence === t.mediaSequence &&
        e.preloadSegment === t.preloadSegment)
    );
  }
  function bl(e, a, t) {
    void 0 === t && (t = gl);
    var n = Tu(e, {}),
      i = n.playlists[a.id];
    if (!i) return null;
    if (t(i, a)) return null;
    a.segments = fl(a);
    var s = Tu(i, a);
    if (
      (s.preloadSegment && !a.preloadSegment && delete s.preloadSegment,
      i.segments)
    ) {
      if (a.skip) {
        a.segments = a.segments || [];
        for (var r = 0; r < a.skip.skippedSegments; r++)
          a.segments.unshift({ skipped: !0 });
      }
      s.segments = pl(
        i.segments,
        a.segments,
        a.mediaSequence - i.mediaSequence
      );
    }
    s.segments.forEach(function (e) {
      ml(e, s.resolvedUri);
    });
    for (var o = 0; o < n.playlists.length; o++)
      n.playlists[o].id === a.id && (n.playlists[o] = s);
    return (
      (n.playlists[a.id] = s),
      (n.playlists[a.uri] = s),
      cl(e, function (e, t, n, i) {
        if (e.playlists)
          for (var r = 0; r < e.playlists.length; r++)
            a.id === e.playlists[r].id && (e.playlists[r] = s);
      }),
      n
    );
  }
  function vl(e, t) {
    var n = e.segments || [],
      i = n[n.length - 1],
      i =
        ((n = i && i.parts && i.parts[i.parts.length - 1]) && n.duration) ||
        (i && i.duration);
    return t && i
      ? 1e3 * i
      : 500 * (e.partTargetDuration || e.targetDuration || 10);
  }
  function yl(e, t, n, i) {
    var r = "arraybuffer" === e.responseType ? e.response : e.responseText;
    !t &&
      r &&
      ((e.responseTime = Date.now()),
      (e.roundTripTime = e.responseTime - e.requestTime),
      (e.bytesReceived = r.byteLength || r.length),
      e.bandwidth ||
        (e.bandwidth = Math.floor(
          (e.bytesReceived / e.roundTripTime) * 8 * 1e3
        ))),
      n.headers && (e.responseHeaders = n.headers),
      t && "ETIMEDOUT" === t.code && (e.timedout = !0),
      i(
        (t =
          !t &&
          !e.aborted &&
          200 !== n.statusCode &&
          206 !== n.statusCode &&
          0 !== n.statusCode
            ? new Error(
                "XHR Failed with a response of: " + (e && (r || e.responseText))
              )
            : t),
        e
      );
  }
  function _l() {
    function a(e, n) {
      e = Au({ timeout: 45e3 }, e);
      var t = a.beforeRequest || w.Vhs.xhr.beforeRequest;
      !t || "function" != typeof t || ((t = t(e)) && (e = t));
      var i = (!0 === w.Vhs.xhr.original ? Su : w.Vhs.xhr)(e, function (e, t) {
          return yl(i, e, t, n);
        }),
        r = i.abort;
      return (
        (i.abort = function () {
          return (i.aborted = !0), r.apply(i, arguments);
        }),
        (i.uri = e.uri),
        (i.requestTime = Date.now()),
        i
      );
    }
    return (a.original = !0), a;
  }
  function Tl(e) {
    var t,
      n = {};
    return (
      e.byterange &&
        (n.Range =
          ((t = e.byterange),
          (e = t.offset),
          (t =
            "bigint" == typeof t.offset || "bigint" == typeof t.length
              ? window.BigInt(t.offset) +
                window.BigInt(t.length) -
                window.BigInt(1)
              : t.offset + t.length - 1),
          "bytes=" + e + "-" + t)),
      n
    );
  }
  function Ol(e, t) {
    return (
      (e = e.toString(16)),
      "00".substring(0, 2 - e.length) + e + (t % 2 ? " " : "")
    );
  }
  function Sl(e) {
    return 32 <= e && e < 126 ? String.fromCharCode(e) : ".";
  }
  function Al(n) {
    var i = {};
    return (
      Object.keys(n).forEach(function (e) {
        var t = n[e];
        Ir(t)
          ? (i[e] = {
              bytes: t.buffer,
              byteOffset: t.byteOffset,
              byteLength: t.byteLength,
            })
          : (i[e] = t);
      }),
      i
    );
  }
  function wl(e) {
    var t = e.byterange || { length: 1 / 0, offset: 0 };
    return [t.length, t.offset, e.resolvedUri].join(",");
  }
  function Cl(e) {
    return e.resolvedUri;
  }
  function Il(e) {
    for (
      var t = Array.prototype.slice.call(e), n = "", i = 0;
      i < t.length / 16;
      i++
    )
      n +=
        t
          .slice(16 * i, 16 * i + 16)
          .map(Ol)
          .join("") +
        " " +
        t
          .slice(16 * i, 16 * i + 16)
          .map(Sl)
          .join("") +
        "\n";
    return n;
  }
  function xl(e) {
    var t = e.playlist,
      n = e.time,
      i = void 0 === n ? void 0 : n;
    if (!(n = e.callback))
      throw new Error("getProgramTime: callback must be provided");
    return t && void 0 !== i
      ? (e = (function (e, t) {
          if (!t || !t.segments || 0 === t.segments.length) return null;
          for (
            var n, i = 0, r = 0;
            r < t.segments.length &&
            !(
              e <=
              (i = (n = t.segments[r]).videoTimingInfo
                ? n.videoTimingInfo.transmuxedPresentationEnd
                : i + n.duration)
            );
            r++
          );
          var a = t.segments[t.segments.length - 1];
          if (
            a.videoTimingInfo &&
            a.videoTimingInfo.transmuxedPresentationEnd < e
          )
            return null;
          if (i < e) {
            if (e > i + 0.25 * a.duration) return null;
            n = a;
          }
          return {
            segment: n,
            estimatedStart: n.videoTimingInfo
              ? n.videoTimingInfo.transmuxedPresentationStart
              : i - n.duration,
            type: n.videoTimingInfo ? "accurate" : "estimate",
          };
        })(i, t))
        ? "estimate" === e.type
          ? n({
              message:
                "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
              seekTime: e.estimatedStart,
            })
          : ((t = { mediaSeconds: i }),
            (e = (function (e, t) {
              if (!t.dateTimeObject) return null;
              var n = t.videoTimingInfo.transmuxerPrependedSeconds,
                n = e - (t.videoTimingInfo.transmuxedPresentationStart + n);
              return new Date(t.dateTimeObject.getTime() + 1e3 * n);
            })(i, e.segment)) && (t.programDateTime = e.toISOString()),
            n(null, t))
        : n({ message: "valid programTime was not found" })
      : n({ message: "getProgramTime: playlist and time must be provided" });
  }
  function El(e) {
    var t = e.programTime,
      n = e.playlist,
      i = e.retryCount,
      r = void 0 === i ? 2 : i,
      a = e.seekTo,
      s = e.pauseAfterSeek,
      o = void 0 === s || s,
      l = e.tech,
      u = e.callback;
    if (!u) throw new Error("seekToProgramTime: callback must be provided");
    return "undefined" != typeof t && n && a
      ? n.endList || l.hasStarted_
        ? (function (e) {
            if (!e.segments || 0 === e.segments.length) return !1;
            for (var t = 0; t < e.segments.length; t++)
              if (!e.segments[t].dateTimeObject) return !1;
            return !0;
          })(n)
          ? (i = (function (e, t) {
              var n;
              try {
                n = new Date(e);
              } catch (e) {
                return null;
              }
              if (!t || !t.segments || 0 === t.segments.length) return null;
              if (n < (r = t.segments[0]).dateTimeObject) return null;
              for (var i = 0; i < t.segments.length - 1; i++) {
                var r = t.segments[i];
                if (n < t.segments[i + 1].dateTimeObject) break;
              }
              var a,
                s = t.segments[t.segments.length - 1],
                e = s.dateTimeObject,
                a = s.videoTimingInfo
                  ? (a = s.videoTimingInfo).transmuxedPresentationEnd -
                    a.transmuxedPresentationStart -
                    a.transmuxerPrependedSeconds
                  : s.duration + 0.25 * s.duration;
              return new Date(e.getTime() + 1e3 * a) < n
                ? null
                : {
                    segment: (r = e < n ? s : r),
                    estimatedStart: r.videoTimingInfo
                      ? r.videoTimingInfo.transmuxedPresentationStart
                      : yu.duration(t, t.mediaSequence + t.segments.indexOf(r)),
                    type: r.videoTimingInfo ? "accurate" : "estimate",
                  };
            })(t, n))
            ? ((s = i.segment),
              (e = (function (e, t) {
                var n;
                try {
                  (i = new Date(e)), (n = new Date(t));
                } catch (e) {}
                var i = i.getTime();
                return (n.getTime() - i) / 1e3;
              })(s.dateTimeObject, t)),
              "estimate" === i.type
                ? 0 === r
                  ? u({ message: t + " is not buffered yet. Try again" })
                  : (a(i.estimatedStart + e),
                    void l.one("seeked", function () {
                      El({
                        programTime: t,
                        playlist: n,
                        retryCount: r - 1,
                        seekTo: a,
                        pauseAfterSeek: o,
                        tech: l,
                        callback: u,
                      });
                    }))
                : ((e = s.start + e),
                  l.one("seeked", function () {
                    return u(null, l.currentTime());
                  }),
                  o && l.pause(),
                  void a(e)))
            : u({ message: t + " was not found in the stream" })
          : u({
              message:
                "programDateTime tags must be provided in the manifest " +
                n.resolvedUri,
            })
        : u({
            message: "player must be playing a live stream to start buffering",
          })
      : u({
          message:
            "seekToProgramTime: programTime, seekTo and playlist must be provided",
        });
  }
  function kl(e, t) {
    if (4 === e.readyState) return t();
  }
  function Pl(e, t, r) {
    function i(e, t, n, i) {
      return t.abort(), (o = !0), r(e, t, n, i);
    }
    function n(e, t) {
      if (!o) {
        if (e) return i(e, t, "", s);
        var n = t.responseText.substring(
          (s && s.byteLength) || 0,
          t.responseText.length
        );
        if (
          ((s = (function () {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            if (
              (t = t.filter(function (e) {
                return e && (e.byteLength || e.length) && "string" != typeof e;
              })).length <= 1
            )
              return C(t[0]);
            var i = t.reduce(function (e, t, n) {
                return e + (t.byteLength || t.length);
              }, 0),
              r = new Uint8Array(i),
              a = 0;
            return (
              t.forEach(function (e) {
                (e = C(e)), r.set(e, a), (a += e.byteLength);
              }),
              r
            );
          })(s, Er(n, !0))),
          (a = a || io(s)),
          s.length < 10 || (a && s.length < a + 2))
        )
          return kl(t, function () {
            return i(e, t, "", s);
          });
        n = Do(s);
        return ("ts" === n && s.length < 188) || (!n && s.length < 376)
          ? kl(t, function () {
              return i(e, t, "", s);
            })
          : i(null, t, n, s);
      }
    }
    var a,
      s = [],
      o = !1,
      l = t(
        {
          uri: e,
          beforeSend: function (t) {
            t.overrideMimeType("text/plain; charset=x-user-defined"),
              t.addEventListener("progress", function (e) {
                return (
                  e.total, e.loaded, yl(t, null, { statusCode: t.status }, n)
                );
              });
          },
        },
        function (e, t) {
          return yl(l, e, t, n);
        }
      );
    return l;
  }
  function jl(e, t) {
    if (!gl(e, t)) return !1;
    if (
      e.sidx &&
      t.sidx &&
      (e.sidx.offset !== t.sidx.offset || e.sidx.length !== t.sidx.length)
    )
      return !1;
    if ((!e.sidx && t.sidx) || (e.sidx && !t.sidx)) return !1;
    if ((e.segments && !t.segments) || (!e.segments && t.segments)) return !1;
    if (!e.segments && !t.segments) return !0;
    for (var n = 0; n < e.segments.length; n++) {
      var i = e.segments[n],
        r = t.segments[n];
      if (i.uri !== r.uri) return !1;
      if (i.byterange || r.byterange) {
        (i = i.byterange), (r = r.byterange);
        if ((i && !r) || (!i && r)) return !1;
        if (i.offset !== r.offset || i.length !== r.length) return !1;
      }
    }
    return !0;
  }
  function Nl(e, t) {
    var n,
      i = {};
    for (n in e) {
      var r = e[n].sidx;
      if (r) {
        var a = Ns(r);
        if (!t[a]) break;
        var s = t[a].sidxInfo;
        (s = s),
          (r = r),
          (Boolean(!s.map && !r.map) ||
            Boolean(
              s.map &&
                r.map &&
                s.map.byterange.offset === r.map.byterange.offset &&
                s.map.byterange.length === r.map.byterange.length
            )) &&
            s.uri === r.uri &&
            s.byterange.offset === r.byterange.offset &&
            s.byterange.length === r.byterange.length &&
            (i[a] = t[a]);
      }
    }
    return i;
  }
  function Ll(e) {
    return (e.on = e.addEventListener), (e.off = e.removeEventListener), e;
  }
  function Ml(n) {
    var i = n.transmuxer,
      e = n.bytes,
      t = n.audioAppendStart,
      r = n.gopsToAlignWith,
      a = n.remux,
      s = n.onData,
      o = n.onTrackInfo,
      l = n.onAudioTimingInfo,
      u = n.onVideoTimingInfo,
      c = n.onVideoSegmentTimingInfo,
      d = n.onAudioSegmentTimingInfo,
      h = n.onId3,
      p = n.onCaptions,
      m = n.onDone,
      f = n.onEndedTimeline,
      g = n.onTransmuxerLog,
      b = n.isEndOfTimeline,
      v = { buffer: [] },
      y = b;
    (i.onmessage = function (e) {
      var t;
      i.currentTransmux === n &&
        ("data" === e.data.action &&
          (function (e, t, n) {
            var i = e.data.segment,
              r = i.type,
              a = i.initSegment,
              s = i.captions,
              o = i.captionStreams,
              l = i.metadata,
              u = i.videoFrameDtsTime,
              i = i.videoFramePtsTime;
            t.buffer.push({ captions: s, captionStreams: o, metadata: l });
            (e = e.data.segment.boxes || { data: e.data.segment.data }),
              (a = {
                type: r,
                data: new Uint8Array(
                  e.data,
                  e.data.byteOffset,
                  e.data.byteLength
                ),
                initSegment: new Uint8Array(a.data, a.byteOffset, a.byteLength),
              });
            "undefined" != typeof u && (a.videoFrameDtsTime = u),
              "undefined" != typeof i && (a.videoFramePtsTime = i),
              n(a);
          })(e, v, s),
        "trackinfo" === e.data.action && o(e.data.trackInfo),
        "gopInfo" === e.data.action && (v.gopInfo = e.data.gopInfo),
        "audioTimingInfo" === e.data.action && l(e.data.audioTimingInfo),
        "videoTimingInfo" === e.data.action && u(e.data.videoTimingInfo),
        "videoSegmentTimingInfo" === e.data.action &&
          c(e.data.videoSegmentTimingInfo),
        "audioSegmentTimingInfo" === e.data.action &&
          d(e.data.audioSegmentTimingInfo),
        "id3Frame" === e.data.action &&
          h([e.data.id3Frame], e.data.id3Frame.dispatchType),
        "caption" === e.data.action && p(e.data.caption),
        "endedtimeline" === e.data.action && ((y = !1), f()),
        "log" === e.data.action && g(e.data.log),
        "transmuxed" === e.data.type &&
          (y ||
            ((i.onmessage = null),
            (e = (t = { transmuxedData: v, callback: m }).transmuxedData),
            (t = t.callback),
            (e.buffer = []),
            t(e),
            xu(i))));
    }),
      t && i.postMessage({ action: "setAudioAppendStart", appendStart: t }),
      Array.isArray(r) &&
        i.postMessage({ action: "alignGopsWith", gopsToAlignWith: r }),
      "undefined" != typeof a &&
        i.postMessage({ action: "setRemux", remux: a }),
      e.byteLength &&
        ((r = e instanceof ArrayBuffer ? e : e.buffer),
        (a = e instanceof ArrayBuffer ? 0 : e.byteOffset),
        i.postMessage(
          { action: "push", data: r, byteOffset: a, byteLength: e.byteLength },
          [r]
        )),
      b && i.postMessage({ action: "endTimeline" }),
      i.postMessage({ action: "flush" });
  }
  function Dl(e, t) {
    e.postMessage({ action: t }), xu(e);
  }
  function Rl(e, t) {
    if (!t.currentTransmux) return (t.currentTransmux = e), Dl(t, e), 0;
    t.transmuxQueue.push(Dl.bind(null, t, e));
  }
  function Bl(e) {
    if (!e.transmuxer.currentTransmux)
      return (e.transmuxer.currentTransmux = e), void Ml(e);
    e.transmuxer.transmuxQueue.push(e);
  }
  function Ul(n) {
    var i = n.transmuxer,
      r = n.endAction || n.action,
      a = n.callback,
      e = Q({}, n, { endAction: null, transmuxer: null, callback: null }),
      t = function e(t) {
        t.data.action === r &&
          (i.removeEventListener("message", e),
          t.data.data &&
            ((t.data.data = new Uint8Array(
              t.data.data,
              n.byteOffset || 0,
              n.byteLength || t.data.data.byteLength
            )),
            n.data && (n.data = t.data.data)),
          a(t.data));
      };
    i.addEventListener("message", t),
      n.data
        ? ((t = n.data instanceof ArrayBuffer),
          (e.byteOffset = t ? 0 : n.data.byteOffset),
          (e.byteLength = n.data.byteLength),
          (t = [t ? n.data : n.data.buffer]),
          i.postMessage(e, t))
        : i.postMessage(e);
  }
  function Vl(e) {
    e.forEach(function (e) {
      e.abort();
    });
  }
  function Fl(e, t) {
    return t.timedout
      ? {
          status: t.status,
          message: "HLS request timed-out at URL: " + t.uri,
          code: ju,
          xhr: t,
        }
      : t.aborted
      ? {
          status: t.status,
          message: "HLS request aborted at URL: " + t.uri,
          code: Nu,
          xhr: t,
        }
      : e
      ? {
          status: t.status,
          message: "HLS request errored at URL: " + t.uri,
          code: Pu,
          xhr: t,
        }
      : "arraybuffer" === t.responseType && 0 === t.response.byteLength
      ? {
          status: t.status,
          message: "Empty HLS response at URL: " + t.uri,
          code: Pu,
          xhr: t,
        }
      : null;
  }
  function Gl(a, s, o) {
    return function (e, t) {
      var n = t.response,
        e = Fl(e, t);
      if (e) return o(e, a);
      if (16 !== n.byteLength)
        return o(
          {
            status: t.status,
            message: "Invalid HLS key at URL: " + t.uri,
            code: Pu,
            xhr: t,
          },
          a
        );
      for (
        var n = new DataView(n),
          i = new Uint32Array([
            n.getUint32(0),
            n.getUint32(4),
            n.getUint32(8),
            n.getUint32(12),
          ]),
          r = 0;
        r < s.length;
        r++
      )
        s[r].bytes = i;
      return o(null, a);
    };
  }
  function ql(n, i) {
    var e = Do(n.map.bytes);
    if ("mp4" !== e) {
      var t = n.map.resolvedUri || n.map.uri;
      return i({
        internal: !0,
        message:
          "Found unsupported " +
          (e || "unknown") +
          " container for initialization segment at URL: " +
          t,
        code: Pu,
      });
    }
    Ul({
      action: "probeMp4Tracks",
      data: n.map.bytes,
      transmuxer: n.transmuxer,
      callback: function (e) {
        var t = e.tracks,
          e = e.data;
        return (
          (n.map.bytes = e),
          t.forEach(function (e) {
            (n.map.tracks = n.map.tracks || {}),
              n.map.tracks[e.type] ||
                ("number" == typeof (n.map.tracks[e.type] = e).id &&
                  e.timescale &&
                  ((n.map.timescales = n.map.timescales || {}),
                  (n.map.timescales[e.id] = e.timescale)));
          }),
          i(null)
        );
      },
    });
  }
  function zl(e) {
    var n = e.segment,
      i = e.finishProcessingFn,
      r = e.responseType;
    return function (e, t) {
      e = Fl(e, t);
      if (e) return i(e, n);
      e =
        "arraybuffer" !== r && t.responseText
          ? (function (e) {
              for (
                var t = new Uint8Array(new ArrayBuffer(e.length)), n = 0;
                n < e.length;
                n++
              )
                t[n] = e.charCodeAt(n);
              return t.buffer;
            })(t.responseText.substring(n.lastReachedChar || 0))
          : t.response;
      return (
        (n.stats = {
          bandwidth: (t = t).bandwidth,
          bytesReceived: t.bytesReceived || 0,
          roundTripTime: t.roundTripTime || 0,
        }),
        n.key
          ? (n.encryptedBytes = new Uint8Array(e))
          : (n.bytes = new Uint8Array(e)),
        i(null, n)
      );
    };
  }
  function Hl(e) {
    var n = e.segment,
      t = e.bytes,
      i = e.trackInfoFn,
      r = e.timingInfoFn,
      a = e.videoSegmentTimingInfoFn,
      s = e.audioSegmentTimingInfoFn,
      o = e.id3Fn,
      l = e.captionsFn,
      u = e.isEndOfTimeline,
      c = e.endedTimelineFn,
      d = e.dataFn,
      h = e.doneFn,
      p = e.onTransmuxerLog,
      e = (n.map && n.map.tracks) || {},
      m = Boolean(e.audio && e.video),
      f = r.bind(null, n, "audio", "start"),
      g = r.bind(null, n, "audio", "end"),
      b = r.bind(null, n, "video", "start"),
      v = r.bind(null, n, "video", "end");
    Ul({
      action: "probeTs",
      transmuxer: n.transmuxer,
      data: t,
      baseStartTime: n.baseStartTime,
      callback: function (e) {
        n.bytes = t = e.data;
        e = e.result;
        e &&
          (i(n, { hasAudio: e.hasAudio, hasVideo: e.hasVideo, isMuxed: m }),
          (i = null),
          e.hasAudio && !m && f(e.audioStart),
          e.hasVideo && b(e.videoStart),
          (b = f = null)),
          Bl({
            bytes: t,
            transmuxer: n.transmuxer,
            audioAppendStart: n.audioAppendStart,
            gopsToAlignWith: n.gopsToAlignWith,
            remux: m,
            onData: function (e) {
              (e.type = "combined" === e.type ? "video" : e.type), d(n, e);
            },
            onTrackInfo: function (e) {
              i && (m && (e.isMuxed = !0), i(n, e));
            },
            onAudioTimingInfo: function (e) {
              f && "undefined" != typeof e.start && (f(e.start), (f = null)),
                g && "undefined" != typeof e.end && g(e.end);
            },
            onVideoTimingInfo: function (e) {
              b && "undefined" != typeof e.start && (b(e.start), (b = null)),
                v && "undefined" != typeof e.end && v(e.end);
            },
            onVideoSegmentTimingInfo: function (e) {
              a(e);
            },
            onAudioSegmentTimingInfo: function (e) {
              s(e);
            },
            onId3: function (e, t) {
              o(n, e, t);
            },
            onCaptions: function (e) {
              l(n, [e]);
            },
            isEndOfTimeline: u,
            onEndedTimeline: function () {
              c();
            },
            onTransmuxerLog: p,
            onDone: function (e) {
              h &&
                ((e.type = "combined" === e.type ? "video" : e.type),
                h(null, n, e));
            },
          });
      },
    });
  }
  function Wl(e) {
    var n = e.segment,
      i = e.bytes,
      t = e.trackInfoFn,
      r = e.timingInfoFn,
      a = e.videoSegmentTimingInfoFn,
      s = e.audioSegmentTimingInfoFn,
      o = e.id3Fn,
      l = e.captionsFn,
      u = e.isEndOfTimeline,
      c = e.endedTimelineFn,
      d = e.dataFn,
      h = e.doneFn,
      p = e.onTransmuxerLog,
      m = new Uint8Array(i);
    if (0 < ao(m, ["moof"]).length) {
      n.isFmp4 = !0;
      var f = n.map.tracks,
        g = { isFmp4: !0, hasVideo: !!f.video, hasAudio: !!f.audio };
      f.audio &&
        f.audio.codec &&
        "enca" !== f.audio.codec &&
        (g.audioCodec = f.audio.codec),
        f.video &&
          f.video.codec &&
          "encv" !== f.video.codec &&
          (g.videoCodec = f.video.codec),
        f.video && f.audio && (g.isMuxed = !0),
        t(n, g);
      var b = function (e) {
        d(n, { data: m, type: g.hasAudio && !g.isMuxed ? "audio" : "video" }),
          e && e.length && l(n, e),
          h(null, n, {});
      };
      Ul({
        action: "probeMp4StartTime",
        timescales: n.map.timescales,
        data: m,
        transmuxer: n.transmuxer,
        callback: function (e) {
          var t = e.data,
            e = e.startTime;
          (i = t.buffer),
            (n.bytes = m = t),
            g.hasAudio && !g.isMuxed && r(n, "audio", "start", e),
            g.hasVideo && r(n, "video", "start", e),
            f.video && t.byteLength && n.transmuxer
              ? Ul({
                  action: "pushMp4Captions",
                  endAction: "mp4Captions",
                  transmuxer: n.transmuxer,
                  data: m,
                  timescales: n.map.timescales,
                  trackIds: [f.video.id],
                  callback: function (e) {
                    (i = e.data.buffer),
                      (n.bytes = m = e.data),
                      e.logs.forEach(function (e) {
                        p(w.mergeOptions(e, { stream: "mp4CaptionParser" }));
                      }),
                      b(e.captions);
                  },
                })
              : b();
        },
      });
    } else if (n.transmuxer) {
      if (
        ("undefined" == typeof n.container && (n.container = Do(m)),
        "ts" !== n.container && "aac" !== n.container)
      )
        return t(n, { hasAudio: !1, hasVideo: !1 }), h(null, n, {}), 0;
      Hl({
        segment: n,
        bytes: i,
        trackInfoFn: t,
        timingInfoFn: r,
        videoSegmentTimingInfoFn: a,
        audioSegmentTimingInfoFn: s,
        id3Fn: o,
        captionsFn: l,
        isEndOfTimeline: u,
        endedTimelineFn: c,
        dataFn: d,
        doneFn: h,
        onTransmuxerLog: p,
      });
    } else h(null, n, {});
  }
  function Xl(e, n) {
    var i = e.id,
      t = e.key,
      r = e.encryptedBytes,
      a = e.decryptionWorker,
      e = function e(t) {
        t.data.source === i &&
          (a.removeEventListener("message", e),
          (t = t.data.decrypted),
          n(new Uint8Array(t.bytes, t.byteOffset, t.byteLength)));
      };
    a.addEventListener("message", e),
      (e = t.bytes.slice
        ? t.bytes.slice()
        : new Uint32Array(Array.prototype.slice.call(t.bytes))),
      a.postMessage(Al({ source: i, encrypted: r, key: e, iv: t.iv }), [
        r.buffer,
        e.buffer,
      ]);
  }
  function Yl(e) {
    var n = e.activeXhrs,
      f = e.decryptionWorker,
      g = e.trackInfoFn,
      b = e.timingInfoFn,
      v = e.videoSegmentTimingInfoFn,
      y = e.audioSegmentTimingInfoFn,
      _ = e.id3Fn,
      T = e.captionsFn,
      O = e.isEndOfTimeline,
      S = e.endedTimelineFn,
      A = e.dataFn,
      w = e.doneFn,
      C = e.onTransmuxerLog,
      i = 0,
      r = !1;
    return function (e, m) {
      if (!r) {
        if (e) return (r = !0), Vl(n), w(e, m);
        if ((i += 1) === n.length) {
          var t = function () {
            if (m.encryptedBytes)
              return (
                (t = (e = {
                  decryptionWorker: f,
                  segment: m,
                  trackInfoFn: g,
                  timingInfoFn: b,
                  videoSegmentTimingInfoFn: v,
                  audioSegmentTimingInfoFn: y,
                  id3Fn: _,
                  captionsFn: T,
                  isEndOfTimeline: O,
                  endedTimelineFn: S,
                  dataFn: A,
                  doneFn: w,
                  onTransmuxerLog: C,
                }).decryptionWorker),
                (n = e.segment),
                (i = e.trackInfoFn),
                (r = e.timingInfoFn),
                (a = e.videoSegmentTimingInfoFn),
                (s = e.audioSegmentTimingInfoFn),
                (o = e.id3Fn),
                (l = e.captionsFn),
                (u = e.isEndOfTimeline),
                (c = e.endedTimelineFn),
                (d = e.dataFn),
                (h = e.doneFn),
                (p = e.onTransmuxerLog),
                void Xl(
                  {
                    id: n.requestId,
                    key: n.key,
                    encryptedBytes: n.encryptedBytes,
                    decryptionWorker: t,
                  },
                  function (e) {
                    (n.bytes = e),
                      Wl({
                        segment: n,
                        bytes: n.bytes,
                        trackInfoFn: i,
                        timingInfoFn: r,
                        videoSegmentTimingInfoFn: a,
                        audioSegmentTimingInfoFn: s,
                        id3Fn: o,
                        captionsFn: l,
                        isEndOfTimeline: u,
                        endedTimelineFn: c,
                        dataFn: d,
                        doneFn: h,
                        onTransmuxerLog: p,
                      });
                  }
                )
              );
            var e, t, n, i, r, a, s, o, l, u, c, d, h, p;
            Wl({
              segment: m,
              bytes: m.bytes,
              trackInfoFn: g,
              timingInfoFn: b,
              videoSegmentTimingInfoFn: v,
              audioSegmentTimingInfoFn: y,
              id3Fn: _,
              captionsFn: T,
              isEndOfTimeline: O,
              endedTimelineFn: S,
              dataFn: A,
              doneFn: w,
              onTransmuxerLog: C,
            });
          };
          if (
            ((m.endOfAllRequests = Date.now()),
            m.map && m.map.encryptedBytes && !m.map.bytes)
          )
            return Xl(
              {
                decryptionWorker: f,
                id: m.requestId + "-init",
                encryptedBytes: m.map.encryptedBytes,
                key: m.map.key,
              },
              function (e) {
                (m.map.bytes = e),
                  ql(m, function (e) {
                    return e ? (Vl(n), w(e, m)) : void t();
                  });
              }
            );
          t();
        }
      }
    };
  }
  function Kl(e) {
    var i = e.segment,
      r = e.progressFn;
    return (
      e.trackInfoFn,
      e.timingInfoFn,
      e.videoSegmentTimingInfoFn,
      e.audioSegmentTimingInfoFn,
      e.id3Fn,
      e.captionsFn,
      e.isEndOfTimeline,
      e.endedTimelineFn,
      e.dataFn,
      function (e) {
        var t,
          n = e.target;
        if (!n.aborted)
          return (
            (i.stats = w.mergeOptions(
              i.stats,
              ((n = (t = e).target),
              ((n = {
                bandwidth: 1 / 0,
                bytesReceived: 0,
                roundTripTime: Date.now() - n.requestTime || 0,
              }).bytesReceived = t.loaded),
              (n.bandwidth = Math.floor(
                (n.bytesReceived / n.roundTripTime) * 8 * 1e3
              )),
              n)
            )),
            !i.stats.firstBytesReceivedAt &&
              i.stats.bytesReceived &&
              (i.stats.firstBytesReceivedAt = Date.now()),
            r(e, i)
          );
      }
    );
  }
  function Ql(e) {
    var t,
      n,
      i,
      r = e.xhr,
      a = e.xhrOptions,
      s = e.decryptionWorker,
      o = e.segment,
      l = e.abortFn,
      u = e.progressFn,
      c = e.trackInfoFn,
      d = e.timingInfoFn,
      h = e.videoSegmentTimingInfoFn,
      p = e.audioSegmentTimingInfoFn,
      m = e.id3Fn,
      f = e.captionsFn,
      g = e.isEndOfTimeline,
      b = e.endedTimelineFn,
      v = e.dataFn,
      y = e.doneFn,
      e = e.onTransmuxerLog,
      _ = [],
      y = Yl({
        activeXhrs: _,
        decryptionWorker: s,
        trackInfoFn: c,
        timingInfoFn: d,
        videoSegmentTimingInfoFn: h,
        audioSegmentTimingInfoFn: p,
        id3Fn: m,
        captionsFn: f,
        isEndOfTimeline: g,
        endedTimelineFn: b,
        dataFn: v,
        doneFn: y,
        onTransmuxerLog: e,
      });
    o.key &&
      !o.key.bytes &&
      ((e = [o.key]),
      o.map &&
        !o.map.bytes &&
        o.map.key &&
        o.map.key.resolvedUri === o.key.resolvedUri &&
        e.push(o.map.key),
      (e = r(
        w.mergeOptions(a, {
          uri: o.key.resolvedUri,
          responseType: "arraybuffer",
        }),
        Gl(o, e, y)
      )),
      _.push(e)),
      o.map &&
        !o.map.bytes &&
        (!o.map.key ||
          (o.key && o.key.resolvedUri === o.map.key.resolvedUri) ||
          ((t = r(
            w.mergeOptions(a, {
              uri: o.map.key.resolvedUri,
              responseType: "arraybuffer",
            }),
            Gl(o, [o.map.key], y)
          )),
          _.push(t)),
        (t = r(
          w.mergeOptions(a, {
            uri: o.map.resolvedUri,
            responseType: "arraybuffer",
            headers: Tl(o.map),
          }),
          ((n = (t = { segment: o, finishProcessingFn: y }).segment),
          (i = t.finishProcessingFn),
          function (e, t) {
            e = Fl(e, t);
            if (e) return i(e, n);
            e = new Uint8Array(t.response);
            if (n.map.key) return (n.map.encryptedBytes = e), i(null, n);
            (n.map.bytes = e),
              ql(n, function (e) {
                return e
                  ? ((e.xhr = t), (e.status = t.status), i(e, n))
                  : void i(null, n);
              });
          })
        )),
        _.push(t)),
      (a = w.mergeOptions(a, {
        uri: (o.part && o.part.resolvedUri) || o.resolvedUri,
        responseType: "arraybuffer",
        headers: Tl(o),
      })),
      (a = r(
        a,
        zl({ segment: o, finishProcessingFn: y, responseType: a.responseType })
      )).addEventListener(
        "progress",
        Kl({
          segment: o,
          progressFn: u,
          trackInfoFn: c,
          timingInfoFn: d,
          videoSegmentTimingInfoFn: h,
          audioSegmentTimingInfoFn: p,
          id3Fn: m,
          captionsFn: f,
          isEndOfTimeline: g,
          endedTimelineFn: b,
          dataFn: v,
        })
      ),
      _.push(a);
    var T = {};
    return (
      _.forEach(function (e) {
        var t, n;
        e.addEventListener(
          "loadend",
          ((t = (e = { loadendState: T, abortFn: l }).loadendState),
          (n = e.abortFn),
          function (e) {
            e.target.aborted &&
              n &&
              !t.calledAbortFn &&
              (n(), (t.calledAbortFn = !0));
          })
        );
      }),
      function () {
        return Vl(_);
      }
    );
  }
  function Zl(e, t) {
    return (
      (t = t.attributes || {}),
      e &&
        e.mediaGroups &&
        e.mediaGroups.AUDIO &&
        t.AUDIO &&
        e.mediaGroups.AUDIO[t.AUDIO]
    );
  }
  function Jl(e) {
    var i = {};
    return (
      e.forEach(function (e) {
        var t = e.mediaType,
          n = e.type,
          e = e.details;
        (i[t] = i[t] || []), i[t].push(_r("" + n + e));
      }),
      Object.keys(i).forEach(function (e) {
        return 1 < i[e].length
          ? (Lu(
              "multiple " +
                e +
                " codecs found as attributes: " +
                i[e].join(", ") +
                ". Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs."
            ),
            void (i[e] = null))
          : void (i[e] = i[e][0]);
      }),
      i
    );
  }
  function $l(e) {
    var t = 0;
    return e.audio && t++, e.video && t++, t;
  }
  function eu(e, t) {
    var n,
      i = t.attributes || {},
      r = Jl(
        (function (e) {
          e = e.attributes || {};
          if (e.CODECS) return Tr(e.CODECS);
        })(t) || []
      );
    return (
      Zl(e, t) &&
        !r.audio &&
        !(function (e, t) {
          if (!Zl(e, t)) return !0;
          var n,
            t = t.attributes || {},
            i = e.mediaGroups.AUDIO[t.AUDIO];
          for (n in i) if (!i[n].uri && !i[n].playlists) return !0;
          return !1;
        })(e, t) &&
        (n = Jl(
          (function (e, t) {
            if (!e.mediaGroups.AUDIO || !t) return null;
            var n,
              i = e.mediaGroups.AUDIO[t];
            if (!i) return null;
            for (n in i) {
              var r = i[n];
              if (r.default && r.playlists)
                return Tr(r.playlists[0].attributes.CODECS);
            }
            return null;
          })(e, i.AUDIO) || []
        )).audio &&
        (r.audio = n.audio),
      r
    );
  }
  function tu(e) {
    if (e && e.playlist) {
      var t = e.playlist;
      return JSON.stringify({
        id: t.id,
        bandwidth: e.bandwidth,
        width: e.width,
        height: e.height,
        codecs: (t.attributes && t.attributes.CODECS) || "",
      });
    }
  }
  function nu(e, t) {
    return (e = e && window.getComputedStyle(e)) ? e[t] : "";
  }
  function iu(e, i) {
    var r = e.slice();
    e.sort(function (e, t) {
      var n = i(e, t);
      return 0 === n ? r.indexOf(e) - r.indexOf(t) : n;
    });
  }
  function ru(e, t) {
    var n, i;
    return (
      (n =
        (n = e.attributes.BANDWIDTH ? e.attributes.BANDWIDTH : n) ||
        window.Number.MAX_VALUE) -
      (i =
        (i = t.attributes.BANDWIDTH ? t.attributes.BANDWIDTH : i) ||
        window.Number.MAX_VALUE)
    );
  }
  function au(e, t, n, i, r, a) {
    if (e) {
      var s = {
          bandwidth: t,
          width: n,
          height: i,
          limitRenditionByPlayerDimensions: r,
        },
        o = e.playlists;
      yu.isAudioOnly(e) &&
        ((o = a.getAudioTrackPlaylists_()), (s.audioOnly = !0));
      var l = o.map(function (e) {
        var t =
            e.attributes &&
            e.attributes.RESOLUTION &&
            e.attributes.RESOLUTION.width,
          n =
            e.attributes &&
            e.attributes.RESOLUTION &&
            e.attributes.RESOLUTION.height,
          i = e.attributes && e.attributes.BANDWIDTH;
        return {
          bandwidth: i || window.Number.MAX_VALUE,
          width: t,
          height: n,
          playlist: e,
        };
      });
      iu(l, function (e, t) {
        return e.bandwidth - t.bandwidth;
      });
      var u = (l = l.filter(function (e) {
          return !yu.isIncompatible(e.playlist);
        })).filter(function (e) {
          return yu.isEnabled(e.playlist);
        }),
        e = (u = !u.length
          ? l.filter(function (e) {
              return !yu.isDisabled(e.playlist);
            })
          : u).filter(function (e) {
          return e.bandwidth * L.BANDWIDTH_VARIANCE < t;
        }),
        c = e[e.length - 1],
        o = e.filter(function (e) {
          return e.bandwidth === c.bandwidth;
        })[0];
      if (!1 === r) {
        var d = o || u[0] || l[0];
        if (d && d.playlist) {
          r = o ? "bandwidthBestRep" : "sortedPlaylistReps";
          return (
            u[0] && (r = "enabledPlaylistReps"),
            Mu("choosing " + tu(d) + " using " + r + " with options", s),
            d.playlist
          );
        }
        return Mu("could not choose a playlist with options", s), null;
      }
      d = e.filter(function (e) {
        return e.width && e.height;
      });
      iu(d, function (e, t) {
        return e.width - t.width;
      });
      var h,
        p,
        m,
        e = d.filter(function (e) {
          return e.width === n && e.height === i;
        }),
        c = e[e.length - 1],
        e = e.filter(function (e) {
          return e.bandwidth === c.bandwidth;
        })[0];
      e ||
        ((p = (h = d.filter(function (e) {
          return e.width > n || e.height > i;
        })).filter(function (e) {
          return e.width === h[0].width && e.height === h[0].height;
        })),
        (c = p[p.length - 1]),
        (p = p.filter(function (e) {
          return e.bandwidth === c.bandwidth;
        })[0])),
        a.experimentalLeastPixelDiffSelector &&
          ((f = d.map(function (e) {
            return (
              (e.pixelDiff = Math.abs(e.width - n) + Math.abs(e.height - i)), e
            );
          })),
          iu(f, function (e, t) {
            return e.pixelDiff === t.pixelDiff
              ? t.bandwidth - e.bandwidth
              : e.pixelDiff - t.pixelDiff;
          }),
          (m = f[0]));
      var f = m || p || e || o || u[0] || l[0];
      if (f && f.playlist) {
        l = "sortedPlaylistReps";
        return (
          m
            ? (l = "leastPixelDiffRep")
            : p
            ? (l = "resolutionPlusOneRep")
            : e
            ? (l = "resolutionBestRep")
            : o
            ? (l = "bandwidthBestRep")
            : u[0] && (l = "enabledPlaylistReps"),
          Mu("choosing " + tu(f) + " using " + l + " with options", s),
          f.playlist
        );
      }
      return Mu("could not choose a playlist with options", s), null;
    }
  }
  function su(e) {
    var t = e.inbandTextTracks,
      n = e.metadataArray,
      r = e.timestampOffset,
      i = e.videoDuration;
    if (n) {
      var a = window.WebKitDataCue || window.VTTCue,
        s = t.metadataTrack_;
      if (
        s &&
        (n.forEach(function (e) {
          var i = e.cueTime + r;
          !("number" != typeof i || window.isNaN(i) || i < 0) &&
            i < 1 / 0 &&
            e.frames.forEach(function (e) {
              var t,
                n = new a(i, i, e.value || e.url || e.data || "");
              (n.frame = e),
                (n.value = e),
                (t = n),
                Object.defineProperties(t.frame, {
                  id: {
                    get: function () {
                      return (
                        w.log.warn(
                          "cue.frame.id is deprecated. Use cue.value.key instead."
                        ),
                        t.value.key
                      );
                    },
                  },
                  value: {
                    get: function () {
                      return (
                        w.log.warn(
                          "cue.frame.value is deprecated. Use cue.value.data instead."
                        ),
                        t.value.data
                      );
                    },
                  },
                  privateData: {
                    get: function () {
                      return (
                        w.log.warn(
                          "cue.frame.privateData is deprecated. Use cue.value.data instead."
                        ),
                        t.value.data
                      );
                    },
                  },
                }),
                s.addCue(n);
            });
        }),
        s.cues && s.cues.length)
      ) {
        for (var o = s.cues, l = [], u = 0; u < o.length; u++)
          o[u] && l.push(o[u]);
        var c = l.reduce(function (e, t) {
            var n = e[t.startTime] || [];
            return n.push(t), (e[t.startTime] = n), e;
          }, {}),
          d = Object.keys(c).sort(function (e, t) {
            return Number(e) - Number(t);
          });
        d.forEach(function (e, t) {
          var e = c[e],
            n = Number(d[t + 1]) || i;
          e.forEach(function (e) {
            e.endTime = n;
          });
        });
      }
    }
  }
  function ou(e, t, n) {
    var i, r;
    if (n && n.cues)
      for (i = n.cues.length; i--; )
        (r = n.cues[i]).startTime >= e && r.endTime <= t && n.removeCue(r);
  }
  function lu(e) {
    return "number" == typeof e && isFinite(e);
  }
  function uu(e) {
    var t = e.startOfSegment,
      n = e.duration,
      i = e.segment,
      r = e.part,
      a = e.playlist,
      s = a.mediaSequence,
      o = a.id,
      l = a.segments,
      u = e.mediaIndex,
      c = e.partIndex,
      d = e.timeline,
      h = (void 0 === l ? [] : l).length - 1,
      p = "mediaIndex/partIndex increment";
    return (
      e.getMediaInfoForTime
        ? (p = "getMediaInfoForTime (" + e.getMediaInfoForTime + ")")
        : e.isSyncRequest && (p = "getSyncSegmentCandidate (isSyncRequest)"),
      e.independent && (p += " with independent " + e.independent),
      (a = "number" == typeof c),
      (l = e.segment.uri ? "segment" : "pre-segment"),
      (e = a ? Ko({ preloadSegment: i }) - 1 : 0),
      l +
        " [" +
        (s + u) +
        "/" +
        (s + h) +
        "]" +
        (a ? " part [" + c + "/" + e + "]" : "") +
        " segment start/end [" +
        i.start +
        " => " +
        i.end +
        "]" +
        (a ? " part start/end [" + r.start + " => " + r.end + "]" : "") +
        " startOfSegment [" +
        t +
        "] duration [" +
        n +
        "] timeline [" +
        d +
        "] selected by [" +
        p +
        "] playlist [" +
        o +
        "]"
    );
  }
  function cu(e) {
    return e + "TimingInfo";
  }
  function du(e) {
    var t = e.timelineChangeController,
      n = e.currentTimeline,
      i = e.segmentTimeline,
      r = e.loaderType,
      e = e.audioDisabled;
    if (n !== i) {
      if ("audio" === r) {
        n = t.lastTimelineChange({ type: "main" });
        return !n || n.to !== i;
      }
      if ("main" === r && e) {
        t = t.pendingTimelineChange({ type: "audio" });
        return t && t.to === i ? !1 : !0;
      }
    }
  }
  function hu(e) {
    var t = e.segmentDuration,
      e = e.maxDuration;
    return !!t && Math.round(t) > e + bu;
  }
  function pu(e, t) {
    if ("hls" !== t) return null;
    var i,
      r,
      n =
        ((i = {
          audioTimingInfo: e.audioTimingInfo,
          videoTimingInfo: e.videoTimingInfo,
        }),
        (r = 0),
        ["video", "audio"].forEach(function (e) {
          var t,
            n = i[e + "TimingInfo"];
          n &&
            ((e = n.start),
            (n = n.end),
            "bigint" == typeof e || "bigint" == typeof n
              ? (t = window.BigInt(n) - window.BigInt(e))
              : "number" == typeof e && "number" == typeof n && (t = n - e),
            "undefined" != typeof t && r < t && (r = t));
        }),
        (r =
          "bigint" == typeof r && r < Number.MAX_SAFE_INTEGER ? Number(r) : r));
    if (!n) return null;
    var a = e.playlist.targetDuration,
      s = hu({ segmentDuration: n, maxDuration: 2 * a }),
      t = hu({ segmentDuration: n, maxDuration: a }),
      a =
        "Segment with index " +
        e.mediaIndex +
        " from playlist " +
        e.playlist.id +
        " has a duration of " +
        n +
        " when the reported duration is " +
        e.duration +
        " and the target duration is " +
        a +
        ". For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1";
    return s || t ? { severity: s ? "warn" : "info", message: a } : null;
  }
  var mu = Lo,
    fu = 9e4,
    gu = function (e, t) {
      if (/^[a-z]+:/i.test(t)) return t;
      /^data:/.test(e) && (e = (window.location && window.location.href) || "");
      var n = "function" == typeof window.URL,
        i = /^\/\//.test(e),
        r = !window.location && !/\/\//i.test(e);
      if (
        (n
          ? (e = new window.URL(e, window.location || pr))
          : /\/\//i.test(e) ||
            (e = hr.buildAbsoluteURL(
              (window.location && window.location.href) || "",
              e
            )),
        n)
      ) {
        n = new URL(t, e);
        return r
          ? n.href.slice(pr.length)
          : i
          ? n.href.slice(n.protocol.length)
          : n.href;
      }
      return hr.buildAbsoluteURL(e, t);
    },
    bu = 1 / 30,
    vu = w.createTimeRange,
    yu = {
      liveEdgeDelay: Qo,
      duration: Jo,
      seekable: function (e, t, n) {
        var i = t || 0,
          n = el(e, t, !0, n);
        return null === n ? vu() : vu(i, n);
      },
      getMediaInfoForTime: function (e) {
        for (
          var t = e.playlist,
            n = e.currentTime,
            i = e.startingSegmentIndex,
            r = e.startingPartIndex,
            a = e.startTime,
            s = e.experimentalExactManifestTimings,
            o = n - a,
            l = Xo(t),
            u = 0,
            c = 0;
          c < l.length;
          c++
        ) {
          var d = l[c];
          if (
            i === d.segmentIndex &&
            ("number" != typeof r ||
              "number" != typeof d.partIndex ||
              r === d.partIndex)
          ) {
            u = c;
            break;
          }
        }
        if (o < 0) {
          if (0 < u)
            for (var h = u - 1; 0 <= h; h--) {
              var p = l[h];
              if (((o += p.duration), s)) {
                if (o < 0) continue;
              } else if (o + bu <= 0) continue;
              return {
                partIndex: p.partIndex,
                segmentIndex: p.segmentIndex,
                startTime:
                  a -
                  $o({
                    defaultDuration: t.targetDuration,
                    durationList: l,
                    startIndex: u,
                    endIndex: h,
                  }),
              };
            }
          return {
            partIndex: (l[0] && l[0].partIndex) || null,
            segmentIndex: (l[0] && l[0].segmentIndex) || 0,
            startTime: n,
          };
        }
        if (u < 0) {
          for (var m = u; m < 0; m++)
            if ((o -= t.targetDuration) < 0)
              return {
                partIndex: (l[0] && l[0].partIndex) || null,
                segmentIndex: (l[0] && l[0].segmentIndex) || 0,
                startTime: n,
              };
          u = 0;
        }
        for (var f = u; f < l.length; f++) {
          var g = l[f];
          if (((o -= g.duration), s)) {
            if (0 < o) continue;
          } else if (0 <= o - bu) continue;
          return {
            partIndex: g.partIndex,
            segmentIndex: g.segmentIndex,
            startTime:
              a +
              $o({
                defaultDuration: t.targetDuration,
                durationList: l,
                startIndex: u,
                endIndex: f,
              }),
          };
        }
        return {
          segmentIndex: l[l.length - 1].segmentIndex,
          partIndex: l[l.length - 1].partIndex,
          startTime: n,
        };
      },
      isEnabled: il,
      isDisabled: function (e) {
        return e.disabled;
      },
      isBlacklisted: tl,
      isIncompatible: nl,
      playlistEnd: el,
      isAes: function (e) {
        for (var t = 0; t < e.segments.length; t++)
          if (e.segments[t].key) return !0;
        return !1;
      },
      hasAttribute: rl,
      estimateSegmentRequestTime: function (e, t, n, i) {
        return rl("BANDWIDTH", n)
          ? (e * n.attributes.BANDWIDTH - 8 * (i = void 0 === i ? 0 : i)) / t
          : NaN;
      },
      isLowestEnabledRendition: al,
      isAudioOnly: ll,
      playlistMatch: sl,
      segmentDurationWithParts: Wo,
    },
    _u = w.log,
    Tu = w.mergeOptions,
    s = w.EventTarget,
    Ou = (function (a) {
      function e(e, t, n) {
        var i;
        if ((void 0 === n && (n = {}), (i = a.call(this) || this), !e))
          throw new Error("A non-empty playlist URL or object is required");
        i.logger_ = Bo("PlaylistLoader");
        var r = n.withCredentials,
          r = void 0 !== r && r,
          n = n.handleManifestRedirects,
          n = void 0 !== n && n;
        (i.src = e),
          (i.vhs_ = t),
          (i.withCredentials = r),
          (i.handleManifestRedirects = n);
        t = t.options_;
        return (
          (i.customTagParsers = (t && t.customTagParsers) || []),
          (i.customTagMappers = (t && t.customTagMappers) || []),
          (i.experimentalLLHLS = (t && t.experimentalLLHLS) || !1),
          w.browser.IE_VERSION && (i.experimentalLLHLS = !1),
          (i.state = "HAVE_NOTHING"),
          (i.handleMediaupdatetimeout_ = i.handleMediaupdatetimeout_.bind(
            y(i)
          )),
          i.on("mediaupdatetimeout", i.handleMediaupdatetimeout_),
          i
        );
      }
      b(e, a);
      var t = e.prototype;
      return (
        (t.handleMediaupdatetimeout_ = function () {
          var e,
            t,
            n = this;
          "HAVE_METADATA" === this.state &&
            ((e = this.media()),
            (t = gu(this.master.uri, e.uri)),
            this.experimentalLLHLS &&
              (t = (function (e, t) {
                if (t.endList || !t.serverControl) return e;
                var n,
                  i,
                  r,
                  a,
                  s = {};
                return (
                  t.serverControl.canBlockReload &&
                    ((r = t.preloadSegment),
                    (n = t.mediaSequence + t.segments.length),
                    r &&
                      ((i = r.parts || []),
                      -1 < (r = Ko(t) - 1) &&
                        r != i.length - 1 &&
                        (s._HLS_part = r),
                      (-1 < r || i.length) && n--),
                    (s._HLS_msn = n)),
                  t.serverControl &&
                    t.serverControl.canSkipUntil &&
                    (s._HLS_skip = t.serverControl.canSkipDateranges
                      ? "v2"
                      : "YES"),
                  Object.keys(s).length &&
                    ((a = new window.URL(e)),
                    ["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach(function (
                      e
                    ) {
                      s.hasOwnProperty(e) && a.searchParams.set(e, s[e]);
                    }),
                    (e = a.toString())),
                  e
                );
              })(t, e)),
            (this.state = "HAVE_CURRENT_METADATA"),
            (this.request = this.vhs_.xhr(
              { uri: t, withCredentials: this.withCredentials },
              function (e, t) {
                if (n.request)
                  return e
                    ? n.playlistRequestError(
                        n.request,
                        n.media(),
                        "HAVE_METADATA"
                      )
                    : void n.haveMetadata({
                        playlistString: n.request.responseText,
                        url: n.media().uri,
                        id: n.media().id,
                      });
              }
            )));
        }),
        (t.playlistRequestError = function (e, t, n) {
          var i = t.uri,
            t = t.id;
          (this.request = null),
            n && (this.state = n),
            (this.error = {
              playlist: this.master.playlists[t],
              status: e.status,
              message: "HLS playlist request error at URL: " + i + ".",
              responseText: e.responseText,
              code: 500 <= e.status ? 4 : 2,
            }),
            this.trigger("error");
        }),
        (t.parseManifest_ = function (e) {
          var t = this,
            n = e.url;
          return (function (e) {
            var t = e.onwarn,
              n = e.oninfo,
              i = e.manifestString,
              r = e.customTagParsers,
              a = void 0 === r ? [] : r,
              r = e.customTagMappers,
              r = void 0 === r ? [] : r,
              e = e.experimentalLLHLS,
              s = new Lr();
            t && s.on("warn", t),
              n && s.on("info", n),
              a.forEach(function (e) {
                return s.addParser(e);
              }),
              r.forEach(function (e) {
                return s.addTagMapper(e);
              }),
              s.push(i),
              s.end();
            var o = s.manifest;
            e ||
              ([
                "preloadSegment",
                "skip",
                "serverControl",
                "renditionReports",
                "partInf",
                "partTargetDuration",
              ].forEach(function (e) {
                o.hasOwnProperty(e) && delete o[e];
              }),
              o.segments &&
                o.segments.forEach(function (t) {
                  ["parts", "preloadHints"].forEach(function (e) {
                    t.hasOwnProperty(e) && delete t[e];
                  });
                })),
              o.targetDuration ||
                ((l = 10),
                o.segments &&
                  o.segments.length &&
                  (l = o.segments.reduce(function (e, t) {
                    return Math.max(e, t.duration);
                  }, 0)),
                t && t("manifest has no targetDuration defaulting to " + l),
                (o.targetDuration = l));
            var l = Yo(o);
            return (
              l.length &&
                !o.partTargetDuration &&
                ((l = l.reduce(function (e, t) {
                  return Math.max(e, t.duration);
                }, 0)),
                t &&
                  (t("manifest has no partTargetDuration defaulting to " + l),
                  _u.error(
                    "LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed."
                  )),
                (o.partTargetDuration = l)),
              o
            );
          })({
            onwarn: function (e) {
              e = e.message;
              return t.logger_("m3u8-parser warn for " + n + ": " + e);
            },
            oninfo: function (e) {
              e = e.message;
              return t.logger_("m3u8-parser info for " + n + ": " + e);
            },
            manifestString: e.manifestString,
            customTagParsers: this.customTagParsers,
            customTagMappers: this.customTagMappers,
            experimentalLLHLS: this.experimentalLLHLS,
          });
        }),
        (t.haveMetadata = function (e) {
          var t = e.playlistString,
            n = e.playlistObject,
            i = e.url,
            e = e.id;
          (this.request = null), (this.state = "HAVE_METADATA");
          t = n || this.parseManifest_({ url: i, manifestString: t });
          (t.lastRequest = Date.now()), dl({ playlist: t, uri: i, id: e });
          i = bl(this.master, t);
          (this.targetDuration = t.partTargetDuration || t.targetDuration),
            (this.pendingMedia_ = null),
            i
              ? ((this.master = i), (this.media_ = this.master.playlists[e]))
              : this.trigger("playlistunchanged"),
            this.updateMediaUpdateTimeout_(vl(this.media(), !!i)),
            this.trigger("loadedplaylist");
        }),
        (t.dispose = function () {
          this.trigger("dispose"),
            this.stopRequest(),
            window.clearTimeout(this.mediaUpdateTimeout),
            window.clearTimeout(this.finalRenditionTimeout),
            this.off();
        }),
        (t.stopRequest = function () {
          var e;
          this.request &&
            ((e = this.request),
            (this.request = null),
            (e.onreadystatechange = null),
            e.abort());
        }),
        (t.media = function (n, e) {
          var i = this;
          if (!n) return this.media_;
          if ("HAVE_NOTHING" === this.state)
            throw new Error("Cannot switch media playlist from " + this.state);
          if ("string" == typeof n) {
            if (!this.master.playlists[n])
              throw new Error("Unknown playlist URI: " + n);
            n = this.master.playlists[n];
          }
          if ((window.clearTimeout(this.finalRenditionTimeout), e)) {
            var t =
              ((n.partTargetDuration || n.targetDuration) / 2) * 1e3 || 5e3;
            this.finalRenditionTimeout = window.setTimeout(
              this.media.bind(this, n, !1),
              t
            );
          } else {
            var r = this.state,
              e = !this.media_ || n.id !== this.media_.id,
              t = this.master.playlists[n.id];
            if ((t && t.endList) || (n.endList && n.segments.length))
              return (
                this.request &&
                  ((this.request.onreadystatechange = null),
                  this.request.abort(),
                  (this.request = null)),
                (this.state = "HAVE_METADATA"),
                (this.media_ = n),
                void (
                  e &&
                  (this.trigger("mediachanging"),
                  "HAVE_MASTER" === r
                    ? this.trigger("loadedmetadata")
                    : this.trigger("mediachange"))
                )
              );
            if ((this.updateMediaUpdateTimeout_(vl(n, !0)), e)) {
              if (((this.state = "SWITCHING_MEDIA"), this.request)) {
                if (n.resolvedUri === this.request.url) return;
                (this.request.onreadystatechange = null),
                  this.request.abort(),
                  (this.request = null);
              }
              this.media_ && this.trigger("mediachanging"),
                (this.pendingMedia_ = n),
                (this.request = this.vhs_.xhr(
                  { uri: n.resolvedUri, withCredentials: this.withCredentials },
                  function (e, t) {
                    if (i.request) {
                      if (
                        ((n.lastRequest = Date.now()),
                        (n.resolvedUri = Ro(
                          i.handleManifestRedirects,
                          n.resolvedUri,
                          t
                        )),
                        e)
                      )
                        return i.playlistRequestError(i.request, n, r);
                      i.haveMetadata({
                        playlistString: t.responseText,
                        url: n.uri,
                        id: n.id,
                      }),
                        "HAVE_MASTER" === r
                          ? i.trigger("loadedmetadata")
                          : i.trigger("mediachange");
                    }
                  }
                ));
            }
          }
        }),
        (t.pause = function () {
          this.mediaUpdateTimeout &&
            (window.clearTimeout(this.mediaUpdateTimeout),
            (this.mediaUpdateTimeout = null)),
            this.stopRequest(),
            "HAVE_NOTHING" === this.state && (this.started = !1),
            "SWITCHING_MEDIA" === this.state
              ? this.media_
                ? (this.state = "HAVE_METADATA")
                : (this.state = "HAVE_MASTER")
              : "HAVE_CURRENT_METADATA" === this.state &&
                (this.state = "HAVE_METADATA");
        }),
        (t.load = function (e) {
          var t = this;
          this.mediaUpdateTimeout &&
            (window.clearTimeout(this.mediaUpdateTimeout),
            (this.mediaUpdateTimeout = null));
          var n = this.media();
          e
            ? ((e = n
                ? ((n.partTargetDuration || n.targetDuration) / 2) * 1e3
                : 5e3),
              (this.mediaUpdateTimeout = window.setTimeout(function () {
                (t.mediaUpdateTimeout = null), t.load();
              }, e)))
            : this.started
            ? n && !n.endList
              ? this.trigger("mediaupdatetimeout")
              : this.trigger("loadedplaylist")
            : this.start();
        }),
        (t.updateMediaUpdateTimeout_ = function (e) {
          var t = this;
          this.mediaUpdateTimeout &&
            (window.clearTimeout(this.mediaUpdateTimeout),
            (this.mediaUpdateTimeout = null)),
            this.media() &&
              !this.media().endList &&
              (this.mediaUpdateTimeout = window.setTimeout(function () {
                (t.mediaUpdateTimeout = null),
                  t.trigger("mediaupdatetimeout"),
                  t.updateMediaUpdateTimeout_(e);
              }, e));
        }),
        (t.start = function () {
          var n = this;
          if (((this.started = !0), "object" == typeof this.src))
            return (
              this.src.uri || (this.src.uri = window.location.href),
              (this.src.resolvedUri = this.src.uri),
              void setTimeout(function () {
                n.setupInitialPlaylist(n.src);
              }, 0)
            );
          this.request = this.vhs_.xhr(
            { uri: this.src, withCredentials: this.withCredentials },
            function (e, t) {
              if (n.request) {
                if (((n.request = null), e))
                  return (
                    (n.error = {
                      status: t.status,
                      message:
                        "HLS playlist request error at URL: " + n.src + ".",
                      responseText: t.responseText,
                      code: 2,
                    }),
                    "HAVE_NOTHING" === n.state && (n.started = !1),
                    n.trigger("error")
                  );
                n.src = Ro(n.handleManifestRedirects, n.src, t);
                t = n.parseManifest_({
                  manifestString: t.responseText,
                  url: n.src,
                });
                n.setupInitialPlaylist(t);
              }
            }
          );
        }),
        (t.srcUri = function () {
          return "string" == typeof this.src ? this.src : this.src.uri;
        }),
        (t.setupInitialPlaylist = function (e) {
          if (((this.state = "HAVE_MASTER"), e.playlists))
            return (
              (this.master = e),
              hl(this.master, this.srcUri()),
              e.playlists.forEach(function (t) {
                (t.segments = fl(t)),
                  t.segments.forEach(function (e) {
                    ml(e, t.resolvedUri);
                  });
              }),
              this.trigger("loadedplaylist"),
              void (this.request || this.media(this.master.playlists[0]))
            );
          var t,
            n,
            i,
            r = this.srcUri() || window.location.href;
          (this.master =
            ((n = ul(0, (t = r))),
            ((i = {
              mediaGroups: {
                AUDIO: {},
                VIDEO: {},
                "CLOSED-CAPTIONS": {},
                SUBTITLES: {},
              },
              uri: window.location.href,
              resolvedUri: window.location.href,
              playlists: [{ uri: t, id: n, resolvedUri: t, attributes: {} }],
            }).playlists[n] = i.playlists[0]),
            (i.playlists[t] = i.playlists[0]),
            i)),
            this.haveMetadata({
              playlistObject: e,
              url: r,
              id: this.master.playlists[0].id,
            }),
            this.trigger("loadedmetadata");
        }),
        e
      );
    })(s),
    Su = w.xhr,
    Au = w.mergeOptions,
    cn = Object.freeze({
      __proto__: null,
      createTransferableMessage: Al,
      initSegmentId: wl,
      segmentKeyId: Cl,
      hexDump: Il,
      tagDump: function (e) {
        e = e.bytes;
        return Il(e);
      },
      textRanges: function (e) {
        for (var t, n, i = "", r = 0; r < e.length; r++)
          i += ((n = r), (t = e).start(n) + "-" + t.end(n) + " ");
        return i;
      },
    }),
    mr = w.EventTarget,
    wu = w.mergeOptions,
    Cu = (function (a) {
      function e(e, t, n, i) {
        var r;
        void 0 === n && (n = {}),
          ((r = a.call(this) || this).masterPlaylistLoader_ = i || y(r)),
          i || (r.isMaster_ = !0);
        (i = n.withCredentials),
          (i = void 0 !== i && i),
          (n = n.handleManifestRedirects),
          (n = void 0 !== n && n);
        if (
          ((r.vhs_ = t),
          (r.withCredentials = i),
          (r.handleManifestRedirects = n),
          !e)
        )
          throw new Error("A non-empty playlist URL or object is required");
        return (
          r.on("minimumUpdatePeriod", function () {
            r.refreshXml_();
          }),
          r.on("mediaupdatetimeout", function () {
            r.refreshMedia_(r.media().id);
          }),
          (r.state = "HAVE_NOTHING"),
          (r.loadedPlaylists_ = {}),
          (r.logger_ = Bo("DashPlaylistLoader")),
          r.isMaster_
            ? ((r.masterPlaylistLoader_.srcUrl = e),
              (r.masterPlaylistLoader_.sidxMapping_ = {}))
            : (r.childPlaylist_ = e),
          r
        );
      }
      b(e, a);
      var t = e.prototype;
      return (
        (t.requestErrored_ = function (e, t, n) {
          return (
            !this.request ||
            ((this.request = null),
            e
              ? ((this.error =
                  "object" != typeof e || e instanceof Error
                    ? {
                        status: t.status,
                        message: "DASH request error at URL: " + t.uri,
                        response: t.response,
                        code: 2,
                      }
                    : e),
                n && (this.state = n),
                this.trigger("error"),
                !0)
              : void 0)
          );
        }),
        (t.addSidxSegments_ = function (a, i, r) {
          var s,
            o,
            l = this,
            u = a.sidx && Ns(a.sidx);
          a.sidx && u && !this.masterPlaylistLoader_.sidxMapping_[u]
            ? ((s = Ro(this.handleManifestRedirects, a.sidx.resolvedUri)),
              (o = function (e, t) {
                if (!l.requestErrored_(e, t, i)) {
                  var n,
                    e = l.masterPlaylistLoader_.sidxMapping_;
                  try {
                    n = Co(C(t.response).subarray(8));
                  } catch (e) {
                    return void l.requestErrored_(e, t, i);
                  }
                  return (
                    (e[u] = { sidxInfo: a.sidx, sidx: n }),
                    xs(a, n, a.sidx.resolvedUri),
                    r(!0)
                  );
                }
              }),
              (this.request = Pl(s, this.vhs_.xhr, function (e, t, n, i) {
                if (e) return o(e, t);
                if (!n || "mp4" !== n)
                  return o(
                    {
                      status: t.status,
                      message:
                        "Unsupported " +
                        (n || "unknown") +
                        " container type for sidx segment at URL: " +
                        s,
                      response: "",
                      playlist: a,
                      internal: !0,
                      blacklistDuration: 1 / 0,
                      code: 2,
                    },
                    t
                  );
                var r = a.sidx.byterange,
                  n = r.offset,
                  r = r.length;
                if (i.length >= r + n)
                  return o(e, {
                    response: i.subarray(n, n + r),
                    status: t.status,
                    uri: t.uri,
                  });
                l.request = l.vhs_.xhr(
                  {
                    uri: s,
                    responseType: "arraybuffer",
                    headers: Tl({ byterange: a.sidx.byterange }),
                  },
                  o
                );
              })))
            : (this.mediaRequest_ = window.setTimeout(function () {
                return r(!1);
              }, 0));
        }),
        (t.dispose = function () {
          this.trigger("dispose"),
            this.stopRequest(),
            (this.loadedPlaylists_ = {}),
            window.clearTimeout(this.minimumUpdatePeriodTimeout_),
            window.clearTimeout(this.mediaRequest_),
            window.clearTimeout(this.mediaUpdateTimeout),
            (this.mediaUpdateTimeout = null),
            (this.mediaRequest_ = null),
            (this.minimumUpdatePeriodTimeout_ = null),
            this.masterPlaylistLoader_.createMupOnMedia_ &&
              (this.off(
                "loadedmetadata",
                this.masterPlaylistLoader_.createMupOnMedia_
              ),
              (this.masterPlaylistLoader_.createMupOnMedia_ = null)),
            this.off();
        }),
        (t.hasPendingRequest = function () {
          return this.request || this.mediaRequest_;
        }),
        (t.stopRequest = function () {
          var e;
          this.request &&
            ((e = this.request),
            (this.request = null),
            (e.onreadystatechange = null),
            e.abort());
        }),
        (t.media = function (t) {
          var n = this;
          if (!t) return this.media_;
          if ("HAVE_NOTHING" === this.state)
            throw new Error("Cannot switch media playlist from " + this.state);
          var i = this.state;
          if ("string" == typeof t) {
            if (!this.masterPlaylistLoader_.master.playlists[t])
              throw new Error("Unknown playlist URI: " + t);
            t = this.masterPlaylistLoader_.master.playlists[t];
          }
          var e = !this.media_ || t.id !== this.media_.id;
          if (
            e &&
            this.loadedPlaylists_[t.id] &&
            this.loadedPlaylists_[t.id].endList
          )
            return (
              (this.state = "HAVE_METADATA"),
              (this.media_ = t),
              void (
                e &&
                (this.trigger("mediachanging"), this.trigger("mediachange"))
              )
            );
          e &&
            (this.media_ && this.trigger("mediachanging"),
            this.addSidxSegments_(t, i, function (e) {
              n.haveMetadata({ startingState: i, playlist: t });
            }));
        }),
        (t.haveMetadata = function (e) {
          var t = e.startingState,
            e = e.playlist;
          (this.state = "HAVE_METADATA"),
            (this.loadedPlaylists_[e.id] = e),
            (this.mediaRequest_ = null),
            this.refreshMedia_(e.id),
            "HAVE_MASTER" === t
              ? this.trigger("loadedmetadata")
              : this.trigger("mediachange");
        }),
        (t.pause = function () {
          this.masterPlaylistLoader_.createMupOnMedia_ &&
            (this.off(
              "loadedmetadata",
              this.masterPlaylistLoader_.createMupOnMedia_
            ),
            (this.masterPlaylistLoader_.createMupOnMedia_ = null)),
            this.stopRequest(),
            window.clearTimeout(this.mediaUpdateTimeout),
            (this.mediaUpdateTimeout = null),
            this.isMaster_ &&
              (window.clearTimeout(
                this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_
              ),
              (this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_ = null)),
            "HAVE_NOTHING" === this.state && (this.started = !1);
        }),
        (t.load = function (e) {
          var t = this;
          window.clearTimeout(this.mediaUpdateTimeout),
            (this.mediaUpdateTimeout = null);
          var n = this.media();
          e
            ? ((e = n ? (n.targetDuration / 2) * 1e3 : 5e3),
              (this.mediaUpdateTimeout = window.setTimeout(function () {
                return t.load();
              }, e)))
            : this.started
            ? n && !n.endList
              ? (this.isMaster_ &&
                  !this.minimumUpdatePeriodTimeout_ &&
                  (this.trigger("minimumUpdatePeriod"),
                  this.updateMinimumUpdatePeriodTimeout_()),
                this.trigger("mediaupdatetimeout"))
              : this.trigger("loadedplaylist")
            : this.start();
        }),
        (t.start = function () {
          var n = this;
          (this.started = !0),
            this.isMaster_
              ? this.requestMaster_(function (e, t) {
                  n.haveMaster_(),
                    n.hasPendingRequest() ||
                      n.media_ ||
                      n.media(n.masterPlaylistLoader_.master.playlists[0]);
                })
              : (this.mediaRequest_ = window.setTimeout(function () {
                  return n.haveMaster_();
                }, 0));
        }),
        (t.requestMaster_ = function (i) {
          var r = this;
          this.request = this.vhs_.xhr(
            {
              uri: this.masterPlaylistLoader_.srcUrl,
              withCredentials: this.withCredentials,
            },
            function (e, t) {
              if (!r.requestErrored_(e, t)) {
                var n = t.responseText !== r.masterPlaylistLoader_.masterXml_;
                return (
                  (r.masterPlaylistLoader_.masterXml_ = t.responseText),
                  t.responseHeaders && t.responseHeaders.date
                    ? (r.masterLoaded_ = Date.parse(t.responseHeaders.date))
                    : (r.masterLoaded_ = Date.now()),
                  (r.masterPlaylistLoader_.srcUrl = Ro(
                    r.handleManifestRedirects,
                    r.masterPlaylistLoader_.srcUrl,
                    t
                  )),
                  n
                    ? (r.handleMaster_(),
                      void r.syncClientServerClock_(function () {
                        return i(t, n);
                      }))
                    : i(t, n)
                );
              }
              "HAVE_NOTHING" === r.state && (r.started = !1);
            }
          );
        }),
        (t.syncClientServerClock_ = function (n) {
          var i = this,
            r = no(this.masterPlaylistLoader_.masterXml_);
          return null === r
            ? ((this.masterPlaylistLoader_.clientOffset_ =
                this.masterLoaded_ - Date.now()),
              n())
            : "DIRECT" === r.method
            ? ((this.masterPlaylistLoader_.clientOffset_ =
                r.value - Date.now()),
              n())
            : void (this.request = this.vhs_.xhr(
                {
                  uri: gu(this.masterPlaylistLoader_.srcUrl, r.value),
                  method: r.method,
                  withCredentials: this.withCredentials,
                },
                function (e, t) {
                  if (i.request) {
                    if (e)
                      return (
                        (i.masterPlaylistLoader_.clientOffset_ =
                          i.masterLoaded_ - Date.now()),
                        n()
                      );
                    t =
                      "HEAD" === r.method
                        ? t.responseHeaders && t.responseHeaders.date
                          ? Date.parse(t.responseHeaders.date)
                          : i.masterLoaded_
                        : Date.parse(t.responseText);
                    (i.masterPlaylistLoader_.clientOffset_ = t - Date.now()),
                      n();
                  }
                }
              ));
        }),
        (t.haveMaster_ = function () {
          (this.state = "HAVE_MASTER"),
            this.isMaster_
              ? this.trigger("loadedplaylist")
              : this.media_ || this.media(this.childPlaylist_);
        }),
        (t.handleMaster_ = function () {
          this.mediaRequest_ = null;
          var e,
            t,
            n,
            i,
            r = this.masterPlaylistLoader_.master,
            t =
              ((a = {
                masterXml: this.masterPlaylistLoader_.masterXml_,
                srcUrl: this.masterPlaylistLoader_.srcUrl,
                clientOffset: this.masterPlaylistLoader_.clientOffset_,
                sidxMapping: this.masterPlaylistLoader_.sidxMapping_,
                previousManifest: r,
              }),
              (e = a.masterXml),
              (t = a.srcUrl),
              (n = a.clientOffset),
              (i = a.sidxMapping),
              (a = a.previousManifest),
              (a = to(e, {
                manifestUri: t,
                clientOffset: n,
                sidxMapping: i,
                previousManifest: a,
              })),
              hl(a, t),
              a);
          r &&
            (t = (function (e, t, n) {
              for (
                var a = !0,
                  s = wu(e, {
                    duration: t.duration,
                    minimumUpdatePeriod: t.minimumUpdatePeriod,
                    timelineStarts: t.timelineStarts,
                  }),
                  i = 0;
                i < t.playlists.length;
                i++
              ) {
                var r,
                  o = t.playlists[i];
                o.sidx &&
                  ((r = Ns(o.sidx)),
                  n &&
                    n[r] &&
                    n[r].sidx &&
                    xs(o, n[r].sidx, o.sidx.resolvedUri));
                o = bl(s, o, jl);
                o && ((s = o), (a = !1));
              }
              return (
                cl(t, function (e, t, n, i) {
                  var r;
                  e.playlists &&
                    e.playlists.length &&
                    ((r = e.playlists[0].id),
                    (e = bl(s, e.playlists[0], jl)) &&
                      (((s = e).mediaGroups[t][n][i].playlists[0] =
                        s.playlists[r]),
                      (a = !1)));
                }),
                (a = t.minimumUpdatePeriod === e.minimumUpdatePeriod && a)
                  ? null
                  : s
              );
            })(r, t, this.masterPlaylistLoader_.sidxMapping_)),
            (this.masterPlaylistLoader_.master = t || r);
          var a =
            this.masterPlaylistLoader_.master.locations &&
            this.masterPlaylistLoader_.master.locations[0];
          return (
            a &&
              a !== this.masterPlaylistLoader_.srcUrl &&
              (this.masterPlaylistLoader_.srcUrl = a),
            (!r || (t && t.minimumUpdatePeriod !== r.minimumUpdatePeriod)) &&
              this.updateMinimumUpdatePeriodTimeout_(),
            Boolean(t)
          );
        }),
        (t.updateMinimumUpdatePeriodTimeout_ = function () {
          var e = this.masterPlaylistLoader_;
          e.createMupOnMedia_ &&
            (e.off("loadedmetadata", e.createMupOnMedia_),
            (e.createMupOnMedia_ = null)),
            e.minimumUpdatePeriodTimeout_ &&
              (window.clearTimeout(e.minimumUpdatePeriodTimeout_),
              (e.minimumUpdatePeriodTimeout_ = null));
          var t = e.master && e.master.minimumUpdatePeriod;
          0 === t &&
            (e.media()
              ? (t = 1e3 * e.media().targetDuration)
              : ((e.createMupOnMedia_ = e.updateMinimumUpdatePeriodTimeout_),
                e.one("loadedmetadata", e.createMupOnMedia_))),
            "number" != typeof t || t <= 0
              ? t < 0 &&
                this.logger_(
                  "found invalid minimumUpdatePeriod of " +
                    t +
                    ", not setting a timeout"
                )
              : this.createMUPTimeout_(t);
        }),
        (t.createMUPTimeout_ = function (e) {
          var t = this.masterPlaylistLoader_;
          t.minimumUpdatePeriodTimeout_ = window.setTimeout(function () {
            (t.minimumUpdatePeriodTimeout_ = null),
              t.trigger("minimumUpdatePeriod"),
              t.createMUPTimeout_(e);
          }, e);
        }),
        (t.refreshXml_ = function () {
          var n = this;
          this.requestMaster_(function (e, t) {
            var r, a;
            t &&
              (n.media_ &&
                (n.media_ =
                  n.masterPlaylistLoader_.master.playlists[n.media_.id]),
              (n.masterPlaylistLoader_.sidxMapping_ =
                ((t = n.masterPlaylistLoader_.master),
                (r = n.masterPlaylistLoader_.sidxMapping_),
                (a = Nl(t.playlists, r)),
                cl(t, function (e, t, n, i) {
                  e.playlists &&
                    e.playlists.length &&
                    ((e = e.playlists), (a = wu(a, Nl(e, r))));
                }),
                a)),
              n.addSidxSegments_(n.media(), n.state, function (e) {
                n.refreshMedia_(n.media().id);
              }));
          });
        }),
        (t.refreshMedia_ = function (e) {
          var t = this;
          if (!e) throw new Error("refreshMedia_ must take a media id");
          this.media_ && this.isMaster_ && this.handleMaster_();
          var n = this.masterPlaylistLoader_.master.playlists,
            i = !this.media_ || this.media_ !== n[e];
          i ? (this.media_ = n[e]) : this.trigger("playlistunchanged"),
            this.mediaUpdateTimeout ||
              (function e() {
                t.media().endList ||
                  (t.mediaUpdateTimeout = window.setTimeout(function () {
                    t.trigger("mediaupdatetimeout"), e();
                  }, vl(t.media(), Boolean(i))));
              })(),
            this.trigger("loadedplaylist");
        }),
        e
      );
    })(mr),
    L = {
      GOAL_BUFFER_LENGTH: 30,
      MAX_GOAL_BUFFER_LENGTH: 60,
      BACK_BUFFER_LENGTH: 30,
      GOAL_BUFFER_LENGTH_RATE: 1,
      INITIAL_BANDWIDTH: 4194304,
      BANDWIDTH_VARIANCE: 1.2,
      BUFFER_LOW_WATER_LINE: 0,
      MAX_BUFFER_LOW_WATER_LINE: 30,
      EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
      BUFFER_LOW_WATER_LINE_RATE: 1,
      BUFFER_HIGH_WATER_LINE: 30,
    },
    r = function (i) {
      return function () {
        var e = (function (t) {
            try {
              return URL.createObjectURL(
                new Blob([t], { type: "application/javascript" })
              );
            } catch (e) {
              var n = new BlobBuilder();
              return n.append(t), URL.createObjectURL(n.getBlob());
            }
          })(i),
          t = Ll(new Worker(e));
        t.objURL = e;
        var n = t.terminate;
        return (
          (t.on = t.addEventListener),
          (t.off = t.removeEventListener),
          (t.terminate = function () {
            return URL.revokeObjectURL(e), n.call(this);
          }),
          t
        );
      };
    },
    he = function (e) {
      return (
        "var browserWorkerPolyFill = " +
        Ll.toString() +
        ";\nbrowserWorkerPolyFill(self);\n" +
        e
      );
    },
    s = function (e) {
      return e
        .toString()
        .replace(/^function.+?{/, "")
        .slice(0, -1);
    },
    Iu = r(
      he(
        s(function () {
          var e = function () {
            this.init = function () {
              var a = {};
              (this.on = function (e, t) {
                a[e] || (a[e] = []), (a[e] = a[e].concat(t));
              }),
                (this.off = function (e, t) {
                  return (
                    !!a[e] &&
                    ((t = a[e].indexOf(t)),
                    (a[e] = a[e].slice()),
                    a[e].splice(t, 1),
                    -1 < t)
                  );
                }),
                (this.trigger = function (e) {
                  var t,
                    n,
                    i,
                    r = a[e];
                  if (r)
                    if (2 === arguments.length)
                      for (n = r.length, t = 0; t < n; ++t)
                        r[t].call(this, arguments[1]);
                    else {
                      for (
                        i = [], t = arguments.length, t = 1;
                        t < arguments.length;
                        ++t
                      )
                        i.push(arguments[t]);
                      for (n = r.length, t = 0; t < n; ++t) r[t].apply(this, i);
                    }
                }),
                (this.dispose = function () {
                  a = {};
                });
            };
          };
          (e.prototype.pipe = function (t) {
            return (
              this.on("data", function (e) {
                t.push(e);
              }),
              this.on("done", function (e) {
                t.flush(e);
              }),
              this.on("partialdone", function (e) {
                t.partialFlush(e);
              }),
              this.on("endedtimeline", function (e) {
                t.endTimeline(e);
              }),
              this.on("reset", function (e) {
                t.reset(e);
              }),
              t
            );
          }),
            (e.prototype.push = function (e) {
              this.trigger("data", e);
            }),
            (e.prototype.flush = function (e) {
              this.trigger("done", e);
            }),
            (e.prototype.partialFlush = function (e) {
              this.trigger("partialdone", e);
            }),
            (e.prototype.endTimeline = function (e) {
              this.trigger("endedtimeline", e);
            }),
            (e.prototype.reset = function (e) {
              this.trigger("reset", e);
            });
          var l,
            D,
            R,
            B,
            U,
            V,
            F,
            G,
            q,
            z,
            H,
            W,
            X,
            Y,
            K,
            Q,
            Z,
            J,
            $,
            ee,
            u,
            te,
            ne,
            ie,
            re,
            ae,
            se,
            oe,
            le,
            ue,
            t,
            ce,
            de,
            he,
            pe,
            me,
            fe,
            ge,
            be,
            n = e,
            ve = Math.pow(2, 32),
            i = {
              getUint64: function (e) {
                var t = new DataView(e.buffer, e.byteOffset, e.byteLength);
                return t.getBigUint64
                  ? (e = t.getBigUint64(0)) < Number.MAX_SAFE_INTEGER
                    ? Number(e)
                    : e
                  : t.getUint32(0) * ve + t.getUint32(4);
              },
              MAX_UINT32: ve,
            },
            ye = i.MAX_UINT32;
          !(function () {
            if (
              ((u = {
                avc1: [],
                avcC: [],
                btrt: [],
                dinf: [],
                dref: [],
                esds: [],
                ftyp: [],
                hdlr: [],
                mdat: [],
                mdhd: [],
                mdia: [],
                mfhd: [],
                minf: [],
                moof: [],
                moov: [],
                mp4a: [],
                mvex: [],
                mvhd: [],
                pasp: [],
                sdtp: [],
                smhd: [],
                stbl: [],
                stco: [],
                stsc: [],
                stsd: [],
                stsz: [],
                stts: [],
                styp: [],
                tfdt: [],
                tfhd: [],
                traf: [],
                trak: [],
                trun: [],
                trex: [],
                tkhd: [],
                vmhd: [],
              }),
              "undefined" != typeof Uint8Array)
            ) {
              for (var e in u)
                u.hasOwnProperty(e) &&
                  (u[e] = [
                    e.charCodeAt(0),
                    e.charCodeAt(1),
                    e.charCodeAt(2),
                    e.charCodeAt(3),
                  ]);
              (te = new Uint8Array([
                "i".charCodeAt(0),
                "s".charCodeAt(0),
                "o".charCodeAt(0),
                "m".charCodeAt(0),
              ])),
                (ie = new Uint8Array([
                  "a".charCodeAt(0),
                  "v".charCodeAt(0),
                  "c".charCodeAt(0),
                  "1".charCodeAt(0),
                ])),
                (ne = new Uint8Array([0, 0, 0, 1])),
                (re = new Uint8Array([
                  0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100,
                  108, 101, 114, 0,
                ])),
                (ae = new Uint8Array([
                  0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0,
                  0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100,
                  108, 101, 114, 0,
                ])),
                (se = { video: re, audio: ae }),
                (ue = new Uint8Array([
                  0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0,
                  0, 1,
                ])),
                (le = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0])),
                (t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0])),
                (ce = t),
                (de = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])),
                (he = t),
                (oe = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]));
            }
          })(),
            (l = function (e) {
              for (var t, n = [], i = 0, r = 1; r < arguments.length; r++)
                n.push(arguments[r]);
              for (r = n.length; r--; ) i += n[r].byteLength;
              for (
                t = new Uint8Array(i + 8),
                  new DataView(t.buffer, t.byteOffset, t.byteLength).setUint32(
                    0,
                    t.byteLength
                  ),
                  t.set(e, 4),
                  r = 0,
                  i = 8;
                r < n.length;
                r++
              )
                t.set(n[r], i), (i += n[r].byteLength);
              return t;
            }),
            (D = function () {
              return l(u.dinf, l(u.dref, ue));
            }),
            (R = function (e) {
              return l(
                u.esds,
                new Uint8Array([
                  0,
                  0,
                  0,
                  0,
                  3,
                  25,
                  0,
                  0,
                  0,
                  4,
                  17,
                  64,
                  21,
                  0,
                  6,
                  0,
                  0,
                  0,
                  218,
                  192,
                  0,
                  0,
                  218,
                  192,
                  5,
                  2,
                  (e.audioobjecttype << 3) | (e.samplingfrequencyindex >>> 1),
                  (e.samplingfrequencyindex << 7) | (e.channelcount << 3),
                  6,
                  1,
                  2,
                ])
              );
            }),
            (Y = function (e) {
              return l(u.hdlr, se[e]);
            }),
            (X = function (e) {
              var t = new Uint8Array([
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                0,
                0,
                0,
                3,
                0,
                1,
                95,
                144,
                (e.duration >>> 24) & 255,
                (e.duration >>> 16) & 255,
                (e.duration >>> 8) & 255,
                255 & e.duration,
                85,
                196,
                0,
                0,
              ]);
              return (
                e.samplerate &&
                  ((t[12] = (e.samplerate >>> 24) & 255),
                  (t[13] = (e.samplerate >>> 16) & 255),
                  (t[14] = (e.samplerate >>> 8) & 255),
                  (t[15] = 255 & e.samplerate)),
                l(u.mdhd, t)
              );
            }),
            (W = function (e) {
              return l(u.mdia, X(e), Y(e.type), V(e));
            }),
            (U = function (e) {
              return l(
                u.mfhd,
                new Uint8Array([
                  0,
                  0,
                  0,
                  0,
                  (4278190080 & e) >> 24,
                  (16711680 & e) >> 16,
                  (65280 & e) >> 8,
                  255 & e,
                ])
              );
            }),
            (V = function (e) {
              return l(
                u.minf,
                "video" === e.type ? l(u.vmhd, oe) : l(u.smhd, le),
                D(),
                Q(e)
              );
            }),
            (S = function (e, t) {
              for (var n = [], i = t.length; i--; ) n[i] = J(t[i]);
              return l.apply(null, [u.moof, U(e)].concat(n));
            }),
            (F = function (e) {
              for (var t = e.length, n = []; t--; ) n[t] = z(e[t]);
              return l.apply(
                null,
                [u.moov, q(4294967295)].concat(n).concat(G(e))
              );
            }),
            (G = function (e) {
              for (var t = e.length, n = []; t--; ) n[t] = $(e[t]);
              return l.apply(null, [u.mvex].concat(n));
            }),
            (q = function (e) {
              e = new Uint8Array([
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                2,
                0,
                1,
                95,
                144,
                (4278190080 & e) >> 24,
                (16711680 & e) >> 16,
                (65280 & e) >> 8,
                255 & e,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                64,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                255,
                255,
                255,
                255,
              ]);
              return l(u.mvhd, e);
            }),
            (K = function (e) {
              for (
                var t,
                  n = e.samples || [],
                  i = new Uint8Array(4 + n.length),
                  r = 0;
                r < n.length;
                r++
              )
                (t = n[r].flags),
                  (i[r + 4] =
                    (t.dependsOn << 4) |
                    (t.isDependedOn << 2) |
                    t.hasRedundancy);
              return l(u.sdtp, i);
            }),
            (Q = function (e) {
              return l(
                u.stbl,
                Z(e),
                l(u.stts, he),
                l(u.stsc, ce),
                l(u.stsz, de),
                l(u.stco, t)
              );
            }),
            (Z = function (e) {
              return l(
                u.stsd,
                new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]),
                ("video" === e.type ? pe : me)(e)
              );
            }),
            (pe = function (e) {
              for (
                var t,
                  n,
                  i = e.sps || [],
                  r = e.pps || [],
                  a = [],
                  s = [],
                  o = 0;
                o < i.length;
                o++
              )
                a.push((65280 & i[o].byteLength) >>> 8),
                  a.push(255 & i[o].byteLength),
                  (a = a.concat(Array.prototype.slice.call(i[o])));
              for (o = 0; o < r.length; o++)
                s.push((65280 & r[o].byteLength) >>> 8),
                  s.push(255 & r[o].byteLength),
                  (s = s.concat(Array.prototype.slice.call(r[o])));
              return (
                (t = [
                  u.avc1,
                  new Uint8Array([
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    (65280 & e.width) >> 8,
                    255 & e.width,
                    (65280 & e.height) >> 8,
                    255 & e.height,
                    0,
                    72,
                    0,
                    0,
                    0,
                    72,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    19,
                    118,
                    105,
                    100,
                    101,
                    111,
                    106,
                    115,
                    45,
                    99,
                    111,
                    110,
                    116,
                    114,
                    105,
                    98,
                    45,
                    104,
                    108,
                    115,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    24,
                    17,
                    17,
                  ]),
                  l(
                    u.avcC,
                    new Uint8Array(
                      [
                        1,
                        e.profileIdc,
                        e.profileCompatibility,
                        e.levelIdc,
                        255,
                      ].concat([i.length], a, [r.length], s)
                    )
                  ),
                  l(
                    u.btrt,
                    new Uint8Array([
                      0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192,
                    ])
                  ),
                ]),
                e.sarRatio &&
                  ((n = e.sarRatio[0]),
                  (e = e.sarRatio[1]),
                  t.push(
                    l(
                      u.pasp,
                      new Uint8Array([
                        (4278190080 & n) >> 24,
                        (16711680 & n) >> 16,
                        (65280 & n) >> 8,
                        255 & n,
                        (4278190080 & e) >> 24,
                        (16711680 & e) >> 16,
                        (65280 & e) >> 8,
                        255 & e,
                      ])
                    )
                  )),
                l.apply(null, t)
              );
            }),
            (me = function (e) {
              return l(
                u.mp4a,
                new Uint8Array([
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  (65280 & e.channelcount) >> 8,
                  255 & e.channelcount,
                  (65280 & e.samplesize) >> 8,
                  255 & e.samplesize,
                  0,
                  0,
                  0,
                  0,
                  (65280 & e.samplerate) >> 8,
                  255 & e.samplerate,
                  0,
                  0,
                ]),
                R(e)
              );
            }),
            (H = function (e) {
              e = new Uint8Array([
                0,
                0,
                0,
                7,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                (4278190080 & e.id) >> 24,
                (16711680 & e.id) >> 16,
                (65280 & e.id) >> 8,
                255 & e.id,
                0,
                0,
                0,
                0,
                (4278190080 & e.duration) >> 24,
                (16711680 & e.duration) >> 16,
                (65280 & e.duration) >> 8,
                255 & e.duration,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                64,
                0,
                0,
                0,
                (65280 & e.width) >> 8,
                255 & e.width,
                0,
                0,
                (65280 & e.height) >> 8,
                255 & e.height,
                0,
                0,
              ]);
              return l(u.tkhd, e);
            }),
            (J = function (e) {
              var t,
                n = l(
                  u.tfhd,
                  new Uint8Array([
                    0,
                    0,
                    0,
                    58,
                    (4278190080 & e.id) >> 24,
                    (16711680 & e.id) >> 16,
                    (65280 & e.id) >> 8,
                    255 & e.id,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                  ])
                ),
                i = Math.floor(e.baseMediaDecodeTime / ye),
                r = Math.floor(e.baseMediaDecodeTime % ye),
                i = l(
                  u.tfdt,
                  new Uint8Array([
                    1,
                    0,
                    0,
                    0,
                    (i >>> 24) & 255,
                    (i >>> 16) & 255,
                    (i >>> 8) & 255,
                    255 & i,
                    (r >>> 24) & 255,
                    (r >>> 16) & 255,
                    (r >>> 8) & 255,
                    255 & r,
                  ])
                );
              return "audio" === e.type
                ? ((t = ee(e, 92)), l(u.traf, n, i, t))
                : ((r = K(e)),
                  (t = ee(e, r.length + 92)),
                  l(u.traf, n, i, t, r));
            }),
            (z = function (e) {
              return (
                (e.duration = e.duration || 4294967295), l(u.trak, H(e), W(e))
              );
            }),
            ($ = function (e) {
              var t = new Uint8Array([
                0,
                0,
                0,
                0,
                (4278190080 & e.id) >> 24,
                (16711680 & e.id) >> 16,
                (65280 & e.id) >> 8,
                255 & e.id,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                1,
              ]);
              return "video" !== e.type && (t[t.length - 1] = 0), l(u.trex, t);
            }),
            (fe = function (e, t) {
              var n = 0,
                i = 0,
                r = 0,
                a = 0;
              return (
                e.length &&
                  (void 0 !== e[0].duration && (n = 1),
                  void 0 !== e[0].size && (i = 2),
                  void 0 !== e[0].flags && (r = 4),
                  void 0 !== e[0].compositionTimeOffset && (a = 8)),
                [
                  0,
                  0,
                  n | i | r | a,
                  1,
                  (4278190080 & e.length) >>> 24,
                  (16711680 & e.length) >>> 16,
                  (65280 & e.length) >>> 8,
                  255 & e.length,
                  (4278190080 & t) >>> 24,
                  (16711680 & t) >>> 16,
                  (65280 & t) >>> 8,
                  255 & t,
                ]
              );
            }),
            (ge = function (e, t) {
              var n,
                i,
                r,
                a,
                s = e.samples || [];
              for (
                t += 20 + 16 * s.length,
                  t = fe(s, t),
                  (i = new Uint8Array(t.length + 16 * s.length)).set(t),
                  n = t.length,
                  a = 0;
                a < s.length;
                a++
              )
                (r = s[a]),
                  (i[n++] = (4278190080 & r.duration) >>> 24),
                  (i[n++] = (16711680 & r.duration) >>> 16),
                  (i[n++] = (65280 & r.duration) >>> 8),
                  (i[n++] = 255 & r.duration),
                  (i[n++] = (4278190080 & r.size) >>> 24),
                  (i[n++] = (16711680 & r.size) >>> 16),
                  (i[n++] = (65280 & r.size) >>> 8),
                  (i[n++] = 255 & r.size),
                  (i[n++] = (r.flags.isLeading << 2) | r.flags.dependsOn),
                  (i[n++] =
                    (r.flags.isDependedOn << 6) |
                    (r.flags.hasRedundancy << 4) |
                    (r.flags.paddingValue << 1) |
                    r.flags.isNonSyncSample),
                  (i[n++] = 61440 & r.flags.degradationPriority),
                  (i[n++] = 15 & r.flags.degradationPriority),
                  (i[n++] = (4278190080 & r.compositionTimeOffset) >>> 24),
                  (i[n++] = (16711680 & r.compositionTimeOffset) >>> 16),
                  (i[n++] = (65280 & r.compositionTimeOffset) >>> 8),
                  (i[n++] = 255 & r.compositionTimeOffset);
              return l(u.trun, i);
            }),
            (be = function (e, t) {
              var n,
                i,
                r,
                a,
                s = e.samples || [];
              for (
                t += 20 + 8 * s.length,
                  t = fe(s, t),
                  (n = new Uint8Array(t.length + 8 * s.length)).set(t),
                  i = t.length,
                  a = 0;
                a < s.length;
                a++
              )
                (r = s[a]),
                  (n[i++] = (4278190080 & r.duration) >>> 24),
                  (n[i++] = (16711680 & r.duration) >>> 16),
                  (n[i++] = (65280 & r.duration) >>> 8),
                  (n[i++] = 255 & r.duration),
                  (n[i++] = (4278190080 & r.size) >>> 24),
                  (n[i++] = (16711680 & r.size) >>> 16),
                  (n[i++] = (65280 & r.size) >>> 8),
                  (n[i++] = 255 & r.size);
              return l(u.trun, n);
            }),
            (ee = function (e, t) {
              return ("audio" === e.type ? be : ge)(e, t);
            });
          B = function () {
            return l(u.ftyp, te, ne, te, ie);
          };
          function _e(e, t) {
            var n = {
              size: 0,
              flags: {
                isLeading: 0,
                dependsOn: 1,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradationPriority: 0,
                isNonSyncSample: 1,
              },
            };
            return (
              (n.dataOffset = t),
              (n.compositionTimeOffset = e.pts - e.dts),
              (n.duration = e.duration),
              (n.size = 4 * e.length),
              (n.size += e.byteLength),
              e.keyFrame &&
                ((n.flags.dependsOn = 2), (n.flags.isNonSyncSample = 0)),
              n
            );
          }
          function r(e) {
            for (var t = []; e--; ) t.push(0);
            return t;
          }
          function Te() {
            var e, n;
            return (
              Oe ||
                ((e = {
                  96e3: [a, [227, 64], r(154), [56]],
                  88200: [a, [231], r(170), [56]],
                  64e3: [a, [248, 192], r(240), [56]],
                  48e3: [a, [255, 192], r(268), [55, 148, 128], r(54), [112]],
                  44100: [a, [255, 192], r(268), [55, 163, 128], r(84), [112]],
                  32e3: [a, [255, 192], r(268), [55, 234], r(226), [112]],
                  24e3: [
                    a,
                    [255, 192],
                    r(268),
                    [55, 255, 128],
                    r(268),
                    [111, 112],
                    r(126),
                    [224],
                  ],
                  16e3: [
                    a,
                    [255, 192],
                    r(268),
                    [55, 255, 128],
                    r(268),
                    [111, 255],
                    r(269),
                    [223, 108],
                    r(195),
                    [1, 192],
                  ],
                  12e3: [
                    Pe,
                    r(268),
                    [3, 127, 248],
                    r(268),
                    [6, 255, 240],
                    r(268),
                    [13, 255, 224],
                    r(268),
                    [27, 253, 128],
                    r(259),
                    [56],
                  ],
                  11025: [
                    Pe,
                    r(268),
                    [3, 127, 248],
                    r(268),
                    [6, 255, 240],
                    r(268),
                    [13, 255, 224],
                    r(268),
                    [27, 255, 192],
                    r(268),
                    [55, 175, 128],
                    r(108),
                    [112],
                  ],
                  8e3: [Pe, r(268), [3, 121, 16], r(47), [7]],
                }),
                (n = e),
                (Oe = Object.keys(n).reduce(function (e, t) {
                  return (
                    (e[t] = new Uint8Array(
                      n[t].reduce(function (e, t) {
                        return e.concat(t);
                      }, [])
                    )),
                    e
                  );
                }, {}))),
              Oe
            );
          }
          var Oe,
            Se = function (e) {
              return l(u.mdat, e);
            },
            Ae = S,
            we = function (e) {
              var t = B(),
                n = F(e),
                e = new Uint8Array(t.byteLength + n.byteLength);
              return e.set(t), e.set(n, t.byteLength), e;
            },
            Ce = function (e) {
              var t,
                n,
                i = [],
                r = [];
              for (
                r.byteLength = 0,
                  r.nalCount = 0,
                  r.duration = 0,
                  t = i.byteLength = 0;
                t < e.length;
                t++
              )
                "access_unit_delimiter_rbsp" === (n = e[t]).nalUnitType
                  ? (i.length &&
                      ((i.duration = n.dts - i.dts),
                      (r.byteLength += i.byteLength),
                      (r.nalCount += i.length),
                      (r.duration += i.duration),
                      r.push(i)),
                    ((i = [n]).byteLength = n.data.byteLength),
                    (i.pts = n.pts),
                    (i.dts = n.dts))
                  : ("slice_layer_without_partitioning_rbsp_idr" ===
                      n.nalUnitType && (i.keyFrame = !0),
                    (i.duration = n.dts - i.dts),
                    (i.byteLength += n.data.byteLength),
                    i.push(n));
              return (
                r.length &&
                  (!i.duration || i.duration <= 0) &&
                  (i.duration = r[r.length - 1].duration),
                (r.byteLength += i.byteLength),
                (r.nalCount += i.length),
                (r.duration += i.duration),
                r.push(i),
                r
              );
            },
            Ie = function (e) {
              var t,
                n,
                i = [],
                r = [];
              for (
                i.byteLength = 0,
                  i.nalCount = 0,
                  i.duration = 0,
                  i.pts = e[0].pts,
                  i.dts = e[0].dts,
                  r.byteLength = 0,
                  r.nalCount = 0,
                  r.duration = 0,
                  r.pts = e[0].pts,
                  r.dts = e[0].dts,
                  t = 0;
                t < e.length;
                t++
              )
                (n = e[t]).keyFrame
                  ? (i.length &&
                      (r.push(i),
                      (r.byteLength += i.byteLength),
                      (r.nalCount += i.nalCount),
                      (r.duration += i.duration)),
                    ((i = [n]).nalCount = n.length),
                    (i.byteLength = n.byteLength),
                    (i.pts = n.pts),
                    (i.dts = n.dts),
                    (i.duration = n.duration))
                  : ((i.duration += n.duration),
                    (i.nalCount += n.length),
                    (i.byteLength += n.byteLength),
                    i.push(n));
              return (
                r.length &&
                  i.duration <= 0 &&
                  (i.duration = r[r.length - 1].duration),
                (r.byteLength += i.byteLength),
                (r.nalCount += i.nalCount),
                (r.duration += i.duration),
                r.push(i),
                r
              );
            },
            xe = function (e) {
              var t;
              return (
                !e[0][0].keyFrame &&
                  1 < e.length &&
                  ((t = e.shift()),
                  (e.byteLength -= t.byteLength),
                  (e.nalCount -= t.nalCount),
                  (e[0][0].dts = t.dts),
                  (e[0][0].pts = t.pts),
                  (e[0][0].duration += t.duration)),
                e
              );
            },
            Ee = function (e, t) {
              for (var n, i, r, a = t || 0, s = [], o = 0; o < e.length; o++)
                for (i = e[o], n = 0; n < i.length; n++)
                  (r = i[n]), (a += (r = _e(r, a)).size), s.push(r);
              return s;
            },
            ke = function (e) {
              for (
                var t,
                  n,
                  i,
                  r,
                  a,
                  s = 0,
                  o = e.byteLength,
                  l = e.nalCount,
                  u = new Uint8Array(o + 4 * l),
                  c = new DataView(u.buffer),
                  d = 0;
                d < e.length;
                d++
              )
                for (i = e[d], t = 0; t < i.length; t++)
                  for (r = i[t], n = 0; n < r.length; n++)
                    (a = r[n]),
                      c.setUint32(s, a.data.byteLength),
                      u.set(a.data, (s += 4)),
                      (s += a.data.byteLength);
              return u;
            },
            a = [33, 16, 5, 32, 164, 27],
            Pe = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252],
            je = function (e) {
              return 9e4 * e;
            },
            Ne = function (e, t) {
              return e * t;
            },
            Le = function (e) {
              return e / 9e4;
            },
            Me = function (e, t) {
              return e / t;
            },
            h = 9e4,
            De = je,
            s = Le,
            Re = function (e, t) {
              return je(Me(e, t));
            },
            Be = function (e, t) {
              return Ne(Le(e), t);
            },
            Ue = function (e, t, n) {
              return Le(n ? e : e - t);
            },
            Ve = function (e, t, n, i) {
              var r,
                a,
                s,
                o,
                l,
                u,
                c = 0,
                d = 0;
              if (
                t.length &&
                ((r = Re(e.baseMediaDecodeTime, e.samplerate)),
                (a = Math.ceil(h / (e.samplerate / 1024))),
                n &&
                  i &&
                  ((s = r - Math.max(n, i)), (d = (c = Math.floor(s / a)) * a)),
                !(c < 1 || h / 2 < d))
              ) {
                for (
                  o = (o = Te()[e.samplerate]) || t[0].data, l = 0;
                  l < c;
                  l++
                )
                  (u = t[0]),
                    t.splice(0, 0, { data: o, dts: u.dts - a, pts: u.pts - a });
                return (
                  (e.baseMediaDecodeTime -= Math.floor(Be(d, e.samplerate))), d
                );
              }
            },
            Fe = function (e, t, n) {
              return t.minSegmentDts >= n
                ? e
                : ((t.minSegmentDts = 1 / 0),
                  e.filter(function (e) {
                    return (
                      e.dts >= n &&
                      ((t.minSegmentDts = Math.min(t.minSegmentDts, e.dts)),
                      (t.minSegmentPts = t.minSegmentDts),
                      !0)
                    );
                  }));
            },
            Ge = function (e) {
              for (var t, n = [], i = 0; i < e.length; i++)
                (t = e[i]), n.push({ size: t.data.byteLength, duration: 1024 });
              return n;
            },
            qe = function (e) {
              for (
                var t,
                  n = 0,
                  i = new Uint8Array(
                    (function (e) {
                      for (var t = 0, n = 0; n < e.length; n++)
                        t += e[n].data.byteLength;
                      return t;
                    })(e)
                  ),
                  r = 0;
                r < e.length;
                r++
              )
                (t = e[r]), i.set(t.data, n), (n += t.data.byteLength);
              return i;
            },
            ze = h,
            p = function (e) {
              delete e.minSegmentDts,
                delete e.maxSegmentDts,
                delete e.minSegmentPts,
                delete e.maxSegmentPts;
            },
            He = function (e, t) {
              var n = e.minSegmentDts;
              return (
                t || (n -= e.timelineStartInfo.dts),
                (t = e.timelineStartInfo.baseMediaDecodeTime),
                (t += n),
                (t = Math.max(0, t)),
                "audio" === e.type &&
                  ((t *= e.samplerate / ze), (t = Math.floor(t))),
                t
              );
            },
            We = function (e, t) {
              "number" == typeof t.pts &&
                (void 0 === e.timelineStartInfo.pts &&
                  (e.timelineStartInfo.pts = t.pts),
                void 0 === e.minSegmentPts
                  ? (e.minSegmentPts = t.pts)
                  : (e.minSegmentPts = Math.min(e.minSegmentPts, t.pts)),
                void 0 === e.maxSegmentPts
                  ? (e.maxSegmentPts = t.pts)
                  : (e.maxSegmentPts = Math.max(e.maxSegmentPts, t.pts))),
                "number" == typeof t.dts &&
                  (void 0 === e.timelineStartInfo.dts &&
                    (e.timelineStartInfo.dts = t.dts),
                  void 0 === e.minSegmentDts
                    ? (e.minSegmentDts = t.dts)
                    : (e.minSegmentDts = Math.min(e.minSegmentDts, t.dts)),
                  void 0 === e.maxSegmentDts
                    ? (e.maxSegmentDts = t.dts)
                    : (e.maxSegmentDts = Math.max(e.maxSegmentDts, t.dts)));
            },
            Xe = function (e) {
              for (
                var t = 0,
                  n = { payloadType: -1, payloadSize: 0 },
                  i = 0,
                  r = 0;
                t < e.byteLength && 128 !== e[t];

              ) {
                for (; 255 === e[t]; ) (i += 255), t++;
                for (i += e[t++]; 255 === e[t]; ) (r += 255), t++;
                if (((r += e[t++]), !n.payload && 4 === i)) {
                  if (
                    "GA94" ===
                    String.fromCharCode(e[t + 3], e[t + 4], e[t + 5], e[t + 6])
                  ) {
                    (n.payloadType = i),
                      (n.payloadSize = r),
                      (n.payload = e.subarray(t, t + r));
                    break;
                  }
                  n.payload = void 0;
                }
                (t += r), (r = i = 0);
              }
              return n;
            },
            Ye = function (e) {
              return 181 !== e.payload[0] ||
                49 != ((e.payload[1] << 8) | e.payload[2]) ||
                "GA94" !==
                  String.fromCharCode(
                    e.payload[3],
                    e.payload[4],
                    e.payload[5],
                    e.payload[6]
                  ) ||
                3 !== e.payload[7]
                ? null
                : e.payload.subarray(8, e.payload.length - 1);
            },
            Ke = function (e, t) {
              var n,
                i,
                r,
                a,
                s = [];
              if (!(64 & t[0])) return s;
              for (i = 31 & t[0], n = 0; n < i; n++)
                (a = { type: 3 & t[2 + (r = 3 * n)], pts: e }),
                  4 & t[2 + r] &&
                    ((a.ccData = (t[3 + r] << 8) | t[4 + r]), s.push(a));
              return s;
            },
            Qe = function (e) {
              for (var t = e.byteLength, n = [], i = 1; i < t - 2; )
                0 === e[i] && 0 === e[i + 1] && 3 === e[i + 2]
                  ? (n.push(i + 2), (i += 2))
                  : i++;
              if (0 === n.length) return e;
              for (
                var r = t - n.length, a = new Uint8Array(r), s = 0, i = 0;
                i < r;
                s++, i++
              )
                s === n[0] && (s++, n.shift()), (a[i] = e[s]);
              return a;
            },
            Ze = 4,
            o = function e(t) {
              (t = t || {}),
                e.prototype.init.call(this),
                (this.parse708captions_ =
                  "boolean" != typeof t.parse708captions || t.parse708captions),
                (this.captionPackets_ = []),
                (this.ccStreams_ = [
                  new v(0, 0),
                  new v(0, 1),
                  new v(1, 0),
                  new v(1, 1),
                ]),
                this.parse708captions_ &&
                  (this.cc708Stream_ = new f({
                    captionServices: t.captionServices,
                  })),
                this.reset(),
                this.ccStreams_.forEach(function (e) {
                  e.on("data", this.trigger.bind(this, "data")),
                    e.on("partialdone", this.trigger.bind(this, "partialdone")),
                    e.on("done", this.trigger.bind(this, "done"));
                }, this),
                this.parse708captions_ &&
                  (this.cc708Stream_.on(
                    "data",
                    this.trigger.bind(this, "data")
                  ),
                  this.cc708Stream_.on(
                    "partialdone",
                    this.trigger.bind(this, "partialdone")
                  ),
                  this.cc708Stream_.on(
                    "done",
                    this.trigger.bind(this, "done")
                  ));
            };
          ((o.prototype = new n()).push = function (e) {
            var t, n;
            if (
              "sei_rbsp" === e.nalUnitType &&
              (t = Xe(e.escapedRBSP)).payload &&
              t.payloadType === Ze &&
              (n = Ye(t))
            )
              if (e.dts < this.latestDts_) this.ignoreNextEqualDts_ = !0;
              else {
                if (e.dts === this.latestDts_ && this.ignoreNextEqualDts_)
                  return (
                    this.numSameDts_--,
                    void (this.numSameDts_ || (this.ignoreNextEqualDts_ = !1))
                  );
                (n = Ke(e.pts, n)),
                  (this.captionPackets_ = this.captionPackets_.concat(n)),
                  this.latestDts_ !== e.dts && (this.numSameDts_ = 0),
                  this.numSameDts_++,
                  (this.latestDts_ = e.dts);
              }
          }),
            (o.prototype.flushCCStreams = function (t) {
              this.ccStreams_.forEach(function (e) {
                return "flush" === t ? e.flush() : e.partialFlush();
              }, this);
            }),
            (o.prototype.flushStream = function (e) {
              this.captionPackets_.length &&
                (this.captionPackets_.forEach(function (e, t) {
                  e.presortIndex = t;
                }),
                this.captionPackets_.sort(function (e, t) {
                  return e.pts === t.pts
                    ? e.presortIndex - t.presortIndex
                    : e.pts - t.pts;
                }),
                this.captionPackets_.forEach(function (e) {
                  e.type < 2
                    ? this.dispatchCea608Packet(e)
                    : this.dispatchCea708Packet(e);
                }, this),
                (this.captionPackets_.length = 0)),
                this.flushCCStreams(e);
            }),
            (o.prototype.flush = function () {
              return this.flushStream("flush");
            }),
            (o.prototype.partialFlush = function () {
              return this.flushStream("partialFlush");
            }),
            (o.prototype.reset = function () {
              (this.latestDts_ = null),
                (this.ignoreNextEqualDts_ = !1),
                (this.numSameDts_ = 0),
                (this.activeCea608Channel_ = [null, null]),
                this.ccStreams_.forEach(function (e) {
                  e.reset();
                });
            }),
            (o.prototype.dispatchCea608Packet = function (e) {
              this.setsTextOrXDSActive(e)
                ? (this.activeCea608Channel_[e.type] = null)
                : this.setsChannel1Active(e)
                ? (this.activeCea608Channel_[e.type] = 0)
                : this.setsChannel2Active(e) &&
                  (this.activeCea608Channel_[e.type] = 1),
                null !== this.activeCea608Channel_[e.type] &&
                  this.ccStreams_[
                    (e.type << 1) + this.activeCea608Channel_[e.type]
                  ].push(e);
            }),
            (o.prototype.setsChannel1Active = function (e) {
              return 4096 == (30720 & e.ccData);
            }),
            (o.prototype.setsChannel2Active = function (e) {
              return 6144 == (30720 & e.ccData);
            }),
            (o.prototype.setsTextOrXDSActive = function (e) {
              return (
                256 == (28928 & e.ccData) ||
                4138 == (30974 & e.ccData) ||
                6186 == (30974 & e.ccData)
              );
            }),
            (o.prototype.dispatchCea708Packet = function (e) {
              this.parse708captions_ && this.cc708Stream_.push(e);
            });
          function c(e) {
            return (32 <= e && e <= 127) || (160 <= e && e <= 255);
          }
          function d(e) {
            (this.windowNum = e), this.reset();
          }
          var Je = {
            127: 9834,
            4128: 32,
            4129: 160,
            4133: 8230,
            4138: 352,
            4140: 338,
            4144: 9608,
            4145: 8216,
            4146: 8217,
            4147: 8220,
            4148: 8221,
            4149: 8226,
            4153: 8482,
            4154: 353,
            4156: 339,
            4157: 8480,
            4159: 376,
            4214: 8539,
            4215: 8540,
            4216: 8541,
            4217: 8542,
            4218: 9168,
            4219: 9124,
            4220: 9123,
            4221: 9135,
            4222: 9126,
            4223: 9121,
            4256: 12600,
          };
          (d.prototype.reset = function () {
            this.clearText(),
              (this.pendingNewLine = !1),
              (this.winAttr = {}),
              (this.penAttr = {}),
              (this.penLoc = {}),
              (this.penColor = {}),
              (this.visible = 0),
              (this.rowLock = 0),
              (this.columnLock = 0),
              (this.priority = 0),
              (this.relativePositioning = 0),
              (this.anchorVertical = 0),
              (this.anchorHorizontal = 0),
              (this.anchorPoint = 0),
              (this.rowCount = 1),
              (this.virtualRowCount = this.rowCount + 1),
              (this.columnCount = 41),
              (this.windowStyle = 0),
              (this.penStyle = 0);
          }),
            (d.prototype.getText = function () {
              return this.rows.join("\n");
            }),
            (d.prototype.clearText = function () {
              (this.rows = [""]), (this.rowIdx = 0);
            }),
            (d.prototype.newLine = function (e) {
              for (
                this.rows.length >= this.virtualRowCount &&
                  "function" == typeof this.beforeRowOverflow &&
                  this.beforeRowOverflow(e),
                  0 < this.rows.length && (this.rows.push(""), this.rowIdx++);
                this.rows.length > this.virtualRowCount;

              )
                this.rows.shift(), this.rowIdx--;
            }),
            (d.prototype.isEmpty = function () {
              return (
                0 === this.rows.length ||
                (1 === this.rows.length && "" === this.rows[0])
              );
            }),
            (d.prototype.addText = function (e) {
              this.rows[this.rowIdx] += e;
            }),
            (d.prototype.backspace = function () {
              var e;
              this.isEmpty() ||
                ((e = this.rows[this.rowIdx]),
                (this.rows[this.rowIdx] = e.substr(0, e.length - 1)));
            });
          function m(e, t, n) {
            (this.serviceNum = e),
              (this.text = ""),
              (this.currentWindow = new d(-1)),
              (this.windows = []),
              (this.stream = n),
              "string" == typeof t && this.createTextDecoder(t);
          }
          (m.prototype.init = function (e, t) {
            this.startPts = e;
            for (var n = 0; n < 8; n++)
              (this.windows[n] = new d(n)),
                "function" == typeof t &&
                  (this.windows[n].beforeRowOverflow = t);
          }),
            (m.prototype.setCurrentWindow = function (e) {
              this.currentWindow = this.windows[e];
            }),
            (m.prototype.createTextDecoder = function (t) {
              if ("undefined" == typeof TextDecoder)
                this.stream.trigger("log", {
                  level: "warn",
                  message:
                    "The `encoding` option is unsupported without TextDecoder support",
                });
              else
                try {
                  this.textDecoder_ = new TextDecoder(t);
                } catch (e) {
                  this.stream.trigger("log", {
                    level: "warn",
                    message:
                      "TextDecoder could not be created with " +
                      t +
                      " encoding. " +
                      e,
                  });
                }
            });
          var f = function e(t) {
            (t = t || {}), e.prototype.init.call(this);
            var n,
              i = this,
              r = t.captionServices || {},
              a = {};
            Object.keys(r).forEach(function (e) {
              (n = r[e]), /^SERVICE/.test(e) && (a[e] = n.encoding);
            }),
              (this.serviceEncodings = a),
              (this.current708Packet = null),
              (this.services = {}),
              (this.push = function (e) {
                (3 === e.type || null === i.current708Packet) &&
                  i.new708Packet(),
                  i.add708Bytes(e);
              });
          };
          (f.prototype = new n()),
            (f.prototype.new708Packet = function () {
              null !== this.current708Packet && this.push708Packet(),
                (this.current708Packet = { data: [], ptsVals: [] });
            }),
            (f.prototype.add708Bytes = function (e) {
              var t = e.ccData,
                n = t >>> 8,
                t = 255 & t;
              this.current708Packet.ptsVals.push(e.pts),
                this.current708Packet.data.push(n),
                this.current708Packet.data.push(t);
            }),
            (f.prototype.push708Packet = function () {
              var e,
                t = this.current708Packet,
                n = t.data,
                i = null,
                r = 0,
                a = n[r++];
              for (t.seq = a >> 6, t.sizeCode = 63 & a; r < n.length; r++)
                (e = 31 & (a = n[r++])),
                  7 === (i = a >> 5) && 0 < e && (i = n[r++]),
                  this.pushServiceBlock(i, r, e),
                  0 < e && (r += e - 1);
            }),
            (f.prototype.pushServiceBlock = function (e, t, n) {
              for (
                var i,
                  r = t,
                  a = this.current708Packet.data,
                  s = (s = this.services[e]) || this.initService(e, r);
                r < t + n && r < a.length;
                r++
              )
                (i = a[r]),
                  c(i)
                    ? (r = this.handleText(r, s))
                    : 24 === i
                    ? (r = this.multiByteCharacter(r, s))
                    : 16 === i
                    ? (r = this.extendedCommands(r, s))
                    : 128 <= i && i <= 135
                    ? (r = this.setCurrentWindow(r, s))
                    : 152 <= i && i <= 159
                    ? (r = this.defineWindow(r, s))
                    : 136 === i
                    ? (r = this.clearWindows(r, s))
                    : 140 === i
                    ? (r = this.deleteWindows(r, s))
                    : 137 === i
                    ? (r = this.displayWindows(r, s))
                    : 138 === i
                    ? (r = this.hideWindows(r, s))
                    : 139 === i
                    ? (r = this.toggleWindows(r, s))
                    : 151 === i
                    ? (r = this.setWindowAttributes(r, s))
                    : 144 === i
                    ? (r = this.setPenAttributes(r, s))
                    : 145 === i
                    ? (r = this.setPenColor(r, s))
                    : 146 === i
                    ? (r = this.setPenLocation(r, s))
                    : 143 === i
                    ? (s = this.reset(r, s))
                    : 8 === i
                    ? s.currentWindow.backspace()
                    : 12 === i
                    ? s.currentWindow.clearText()
                    : 13 === i
                    ? (s.currentWindow.pendingNewLine = !0)
                    : 14 === i
                    ? s.currentWindow.clearText()
                    : 141 === i && r++;
            }),
            (f.prototype.extendedCommands = function (e, t) {
              var n = this.current708Packet.data[++e];
              return (e = c(n) ? this.handleText(e, t, { isExtended: !0 }) : e);
            }),
            (f.prototype.getPts = function (e) {
              return this.current708Packet.ptsVals[Math.floor(e / 2)];
            }),
            (f.prototype.initService = function (t, e) {
              var n,
                i = "SERVICE" + t,
                r = this;
              return (
                i in this.serviceEncodings && (n = this.serviceEncodings[i]),
                (this.services[t] = new m(t, n, r)),
                this.services[t].init(this.getPts(e), function (e) {
                  r.flushDisplayed(e, r.services[t]);
                }),
                this.services[t]
              );
            }),
            (f.prototype.handleText = function (e, t, n) {
              var i,
                r = n && n.isExtended,
                a = n && n.isMultiByte,
                s = this.current708Packet.data,
                o = r ? 4096 : 0,
                l = s[e],
                n = s[e + 1],
                s = t.currentWindow,
                u =
                  t.textDecoder_ && !r
                    ? (a ? ((i = [l, n]), e++) : (i = [l]),
                      t.textDecoder_.decode(new Uint8Array(i)))
                    : ((u = Je[(l = o | l)] || l),
                      4096 & l && l === u ? "" : String.fromCharCode(u));
              return (
                s.pendingNewLine && !s.isEmpty() && s.newLine(this.getPts(e)),
                (s.pendingNewLine = !1),
                s.addText(u),
                e
              );
            }),
            (f.prototype.multiByteCharacter = function (e, t) {
              var n = this.current708Packet.data,
                i = n[e + 1],
                n = n[e + 2];
              return (e =
                c(i) && c(n)
                  ? this.handleText(++e, t, { isMultiByte: !0 })
                  : e);
            }),
            (f.prototype.setCurrentWindow = function (e, t) {
              var n = this.current708Packet.data[e];
              return t.setCurrentWindow(7 & n), e;
            }),
            (f.prototype.defineWindow = function (e, t) {
              var n = this.current708Packet.data,
                i = n[e];
              t.setCurrentWindow(7 & i);
              (t = t.currentWindow), (i = n[++e]);
              return (
                (t.visible = (32 & i) >> 5),
                (t.rowLock = (16 & i) >> 4),
                (t.columnLock = (8 & i) >> 3),
                (t.priority = 7 & i),
                (i = n[++e]),
                (t.relativePositioning = (128 & i) >> 7),
                (t.anchorVertical = 127 & i),
                (i = n[++e]),
                (t.anchorHorizontal = i),
                (i = n[++e]),
                (t.anchorPoint = (240 & i) >> 4),
                (t.rowCount = 15 & i),
                (i = n[++e]),
                (t.columnCount = 63 & i),
                (i = n[++e]),
                (t.windowStyle = (56 & i) >> 3),
                (t.penStyle = 7 & i),
                (t.virtualRowCount = t.rowCount + 1),
                e
              );
            }),
            (f.prototype.setWindowAttributes = function (e, t) {
              var n = this.current708Packet.data,
                i = n[e],
                t = t.currentWindow.winAttr,
                i = n[++e];
              return (
                (t.fillOpacity = (192 & i) >> 6),
                (t.fillRed = (48 & i) >> 4),
                (t.fillGreen = (12 & i) >> 2),
                (t.fillBlue = 3 & i),
                (i = n[++e]),
                (t.borderType = (192 & i) >> 6),
                (t.borderRed = (48 & i) >> 4),
                (t.borderGreen = (12 & i) >> 2),
                (t.borderBlue = 3 & i),
                (i = n[++e]),
                (t.borderType += (128 & i) >> 5),
                (t.wordWrap = (64 & i) >> 6),
                (t.printDirection = (48 & i) >> 4),
                (t.scrollDirection = (12 & i) >> 2),
                (t.justify = 3 & i),
                (i = n[++e]),
                (t.effectSpeed = (240 & i) >> 4),
                (t.effectDirection = (12 & i) >> 2),
                (t.displayEffect = 3 & i),
                e
              );
            }),
            (f.prototype.flushDisplayed = function (e, t) {
              for (var n = [], i = 0; i < 8; i++)
                t.windows[i].visible &&
                  !t.windows[i].isEmpty() &&
                  n.push(t.windows[i].getText());
              (t.endPts = e),
                (t.text = n.join("\n\n")),
                this.pushCaption(t),
                (t.startPts = e);
            }),
            (f.prototype.pushCaption = function (e) {
              "" !== e.text &&
                (this.trigger("data", {
                  startPts: e.startPts,
                  endPts: e.endPts,
                  text: e.text,
                  stream: "cc708_" + e.serviceNum,
                }),
                (e.text = ""),
                (e.startPts = e.endPts));
            }),
            (f.prototype.displayWindows = function (e, t) {
              var n = this.current708Packet.data[++e],
                i = this.getPts(e);
              this.flushDisplayed(i, t);
              for (var r = 0; r < 8; r++)
                n & (1 << r) && (t.windows[r].visible = 1);
              return e;
            }),
            (f.prototype.hideWindows = function (e, t) {
              var n = this.current708Packet.data[++e],
                i = this.getPts(e);
              this.flushDisplayed(i, t);
              for (var r = 0; r < 8; r++)
                n & (1 << r) && (t.windows[r].visible = 0);
              return e;
            }),
            (f.prototype.toggleWindows = function (e, t) {
              var n = this.current708Packet.data[++e],
                i = this.getPts(e);
              this.flushDisplayed(i, t);
              for (var r = 0; r < 8; r++)
                n & (1 << r) && (t.windows[r].visible ^= 1);
              return e;
            }),
            (f.prototype.clearWindows = function (e, t) {
              var n = this.current708Packet.data[++e],
                i = this.getPts(e);
              this.flushDisplayed(i, t);
              for (var r = 0; r < 8; r++)
                n & (1 << r) && t.windows[r].clearText();
              return e;
            }),
            (f.prototype.deleteWindows = function (e, t) {
              var n = this.current708Packet.data[++e],
                i = this.getPts(e);
              this.flushDisplayed(i, t);
              for (var r = 0; r < 8; r++) n & (1 << r) && t.windows[r].reset();
              return e;
            }),
            (f.prototype.setPenAttributes = function (e, t) {
              var n = this.current708Packet.data,
                i = n[e],
                t = t.currentWindow.penAttr,
                i = n[++e];
              return (
                (t.textTag = (240 & i) >> 4),
                (t.offset = (12 & i) >> 2),
                (t.penSize = 3 & i),
                (i = n[++e]),
                (t.italics = (128 & i) >> 7),
                (t.underline = (64 & i) >> 6),
                (t.edgeType = (56 & i) >> 3),
                (t.fontStyle = 7 & i),
                e
              );
            }),
            (f.prototype.setPenColor = function (e, t) {
              var n = this.current708Packet.data,
                i = n[e],
                t = t.currentWindow.penColor,
                i = n[++e];
              return (
                (t.fgOpacity = (192 & i) >> 6),
                (t.fgRed = (48 & i) >> 4),
                (t.fgGreen = (12 & i) >> 2),
                (t.fgBlue = 3 & i),
                (i = n[++e]),
                (t.bgOpacity = (192 & i) >> 6),
                (t.bgRed = (48 & i) >> 4),
                (t.bgGreen = (12 & i) >> 2),
                (t.bgBlue = 3 & i),
                (i = n[++e]),
                (t.edgeRed = (48 & i) >> 4),
                (t.edgeGreen = (12 & i) >> 2),
                (t.edgeBlue = 3 & i),
                e
              );
            }),
            (f.prototype.setPenLocation = function (e, t) {
              var n = this.current708Packet.data,
                i = n[e],
                r = t.currentWindow.penLoc;
              return (
                (t.currentWindow.pendingNewLine = !0),
                (i = n[++e]),
                (r.row = 15 & i),
                (i = n[++e]),
                (r.column = 63 & i),
                e
              );
            }),
            (f.prototype.reset = function (e, t) {
              var n = this.getPts(e);
              return (
                this.flushDisplayed(n, t), this.initService(t.serviceNum, e)
              );
            });
          function g(e) {
            return null === e ? "" : ((e = $e[e] || e), String.fromCharCode(e));
          }
          function b() {
            for (var e = [], t = 15; t--; ) e.push("");
            return e;
          }
          var $e = {
              42: 225,
              92: 233,
              94: 237,
              95: 243,
              96: 250,
              123: 231,
              124: 247,
              125: 209,
              126: 241,
              127: 9608,
              304: 174,
              305: 176,
              306: 189,
              307: 191,
              308: 8482,
              309: 162,
              310: 163,
              311: 9834,
              312: 224,
              313: 160,
              314: 232,
              315: 226,
              316: 234,
              317: 238,
              318: 244,
              319: 251,
              544: 193,
              545: 201,
              546: 211,
              547: 218,
              548: 220,
              549: 252,
              550: 8216,
              551: 161,
              552: 42,
              553: 39,
              554: 8212,
              555: 169,
              556: 8480,
              557: 8226,
              558: 8220,
              559: 8221,
              560: 192,
              561: 194,
              562: 199,
              563: 200,
              564: 202,
              565: 203,
              566: 235,
              567: 206,
              568: 207,
              569: 239,
              570: 212,
              571: 217,
              572: 249,
              573: 219,
              574: 171,
              575: 187,
              800: 195,
              801: 227,
              802: 205,
              803: 204,
              804: 236,
              805: 210,
              806: 242,
              807: 213,
              808: 245,
              809: 123,
              810: 125,
              811: 92,
              812: 94,
              813: 95,
              814: 124,
              815: 126,
              816: 196,
              817: 228,
              818: 214,
              819: 246,
              820: 223,
              821: 165,
              822: 164,
              823: 9474,
              824: 197,
              825: 229,
              826: 216,
              827: 248,
              828: 9484,
              829: 9488,
              830: 9492,
              831: 9496,
            },
            et = [
              4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096,
              4864, 4896, 5120, 5152,
            ],
            v = function e(t, n) {
              e.prototype.init.call(this),
                (this.field_ = t || 0),
                (this.dataChannel_ = n || 0),
                (this.name_ =
                  "CC" + (1 + ((this.field_ << 1) | this.dataChannel_))),
                this.setConstants(),
                this.reset(),
                (this.push = function (e) {
                  var t,
                    n,
                    i,
                    r,
                    a = 32639 & e.ccData;
                  a !== this.lastControlCode_
                    ? (4096 == (61440 & a)
                        ? (this.lastControlCode_ = a)
                        : a !== this.PADDING_ && (this.lastControlCode_ = null),
                      (t = a >>> 8),
                      (n = 255 & a),
                      a === this.PADDING_ ||
                        (a === this.RESUME_CAPTION_LOADING_
                          ? (this.mode_ = "popOn")
                          : a === this.END_OF_CAPTION_
                          ? ((this.mode_ = "popOn"),
                            this.clearFormatting(e.pts),
                            this.flushDisplayed(e.pts),
                            (r = this.displayed_),
                            (this.displayed_ = this.nonDisplayed_),
                            (this.nonDisplayed_ = r),
                            (this.startPts_ = e.pts))
                          : a === this.ROLL_UP_2_ROWS_
                          ? ((this.rollUpRows_ = 2), this.setRollUp(e.pts))
                          : a === this.ROLL_UP_3_ROWS_
                          ? ((this.rollUpRows_ = 3), this.setRollUp(e.pts))
                          : a === this.ROLL_UP_4_ROWS_
                          ? ((this.rollUpRows_ = 4), this.setRollUp(e.pts))
                          : a === this.CARRIAGE_RETURN_
                          ? (this.clearFormatting(e.pts),
                            this.flushDisplayed(e.pts),
                            this.shiftRowsUp_(),
                            (this.startPts_ = e.pts))
                          : a === this.BACKSPACE_
                          ? "popOn" === this.mode_
                            ? (this.nonDisplayed_[this.row_] =
                                this.nonDisplayed_[this.row_].slice(0, -1))
                            : (this.displayed_[this.row_] = this.displayed_[
                                this.row_
                              ].slice(0, -1))
                          : a === this.ERASE_DISPLAYED_MEMORY_
                          ? (this.flushDisplayed(e.pts),
                            (this.displayed_ = b()))
                          : a === this.ERASE_NON_DISPLAYED_MEMORY_
                          ? (this.nonDisplayed_ = b())
                          : a === this.RESUME_DIRECT_CAPTIONING_
                          ? ("paintOn" !== this.mode_ &&
                              (this.flushDisplayed(e.pts),
                              (this.displayed_ = b())),
                            (this.mode_ = "paintOn"),
                            (this.startPts_ = e.pts))
                          : this.isSpecialCharacter(t, n)
                          ? ((i = g((t = (3 & t) << 8) | n)),
                            this[this.mode_](e.pts, i),
                            this.column_++)
                          : this.isExtCharacter(t, n)
                          ? ("popOn" === this.mode_
                              ? (this.nonDisplayed_[this.row_] =
                                  this.nonDisplayed_[this.row_].slice(0, -1))
                              : (this.displayed_[this.row_] = this.displayed_[
                                  this.row_
                                ].slice(0, -1)),
                            (i = g((t = (3 & t) << 8) | n)),
                            this[this.mode_](e.pts, i),
                            this.column_++)
                          : this.isMidRowCode(t, n)
                          ? (this.clearFormatting(e.pts),
                            this[this.mode_](e.pts, " "),
                            this.column_++,
                            14 == (14 & n) && this.addFormatting(e.pts, ["i"]),
                            1 == (1 & n) && this.addFormatting(e.pts, ["u"]))
                          : this.isOffsetControlCode(t, n)
                          ? (this.column_ += 3 & n)
                          : this.isPAC(t, n)
                          ? ((r = et.indexOf(7968 & a)),
                            "rollUp" === this.mode_ &&
                              (r - this.rollUpRows_ + 1 < 0 &&
                                (r = this.rollUpRows_ - 1),
                              this.setRollUp(e.pts, r)),
                            r !== this.row_ &&
                              (this.clearFormatting(e.pts), (this.row_ = r)),
                            1 & n &&
                              -1 === this.formatting_.indexOf("u") &&
                              this.addFormatting(e.pts, ["u"]),
                            16 == (16 & a) &&
                              (this.column_ = 4 * ((14 & a) >> 1)),
                            this.isColorPAC(n) &&
                              14 == (14 & n) &&
                              this.addFormatting(e.pts, ["i"]))
                          : this.isNormalChar(t) &&
                            (0 === n && (n = null),
                            (i = g(t)),
                            (i += g(n)),
                            this[this.mode_](e.pts, i),
                            (this.column_ += i.length))))
                    : (this.lastControlCode_ = null);
                });
            };
          (v.prototype = new n()),
            (v.prototype.flushDisplayed = function (e) {
              var t = this.displayed_
                .map(function (e, t) {
                  try {
                    return e.trim();
                  } catch (e) {
                    return (
                      this.trigger("log", {
                        level: "warn",
                        message:
                          "Skipping a malformed 608 caption at index " +
                          t +
                          ".",
                      }),
                      ""
                    );
                  }
                }, this)
                .join("\n")
                .replace(/^\n+|\n+$/g, "");
              t.length &&
                this.trigger("data", {
                  startPts: this.startPts_,
                  endPts: e,
                  text: t,
                  stream: this.name_,
                });
            }),
            (v.prototype.reset = function () {
              (this.mode_ = "popOn"),
                (this.topRow_ = 0),
                (this.startPts_ = 0),
                (this.displayed_ = b()),
                (this.nonDisplayed_ = b()),
                (this.lastControlCode_ = null),
                (this.column_ = 0),
                (this.row_ = 14),
                (this.rollUpRows_ = 2),
                (this.formatting_ = []);
            }),
            (v.prototype.setConstants = function () {
              0 === this.dataChannel_
                ? ((this.BASE_ = 16),
                  (this.EXT_ = 17),
                  (this.CONTROL_ = (20 | this.field_) << 8),
                  (this.OFFSET_ = 23))
                : 1 === this.dataChannel_ &&
                  ((this.BASE_ = 24),
                  (this.EXT_ = 25),
                  (this.CONTROL_ = (28 | this.field_) << 8),
                  (this.OFFSET_ = 31)),
                (this.PADDING_ = 0),
                (this.RESUME_CAPTION_LOADING_ = 32 | this.CONTROL_),
                (this.END_OF_CAPTION_ = 47 | this.CONTROL_),
                (this.ROLL_UP_2_ROWS_ = 37 | this.CONTROL_),
                (this.ROLL_UP_3_ROWS_ = 38 | this.CONTROL_),
                (this.ROLL_UP_4_ROWS_ = 39 | this.CONTROL_),
                (this.CARRIAGE_RETURN_ = 45 | this.CONTROL_),
                (this.RESUME_DIRECT_CAPTIONING_ = 41 | this.CONTROL_),
                (this.BACKSPACE_ = 33 | this.CONTROL_),
                (this.ERASE_DISPLAYED_MEMORY_ = 44 | this.CONTROL_),
                (this.ERASE_NON_DISPLAYED_MEMORY_ = 46 | this.CONTROL_);
            }),
            (v.prototype.isSpecialCharacter = function (e, t) {
              return e === this.EXT_ && 48 <= t && t <= 63;
            }),
            (v.prototype.isExtCharacter = function (e, t) {
              return (
                (e === this.EXT_ + 1 || e === this.EXT_ + 2) &&
                32 <= t &&
                t <= 63
              );
            }),
            (v.prototype.isMidRowCode = function (e, t) {
              return e === this.EXT_ && 32 <= t && t <= 47;
            }),
            (v.prototype.isOffsetControlCode = function (e, t) {
              return e === this.OFFSET_ && 33 <= t && t <= 35;
            }),
            (v.prototype.isPAC = function (e, t) {
              return (
                e >= this.BASE_ && e < this.BASE_ + 8 && 64 <= t && t <= 127
              );
            }),
            (v.prototype.isColorPAC = function (e) {
              return (64 <= e && e <= 79) || (96 <= e && e <= 127);
            }),
            (v.prototype.isNormalChar = function (e) {
              return 32 <= e && e <= 127;
            }),
            (v.prototype.setRollUp = function (e, t) {
              if (
                ("rollUp" !== this.mode_ &&
                  ((this.row_ = 14),
                  (this.mode_ = "rollUp"),
                  this.flushDisplayed(e),
                  (this.nonDisplayed_ = b()),
                  (this.displayed_ = b())),
                void 0 !== t && t !== this.row_)
              )
                for (var n = 0; n < this.rollUpRows_; n++)
                  (this.displayed_[t - n] = this.displayed_[this.row_ - n]),
                    (this.displayed_[this.row_ - n] = "");
              void 0 === t && (t = this.row_),
                (this.topRow_ = t - this.rollUpRows_ + 1);
            }),
            (v.prototype.addFormatting = function (e, t) {
              this.formatting_ = this.formatting_.concat(t);
              t = t.reduce(function (e, t) {
                return e + "<" + t + ">";
              }, "");
              this[this.mode_](e, t);
            }),
            (v.prototype.clearFormatting = function (e) {
              var t;
              this.formatting_.length &&
                ((t = this.formatting_.reverse().reduce(function (e, t) {
                  return e + "</" + t + ">";
                }, "")),
                (this.formatting_ = []),
                this[this.mode_](e, t));
            }),
            (v.prototype.popOn = function (e, t) {
              var n = this.nonDisplayed_[this.row_];
              this.nonDisplayed_[this.row_] = n += t;
            }),
            (v.prototype.rollUp = function (e, t) {
              var n = this.displayed_[this.row_];
              this.displayed_[this.row_] = n += t;
            }),
            (v.prototype.shiftRowsUp_ = function () {
              for (var e = 0; e < this.topRow_; e++) this.displayed_[e] = "";
              for (e = this.row_ + 1; e < 15; e++) this.displayed_[e] = "";
              for (e = this.topRow_; e < this.row_; e++)
                this.displayed_[e] = this.displayed_[e + 1];
              this.displayed_[this.row_] = "";
            }),
            (v.prototype.paintOn = function (e, t) {
              var n = this.displayed_[this.row_];
              this.displayed_[this.row_] = n += t;
            });
          function tt(e, t) {
            var n = 1;
            for (t < e && (n = -1); 4294967296 < Math.abs(t - e); )
              e += 8589934592 * n;
            return e;
          }
          var y = { CaptionStream: o, Cea608Stream: v, Cea708Stream: f },
            _ = {
              H264_STREAM_TYPE: 27,
              ADTS_STREAM_TYPE: 15,
              METADATA_STREAM_TYPE: 21,
            },
            e = function e(t) {
              var n, i;
              e.prototype.init.call(this),
                (this.type_ = t || "shared"),
                (this.push = function (e) {
                  ("shared" !== this.type_ && e.type !== this.type_) ||
                    (void 0 === i && (i = e.dts),
                    (e.dts = tt(e.dts, i)),
                    (e.pts = tt(e.pts, i)),
                    (n = e.dts),
                    this.trigger("data", e));
                }),
                (this.flush = function () {
                  (i = n), this.trigger("done");
                }),
                (this.endTimeline = function () {
                  this.flush(), this.trigger("endedtimeline");
                }),
                (this.discontinuity = function () {
                  n = i = void 0;
                }),
                (this.reset = function () {
                  this.discontinuity(), this.trigger("reset");
                });
            };
          e.prototype = new n();
          function nt(e, t, n) {
            for (var i = "", r = t; r < n; r++)
              i += "%" + ("00" + e[r].toString(16)).slice(-2);
            return i;
          }
          function T(e, t, n) {
            return decodeURIComponent(nt(e, t, n));
          }
          function O(e) {
            return (e[0] << 21) | (e[1] << 14) | (e[2] << 7) | e[3];
          }
          var S = e,
            o = tt,
            it = {
              TXXX: function (e) {
                var t;
                if (3 === e.data[0]) {
                  for (t = 1; t < e.data.length; t++)
                    if (0 === e.data[t]) {
                      (e.description = T(e.data, 1, t)),
                        (e.value = T(e.data, t + 1, e.data.length).replace(
                          /\0*$/,
                          ""
                        ));
                      break;
                    }
                  e.data = e.value;
                }
              },
              WXXX: function (e) {
                var t;
                if (3 === e.data[0])
                  for (t = 1; t < e.data.length; t++)
                    if (0 === e.data[t]) {
                      (e.description = T(e.data, 1, t)),
                        (e.url = T(e.data, t + 1, e.data.length));
                      break;
                    }
              },
              PRIV: function (e) {
                for (var t, n = 0; n < e.data.length; n++)
                  if (0 === e.data[n]) {
                    e.owner = ((t = e.data), unescape(nt(t, 0, n)));
                    break;
                  }
                (e.privateData = e.data.subarray(n + 1)),
                  (e.data = e.privateData);
              },
            },
            rt = function (e) {
              var t,
                n = { descriptor: e && e.descriptor },
                l = 0,
                u = [],
                c = 0;
              if (
                (rt.prototype.init.call(this),
                (this.dispatchType = _.METADATA_STREAM_TYPE.toString(16)),
                n.descriptor)
              )
                for (t = 0; t < n.descriptor.length; t++)
                  this.dispatchType += (
                    "00" + n.descriptor[t].toString(16)
                  ).slice(-2);
              this.push = function (e) {
                var t, n, i, r, a, s, o;
                if ("timed-metadata" === e.type)
                  if (
                    (e.dataAlignmentIndicator && ((c = 0), (u.length = 0)),
                    0 === u.length &&
                      (e.data.length < 10 ||
                        e.data[0] !== "I".charCodeAt(0) ||
                        e.data[1] !== "D".charCodeAt(0) ||
                        e.data[2] !== "3".charCodeAt(0)))
                  )
                    this.trigger("log", {
                      level: "warn",
                      message: "Skipping unrecognized metadata packet",
                    });
                  else if (
                    (u.push(e),
                    (c += e.data.byteLength),
                    1 === u.length &&
                      ((l = O(e.data.subarray(6, 10))), (l += 10)),
                    !(c < l))
                  ) {
                    for (
                      t = {
                        data: new Uint8Array(l),
                        frames: [],
                        pts: u[0].pts,
                        dts: u[0].dts,
                      },
                        r = 0;
                      r < l;

                    )
                      t.data.set(u[0].data.subarray(0, l - r), r),
                        (r += u[0].data.byteLength),
                        (c -= u[0].data.byteLength),
                        u.shift();
                    (n = 10),
                      64 & t.data[5] &&
                        ((n += 4),
                        (n += O(t.data.subarray(10, 14))),
                        (l -= O(t.data.subarray(16, 20))));
                    do {
                      if ((i = O(t.data.subarray(n + 4, n + 8))) < 1)
                        return void this.trigger("log", {
                          level: "warn",
                          message:
                            "Malformed ID3 frame encountered. Skipping metadata parsing.",
                        });
                    } while (
                      (((o = {
                        id: String.fromCharCode(
                          t.data[n],
                          t.data[n + 1],
                          t.data[n + 2],
                          t.data[n + 3]
                        ),
                        data: t.data.subarray(n + 10, n + i + 10),
                      }).key = o.id),
                      it[o.id] &&
                        (it[o.id](o),
                        "com.apple.streaming.transportStreamTimestamp" ===
                          o.owner &&
                          ((s =
                            ((1 & (a = o.data)[3]) << 30) |
                            (a[4] << 22) |
                            (a[5] << 14) |
                            (a[6] << 6) |
                            (a[7] >>> 2)),
                          (s *= 4),
                          (s += 3 & a[7]),
                          (o.timeStamp = s),
                          void 0 === t.pts &&
                            void 0 === t.dts &&
                            ((t.pts = o.timeStamp), (t.dts = o.timeStamp)),
                          this.trigger("timestamp", o))),
                      t.frames.push(o),
                      (n += 10),
                      (n += i) < l)
                    );
                    this.trigger("data", t);
                  }
              };
            };
          rt.prototype = new n();
          var A,
            at,
            e = rt,
            S = S,
            st = function () {
              var r = new Uint8Array(188),
                a = 0;
              st.prototype.init.call(this),
                (this.push = function (e) {
                  var t,
                    n = 0,
                    i = 188;
                  for (
                    a
                      ? ((t = new Uint8Array(e.byteLength + a)).set(
                          r.subarray(0, a)
                        ),
                        t.set(e, a),
                        (a = 0))
                      : (t = e);
                    i < t.byteLength;

                  )
                    71 !== t[n] || 71 !== t[i]
                      ? (n++, i++)
                      : (this.trigger("data", t.subarray(n, i)),
                        (n += 188),
                        (i += 188));
                  n < t.byteLength &&
                    (r.set(t.subarray(n), 0), (a = t.byteLength - n));
                }),
                (this.flush = function () {
                  188 === a &&
                    71 === r[0] &&
                    (this.trigger("data", r), (a = 0)),
                    this.trigger("done");
                }),
                (this.endTimeline = function () {
                  this.flush(), this.trigger("endedtimeline");
                }),
                (this.reset = function () {
                  (a = 0), this.trigger("reset");
                });
            };
          (st.prototype = new n()),
            ((A = function () {
              var i, r, a, s;
              A.prototype.init.call(this),
                ((s = this).packetsWaitingForPmt = []),
                (this.programMapTable = void 0),
                (i = function (e, t) {
                  var n = 0;
                  t.payloadUnitStartIndicator && (n += e[n] + 1),
                    ("pat" === t.type ? r : a)(e.subarray(n), t);
                }),
                (r = function (e, t) {
                  (t.section_number = e[7]),
                    (t.last_section_number = e[8]),
                    (s.pmtPid = ((31 & e[10]) << 8) | e[11]),
                    (t.pmtPid = s.pmtPid);
                }),
                (a = function (e, t) {
                  var n, i;
                  if (1 & e[5]) {
                    for (
                      s.programMapTable = {
                        video: null,
                        audio: null,
                        "timed-metadata": {},
                      },
                        n = 3 + (((15 & e[1]) << 8) | e[2]) - 4,
                        i = 12 + (((15 & e[10]) << 8) | e[11]);
                      i < n;

                    ) {
                      var r = e[i],
                        a = ((31 & e[i + 1]) << 8) | e[i + 2];
                      r === _.H264_STREAM_TYPE &&
                      null === s.programMapTable.video
                        ? (s.programMapTable.video = a)
                        : r === _.ADTS_STREAM_TYPE &&
                          null === s.programMapTable.audio
                        ? (s.programMapTable.audio = a)
                        : r === _.METADATA_STREAM_TYPE &&
                          (s.programMapTable["timed-metadata"][a] = r),
                        (i += 5 + (((15 & e[i + 3]) << 8) | e[i + 4]));
                    }
                    t.programMapTable = s.programMapTable;
                  }
                }),
                (this.push = function (e) {
                  var t = {},
                    n = 4;
                  if (
                    ((t.payloadUnitStartIndicator = !!(64 & e[1])),
                    (t.pid = 31 & e[1]),
                    (t.pid <<= 8),
                    (t.pid |= e[2]),
                    1 < (48 & e[3]) >>> 4 && (n += e[n] + 1),
                    0 === t.pid)
                  )
                    (t.type = "pat"),
                      i(e.subarray(n), t),
                      this.trigger("data", t);
                  else if (t.pid === this.pmtPid)
                    for (
                      t.type = "pmt",
                        i(e.subarray(n), t),
                        this.trigger("data", t);
                      this.packetsWaitingForPmt.length;

                    )
                      this.processPes_.apply(
                        this,
                        this.packetsWaitingForPmt.shift()
                      );
                  else
                    void 0 === this.programMapTable
                      ? this.packetsWaitingForPmt.push([e, n, t])
                      : this.processPes_(e, n, t);
                }),
                (this.processPes_ = function (e, t, n) {
                  n.pid === this.programMapTable.video
                    ? (n.streamType = _.H264_STREAM_TYPE)
                    : n.pid === this.programMapTable.audio
                    ? (n.streamType = _.ADTS_STREAM_TYPE)
                    : (n.streamType =
                        this.programMapTable["timed-metadata"][n.pid]),
                    (n.type = "pes"),
                    (n.data = e.subarray(t)),
                    this.trigger("data", n);
                });
            }).prototype = new n()),
            (A.STREAM_TYPES = { h264: 27, adts: 15 }),
            ((at = function () {
              function i(e, t, n) {
                var i,
                  r,
                  a,
                  s,
                  o = new Uint8Array(e.size),
                  l = { type: t },
                  u = 0,
                  c = 0;
                if (e.data.length && !(e.size < 9)) {
                  for (l.trackId = e.data[0].pid, u = 0; u < e.data.length; u++)
                    (i = e.data[u]), o.set(i.data, c), (c += i.data.byteLength);
                  (a = l),
                    (s = ((r = o)[0] << 16) | (r[1] << 8) | r[2]),
                    (a.data = new Uint8Array()),
                    1 == s &&
                      ((a.packetLength = 6 + ((r[4] << 8) | r[5])),
                      (a.dataAlignmentIndicator = 0 != (4 & r[6])),
                      192 & (s = r[7]) &&
                        ((a.pts =
                          ((14 & r[9]) << 27) |
                          ((255 & r[10]) << 20) |
                          ((254 & r[11]) << 12) |
                          ((255 & r[12]) << 5) |
                          ((254 & r[13]) >>> 3)),
                        (a.pts *= 4),
                        (a.pts += (6 & r[13]) >>> 1),
                        (a.dts = a.pts),
                        64 & s &&
                          ((a.dts =
                            ((14 & r[14]) << 27) |
                            ((255 & r[15]) << 20) |
                            ((254 & r[16]) << 12) |
                            ((255 & r[17]) << 5) |
                            ((254 & r[18]) >>> 3)),
                          (a.dts *= 4),
                          (a.dts += (6 & r[18]) >>> 1))),
                      (a.data = r.subarray(9 + r[8]))),
                    (t = "video" === t || l.packetLength <= e.size),
                    (n || t) && ((e.size = 0), (e.data.length = 0)),
                    t && d.trigger("data", l);
                }
              }
              var t,
                d = this,
                r = !1,
                a = { data: [], size: 0 },
                s = { data: [], size: 0 },
                o = { data: [], size: 0 };
              at.prototype.init.call(this),
                (this.push = function (n) {
                  ({
                    pat: function () {},
                    pes: function () {
                      var e, t;
                      switch (n.streamType) {
                        case _.H264_STREAM_TYPE:
                          (e = a), (t = "video");
                          break;
                        case _.ADTS_STREAM_TYPE:
                          (e = s), (t = "audio");
                          break;
                        case _.METADATA_STREAM_TYPE:
                          (e = o), (t = "timed-metadata");
                          break;
                        default:
                          return;
                      }
                      n.payloadUnitStartIndicator && i(e, t, !0),
                        e.data.push(n),
                        (e.size += n.data.byteLength);
                    },
                    pmt: function () {
                      var e = { type: "metadata", tracks: [] };
                      null !== (t = n.programMapTable).video &&
                        e.tracks.push({
                          timelineStartInfo: { baseMediaDecodeTime: 0 },
                          id: +t.video,
                          codec: "avc",
                          type: "video",
                        }),
                        null !== t.audio &&
                          e.tracks.push({
                            timelineStartInfo: { baseMediaDecodeTime: 0 },
                            id: +t.audio,
                            codec: "adts",
                            type: "audio",
                          }),
                        (r = !0),
                        d.trigger("data", e);
                    },
                  })[n.type]();
                }),
                (this.reset = function () {
                  (a.size = 0),
                    (a.data.length = 0),
                    (s.size = 0),
                    (s.data.length = 0),
                    this.trigger("reset");
                }),
                (this.flushStreams_ = function () {
                  i(a, "video"), i(s, "audio"), i(o, "timed-metadata");
                }),
                (this.flush = function () {
                  var e;
                  !r &&
                    t &&
                    ((e = { type: "metadata", tracks: [] }),
                    null !== t.video &&
                      e.tracks.push({
                        timelineStartInfo: { baseMediaDecodeTime: 0 },
                        id: +t.video,
                        codec: "avc",
                        type: "video",
                      }),
                    null !== t.audio &&
                      e.tracks.push({
                        timelineStartInfo: { baseMediaDecodeTime: 0 },
                        id: +t.audio,
                        codec: "adts",
                        type: "audio",
                      }),
                    d.trigger("data", e)),
                    (r = !1),
                    this.flushStreams_(),
                    this.trigger("done");
                });
            }).prototype = new n());
          var w,
            ot = {
              PAT_PID: 0,
              MP2T_PACKET_LENGTH: 188,
              TransportPacketStream: st,
              TransportParseStream: A,
              ElementaryStream: at,
              TimestampRolloverStream: S,
              CaptionStream: y.CaptionStream,
              Cea608Stream: y.Cea608Stream,
              Cea708Stream: y.Cea708Stream,
              MetadataStream: e,
            };
          for (w in _) _.hasOwnProperty(w) && (ot[w] = _[w]);
          var C = ot,
            lt = h,
            ut = [
              96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3,
              11025, 8e3, 7350,
            ],
            ct = function (l) {
              var u,
                c = 0;
              ct.prototype.init.call(this),
                (this.skipWarn_ = function (e, t) {
                  this.trigger("log", {
                    level: "warn",
                    message:
                      "adts skiping bytes " +
                      e +
                      " to " +
                      t +
                      " in frame " +
                      c +
                      " outside syncword",
                  });
                }),
                (this.push = function (e) {
                  var t,
                    n,
                    i,
                    r,
                    a,
                    s,
                    o = 0;
                  if ((l || (c = 0), "audio" === e.type)) {
                    for (
                      u && u.length
                        ? ((i = u),
                          (u = new Uint8Array(
                            i.byteLength + e.data.byteLength
                          )).set(i),
                          u.set(e.data, i.byteLength))
                        : (u = e.data);
                      o + 7 < u.length;

                    )
                      if (255 === u[o] && 240 == (246 & u[o + 1])) {
                        if (
                          ("number" == typeof s &&
                            (this.skipWarn_(s, o), (s = null)),
                          (n = 2 * (1 & ~u[o + 1])),
                          (t =
                            ((3 & u[o + 3]) << 11) |
                            (u[o + 4] << 3) |
                            ((224 & u[o + 5]) >> 5)),
                          (a =
                            ((r = 1024 * (1 + (3 & u[o + 6]))) * lt) /
                            ut[(60 & u[o + 2]) >>> 2]),
                          u.byteLength - o < t)
                        )
                          break;
                        this.trigger("data", {
                          pts: e.pts + c * a,
                          dts: e.dts + c * a,
                          sampleCount: r,
                          audioobjecttype: 1 + ((u[o + 2] >>> 6) & 3),
                          channelcount:
                            ((1 & u[o + 2]) << 2) | ((192 & u[o + 3]) >>> 6),
                          samplerate: ut[(60 & u[o + 2]) >>> 2],
                          samplingfrequencyindex: (60 & u[o + 2]) >>> 2,
                          samplesize: 16,
                          data: u.subarray(o + 7 + n, o + t),
                        }),
                          c++,
                          (o += t);
                      } else "number" != typeof s && (s = o), o++;
                    "number" == typeof s && (this.skipWarn_(s, o), (s = null)),
                      (u = u.subarray(o));
                  }
                }),
                (this.flush = function () {
                  (c = 0), this.trigger("done");
                }),
                (this.reset = function () {
                  (u = void 0), this.trigger("reset");
                }),
                (this.endTimeline = function () {
                  (u = void 0), this.trigger("endedtimeline");
                });
            };
          ct.prototype = new n();
          var dt,
            ht,
            pt = ct,
            mt = function (i) {
              var r = i.byteLength,
                a = 0,
                s = 0;
              (this.length = function () {
                return 8 * r;
              }),
                (this.bitsAvailable = function () {
                  return 8 * r + s;
                }),
                (this.loadWord = function () {
                  var e = i.byteLength - r,
                    t = new Uint8Array(4),
                    n = Math.min(4, r);
                  if (0 === n) throw new Error("no bytes available");
                  t.set(i.subarray(e, e + n)),
                    (a = new DataView(t.buffer).getUint32(0)),
                    (s = 8 * n),
                    (r -= n);
                }),
                (this.skipBits = function (e) {
                  var t;
                  e < s ||
                    ((e -= s),
                    (e -= 8 * (t = Math.floor(e / 8))),
                    (r -= t),
                    this.loadWord()),
                    (a <<= e),
                    (s -= e);
                }),
                (this.readBits = function (e) {
                  var t = Math.min(s, e),
                    n = a >>> (32 - t);
                  return (
                    0 < (s -= t) ? (a <<= t) : 0 < r && this.loadWord(),
                    0 < (t = e - t) ? (n << t) | this.readBits(t) : n
                  );
                }),
                (this.skipLeadingZeros = function () {
                  for (var e = 0; e < s; ++e)
                    if (0 != (a & (2147483648 >>> e)))
                      return (a <<= e), (s -= e), e;
                  return this.loadWord(), e + this.skipLeadingZeros();
                }),
                (this.skipUnsignedExpGolomb = function () {
                  this.skipBits(1 + this.skipLeadingZeros());
                }),
                (this.skipExpGolomb = function () {
                  this.skipBits(1 + this.skipLeadingZeros());
                }),
                (this.readUnsignedExpGolomb = function () {
                  var e = this.skipLeadingZeros();
                  return this.readBits(e + 1) - 1;
                }),
                (this.readExpGolomb = function () {
                  var e = this.readUnsignedExpGolomb();
                  return 1 & e ? (1 + e) >>> 1 : -1 * (e >>> 1);
                }),
                (this.readBoolean = function () {
                  return 1 === this.readBits(1);
                }),
                (this.readUnsignedByte = function () {
                  return this.readBits(8);
                }),
                this.loadWord();
            },
            I = function () {
              var i,
                r,
                a = 0;
              I.prototype.init.call(this),
                (this.push = function (e) {
                  for (
                    var t,
                      n = (r = r
                        ? ((t = new Uint8Array(
                            r.byteLength + e.data.byteLength
                          )).set(r),
                          t.set(e.data, r.byteLength),
                          t)
                        : e.data).byteLength;
                    a < n - 3;
                    a++
                  )
                    if (1 === r[a + 2]) {
                      i = a + 5;
                      break;
                    }
                  for (; i < n; )
                    switch (r[i]) {
                      case 0:
                        if (0 !== r[i - 1]) {
                          i += 2;
                          break;
                        }
                        if (0 !== r[i - 2]) {
                          i++;
                          break;
                        }
                        for (
                          a + 3 !== i - 2 &&
                          this.trigger("data", r.subarray(a + 3, i - 2));
                          1 !== r[++i] && i < n;

                        );
                        (a = i - 2), (i += 3);
                        break;
                      case 1:
                        if (0 !== r[i - 1] || 0 !== r[i - 2]) {
                          i += 3;
                          break;
                        }
                        this.trigger("data", r.subarray(a + 3, i - 2)),
                          (a = i - 2),
                          (i += 3);
                        break;
                      default:
                        i += 3;
                    }
                  (r = r.subarray(a)), (i -= a), (a = 0);
                }),
                (this.reset = function () {
                  (r = null), (a = 0), this.trigger("reset");
                }),
                (this.flush = function () {
                  r &&
                    3 < r.byteLength &&
                    this.trigger("data", r.subarray(a + 3)),
                    (r = null),
                    (a = 0),
                    this.trigger("done");
                }),
                (this.endTimeline = function () {
                  this.flush(), this.trigger("endedtimeline");
                });
            };
          (I.prototype = new n()),
            (ht = {
              100: !0,
              110: !0,
              122: !0,
              244: !0,
              44: !0,
              83: !0,
              86: !0,
              118: !0,
              128: !0,
              138: !0,
              139: !0,
              134: !0,
            }),
            ((dt = function () {
              var n,
                i,
                r,
                a,
                s,
                o,
                f,
                t = new I();
              dt.prototype.init.call(this),
                ((n = this).push = function (e) {
                  "video" === e.type &&
                    ((i = e.trackId), (r = e.pts), (a = e.dts), t.push(e));
                }),
                t.on("data", function (e) {
                  var t = {
                    trackId: i,
                    pts: r,
                    dts: a,
                    data: e,
                    nalUnitTypeCode: 31 & e[0],
                  };
                  switch (t.nalUnitTypeCode) {
                    case 5:
                      t.nalUnitType =
                        "slice_layer_without_partitioning_rbsp_idr";
                      break;
                    case 6:
                      (t.nalUnitType = "sei_rbsp"),
                        (t.escapedRBSP = s(e.subarray(1)));
                      break;
                    case 7:
                      (t.nalUnitType = "seq_parameter_set_rbsp"),
                        (t.escapedRBSP = s(e.subarray(1))),
                        (t.config = o(t.escapedRBSP));
                      break;
                    case 8:
                      t.nalUnitType = "pic_parameter_set_rbsp";
                      break;
                    case 9:
                      t.nalUnitType = "access_unit_delimiter_rbsp";
                  }
                  n.trigger("data", t);
                }),
                t.on("done", function () {
                  n.trigger("done");
                }),
                t.on("partialdone", function () {
                  n.trigger("partialdone");
                }),
                t.on("reset", function () {
                  n.trigger("reset");
                }),
                t.on("endedtimeline", function () {
                  n.trigger("endedtimeline");
                }),
                (this.flush = function () {
                  t.flush();
                }),
                (this.partialFlush = function () {
                  t.partialFlush();
                }),
                (this.reset = function () {
                  t.reset();
                }),
                (this.endTimeline = function () {
                  t.endTimeline();
                }),
                (f = function (e, t) {
                  for (var n = 8, i = 8, r = 0; r < e; r++)
                    n =
                      0 ===
                      (i = 0 !== i ? (n + t.readExpGolomb() + 256) % 256 : i)
                        ? n
                        : i;
                }),
                (s = function (e) {
                  for (var t = e.byteLength, n = [], i = 1; i < t - 2; )
                    0 === e[i] && 0 === e[i + 1] && 3 === e[i + 2]
                      ? (n.push(i + 2), (i += 2))
                      : i++;
                  if (0 === n.length) return e;
                  for (
                    var r = t - n.length, a = new Uint8Array(r), s = 0, i = 0;
                    i < r;
                    s++, i++
                  )
                    s === n[0] && (s++, n.shift()), (a[i] = e[s]);
                  return a;
                }),
                (o = function (e) {
                  var t,
                    n,
                    i,
                    r,
                    a,
                    s = 0,
                    o = 0,
                    l = 0,
                    u = 0,
                    c = [1, 1],
                    d = new mt(e),
                    h = d.readUnsignedByte(),
                    p = d.readUnsignedByte(),
                    m = d.readUnsignedByte();
                  if (
                    (d.skipUnsignedExpGolomb(),
                    ht[h] &&
                      (3 === (n = d.readUnsignedExpGolomb()) && d.skipBits(1),
                      d.skipUnsignedExpGolomb(),
                      d.skipUnsignedExpGolomb(),
                      d.skipBits(1),
                      d.readBoolean()))
                  )
                    for (r = 3 !== n ? 8 : 12, a = 0; a < r; a++)
                      d.readBoolean() && f(a < 6 ? 16 : 64, d);
                  if (
                    (d.skipUnsignedExpGolomb(),
                    0 === (i = d.readUnsignedExpGolomb()))
                  )
                    d.readUnsignedExpGolomb();
                  else if (1 === i)
                    for (
                      d.skipBits(1),
                        d.skipExpGolomb(),
                        d.skipExpGolomb(),
                        t = d.readUnsignedExpGolomb(),
                        a = 0;
                      a < t;
                      a++
                    )
                      d.skipExpGolomb();
                  if (
                    (d.skipUnsignedExpGolomb(),
                    d.skipBits(1),
                    (e = d.readUnsignedExpGolomb()),
                    (n = d.readUnsignedExpGolomb()),
                    0 === (i = d.readBits(1)) && d.skipBits(1),
                    d.skipBits(1),
                    d.readBoolean() &&
                      ((s = d.readUnsignedExpGolomb()),
                      (o = d.readUnsignedExpGolomb()),
                      (l = d.readUnsignedExpGolomb()),
                      (u = d.readUnsignedExpGolomb())),
                    d.readBoolean() && d.readBoolean())
                  ) {
                    switch (d.readUnsignedByte()) {
                      case 1:
                        c = [1, 1];
                        break;
                      case 2:
                        c = [12, 11];
                        break;
                      case 3:
                        c = [10, 11];
                        break;
                      case 4:
                        c = [16, 11];
                        break;
                      case 5:
                        c = [40, 33];
                        break;
                      case 6:
                        c = [24, 11];
                        break;
                      case 7:
                        c = [20, 11];
                        break;
                      case 8:
                        c = [32, 11];
                        break;
                      case 9:
                        c = [80, 33];
                        break;
                      case 10:
                        c = [18, 11];
                        break;
                      case 11:
                        c = [15, 11];
                        break;
                      case 12:
                        c = [64, 33];
                        break;
                      case 13:
                        c = [160, 99];
                        break;
                      case 14:
                        c = [4, 3];
                        break;
                      case 15:
                        c = [3, 2];
                        break;
                      case 16:
                        c = [2, 1];
                        break;
                      case 255:
                        c = [
                          (d.readUnsignedByte() << 8) | d.readUnsignedByte(),
                          (d.readUnsignedByte() << 8) | d.readUnsignedByte(),
                        ];
                    }
                    c && (c[0], c[1]);
                  }
                  return {
                    profileIdc: h,
                    levelIdc: m,
                    profileCompatibility: p,
                    width: 16 * (e + 1) - 2 * s - 2 * o,
                    height: (2 - i) * (n + 1) * 16 - 2 * l - 2 * u,
                    sarRatio: c,
                  };
                });
            }).prototype = new n());
          function ft(e, t) {
            var n =
              0 <=
              (n =
                (e[t + 6] << 21) |
                (e[t + 7] << 14) |
                (e[t + 8] << 7) |
                e[t + 9])
                ? n
                : 0;
            return (16 & e[t + 5]) >> 4 ? n + 20 : n + 10;
          }
          function gt(e, t) {
            return e.length - t < 10 ||
              e[t] !== "I".charCodeAt(0) ||
              e[t + 1] !== "D".charCodeAt(0) ||
              e[t + 2] !== "3".charCodeAt(0)
              ? t
              : gt(e, (t += ft(e, t)));
          }
          function bt(e) {
            return (e[0] << 21) | (e[1] << 14) | (e[2] << 7) | e[3];
          }
          var e = { H264Stream: dt, NalByteStream: I },
            vt = [
              96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3,
              11025, 8e3, 7350,
            ],
            yt = {
              isLikelyAacData: function (e) {
                var t = gt(e, 0);
                return (
                  e.length >= t + 2 &&
                  255 == (255 & e[t]) &&
                  240 == (240 & e[t + 1]) &&
                  16 == (22 & e[t + 1])
                );
              },
              parseId3TagSize: ft,
              parseAdtsSize: function (e, t) {
                var n = (224 & e[t + 5]) >> 5,
                  i = e[t + 4] << 3;
                return (6144 & e[t + 3]) | i | n;
              },
              parseType: function (e, t) {
                return e[t] === "I".charCodeAt(0) &&
                  e[t + 1] === "D".charCodeAt(0) &&
                  e[t + 2] === "3".charCodeAt(0)
                  ? "timed-metadata"
                  : !0 & e[t] && 240 == (240 & e[t + 1])
                  ? "audio"
                  : null;
              },
              parseSampleRate: function (e) {
                for (var t = 0; t + 5 < e.length; ) {
                  if (255 === e[t] && 240 == (246 & e[t + 1]))
                    return vt[(60 & e[t + 2]) >>> 2];
                  t++;
                }
                return null;
              },
              parseAacTimestamp: function (e) {
                var t,
                  n = 10;
                64 & e[5] && ((n += 4), (n += bt(e.subarray(10, 14))));
                do {
                  if ((t = bt(e.subarray(n + 4, n + 8))) < 1) return null;
                  if (
                    "PRIV" ===
                    String.fromCharCode(e[n], e[n + 1], e[n + 2], e[n + 3])
                  )
                    for (
                      var i = e.subarray(n + 10, n + t + 10), r = 0;
                      r < i.byteLength;
                      r++
                    )
                      if (0 === i[r]) {
                        if (
                          "com.apple.streaming.transportStreamTimestamp" !==
                          unescape(
                            (function (e, t, n) {
                              for (var i = "", r = t; r < n; r++)
                                i += "%" + ("00" + e[r].toString(16)).slice(-2);
                              return i;
                            })(i, 0, r)
                          )
                        )
                          break;
                        var a = i.subarray(r + 1),
                          s =
                            ((1 & a[3]) << 30) |
                            (a[4] << 22) |
                            (a[5] << 14) |
                            (a[6] << 6) |
                            (a[7] >>> 2);
                        return (s *= 4), (s += 3 & a[7]);
                      }
                } while (((n += 10), (n += t) < e.byteLength));
                return null;
              },
            },
            _t = function () {
              var a = new Uint8Array(),
                s = 0;
              _t.prototype.init.call(this),
                (this.setTimestamp = function (e) {
                  s = e;
                }),
                (this.push = function (e) {
                  var t,
                    n,
                    i = 0,
                    r = 0;
                  for (
                    a.length
                      ? ((n = a.length),
                        (a = new Uint8Array(e.byteLength + n)).set(
                          a.subarray(0, n)
                        ),
                        a.set(e, n))
                      : (a = e);
                    3 <= a.length - r;

                  )
                    if (
                      a[r] !== "I".charCodeAt(0) ||
                      a[r + 1] !== "D".charCodeAt(0) ||
                      a[r + 2] !== "3".charCodeAt(0)
                    )
                      if (255 != (255 & a[r]) || 240 != (240 & a[r + 1])) r++;
                      else {
                        if (a.length - r < 7) break;
                        if (r + (i = yt.parseAdtsSize(a, r)) > a.length) break;
                        (t = {
                          type: "audio",
                          data: a.subarray(r, r + i),
                          pts: s,
                          dts: s,
                        }),
                          this.trigger("data", t),
                          (r += i);
                      }
                    else {
                      if (a.length - r < 10) break;
                      if (r + (i = yt.parseId3TagSize(a, r)) > a.length) break;
                      (t = {
                        type: "timed-metadata",
                        data: a.subarray(r, r + i),
                      }),
                        this.trigger("data", t),
                        (r += i);
                    }
                  (e = a.length - r),
                    (a = 0 < e ? a.subarray(r) : new Uint8Array());
                }),
                (this.reset = function () {
                  (a = new Uint8Array()), this.trigger("reset");
                }),
                (this.endTimeline = function () {
                  (a = new Uint8Array()), this.trigger("endedtimeline");
                });
            };
          _t.prototype = new n();
          function Tt(e, t) {
            (t.stream = e), this.trigger("log", t);
          }
          function Ot(e, t) {
            for (var n = Object.keys(t), i = 0; i < n.length; i++) {
              var r = n[i];
              "headOfPipeline" !== r &&
                t[r].on &&
                t[r].on("log", Tt.bind(e, r));
            }
          }
          function St(e, t) {
            var n;
            if (e.length === t.length) {
              for (n = 0; n < e.length; n++) if (e[n] !== t[n]) return;
              return 1;
            }
          }
          function At(e, t, n, i, r, a) {
            return {
              start: { dts: e, pts: e + (n - t) },
              end: { dts: e + (i - t), pts: e + (r - n) },
              prependedContentDuration: a,
              baseMediaDecodeTime: e,
            };
          }
          var wt,
            Ct,
            x,
            It = _t,
            xt = [
              "audioobjecttype",
              "channelcount",
              "samplerate",
              "samplingfrequencyindex",
              "samplesize",
            ],
            Et = [
              "width",
              "height",
              "profileIdc",
              "levelIdc",
              "profileCompatibility",
              "sarRatio",
            ],
            kt = e.H264Stream,
            Pt = yt.isLikelyAacData,
            jt = h,
            E = function (a, s) {
              var o = [],
                l = 0,
                u = 0,
                c = 1 / 0,
                d = (s = s || {}).firstSequenceNumber || 0;
              E.prototype.init.call(this),
                (this.push = function (t) {
                  We(a, t),
                    a &&
                      xt.forEach(function (e) {
                        a[e] = t[e];
                      }),
                    o.push(t);
                }),
                (this.setEarliestDts = function (e) {
                  l = e;
                }),
                (this.setVideoBaseMediaDecodeTime = function (e) {
                  c = e;
                }),
                (this.setAudioAppendStart = function (e) {
                  u = e;
                }),
                (this.flush = function () {
                  var e, t, n, i, r;
                  0 !== o.length &&
                    ((e = Fe(o, a, l)),
                    (a.baseMediaDecodeTime = He(a, s.keepOriginalTimestamps)),
                    (r = Ve(a, e, u, c)),
                    (a.samples = Ge(e)),
                    (t = Se(qe(e))),
                    (o = []),
                    (i = Ae(d, [a])),
                    (n = new Uint8Array(i.byteLength + t.byteLength)),
                    d++,
                    n.set(i),
                    n.set(t, i.byteLength),
                    p(a),
                    (i = Math.ceil((1024 * jt) / a.samplerate)),
                    e.length &&
                      ((i = e.length * i),
                      this.trigger(
                        "segmentTimingInfo",
                        At(
                          Re(a.baseMediaDecodeTime, a.samplerate),
                          e[0].dts,
                          e[0].pts,
                          e[0].dts + i,
                          e[0].pts + i,
                          r || 0
                        )
                      ),
                      this.trigger("timingInfo", {
                        start: e[0].pts,
                        end: e[0].pts + i,
                      })),
                    this.trigger("data", { track: a, boxes: n })),
                    this.trigger("done", "AudioSegmentStream");
                }),
                (this.reset = function () {
                  p(a), (o = []), this.trigger("reset");
                });
            };
          (E.prototype = new n()),
            ((wt = function (s, a) {
              var t,
                n,
                o = [],
                u = [],
                l = (a = a || {}).firstSequenceNumber || 0;
              wt.prototype.init.call(this),
                delete s.minPTS,
                (this.gopCache_ = []),
                (this.push = function (e) {
                  We(s, e),
                    "seq_parameter_set_rbsp" !== e.nalUnitType ||
                      t ||
                      ((t = e.config),
                      (s.sps = [e.data]),
                      Et.forEach(function (e) {
                        s[e] = t[e];
                      }, this)),
                    "pic_parameter_set_rbsp" !== e.nalUnitType ||
                      n ||
                      ((n = e.data), (s.pps = [e.data])),
                    o.push(e);
                }),
                (this.flush = function () {
                  for (
                    var e, t, n, i = 0;
                    o.length &&
                    "access_unit_delimiter_rbsp" !== o[0].nalUnitType;

                  )
                    o.shift();
                  if (0 === o.length)
                    return (
                      this.resetStream_(),
                      void this.trigger("done", "VideoSegmentStream")
                    );
                  if (
                    ((e = Ce(o)),
                    (t = Ie(e))[0][0].keyFrame ||
                      ((n = this.getGopForFusion_(o[0], s))
                        ? ((i = n.duration),
                          t.unshift(n),
                          (t.byteLength += n.byteLength),
                          (t.nalCount += n.nalCount),
                          (t.pts = n.pts),
                          (t.dts = n.dts),
                          (t.duration += n.duration))
                        : (t = xe(t))),
                    u.length)
                  ) {
                    var r = a.alignGopsAtEnd
                      ? this.alignGopsAtEnd_(t)
                      : this.alignGopsAtStart_(t);
                    if (!r)
                      return (
                        this.gopCache_.unshift({
                          gop: t.pop(),
                          pps: s.pps,
                          sps: s.sps,
                        }),
                        (this.gopCache_.length = Math.min(
                          6,
                          this.gopCache_.length
                        )),
                        (o = []),
                        this.resetStream_(),
                        void this.trigger("done", "VideoSegmentStream")
                      );
                    p(s), (t = r);
                  }
                  We(s, t),
                    (s.samples = Ee(t)),
                    (e = Se(ke(t))),
                    (s.baseMediaDecodeTime = He(s, a.keepOriginalTimestamps)),
                    this.trigger(
                      "processedGopsInfo",
                      t.map(function (e) {
                        return {
                          pts: e.pts,
                          dts: e.dts,
                          byteLength: e.byteLength,
                        };
                      })
                    ),
                    (n = t[0]),
                    (r = t[t.length - 1]),
                    this.trigger(
                      "segmentTimingInfo",
                      At(
                        s.baseMediaDecodeTime,
                        n.dts,
                        n.pts,
                        r.dts + r.duration,
                        r.pts + r.duration,
                        i
                      )
                    ),
                    this.trigger("timingInfo", {
                      start: t[0].pts,
                      end: t[t.length - 1].pts + t[t.length - 1].duration,
                    }),
                    this.gopCache_.unshift({
                      gop: t.pop(),
                      pps: s.pps,
                      sps: s.sps,
                    }),
                    (this.gopCache_.length = Math.min(
                      6,
                      this.gopCache_.length
                    )),
                    (o = []),
                    this.trigger("baseMediaDecodeTime", s.baseMediaDecodeTime),
                    this.trigger("timelineStartInfo", s.timelineStartInfo),
                    (i = Ae(l, [s])),
                    (t = new Uint8Array(i.byteLength + e.byteLength)),
                    l++,
                    t.set(i),
                    t.set(e, i.byteLength),
                    this.trigger("data", { track: s, boxes: t }),
                    this.resetStream_(),
                    this.trigger("done", "VideoSegmentStream");
                }),
                (this.reset = function () {
                  this.resetStream_(),
                    (o = []),
                    (this.gopCache_.length = 0),
                    (u.length = 0),
                    this.trigger("reset");
                }),
                (this.resetStream_ = function () {
                  p(s), (n = t = void 0);
                }),
                (this.getGopForFusion_ = function (e) {
                  for (
                    var t, n, i, r = 1 / 0, a = 0;
                    a < this.gopCache_.length;
                    a++
                  )
                    (n = (i = this.gopCache_[a]).gop),
                      s.pps &&
                        St(s.pps[0], i.pps[0]) &&
                        s.sps &&
                        St(s.sps[0], i.sps[0]) &&
                        (n.dts < s.timelineStartInfo.dts ||
                          (-1e4 <= (n = e.dts - n.dts - n.duration) &&
                            n <= 45e3 &&
                            (!t || n < r) &&
                            ((t = i), (r = n))));
                  return t ? t.gop : null;
                }),
                (this.alignGopsAtStart_ = function (e) {
                  for (
                    var t,
                      n,
                      i,
                      r,
                      a = e.byteLength,
                      s = e.nalCount,
                      o = e.duration,
                      l = (t = 0);
                    l < u.length &&
                    t < e.length &&
                    ((n = u[l]), (i = e[t]), n.pts !== i.pts);

                  )
                    i.pts > n.pts
                      ? l++
                      : (t++,
                        (a -= i.byteLength),
                        (s -= i.nalCount),
                        (o -= i.duration));
                  return 0 === t
                    ? e
                    : t === e.length
                    ? null
                    : (((r = e.slice(t)).byteLength = a),
                      (r.duration = o),
                      (r.nalCount = s),
                      (r.pts = r[0].pts),
                      (r.dts = r[0].dts),
                      r);
                }),
                (this.alignGopsAtEnd_ = function (e) {
                  for (
                    var t,
                      n,
                      i = u.length - 1,
                      r = e.length - 1,
                      a = null,
                      s = !1;
                    0 <= i && 0 <= r;

                  ) {
                    if (((t = u[i]), (n = e[r]), t.pts === n.pts)) {
                      s = !0;
                      break;
                    }
                    t.pts > n.pts ? i-- : (i === u.length - 1 && (a = r), r--);
                  }
                  if (!s && null === a) return null;
                  if (0 === (l = s ? r : a)) return e;
                  var o = e.slice(l),
                    l = o.reduce(
                      function (e, t) {
                        return (
                          (e.byteLength += t.byteLength),
                          (e.duration += t.duration),
                          (e.nalCount += t.nalCount),
                          e
                        );
                      },
                      { byteLength: 0, duration: 0, nalCount: 0 }
                    );
                  return (
                    (o.byteLength = l.byteLength),
                    (o.duration = l.duration),
                    (o.nalCount = l.nalCount),
                    (o.pts = o[0].pts),
                    (o.dts = o[0].dts),
                    o
                  );
                }),
                (this.alignGopsWith = function (e) {
                  u = e;
                });
            }).prototype = new n()),
            ((x = function (e, t) {
              (this.numberOfTracks = 0),
                (this.metadataStream = t),
                "undefined" != typeof (e = e || {}).remux
                  ? (this.remuxTracks = !!e.remux)
                  : (this.remuxTracks = !0),
                "boolean" == typeof e.keepOriginalTimestamps
                  ? (this.keepOriginalTimestamps = e.keepOriginalTimestamps)
                  : (this.keepOriginalTimestamps = !1),
                (this.pendingTracks = []),
                (this.videoTrack = null),
                (this.pendingBoxes = []),
                (this.pendingCaptions = []),
                (this.pendingMetadata = []),
                (this.pendingBytes = 0),
                (this.emittedTracks = 0),
                x.prototype.init.call(this),
                (this.push = function (e) {
                  return e.text
                    ? this.pendingCaptions.push(e)
                    : e.frames
                    ? this.pendingMetadata.push(e)
                    : (this.pendingTracks.push(e.track),
                      (this.pendingBytes += e.boxes.byteLength),
                      "video" === e.track.type &&
                        ((this.videoTrack = e.track),
                        this.pendingBoxes.push(e.boxes)),
                      void (
                        "audio" === e.track.type &&
                        ((this.audioTrack = e.track),
                        this.pendingBoxes.unshift(e.boxes))
                      ));
                });
            }).prototype = new n()),
            (x.prototype.flush = function (e) {
              var t,
                n,
                i,
                r = 0,
                a = {
                  captions: [],
                  captionStreams: {},
                  metadata: [],
                  info: {},
                },
                s = 0;
              if (this.pendingTracks.length < this.numberOfTracks) {
                if ("VideoSegmentStream" !== e && "AudioSegmentStream" !== e)
                  return;
                if (this.remuxTracks) return;
                if (0 === this.pendingTracks.length)
                  return (
                    this.emittedTracks++,
                    void (
                      this.emittedTracks >= this.numberOfTracks &&
                      (this.trigger("done"), (this.emittedTracks = 0))
                    )
                  );
              }
              if (
                (this.videoTrack
                  ? ((s = this.videoTrack.timelineStartInfo.pts),
                    Et.forEach(function (e) {
                      a.info[e] = this.videoTrack[e];
                    }, this))
                  : this.audioTrack &&
                    ((s = this.audioTrack.timelineStartInfo.pts),
                    xt.forEach(function (e) {
                      a.info[e] = this.audioTrack[e];
                    }, this)),
                this.videoTrack || this.audioTrack)
              ) {
                for (
                  1 === this.pendingTracks.length
                    ? (a.type = this.pendingTracks[0].type)
                    : (a.type = "combined"),
                    this.emittedTracks += this.pendingTracks.length,
                    e = we(this.pendingTracks),
                    a.initSegment = new Uint8Array(e.byteLength),
                    a.initSegment.set(e),
                    a.data = new Uint8Array(this.pendingBytes),
                    i = 0;
                  i < this.pendingBoxes.length;
                  i++
                )
                  a.data.set(this.pendingBoxes[i], r),
                    (r += this.pendingBoxes[i].byteLength);
                for (i = 0; i < this.pendingCaptions.length; i++)
                  ((t = this.pendingCaptions[i]).startTime = Ue(
                    t.startPts,
                    s,
                    this.keepOriginalTimestamps
                  )),
                    (t.endTime = Ue(t.endPts, s, this.keepOriginalTimestamps)),
                    (a.captionStreams[t.stream] = !0),
                    a.captions.push(t);
                for (i = 0; i < this.pendingMetadata.length; i++)
                  ((n = this.pendingMetadata[i]).cueTime = Ue(
                    n.pts,
                    s,
                    this.keepOriginalTimestamps
                  )),
                    a.metadata.push(n);
                for (
                  a.metadata.dispatchType = this.metadataStream.dispatchType,
                    this.pendingTracks.length = 0,
                    this.videoTrack = null,
                    this.pendingBoxes.length = 0,
                    this.pendingCaptions.length = 0,
                    this.pendingBytes = 0,
                    this.pendingMetadata.length = 0,
                    this.trigger("data", a),
                    i = 0;
                  i < a.captions.length;
                  i++
                )
                  (t = a.captions[i]), this.trigger("caption", t);
                for (i = 0; i < a.metadata.length; i++)
                  (n = a.metadata[i]), this.trigger("id3Frame", n);
              }
              this.emittedTracks >= this.numberOfTracks &&
                (this.trigger("done"), (this.emittedTracks = 0));
            }),
            (x.prototype.setRemux = function (e) {
              this.remuxTracks = e;
            }),
            ((Ct = function (i) {
              var r,
                a,
                s = this,
                n = !0;
              Ct.prototype.init.call(this),
                (this.baseMediaDecodeTime =
                  (i = i || {}).baseMediaDecodeTime || 0),
                (this.transmuxPipeline_ = {}),
                (this.setupAacPipeline = function () {
                  var t = {};
                  ((this.transmuxPipeline_ = t).type = "aac"),
                    (t.metadataStream = new C.MetadataStream()),
                    (t.aacStream = new It()),
                    (t.audioTimestampRolloverStream =
                      new C.TimestampRolloverStream("audio")),
                    (t.timedMetadataTimestampRolloverStream =
                      new C.TimestampRolloverStream("timed-metadata")),
                    (t.adtsStream = new pt()),
                    (t.coalesceStream = new x(i, t.metadataStream)),
                    (t.headOfPipeline = t.aacStream),
                    t.aacStream
                      .pipe(t.audioTimestampRolloverStream)
                      .pipe(t.adtsStream),
                    t.aacStream
                      .pipe(t.timedMetadataTimestampRolloverStream)
                      .pipe(t.metadataStream)
                      .pipe(t.coalesceStream),
                    t.metadataStream.on("timestamp", function (e) {
                      t.aacStream.setTimestamp(e.timeStamp);
                    }),
                    t.aacStream.on("data", function (e) {
                      ("timed-metadata" !== e.type && "audio" !== e.type) ||
                        t.audioSegmentStream ||
                        ((a = a || {
                          timelineStartInfo: {
                            baseMediaDecodeTime: s.baseMediaDecodeTime,
                          },
                          codec: "adts",
                          type: "audio",
                        }),
                        t.coalesceStream.numberOfTracks++,
                        (t.audioSegmentStream = new E(a, i)),
                        t.audioSegmentStream.on(
                          "log",
                          s.getLogTrigger_("audioSegmentStream")
                        ),
                        t.audioSegmentStream.on(
                          "timingInfo",
                          s.trigger.bind(s, "audioTimingInfo")
                        ),
                        t.adtsStream
                          .pipe(t.audioSegmentStream)
                          .pipe(t.coalesceStream),
                        s.trigger("trackinfo", {
                          hasAudio: !!a,
                          hasVideo: !!r,
                        }));
                    }),
                    t.coalesceStream.on(
                      "data",
                      this.trigger.bind(this, "data")
                    ),
                    t.coalesceStream.on(
                      "done",
                      this.trigger.bind(this, "done")
                    ),
                    Ot(this, t);
                }),
                (this.setupTsPipeline = function () {
                  var n = {};
                  ((this.transmuxPipeline_ = n).type = "ts"),
                    (n.metadataStream = new C.MetadataStream()),
                    (n.packetStream = new C.TransportPacketStream()),
                    (n.parseStream = new C.TransportParseStream()),
                    (n.elementaryStream = new C.ElementaryStream()),
                    (n.timestampRolloverStream =
                      new C.TimestampRolloverStream()),
                    (n.adtsStream = new pt()),
                    (n.h264Stream = new kt()),
                    (n.captionStream = new C.CaptionStream(i)),
                    (n.coalesceStream = new x(i, n.metadataStream)),
                    (n.headOfPipeline = n.packetStream),
                    n.packetStream
                      .pipe(n.parseStream)
                      .pipe(n.elementaryStream)
                      .pipe(n.timestampRolloverStream),
                    n.timestampRolloverStream.pipe(n.h264Stream),
                    n.timestampRolloverStream.pipe(n.adtsStream),
                    n.timestampRolloverStream
                      .pipe(n.metadataStream)
                      .pipe(n.coalesceStream),
                    n.h264Stream.pipe(n.captionStream).pipe(n.coalesceStream),
                    n.elementaryStream.on("data", function (e) {
                      var t;
                      if ("metadata" === e.type) {
                        for (t = e.tracks.length; t--; )
                          r || "video" !== e.tracks[t].type
                            ? a ||
                              "audio" !== e.tracks[t].type ||
                              ((a =
                                e.tracks[
                                  t
                                ]).timelineStartInfo.baseMediaDecodeTime =
                                s.baseMediaDecodeTime)
                            : ((r =
                                e.tracks[
                                  t
                                ]).timelineStartInfo.baseMediaDecodeTime =
                                s.baseMediaDecodeTime);
                        r &&
                          !n.videoSegmentStream &&
                          (n.coalesceStream.numberOfTracks++,
                          (n.videoSegmentStream = new wt(r, i)),
                          n.videoSegmentStream.on(
                            "log",
                            s.getLogTrigger_("videoSegmentStream")
                          ),
                          n.videoSegmentStream.on(
                            "timelineStartInfo",
                            function (e) {
                              a &&
                                !i.keepOriginalTimestamps &&
                                ((a.timelineStartInfo = e),
                                n.audioSegmentStream.setEarliestDts(
                                  e.dts - s.baseMediaDecodeTime
                                ));
                            }
                          ),
                          n.videoSegmentStream.on(
                            "processedGopsInfo",
                            s.trigger.bind(s, "gopInfo")
                          ),
                          n.videoSegmentStream.on(
                            "segmentTimingInfo",
                            s.trigger.bind(s, "videoSegmentTimingInfo")
                          ),
                          n.videoSegmentStream.on(
                            "baseMediaDecodeTime",
                            function (e) {
                              a &&
                                n.audioSegmentStream.setVideoBaseMediaDecodeTime(
                                  e
                                );
                            }
                          ),
                          n.videoSegmentStream.on(
                            "timingInfo",
                            s.trigger.bind(s, "videoTimingInfo")
                          ),
                          n.h264Stream
                            .pipe(n.videoSegmentStream)
                            .pipe(n.coalesceStream)),
                          a &&
                            !n.audioSegmentStream &&
                            (n.coalesceStream.numberOfTracks++,
                            (n.audioSegmentStream = new E(a, i)),
                            n.audioSegmentStream.on(
                              "log",
                              s.getLogTrigger_("audioSegmentStream")
                            ),
                            n.audioSegmentStream.on(
                              "timingInfo",
                              s.trigger.bind(s, "audioTimingInfo")
                            ),
                            n.audioSegmentStream.on(
                              "segmentTimingInfo",
                              s.trigger.bind(s, "audioSegmentTimingInfo")
                            ),
                            n.adtsStream
                              .pipe(n.audioSegmentStream)
                              .pipe(n.coalesceStream)),
                          s.trigger("trackinfo", {
                            hasAudio: !!a,
                            hasVideo: !!r,
                          });
                      }
                    }),
                    n.coalesceStream.on(
                      "data",
                      this.trigger.bind(this, "data")
                    ),
                    n.coalesceStream.on("id3Frame", function (e) {
                      (e.dispatchType = n.metadataStream.dispatchType),
                        s.trigger("id3Frame", e);
                    }),
                    n.coalesceStream.on(
                      "caption",
                      this.trigger.bind(this, "caption")
                    ),
                    n.coalesceStream.on(
                      "done",
                      this.trigger.bind(this, "done")
                    ),
                    Ot(this, n);
                }),
                (this.setBaseMediaDecodeTime = function (e) {
                  var t = this.transmuxPipeline_;
                  i.keepOriginalTimestamps || (this.baseMediaDecodeTime = e),
                    a &&
                      ((a.timelineStartInfo.dts = void 0),
                      (a.timelineStartInfo.pts = void 0),
                      p(a),
                      t.audioTimestampRolloverStream &&
                        t.audioTimestampRolloverStream.discontinuity()),
                    r &&
                      (t.videoSegmentStream &&
                        (t.videoSegmentStream.gopCache_ = []),
                      (r.timelineStartInfo.dts = void 0),
                      (r.timelineStartInfo.pts = void 0),
                      p(r),
                      t.captionStream.reset()),
                    t.timestampRolloverStream &&
                      t.timestampRolloverStream.discontinuity();
                }),
                (this.setAudioAppendStart = function (e) {
                  a &&
                    this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(
                      e
                    );
                }),
                (this.setRemux = function (e) {
                  var t = this.transmuxPipeline_;
                  (i.remux = e),
                    t && t.coalesceStream && t.coalesceStream.setRemux(e);
                }),
                (this.alignGopsWith = function (e) {
                  r &&
                    this.transmuxPipeline_.videoSegmentStream &&
                    this.transmuxPipeline_.videoSegmentStream.alignGopsWith(e);
                }),
                (this.getLogTrigger_ = function (t) {
                  var n = this;
                  return function (e) {
                    (e.stream = t), n.trigger("log", e);
                  };
                }),
                (this.push = function (e) {
                  var t;
                  n &&
                    ((t = Pt(e)) && "aac" !== this.transmuxPipeline_.type
                      ? this.setupAacPipeline()
                      : t ||
                        "ts" === this.transmuxPipeline_.type ||
                        this.setupTsPipeline(),
                    (n = !1)),
                    this.transmuxPipeline_.headOfPipeline.push(e);
                }),
                (this.flush = function () {
                  (n = !0), this.transmuxPipeline_.headOfPipeline.flush();
                }),
                (this.endTimeline = function () {
                  this.transmuxPipeline_.headOfPipeline.endTimeline();
                }),
                (this.reset = function () {
                  this.transmuxPipeline_.headOfPipeline &&
                    this.transmuxPipeline_.headOfPipeline.reset();
                }),
                (this.resetCaptions = function () {
                  this.transmuxPipeline_.captionStream &&
                    this.transmuxPipeline_.captionStream.reset();
                });
            }).prototype = new n());
          function Nt(e, c) {
            var n = P(e, ["moof", "traf"]),
              e = P(e, ["mdat"]),
              d = {},
              i = [];
            return (
              e.forEach(function (e, t) {
                t = n[t];
                i.push({ mdat: e, traf: t });
              }),
              i.forEach(function (e) {
                var t,
                  n,
                  i,
                  r,
                  a,
                  s = e.mdat,
                  o = e.traf,
                  l = P(o, ["tfhd"]),
                  u = Ht(l[0]),
                  e = u.trackId,
                  l = P(o, ["tfdt"]),
                  l = 0 < l.length ? Gt(l[0]).baseMediaDecodeTime : 0,
                  o = P(o, ["trun"]);
                c === e &&
                  0 < o.length &&
                  ((o = o),
                  (t = l),
                  (n = (u = u).defaultSampleDuration || 0),
                  (i = u.defaultSampleSize || 0),
                  (r = u.trackId),
                  (a = []),
                  o.forEach(function (e) {
                    e = zt(e).samples;
                    e.forEach(function (e) {
                      void 0 === e.duration && (e.duration = n),
                        void 0 === e.size && (e.size = i),
                        (e.trackId = r),
                        (e.dts = t),
                        void 0 === e.compositionTimeOffset &&
                          (e.compositionTimeOffset = 0),
                        "bigint" == typeof t
                          ? ((e.pts = t + Wt.BigInt(e.compositionTimeOffset)),
                            (t += Wt.BigInt(e.duration)))
                          : ((e.pts = t + e.compositionTimeOffset),
                            (t += e.duration));
                    }),
                      (a = a.concat(e));
                  }),
                  (s = (function (e, t, n) {
                    for (
                      var i,
                        r,
                        a = new DataView(e.buffer, e.byteOffset, e.byteLength),
                        s = { logs: [], seiNals: [] },
                        o = 0;
                      o + 4 < e.length;
                      o += i
                    )
                      if (((i = a.getUint32(o)), (o += 4), !(i <= 0)))
                        switch (31 & e[o]) {
                          case 6:
                            var l = e.subarray(o + 1, o + 1 + i),
                              u = (function (e, t) {
                                for (var n = e, i = 0; i < t.length; i++) {
                                  var r = t[i];
                                  if (n < r.size) return r;
                                  n -= r.size;
                                }
                                return null;
                              })(o, t),
                              l = {
                                nalUnitType: "sei_rbsp",
                                size: i,
                                data: l,
                                escapedRBSP: Xt(l),
                                trackId: n,
                              };
                            if (u) (l.pts = u.pts), (l.dts = u.dts), (r = u);
                            else {
                              if (!r) {
                                s.logs.push({
                                  level: "warn",
                                  message:
                                    "We've encountered a nal unit without data at " +
                                    o +
                                    " for trackId " +
                                    n +
                                    ". See mux.js#223.",
                                });
                                break;
                              }
                              (l.pts = r.pts), (l.dts = r.dts);
                            }
                            s.seiNals.push(l);
                        }
                    return s;
                  })(s, a, e)),
                  d[e] || (d[e] = { seiNals: [], logs: [] }),
                  (d[e].seiNals = d[e].seiNals.concat(s.seiNals)),
                  (d[e].logs = d[e].logs.concat(s.logs)));
              }),
              d
            );
          }
          function Lt(e) {
            var t = 31 & e[1];
            return (t <<= 8), (t |= e[2]);
          }
          function Mt(e) {
            return !!(64 & e[1]);
          }
          function Dt(e) {
            var t = 0;
            return 1 < (48 & e[3]) >>> 4 && (t += e[4] + 1), t;
          }
          function Rt(e) {
            switch (e) {
              case 5:
                return "slice_layer_without_partitioning_rbsp_idr";
              case 6:
                return "sei_rbsp";
              case 7:
                return "seq_parameter_set_rbsp";
              case 8:
                return "pic_parameter_set_rbsp";
              case 9:
                return "access_unit_delimiter_rbsp";
              default:
                return null;
            }
          }
          var Bt = {
              Transmuxer: Ct,
              VideoSegmentStream: wt,
              AudioSegmentStream: E,
              AUDIO_PROPERTIES: xt,
              VIDEO_PROPERTIES: Et,
              generateSegmentTimingInfo: At,
            },
            e = function (e) {
              return e >>> 0;
            },
            k = function (e) {
              var t = "";
              return (
                (t += String.fromCharCode(e[0])),
                (t += String.fromCharCode(e[1])),
                (t += String.fromCharCode(e[2])),
                (t += String.fromCharCode(e[3]))
              );
            },
            Ut = e,
            P = function e(t, n) {
              var i,
                r,
                a,
                s = [];
              if (!n.length) return null;
              for (i = 0; i < t.byteLength; )
                (r = Ut(
                  (t[i] << 24) | (t[i + 1] << 16) | (t[i + 2] << 8) | t[i + 3]
                )),
                  (a = k(t.subarray(i + 4, i + 8))),
                  (r = 1 < r ? i + r : t.byteLength),
                  a === n[0] &&
                    (1 === n.length
                      ? s.push(t.subarray(i + 8, r))
                      : (a = e(t.subarray(i + 8, r), n.slice(1))).length &&
                        (s = s.concat(a))),
                  (i = r);
              return s;
            },
            Vt = e,
            Ft = i.getUint64,
            Gt = function (e) {
              var t = {
                version: e[0],
                flags: new Uint8Array(e.subarray(1, 4)),
              };
              return (
                1 === t.version
                  ? (t.baseMediaDecodeTime = Ft(e.subarray(4)))
                  : (t.baseMediaDecodeTime = Vt(
                      (e[4] << 24) | (e[5] << 16) | (e[6] << 8) | e[7]
                    )),
                t
              );
            },
            qt = function (e) {
              return {
                isLeading: (12 & e[0]) >>> 2,
                dependsOn: 3 & e[0],
                isDependedOn: (192 & e[1]) >>> 6,
                hasRedundancy: (48 & e[1]) >>> 4,
                paddingValue: (14 & e[1]) >>> 1,
                isNonSyncSample: 1 & e[1],
                degradationPriority: (e[2] << 8) | e[3],
              };
            },
            zt = function (e) {
              var t,
                n = {
                  version: e[0],
                  flags: new Uint8Array(e.subarray(1, 4)),
                  samples: [],
                },
                i = new DataView(e.buffer, e.byteOffset, e.byteLength),
                r = 1 & n.flags[2],
                a = 4 & n.flags[2],
                s = 1 & n.flags[1],
                o = 2 & n.flags[1],
                l = 4 & n.flags[1],
                u = 8 & n.flags[1],
                c = i.getUint32(4),
                d = 8;
              for (
                r && ((n.dataOffset = i.getInt32(d)), (d += 4)),
                  a &&
                    c &&
                    ((t = { flags: qt(e.subarray(d, d + 4)) }),
                    (d += 4),
                    s && ((t.duration = i.getUint32(d)), (d += 4)),
                    o && ((t.size = i.getUint32(d)), (d += 4)),
                    u &&
                      (1 === n.version
                        ? (t.compositionTimeOffset = i.getInt32(d))
                        : (t.compositionTimeOffset = i.getUint32(d)),
                      (d += 4)),
                    n.samples.push(t),
                    c--);
                c--;

              )
                (t = {}),
                  s && ((t.duration = i.getUint32(d)), (d += 4)),
                  o && ((t.size = i.getUint32(d)), (d += 4)),
                  l && ((t.flags = qt(e.subarray(d, d + 4))), (d += 4)),
                  u &&
                    (1 === n.version
                      ? (t.compositionTimeOffset = i.getInt32(d))
                      : (t.compositionTimeOffset = i.getUint32(d)),
                    (d += 4)),
                  n.samples.push(t);
              return n;
            },
            Ht = function (e) {
              var t = new DataView(e.buffer, e.byteOffset, e.byteLength),
                n = {
                  version: e[0],
                  flags: new Uint8Array(e.subarray(1, 4)),
                  trackId: t.getUint32(4),
                },
                i = 1 & n.flags[2],
                r = 2 & n.flags[2],
                a = 8 & n.flags[2],
                s = 16 & n.flags[2],
                o = 32 & n.flags[2],
                l = 65536 & n.flags[0],
                u = 131072 & n.flags[0],
                e = 8;
              return (
                i && ((e += 4), (n.baseDataOffset = t.getUint32(12)), (e += 4)),
                r && ((n.sampleDescriptionIndex = t.getUint32(e)), (e += 4)),
                a && ((n.defaultSampleDuration = t.getUint32(e)), (e += 4)),
                s && ((n.defaultSampleSize = t.getUint32(e)), (e += 4)),
                o && (n.defaultSampleFlags = t.getUint32(e)),
                l && (n.durationIsEmpty = !0),
                !i && u && (n.baseDataOffsetIsMoof = !0),
                n
              );
            },
            n =
              "undefined" != typeof globalThis
                ? globalThis
                : "undefined" != typeof window
                ? window
                : "undefined" != typeof global
                ? global
                : "undefined" != typeof self
                ? self
                : {},
            n =
              "undefined" != typeof window
                ? window
                : "undefined" != typeof n
                ? n
                : "undefined" != typeof self
                ? self
                : {},
            Wt = n,
            Xt = Qe,
            Yt = y.CaptionStream,
            Kt = function () {
              var t,
                r,
                a,
                s,
                o,
                n,
                i = !1;
              (this.isInitialized = function () {
                return i;
              }),
                (this.init = function (e) {
                  (t = new Yt()),
                    (i = !0),
                    (n = !!e && e.isPartial),
                    t.on("data", function (e) {
                      (e.startTime = e.startPts / s),
                        (e.endTime = e.endPts / s),
                        o.captions.push(e),
                        (o.captionStreams[e.stream] = !0);
                    }),
                    t.on("log", function (e) {
                      o.logs.push(e);
                    });
                }),
                (this.isNewInit = function (e, t) {
                  return (
                    !(
                      (e && 0 === e.length) ||
                      (t && "object" == typeof t && 0 === Object.keys(t).length)
                    ) &&
                    (a !== e[0] || s !== t[a])
                  );
                }),
                (this.parse = function (e, t, n) {
                  if (!this.isInitialized()) return null;
                  if (!t || !n) return null;
                  if (this.isNewInit(t, n)) (a = t[0]), (s = n[a]);
                  else if (null === a || !s) return r.push(e), null;
                  for (; 0 < r.length; ) {
                    var i = r.shift();
                    this.parse(i, t, n);
                  }
                  return (
                    (e = (function (e, t, n) {
                      if (null === t) return null;
                      t = Nt(e, t)[t] || {};
                      return { seiNals: t.seiNals, logs: t.logs, timescale: n };
                    })(e, a, s)) &&
                      e.logs &&
                      (o.logs = o.logs.concat(e.logs)),
                    null !== e && e.seiNals
                      ? (this.pushNals(e.seiNals), this.flushStream(), o)
                      : o.logs.length
                      ? { logs: o.logs, captions: [], captionStreams: [] }
                      : null
                  );
                }),
                (this.pushNals = function (e) {
                  if (!this.isInitialized() || !e || 0 === e.length)
                    return null;
                  e.forEach(function (e) {
                    t.push(e);
                  });
                }),
                (this.flushStream = function () {
                  if (!this.isInitialized()) return null;
                  n ? t.partialFlush() : t.flush();
                }),
                (this.clearParsedCaptions = function () {
                  (o.captions = []), (o.captionStreams = {}), (o.logs = []);
                }),
                (this.resetCaptionStream = function () {
                  if (!this.isInitialized()) return null;
                  t.reset();
                }),
                (this.clearAllCaptions = function () {
                  this.clearParsedCaptions(), this.resetCaptionStream();
                }),
                (this.reset = function () {
                  (r = []),
                    (s = a = null),
                    o
                      ? this.clearParsedCaptions()
                      : (o = { captions: [], captionStreams: {}, logs: [] }),
                    this.resetCaptionStream();
                }),
                this.reset();
            },
            Qt = e,
            j = function (e) {
              return ("00" + e.toString(16)).slice(-2);
            },
            Zt = i.getUint64,
            n = function (e) {
              return P(e, ["moov", "trak"]).reduce(function (e, t) {
                var n,
                  i,
                  r = P(t, ["tkhd"])[0];
                return r
                  ? ((n = r[0]),
                    (r = Qt(
                      (r[(i = 0 === n ? 12 : 20)] << 24) |
                        (r[1 + i] << 16) |
                        (r[2 + i] << 8) |
                        r[3 + i]
                    )),
                    (t = P(t, ["mdia", "mdhd"])[0])
                      ? ((n = t[0]),
                        (e[r] = Qt(
                          (t[(i = 0 === n ? 12 : 20)] << 24) |
                            (t[1 + i] << 16) |
                            (t[2 + i] << 8) |
                            t[3 + i]
                        )),
                        e)
                      : null)
                  : null;
              }, {});
            },
            Qe = function (a, e) {
              e = P(e, ["moof", "traf"]).reduce(function (e, t) {
                var n,
                  i = P(t, ["tfhd"])[0],
                  r = Qt((i[4] << 24) | (i[5] << 16) | (i[6] << 8) | i[7]),
                  i = a[r] || 9e4,
                  r = P(t, ["tfdt"])[0],
                  t = new DataView(r.buffer, r.byteOffset, r.byteLength),
                  t = 1 === r[0] ? Zt(r.subarray(4, 12)) : t.getUint32(4);
                return (
                  "bigint" == typeof t
                    ? (n = t / Wt.BigInt(i))
                    : "number" != typeof t || isNaN(t) || (n = t / i),
                  (e =
                    (n = n < Number.MAX_SAFE_INTEGER ? Number(n) : n) < e
                      ? n
                      : e)
                );
              }, 1 / 0);
              return "bigint" == typeof e || isFinite(e) ? e : 0;
            },
            e = function (e) {
              var e = P(e, ["moov", "trak"]),
                i = [];
              return (
                e.forEach(function (e) {
                  var t = P(e, ["mdia", "hdlr"]),
                    n = P(e, ["tkhd"]);
                  t.forEach(function (e, t) {
                    (e = k(e.subarray(8, 12))), (t = n[t]);
                    "vide" === e &&
                      ((t =
                        0 ===
                        (t = new DataView(
                          t.buffer,
                          t.byteOffset,
                          t.byteLength
                        )).getUint8(0)
                          ? t.getUint32(12)
                          : t.getUint32(20)),
                      i.push(t));
                  });
                }),
                i
              );
            },
            Jt = function (e) {
              var t = 0 === e[0] ? 12 : 20;
              return Qt(
                (e[t] << 24) | (e[1 + t] << 16) | (e[2 + t] << 8) | e[3 + t]
              );
            },
            i = function (e) {
              var e = P(e, ["moov", "trak"]),
                s = [];
              return (
                e.forEach(function (e) {
                  var t = {},
                    n = P(e, ["tkhd"])[0];
                  n &&
                    ((n = (i = new DataView(
                      n.buffer,
                      n.byteOffset,
                      n.byteLength
                    )).getUint8(0)),
                    (t.id = 0 === n ? i.getUint32(12) : i.getUint32(20)));
                  var i = P(e, ["mdia", "hdlr"])[0];
                  i &&
                    ((a = k(i.subarray(8, 12))),
                    (t.type =
                      "vide" === a ? "video" : "soun" === a ? "audio" : a));
                  var r,
                    a = P(e, ["mdia", "minf", "stbl", "stsd"])[0];
                  a &&
                    ((a = a.subarray(8)),
                    (t.codec = k(a.subarray(4, 8))),
                    (a = P(a, [t.codec])[0]) &&
                      (/^[asm]vc[1-9]$/i.test(t.codec)
                        ? ((r = a.subarray(78)),
                          "avcC" === k(r.subarray(4, 8)) && 11 < r.length
                            ? ((t.codec += "."),
                              (t.codec += j(r[9])),
                              (t.codec += j(r[10])),
                              (t.codec += j(r[11])))
                            : (t.codec = "avc1.4d400d"))
                        : /^mp4[a,v]$/i.test(t.codec)
                        ? ((r = a.subarray(28)),
                          "esds" === k(r.subarray(4, 8)) &&
                          20 < r.length &&
                          0 !== r[19]
                            ? ((t.codec += "." + j(r[19])),
                              (t.codec +=
                                "." + j((r[20] >>> 2) & 63).replace(/^0/, "")))
                            : (t.codec = "mp4a.40.2"))
                        : (t.codec = t.codec.toLowerCase())));
                  e = P(e, ["mdia", "mdhd"])[0];
                  e && (t.timescale = Jt(e)), s.push(t);
                }),
                s
              );
            },
            $t = Qe,
            en = i,
            N = o,
            L = {};
          (L.ts = {
            parseType: function (e, t) {
              e = Lt(e);
              return 0 === e ? "pat" : e === t ? "pmt" : t ? "pes" : null;
            },
            parsePat: function (e) {
              var t = Mt(e),
                n = 4 + Dt(e);
              return t && (n += e[n] + 1), ((31 & e[n + 10]) << 8) | e[n + 11];
            },
            parsePmt: function (e) {
              var t = {},
                n = Mt(e),
                i = 4 + Dt(e);
              if ((n && (i += e[i] + 1), 1 & e[i + 5])) {
                for (
                  var r = 3 + (((15 & e[i + 1]) << 8) | e[i + 2]) - 4,
                    a = 12 + (((15 & e[i + 10]) << 8) | e[i + 11]);
                  a < r;

                ) {
                  var s = i + a;
                  (t[((31 & e[s + 1]) << 8) | e[s + 2]] = e[s]),
                    (a += 5 + (((15 & e[s + 3]) << 8) | e[s + 4]));
                }
                return t;
              }
            },
            parsePayloadUnitStartIndicator: Mt,
            parsePesType: function (e, t) {
              switch (t[Lt(e)]) {
                case _.H264_STREAM_TYPE:
                  return "video";
                case _.ADTS_STREAM_TYPE:
                  return "audio";
                case _.METADATA_STREAM_TYPE:
                  return "timed-metadata";
                default:
                  return null;
              }
            },
            parsePesTime: function (e) {
              if (!Mt(e)) return null;
              var t = 4 + Dt(e);
              if (t >= e.byteLength) return null;
              var n = null,
                i = e[t + 7];
              return (
                192 & i &&
                  (((n = {}).pts =
                    ((14 & e[t + 9]) << 27) |
                    ((255 & e[t + 10]) << 20) |
                    ((254 & e[t + 11]) << 12) |
                    ((255 & e[t + 12]) << 5) |
                    ((254 & e[t + 13]) >>> 3)),
                  (n.pts *= 4),
                  (n.pts += (6 & e[t + 13]) >>> 1),
                  (n.dts = n.pts),
                  64 & i &&
                    ((n.dts =
                      ((14 & e[t + 14]) << 27) |
                      ((255 & e[t + 15]) << 20) |
                      ((254 & e[t + 16]) << 12) |
                      ((255 & e[t + 17]) << 5) |
                      ((254 & e[t + 18]) >>> 3)),
                    (n.dts *= 4),
                    (n.dts += (6 & e[t + 18]) >>> 1))),
                n
              );
            },
            videoPacketContainsKeyFrame: function (e) {
              for (
                var t = 4 + Dt(e), n = e.subarray(t), i = 0, r = 0, a = !1;
                r < n.byteLength - 3;
                r++
              )
                if (1 === n[r + 2]) {
                  i = r + 5;
                  break;
                }
              for (; i < n.byteLength; )
                switch (n[i]) {
                  case 0:
                    if (0 !== n[i - 1]) {
                      i += 2;
                      break;
                    }
                    if (0 !== n[i - 2]) {
                      i++;
                      break;
                    }
                    for (
                      r + 3 !== i - 2 &&
                      "slice_layer_without_partitioning_rbsp_idr" ===
                        Rt(31 & n[r + 3]) &&
                      (a = !0);
                      1 !== n[++i] && i < n.length;

                    );
                    (r = i - 2), (i += 3);
                    break;
                  case 1:
                    if (0 !== n[i - 1] || 0 !== n[i - 2]) {
                      i += 3;
                      break;
                    }
                    "slice_layer_without_partitioning_rbsp_idr" ===
                      Rt(31 & n[r + 3]) && (a = !0),
                      (r = i - 2),
                      (i += 3);
                    break;
                  default:
                    i += 3;
                }
              return (
                (n = n.subarray(r)),
                (i -= r),
                (r = 0),
                (a =
                  n &&
                  3 < n.byteLength &&
                  "slice_layer_without_partitioning_rbsp_idr" ===
                    Rt(31 & n[r + 3])
                    ? !0
                    : a)
              );
            },
          }),
            (L.aac = yt);
          function tn(e, t, n) {
            for (var i, r, a, s, o = 0, l = 188, u = !1; l <= e.byteLength; )
              if (71 !== e[o] || (71 !== e[l] && l !== e.byteLength)) o++, l++;
              else {
                if (
                  ((i = e.subarray(o, l)),
                  "pes" === L.ts.parseType(i, t.pid) &&
                    ((r = L.ts.parsePesType(i, t.table)),
                    (a = L.ts.parsePayloadUnitStartIndicator(i)),
                    "audio" === r &&
                      a &&
                      (s = L.ts.parsePesTime(i)) &&
                      ((s.type = "audio"), n.audio.push(s), (u = !0))),
                  u)
                )
                  break;
                (o += 188), (l += 188);
              }
            for (o = (l = e.byteLength) - 188, u = !1; 0 <= o; )
              if (71 !== e[o] || (71 !== e[l] && l !== e.byteLength)) o--, l--;
              else {
                if (
                  ((i = e.subarray(o, l)),
                  "pes" === L.ts.parseType(i, t.pid) &&
                    ((r = L.ts.parsePesType(i, t.table)),
                    (a = L.ts.parsePayloadUnitStartIndicator(i)),
                    "audio" === r &&
                      a &&
                      (s = L.ts.parsePesTime(i)) &&
                      ((s.type = "audio"), n.audio.push(s), (u = !0))),
                  u)
                )
                  break;
                (o -= 188), (l -= 188);
              }
          }
          function nn(e) {
            var t,
              n = { pid: null, table: null },
              i = {};
            for (t in (!(function (e, t) {
              for (var n, i = 0, r = 188; r < e.byteLength; )
                if (71 !== e[i] || 71 !== e[r]) i++, r++;
                else {
                  switch (((n = e.subarray(i, r)), L.ts.parseType(n, t.pid))) {
                    case "pat":
                      t.pid = L.ts.parsePat(n);
                      break;
                    case "pmt":
                      var a = L.ts.parsePmt(n);
                      (t.table = t.table || {}),
                        Object.keys(a).forEach(function (e) {
                          t.table[e] = a[e];
                        });
                  }
                  (i += 188), (r += 188);
                }
            })(e, n),
            n.table))
              if (n.table.hasOwnProperty(t))
                switch (n.table[t]) {
                  case _.H264_STREAM_TYPE:
                    (i.video = []),
                      (function (e, t, n) {
                        for (
                          var i,
                            r,
                            a,
                            s,
                            o,
                            l,
                            u,
                            c,
                            d = 0,
                            h = 188,
                            p = !1,
                            m = { data: [], size: 0 };
                          h < e.byteLength;

                        )
                          if (71 !== e[d] || 71 !== e[h]) d++, h++;
                          else {
                            if (
                              ((i = e.subarray(d, h)),
                              "pes" === L.ts.parseType(i, t.pid))
                            )
                              if (
                                ((r = L.ts.parsePesType(i, t.table)),
                                (a = L.ts.parsePayloadUnitStartIndicator(i)),
                                "video" === r &&
                                  (a &&
                                    !p &&
                                    (s = L.ts.parsePesTime(i)) &&
                                    ((s.type = "video"),
                                    n.video.push(s),
                                    (p = !0)),
                                  !n.firstKeyFrame))
                              ) {
                                if (a && 0 !== m.size) {
                                  for (
                                    o = new Uint8Array(m.size), l = 0;
                                    m.data.length;

                                  )
                                    (u = m.data.shift()),
                                      o.set(u, l),
                                      (l += u.byteLength);
                                  !L.ts.videoPacketContainsKeyFrame(o) ||
                                    ((c = L.ts.parsePesTime(o)) &&
                                      ((n.firstKeyFrame = c),
                                      (n.firstKeyFrame.type = "video"))),
                                    (m.size = 0);
                                }
                                m.data.push(i), (m.size += i.byteLength);
                              }
                            if (p && n.firstKeyFrame) break;
                            (d += 188), (h += 188);
                          }
                        for (d = (h = e.byteLength) - 188, p = !1; 0 <= d; )
                          if (71 !== e[d] || 71 !== e[h]) d--, h--;
                          else {
                            if (
                              ((i = e.subarray(d, h)),
                              "pes" === L.ts.parseType(i, t.pid) &&
                                ((r = L.ts.parsePesType(i, t.table)),
                                (a = L.ts.parsePayloadUnitStartIndicator(i)),
                                "video" === r &&
                                  a &&
                                  (s = L.ts.parsePesTime(i)) &&
                                  ((s.type = "video"),
                                  n.video.push(s),
                                  (p = !0))),
                              p)
                            )
                              break;
                            (d -= 188), (h -= 188);
                          }
                      })(e, n, i),
                      0 === i.video.length && delete i.video;
                    break;
                  case _.ADTS_STREAM_TYPE:
                    (i.audio = []),
                      tn(e, n, i),
                      0 === i.audio.length && delete i.audio;
                }
            return i;
          }
          var M = h,
            rn = function (e, t) {
              var n,
                i,
                r = (
                  L.aac.isLikelyAacData(e)
                    ? function (e) {
                        for (
                          var t,
                            n = !1,
                            i = 0,
                            r = null,
                            a = null,
                            s = 0,
                            o = 0;
                          3 <= e.length - o;

                        ) {
                          switch (L.aac.parseType(e, o)) {
                            case "timed-metadata":
                              if (e.length - o < 10) {
                                n = !0;
                                break;
                              }
                              if (
                                (s = L.aac.parseId3TagSize(e, o)) > e.length
                              ) {
                                n = !0;
                                break;
                              }
                              null === a &&
                                ((t = e.subarray(o, o + s)),
                                (a = L.aac.parseAacTimestamp(t))),
                                (o += s);
                              break;
                            case "audio":
                              if (e.length - o < 7) {
                                n = !0;
                                break;
                              }
                              if ((s = L.aac.parseAdtsSize(e, o)) > e.length) {
                                n = !0;
                                break;
                              }
                              null === r &&
                                ((t = e.subarray(o, o + s)),
                                (r = L.aac.parseSampleRate(t))),
                                i++,
                                (o += s);
                              break;
                            default:
                              o++;
                          }
                          if (n) return null;
                        }
                        if (null === r || null === a) return null;
                        var l = M / r;
                        return {
                          audio: [
                            { type: "audio", dts: a, pts: a },
                            {
                              type: "audio",
                              dts: a + 1024 * i * l,
                              pts: a + 1024 * i * l,
                            },
                          ],
                        };
                      }
                    : nn
                )(e);
              return r && (r.audio || r.video)
                ? ((e = t),
                  (t = r).audio &&
                    t.audio.length &&
                    (("undefined" != typeof (n = e) && !isNaN(n)) ||
                      (n = t.audio[0].dts),
                    t.audio.forEach(function (e) {
                      (e.dts = N(e.dts, n)),
                        (e.pts = N(e.pts, n)),
                        (e.dtsTime = e.dts / M),
                        (e.ptsTime = e.pts / M);
                    })),
                  t.video &&
                    t.video.length &&
                    (("undefined" != typeof (i = e) && !isNaN(i)) ||
                      (i = t.video[0].dts),
                    t.video.forEach(function (e) {
                      (e.dts = N(e.dts, i)),
                        (e.pts = N(e.pts, i)),
                        (e.dtsTime = e.dts / M),
                        (e.ptsTime = e.pts / M);
                    }),
                    t.firstKeyFrame &&
                      (((t = t.firstKeyFrame).dts = N(t.dts, i)),
                      (t.pts = N(t.pts, i)),
                      (t.dtsTime = t.dts / M),
                      (t.ptsTime = t.pts / M))),
                  r)
                : null;
            },
            an = (function () {
              function e(e, t) {
                (this.options = t || {}), (this.self = e), this.init();
              }
              var t = e.prototype;
              return (
                (t.init = function () {
                  var n, e;
                  this.transmuxer && this.transmuxer.dispose(),
                    (this.transmuxer = new Bt.Transmuxer(this.options)),
                    (n = this.self),
                    (e = this.transmuxer).on("data", function (e) {
                      var t = e.initSegment;
                      e.initSegment = {
                        data: t.buffer,
                        byteOffset: t.byteOffset,
                        byteLength: t.byteLength,
                      };
                      t = e.data;
                      (e.data = t.buffer),
                        n.postMessage(
                          {
                            action: "data",
                            segment: e,
                            byteOffset: t.byteOffset,
                            byteLength: t.byteLength,
                          },
                          [e.data]
                        );
                    }),
                    e.on("done", function (e) {
                      n.postMessage({ action: "done" });
                    }),
                    e.on("gopInfo", function (e) {
                      n.postMessage({ action: "gopInfo", gopInfo: e });
                    }),
                    e.on("videoSegmentTimingInfo", function (e) {
                      var t = {
                        start: {
                          decode: s(e.start.dts),
                          presentation: s(e.start.pts),
                        },
                        end: {
                          decode: s(e.end.dts),
                          presentation: s(e.end.pts),
                        },
                        baseMediaDecodeTime: s(e.baseMediaDecodeTime),
                      };
                      e.prependedContentDuration &&
                        (t.prependedContentDuration = s(
                          e.prependedContentDuration
                        )),
                        n.postMessage({
                          action: "videoSegmentTimingInfo",
                          videoSegmentTimingInfo: t,
                        });
                    }),
                    e.on("audioSegmentTimingInfo", function (e) {
                      var t = {
                        start: {
                          decode: s(e.start.dts),
                          presentation: s(e.start.pts),
                        },
                        end: {
                          decode: s(e.end.dts),
                          presentation: s(e.end.pts),
                        },
                        baseMediaDecodeTime: s(e.baseMediaDecodeTime),
                      };
                      e.prependedContentDuration &&
                        (t.prependedContentDuration = s(
                          e.prependedContentDuration
                        )),
                        n.postMessage({
                          action: "audioSegmentTimingInfo",
                          audioSegmentTimingInfo: t,
                        });
                    }),
                    e.on("id3Frame", function (e) {
                      n.postMessage({ action: "id3Frame", id3Frame: e });
                    }),
                    e.on("caption", function (e) {
                      n.postMessage({ action: "caption", caption: e });
                    }),
                    e.on("trackinfo", function (e) {
                      n.postMessage({ action: "trackinfo", trackInfo: e });
                    }),
                    e.on("audioTimingInfo", function (e) {
                      n.postMessage({
                        action: "audioTimingInfo",
                        audioTimingInfo: { start: s(e.start), end: s(e.end) },
                      });
                    }),
                    e.on("videoTimingInfo", function (e) {
                      n.postMessage({
                        action: "videoTimingInfo",
                        videoTimingInfo: { start: s(e.start), end: s(e.end) },
                      });
                    }),
                    e.on("log", function (e) {
                      n.postMessage({ action: "log", log: e });
                    });
                }),
                (t.pushMp4Captions = function (e) {
                  this.captionParser ||
                    ((this.captionParser = new Kt()),
                    this.captionParser.init());
                  var t = new Uint8Array(e.data, e.byteOffset, e.byteLength),
                    e = this.captionParser.parse(t, e.trackIds, e.timescales);
                  this.self.postMessage(
                    {
                      action: "mp4Captions",
                      captions: (e && e.captions) || [],
                      logs: (e && e.logs) || [],
                      data: t.buffer,
                    },
                    [t.buffer]
                  );
                }),
                (t.probeMp4StartTime = function (e) {
                  var t = e.timescales,
                    e = e.data,
                    t = $t(t, e);
                  this.self.postMessage(
                    { action: "probeMp4StartTime", startTime: t, data: e },
                    [e.buffer]
                  );
                }),
                (t.probeMp4Tracks = function (e) {
                  var t = e.data,
                    e = en(t);
                  this.self.postMessage(
                    { action: "probeMp4Tracks", tracks: e, data: t },
                    [t.buffer]
                  );
                }),
                (t.probeTs = function (e) {
                  var t = e.data,
                    n = e.baseStartTime,
                    e = "number" != typeof n || isNaN(n) ? void 0 : n * h,
                    n = rn(t, e),
                    e = null;
                  n &&
                    ((e = {
                      hasVideo: (n.video && 2 === n.video.length) || !1,
                      hasAudio: (n.audio && 2 === n.audio.length) || !1,
                    }).hasVideo && (e.videoStart = n.video[0].ptsTime),
                    e.hasAudio && (e.audioStart = n.audio[0].ptsTime)),
                    this.self.postMessage(
                      { action: "probeTs", result: e, data: t },
                      [t.buffer]
                    );
                }),
                (t.clearAllMp4Captions = function () {
                  this.captionParser && this.captionParser.clearAllCaptions();
                }),
                (t.clearParsedMp4Captions = function () {
                  this.captionParser &&
                    this.captionParser.clearParsedCaptions();
                }),
                (t.push = function (e) {
                  e = new Uint8Array(e.data, e.byteOffset, e.byteLength);
                  this.transmuxer.push(e);
                }),
                (t.reset = function () {
                  this.transmuxer.reset();
                }),
                (t.setTimestampOffset = function (e) {
                  e = e.timestampOffset || 0;
                  this.transmuxer.setBaseMediaDecodeTime(Math.round(De(e)));
                }),
                (t.setAudioAppendStart = function (e) {
                  this.transmuxer.setAudioAppendStart(
                    Math.ceil(De(e.appendStart))
                  );
                }),
                (t.setRemux = function (e) {
                  this.transmuxer.setRemux(e.remux);
                }),
                (t.flush = function (e) {
                  this.transmuxer.flush(),
                    self.postMessage({ action: "done", type: "transmuxed" });
                }),
                (t.endTimeline = function () {
                  this.transmuxer.endTimeline(),
                    self.postMessage({
                      action: "endedtimeline",
                      type: "transmuxed",
                    });
                }),
                (t.alignGopsWith = function (e) {
                  this.transmuxer.alignGopsWith(e.gopsToAlignWith.slice());
                }),
                e
              );
            })();
          self.onmessage = function (e) {
            "init" === e.data.action && e.data.options
              ? (this.messageHandlers = new an(self, e.data.options))
              : (this.messageHandlers || (this.messageHandlers = new an(self)),
                e.data &&
                  e.data.action &&
                  "init" !== e.data.action &&
                  this.messageHandlers[e.data.action] &&
                  this.messageHandlers[e.data.action](e.data));
          };
        })
      )
    ),
    xu = function (e) {
      (e.currentTransmux = null),
        e.transmuxQueue.length &&
          ((e.currentTransmux = e.transmuxQueue.shift()),
          "function" == typeof e.currentTransmux
            ? e.currentTransmux()
            : Ml(e.currentTransmux));
    },
    Eu = function (e) {
      Rl("reset", e);
    },
    ku = function (e) {
      var t = new Iu();
      (t.currentTransmux = null), (t.transmuxQueue = []);
      var n = t.terminate;
      return (
        (t.terminate = function () {
          return (
            (t.currentTransmux = null), (t.transmuxQueue.length = 0), n.call(t)
          );
        }),
        t.postMessage({ action: "init", options: e }),
        t
      );
    },
    Pu = 2,
    ju = -101,
    Nu = -102,
    Lu = Bo("CodecUtils"),
    Mu = Bo("PlaylistSelector"),
    mr = function () {
      var e = (this.useDevicePixelRatio && window.devicePixelRatio) || 1;
      return au(
        this.playlists.master,
        this.systemBandwidth,
        parseInt(nu(this.tech_.el(), "width"), 10) * e,
        parseInt(nu(this.tech_.el(), "height"), 10) * e,
        this.limitRenditionByPlayerDimensions,
        this.masterPlaylistController_
      );
    },
    Du = (function (i) {
      function e(e, t) {
        var n = i.call(this) || this;
        if (!e) throw new TypeError("Initialization settings are required");
        if ("function" != typeof e.currentTime)
          throw new TypeError("No currentTime getter specified");
        if (!e.mediaSource) throw new TypeError("No MediaSource specified");
        return (
          (n.bandwidth = e.bandwidth),
          (n.throughput = { rate: 0, count: 0 }),
          (n.roundTrip = NaN),
          n.resetStats_(),
          (n.mediaIndex = null),
          (n.partIndex = null),
          (n.hasPlayed_ = e.hasPlayed),
          (n.currentTime_ = e.currentTime),
          (n.seekable_ = e.seekable),
          (n.seeking_ = e.seeking),
          (n.duration_ = e.duration),
          (n.mediaSource_ = e.mediaSource),
          (n.vhs_ = e.vhs),
          (n.loaderType_ = e.loaderType),
          (n.currentMediaInfo_ = void 0),
          (n.startingMediaInfo_ = void 0),
          (n.segmentMetadataTrack_ = e.segmentMetadataTrack),
          (n.goalBufferLength_ = e.goalBufferLength),
          (n.sourceType_ = e.sourceType),
          (n.sourceUpdater_ = e.sourceUpdater),
          (n.inbandTextTracks_ = e.inbandTextTracks),
          (n.state_ = "INIT"),
          (n.timelineChangeController_ = e.timelineChangeController),
          (n.shouldSaveSegmentTimingInfo_ = !0),
          (n.parse708captions_ = e.parse708captions),
          (n.useDtsForTimestampOffset_ = e.useDtsForTimestampOffset),
          (n.captionServices_ = e.captionServices),
          (n.experimentalExactManifestTimings =
            e.experimentalExactManifestTimings),
          (n.checkBufferTimeout_ = null),
          (n.error_ = void 0),
          (n.currentTimeline_ = -1),
          (n.pendingSegment_ = null),
          (n.xhrOptions_ = null),
          (n.pendingSegments_ = []),
          (n.audioDisabled_ = !1),
          (n.isPendingTimestampOffset_ = !1),
          (n.gopBuffer_ = []),
          (n.timeMapping_ = 0),
          (n.safeAppend_ = 11 <= w.browser.IE_VERSION),
          (n.appendInitSegment_ = { audio: !0, video: !0 }),
          (n.playlistOfLastInitSegment_ = { audio: null, video: null }),
          (n.callQueue_ = []),
          (n.loadQueue_ = []),
          (n.metadataQueue_ = { id3: [], caption: [] }),
          (n.waitingOnRemove_ = !1),
          (n.quotaExceededErrorRetryTimeout_ = null),
          (n.activeInitSegmentId_ = null),
          (n.initSegments_ = {}),
          (n.cacheEncryptionKeys_ = e.cacheEncryptionKeys),
          (n.keyCache_ = {}),
          (n.decrypter_ = e.decrypter),
          (n.syncController_ = e.syncController),
          (n.syncPoint_ = { segmentIndex: 0, time: 0 }),
          (n.transmuxer_ = n.createTransmuxer_()),
          (n.triggerSyncInfoUpdate_ = function () {
            return n.trigger("syncinfoupdate");
          }),
          n.syncController_.on("syncinfoupdate", n.triggerSyncInfoUpdate_),
          n.mediaSource_.addEventListener("sourceopen", function () {
            n.isEndOfStream_() || (n.ended_ = !1);
          }),
          (n.fetchAtBuffer_ = !1),
          (n.logger_ = Bo("SegmentLoader[" + n.loaderType_ + "]")),
          Object.defineProperty(y(n), "state", {
            get: function () {
              return this.state_;
            },
            set: function (e) {
              e !== this.state_ &&
                (this.logger_(this.state_ + " -> " + e),
                (this.state_ = e),
                this.trigger("statechange"));
            },
          }),
          n.sourceUpdater_.on("ready", function () {
            n.hasEnoughInfoToAppend_() && n.processCallQueue_();
          }),
          "main" === n.loaderType_ &&
            n.timelineChangeController_.on(
              "pendingtimelinechange",
              function () {
                n.hasEnoughInfoToAppend_() && n.processCallQueue_();
              }
            ),
          "audio" === n.loaderType_ &&
            n.timelineChangeController_.on("timelinechange", function () {
              n.hasEnoughInfoToLoad_() && n.processLoadQueue_(),
                n.hasEnoughInfoToAppend_() && n.processCallQueue_();
            }),
          n
        );
      }
      b(e, i);
      var t = e.prototype;
      return (
        (t.createTransmuxer_ = function () {
          return ku({
            remux: !1,
            alignGopsAtEnd: this.safeAppend_,
            keepOriginalTimestamps: !0,
            parse708captions: this.parse708captions_,
            captionServices: this.captionServices_,
          });
        }),
        (t.resetStats_ = function () {
          (this.mediaBytesTransferred = 0),
            (this.mediaRequests = 0),
            (this.mediaRequestsAborted = 0),
            (this.mediaRequestsTimedout = 0),
            (this.mediaRequestsErrored = 0),
            (this.mediaTransferDuration = 0),
            (this.mediaSecondsLoaded = 0),
            (this.mediaAppends = 0);
        }),
        (t.dispose = function () {
          this.trigger("dispose"),
            (this.state = "DISPOSED"),
            this.pause(),
            this.abort_(),
            this.transmuxer_ && this.transmuxer_.terminate(),
            this.resetStats_(),
            this.checkBufferTimeout_ &&
              window.clearTimeout(this.checkBufferTimeout_),
            this.syncController_ &&
              this.triggerSyncInfoUpdate_ &&
              this.syncController_.off(
                "syncinfoupdate",
                this.triggerSyncInfoUpdate_
              ),
            this.off();
        }),
        (t.setAudio = function (e) {
          (this.audioDisabled_ = !e),
            e
              ? (this.appendInitSegment_.audio = !0)
              : this.sourceUpdater_.removeAudio(0, this.duration_());
        }),
        (t.abort = function () {
          "WAITING" === this.state
            ? (this.abort_(),
              (this.state = "READY"),
              this.paused() || this.monitorBuffer_())
            : this.pendingSegment_ && (this.pendingSegment_ = null);
        }),
        (t.abort_ = function () {
          this.pendingSegment_ &&
            this.pendingSegment_.abortRequests &&
            this.pendingSegment_.abortRequests(),
            (this.pendingSegment_ = null),
            (this.callQueue_ = []),
            (this.loadQueue_ = []),
            (this.metadataQueue_.id3 = []),
            (this.metadataQueue_.caption = []),
            this.timelineChangeController_.clearPendingTimelineChange(
              this.loaderType_
            ),
            (this.waitingOnRemove_ = !1),
            window.clearTimeout(this.quotaExceededErrorRetryTimeout_),
            (this.quotaExceededErrorRetryTimeout_ = null);
        }),
        (t.checkForAbort_ = function (e) {
          return "APPENDING" !== this.state || this.pendingSegment_
            ? !this.pendingSegment_ || this.pendingSegment_.requestId !== e
            : ((this.state = "READY"), !0);
        }),
        (t.error = function (e) {
          return (
            "undefined" != typeof e &&
              (this.logger_("error occurred:", e), (this.error_ = e)),
            (this.pendingSegment_ = null),
            this.error_
          );
        }),
        (t.endOfStream = function () {
          (this.ended_ = !0),
            this.transmuxer_ && Eu(this.transmuxer_),
            (this.gopBuffer_.length = 0),
            this.pause(),
            this.trigger("ended");
        }),
        (t.buffered_ = function () {
          var e = this.getMediaInfo_();
          if (!this.sourceUpdater_ || !e) return w.createTimeRanges();
          if ("main" === this.loaderType_) {
            var t = e.hasAudio,
              n = e.hasVideo,
              e = e.isMuxed;
            if (n && t && !this.audioDisabled_ && !e)
              return this.sourceUpdater_.buffered();
            if (n) return this.sourceUpdater_.videoBuffered();
          }
          return this.sourceUpdater_.audioBuffered();
        }),
        (t.initSegmentForMap = function (e, t) {
          if ((void 0 === t && (t = !1), !e)) return null;
          var n = wl(e),
            i = this.initSegments_[n];
          return (
            t &&
              !i &&
              e.bytes &&
              (this.initSegments_[n] = i =
                {
                  resolvedUri: e.resolvedUri,
                  byterange: e.byterange,
                  bytes: e.bytes,
                  tracks: e.tracks,
                  timescales: e.timescales,
                }),
            i || e
          );
        }),
        (t.segmentKey = function (e, t) {
          if ((void 0 === t && (t = !1), !e)) return null;
          var n = Cl(e),
            i = this.keyCache_[n];
          this.cacheEncryptionKeys_ &&
            t &&
            !i &&
            e.bytes &&
            (this.keyCache_[n] = i =
              { resolvedUri: e.resolvedUri, bytes: e.bytes });
          e = { resolvedUri: (i || e).resolvedUri };
          return i && (e.bytes = i.bytes), e;
        }),
        (t.couldBeginLoading_ = function () {
          return this.playlist_ && !this.paused();
        }),
        (t.load = function () {
          if ((this.monitorBuffer_(), this.playlist_))
            return "INIT" === this.state && this.couldBeginLoading_()
              ? this.init_()
              : void (
                  !this.couldBeginLoading_() ||
                  ("READY" !== this.state && "INIT" !== this.state) ||
                  (this.state = "READY")
                );
        }),
        (t.init_ = function () {
          return (
            (this.state = "READY"),
            this.resetEverything(),
            this.monitorBuffer_()
          );
        }),
        (t.playlist = function (e, t) {
          if ((void 0 === t && (t = {}), e)) {
            var n = this.playlist_,
              i = this.pendingSegment_;
            (this.playlist_ = e),
              (this.xhrOptions_ = t),
              "INIT" === this.state &&
                ((e.syncInfo = { mediaSequence: e.mediaSequence, time: 0 }),
                "main" === this.loaderType_ &&
                  this.syncController_.setDateTimeMappingForStart(e));
            var r = null;
            if (
              (n && (n.id ? (r = n.id) : n.uri && (r = n.uri)),
              this.logger_(
                "playlist update [" + r + " => " + (e.id || e.uri) + "]"
              ),
              this.trigger("syncinfoupdate"),
              "INIT" === this.state && this.couldBeginLoading_())
            )
              return this.init_();
            if (!n || n.uri !== e.uri)
              return (
                null !== this.mediaIndex &&
                  (e.endList ? this.resyncLoader() : this.resetLoader()),
                (this.currentMediaInfo_ = void 0),
                void this.trigger("playlistupdate")
              );
            t = e.mediaSequence - n.mediaSequence;
            this.logger_("live window shift [" + t + "]"),
              null !== this.mediaIndex &&
                ((this.mediaIndex -= t),
                this.mediaIndex < 0
                  ? ((this.mediaIndex = null), (this.partIndex = null))
                  : ((r = this.playlist_.segments[this.mediaIndex]),
                    !this.partIndex ||
                      (r.parts && r.parts.length && r.parts[this.partIndex]) ||
                      ((r = this.mediaIndex),
                      this.logger_(
                        "currently processing part (index " +
                          this.partIndex +
                          ") no longer exists."
                      ),
                      this.resetLoader(),
                      (this.mediaIndex = r)))),
              i &&
                ((i.mediaIndex -= t),
                i.mediaIndex < 0
                  ? ((i.mediaIndex = null), (i.partIndex = null))
                  : (0 <= i.mediaIndex &&
                      (i.segment = e.segments[i.mediaIndex]),
                    0 <= i.partIndex &&
                      i.segment.parts &&
                      (i.part = i.segment.parts[i.partIndex]))),
              this.syncController_.saveExpiredSegmentInfo(n, e);
          }
        }),
        (t.pause = function () {
          this.checkBufferTimeout_ &&
            (window.clearTimeout(this.checkBufferTimeout_),
            (this.checkBufferTimeout_ = null));
        }),
        (t.paused = function () {
          return null === this.checkBufferTimeout_;
        }),
        (t.resetEverything = function (e) {
          (this.ended_ = !1),
            (this.appendInitSegment_ = { audio: !0, video: !0 }),
            this.resetLoader(),
            this.remove(0, 1 / 0, e),
            this.transmuxer_ &&
              (this.transmuxer_.postMessage({ action: "clearAllMp4Captions" }),
              this.transmuxer_.postMessage({ action: "reset" }));
        }),
        (t.resetLoader = function () {
          (this.fetchAtBuffer_ = !1), this.resyncLoader();
        }),
        (t.resyncLoader = function () {
          this.transmuxer_ && Eu(this.transmuxer_),
            (this.mediaIndex = null),
            (this.partIndex = null),
            (this.syncPoint_ = null),
            (this.isPendingTimestampOffset_ = !1),
            (this.callQueue_ = []),
            (this.loadQueue_ = []),
            (this.metadataQueue_.id3 = []),
            (this.metadataQueue_.caption = []),
            this.abort(),
            this.transmuxer_ &&
              this.transmuxer_.postMessage({
                action: "clearParsedMp4Captions",
              });
        }),
        (t.remove = function (e, t, n, i) {
          if (
            (void 0 === n && (n = function () {}),
            void 0 === i && (i = !1),
            (t = t === 1 / 0 ? this.duration_() : t) <= e)
          )
            this.logger_(
              "skipping remove because end ${end} is <= start ${start}"
            );
          else if (this.sourceUpdater_ && this.getMediaInfo_()) {
            var r,
              a = 1,
              s = function () {
                0 === --a && n();
              };
            for (r in ((!i && this.audioDisabled_) ||
              (a++, this.sourceUpdater_.removeAudio(e, t, s)),
            (!i && "main" !== this.loaderType_) ||
              ((this.gopBuffer_ = (function (e, t, n, i) {
                for (
                  var r = Math.ceil((t - i) * fu),
                    a = Math.ceil((n - i) * fu),
                    i = e.slice(),
                    s = e.length;
                  s-- && !(e[s].pts <= a);

                );
                if (-1 === s) return i;
                for (var o = s + 1; o-- && !(e[o].pts <= r); );
                return (o = Math.max(o, 0)), i.splice(o, s - o + 1), i;
              })(this.gopBuffer_, e, t, this.timeMapping_)),
              a++,
              this.sourceUpdater_.removeVideo(e, t, s)),
            this.inbandTextTracks_))
              ou(e, t, this.inbandTextTracks_[r]);
            ou(e, t, this.segmentMetadataTrack_), s();
          } else
            this.logger_(
              "skipping remove because no source updater or starting media info"
            );
        }),
        (t.monitorBuffer_ = function () {
          this.checkBufferTimeout_ &&
            window.clearTimeout(this.checkBufferTimeout_),
            (this.checkBufferTimeout_ = window.setTimeout(
              this.monitorBufferTick_.bind(this),
              1
            ));
        }),
        (t.monitorBufferTick_ = function () {
          "READY" === this.state && this.fillBuffer_(),
            this.checkBufferTimeout_ &&
              window.clearTimeout(this.checkBufferTimeout_),
            (this.checkBufferTimeout_ = window.setTimeout(
              this.monitorBufferTick_.bind(this),
              500
            ));
        }),
        (t.fillBuffer_ = function () {
          var e;
          this.sourceUpdater_.updating() ||
            ((e = this.chooseNextRequest_()) &&
              ("number" == typeof e.timestampOffset &&
                ((this.isPendingTimestampOffset_ = !1),
                this.timelineChangeController_.pendingTimelineChange({
                  type: this.loaderType_,
                  from: this.currentTimeline_,
                  to: e.timeline,
                })),
              this.loadSegment_(e)));
        }),
        (t.isEndOfStream_ = function (e, t, n) {
          if (
            (void 0 === e && (e = this.mediaIndex),
            void 0 === t && (t = this.playlist_),
            void 0 === n && (n = this.partIndex),
            !t || !this.mediaSource_)
          )
            return !1;
          var i = "number" == typeof e && t.segments[e],
            e = e + 1 === t.segments.length,
            i = !i || !i.parts || n + 1 === i.parts.length;
          return t.endList && "open" === this.mediaSource_.readyState && e && i;
        }),
        (t.chooseNextRequest_ = function () {
          var e = this.buffered_(),
            t = zo(e) || 0,
            n = Ho(e, this.currentTime_()),
            i = !this.hasPlayed_() && 1 <= n,
            r = n >= this.goalBufferLength_(),
            e = this.playlist_.segments;
          if (!e.length || i || r) return null;
          this.syncPoint_ =
            this.syncPoint_ ||
            this.syncController_.getSyncPoint(
              this.playlist_,
              this.duration_(),
              this.currentTimeline_,
              this.currentTime_()
            );
          var a,
            i = {
              partIndex: null,
              mediaIndex: null,
              startOfSegment: null,
              playlist: this.playlist_,
              isSyncRequest: Boolean(!this.syncPoint_),
            };
          i.isSyncRequest
            ? (i.mediaIndex = (function (e, t, n) {
                t = t || [];
                for (var i = [], r = 0, a = 0; a < t.length; a++) {
                  var s = t[a];
                  if (e === s.timeline && (i.push(a), n < (r += s.duration)))
                    return a;
                }
                return 0 === i.length ? 0 : i[i.length - 1];
              })(this.currentTimeline_, e, t))
            : null !== this.mediaIndex
            ? ((r = e[this.mediaIndex]),
              (a = "number" == typeof this.partIndex ? this.partIndex : -1),
              (i.startOfSegment = r.end || t),
              r.parts && r.parts[a + 1]
                ? ((i.mediaIndex = this.mediaIndex), (i.partIndex = a + 1))
                : (i.mediaIndex = this.mediaIndex + 1))
            : ((a = (o = yu.getMediaInfoForTime({
                experimentalExactManifestTimings:
                  this.experimentalExactManifestTimings,
                playlist: this.playlist_,
                currentTime: this.fetchAtBuffer_ ? t : this.currentTime_(),
                startingPartIndex: this.syncPoint_.partIndex,
                startingSegmentIndex: this.syncPoint_.segmentIndex,
                startTime: this.syncPoint_.time,
              })).segmentIndex),
              (s = o.startTime),
              (o = o.partIndex),
              (i.getMediaInfoForTime = this.fetchAtBuffer_
                ? "bufferedEnd " + t
                : "currentTime " + this.currentTime_()),
              (i.mediaIndex = a),
              (i.startOfSegment = s),
              (i.partIndex = o));
          var s = e[i.mediaIndex],
            o =
              s &&
              "number" == typeof i.partIndex &&
              s.parts &&
              s.parts[i.partIndex];
          if (!s || ("number" == typeof i.partIndex && !o)) return null;
          "number" != typeof i.partIndex &&
            s.parts &&
            ((i.partIndex = 0), (o = s.parts[0])),
            n ||
              !o ||
              o.independent ||
              (0 === i.partIndex
                ? (o =
                    (n = e[i.mediaIndex - 1]).parts &&
                    n.parts.length &&
                    n.parts[n.parts.length - 1]) &&
                  o.independent &&
                  (--i.mediaIndex,
                  (i.partIndex = n.parts.length - 1),
                  (i.independent = "previous segment"))
                : s.parts[i.partIndex - 1].independent &&
                  (--i.partIndex, (i.independent = "previous part")));
          s = this.mediaSource_ && "ended" === this.mediaSource_.readyState;
          return i.mediaIndex >= e.length - 1 && s && !this.seeking_()
            ? null
            : this.generateSegmentInfo_(i);
        }),
        (t.generateSegmentInfo_ = function (e) {
          var t = e.independent,
            n = e.playlist,
            i = e.mediaIndex,
            r = e.startOfSegment,
            a = e.isSyncRequest,
            s = e.partIndex,
            o = e.forceTimestampOffset,
            l = e.getMediaInfoForTime,
            u = n.segments[i],
            e = "number" == typeof s && u.parts[s],
            t = {
              requestId: "segment-loader-" + Math.random(),
              uri: (e && e.resolvedUri) || u.resolvedUri,
              mediaIndex: i,
              partIndex: e ? s : null,
              isSyncRequest: a,
              startOfSegment: r,
              playlist: n,
              bytes: null,
              encryptedBytes: null,
              timestampOffset: null,
              timeline: u.timeline,
              duration: (e && e.duration) || u.duration,
              segment: u,
              part: e,
              byteLength: 0,
              transmuxer: this.transmuxer_,
              getMediaInfoForTime: l,
              independent: t,
            },
            o = "undefined" != typeof o ? o : this.isPendingTimestampOffset_;
          t.timestampOffset = this.timestampOffsetForSegment_({
            segmentTimeline: u.timeline,
            currentTimeline: this.currentTimeline_,
            startOfSegment: r,
            buffered: this.buffered_(),
            overrideCheck: o,
          });
          o = zo(this.sourceUpdater_.audioBuffered());
          return (
            "number" == typeof o &&
              (t.audioAppendStart =
                o - this.sourceUpdater_.audioTimestampOffset()),
            this.sourceUpdater_.videoBuffered().length &&
              (t.gopsToAlignWith = (function (e, t, n) {
                if ("undefined" == typeof t || null === t || !e.length)
                  return [];
                for (
                  var i = Math.ceil((t - n + 3) * fu), r = 0;
                  r < e.length && !(e[r].pts > i);
                  r++
                );
                return e.slice(r);
              })(
                this.gopBuffer_,
                this.currentTime_() -
                  this.sourceUpdater_.videoTimestampOffset(),
                this.timeMapping_
              )),
            t
          );
        }),
        (t.timestampOffsetForSegment_ = function (e) {
          return (
            (n = (t = e).segmentTimeline),
            (i = t.currentTimeline),
            (r = t.startOfSegment),
            (e = t.buffered),
            t.overrideCheck || n !== i
              ? !(n < i) && e.length
                ? e.end(e.length - 1)
                : r
              : null
          );
          var t, n, i, r;
        }),
        (t.earlyAbortWhenNeeded_ = function (e) {
          var t, n, i, r, a, s, o, l, u, c, d, h, p;
          !this.vhs_.tech_.paused() &&
            this.xhrOptions_.timeout &&
            this.playlist_.attributes.BANDWIDTH &&
            (Date.now() - (e.firstBytesReceivedAt || Date.now()) < 1e3 ||
              ((t = this.currentTime_()),
              (r = e.bandwidth),
              (a = this.pendingSegment_.duration),
              (p = yu.estimateSegmentRequestTime(
                a,
                r,
                this.playlist_,
                e.bytesReceived
              )),
              (n = this.buffered_()),
              (i = t),
              void 0 === (e = this.vhs_.tech_.playbackRate()) && (e = 1),
              p <= (e = ((n.length ? n.end(n.length - 1) : 0) - i) / e - 1) ||
                ((r = {
                  master: this.vhs_.playlists.master,
                  currentTime: t,
                  bandwidth: r,
                  duration: this.duration_(),
                  segmentDuration: a,
                  timeUntilRebuffer: e,
                  currentTimeline: this.currentTimeline_,
                  syncController: this.syncController_,
                }),
                (a = r.master),
                (s = r.currentTime),
                (o = r.bandwidth),
                (l = r.duration),
                (u = r.segmentDuration),
                (c = r.timeUntilRebuffer),
                (d = r.currentTimeline),
                (h = r.syncController),
                (a = (r = (a = !(a = (r = a.playlists.filter(function (e) {
                  return !yu.isIncompatible(e);
                })).filter(yu.isEnabled)).length
                  ? r.filter(function (e) {
                      return !yu.isDisabled(e);
                    })
                  : a)
                  .filter(yu.hasAttribute.bind(null, "BANDWIDTH"))
                  .map(function (e) {
                    var t = h.getSyncPoint(e, l, d, s) ? 1 : 2;
                    return {
                      playlist: e,
                      rebufferingImpact:
                        yu.estimateSegmentRequestTime(u, o, e) * t - c,
                    };
                  })).filter(function (e) {
                  return e.rebufferingImpact <= 0;
                })),
                iu(a, function (e, t) {
                  return ru(t.playlist, e.playlist);
                }),
                (r = a.length
                  ? a[0]
                  : (iu(r, function (e, t) {
                      return e.rebufferingImpact - t.rebufferingImpact;
                    }),
                    r[0] || null)) &&
                  ((p = p - e - r.rebufferingImpact),
                  !r.playlist ||
                    r.playlist.uri === this.playlist_.uri ||
                    p < (e <= bu ? 1 : 0.5) ||
                    ((this.bandwidth =
                      r.playlist.attributes.BANDWIDTH * L.BANDWIDTH_VARIANCE +
                      1),
                    this.trigger("earlyabort"))))));
        }),
        (t.handleAbort_ = function (e) {
          this.logger_("Aborting " + uu(e)), (this.mediaRequestsAborted += 1);
        }),
        (t.handleProgress_ = function (e, t) {
          this.earlyAbortWhenNeeded_(t.stats),
            this.checkForAbort_(t.requestId) || this.trigger("progress");
        }),
        (t.handleTrackInfo_ = function (e, t) {
          this.earlyAbortWhenNeeded_(e.stats),
            this.checkForAbort_(e.requestId) ||
              this.checkForIllegalMediaSwitch(t) ||
              ((function (e, t) {
                if ((!e && !t) || (!e && t) || (e && !t)) return !1;
                if (e === t) return !0;
                var n = Object.keys(e).sort(),
                  i = Object.keys(t).sort();
                if (n.length !== i.length) return !1;
                for (var r = 0; r < n.length; r++) {
                  var a = n[r];
                  if (a !== i[r]) return !1;
                  if (e[a] !== t[a]) return !1;
                }
                return !0;
              })(this.currentMediaInfo_, (t = t || {})) ||
                ((this.appendInitSegment_ = { audio: !0, video: !0 }),
                (this.startingMediaInfo_ = t),
                (this.currentMediaInfo_ = t),
                this.logger_("trackinfo update", t),
                this.trigger("trackinfo")),
              this.checkForAbort_(e.requestId) ||
                ((this.pendingSegment_.trackInfo = t),
                this.hasEnoughInfoToAppend_() && this.processCallQueue_()));
        }),
        (t.handleTimingInfo_ = function (e, t, n, i) {
          var r;
          this.earlyAbortWhenNeeded_(e.stats),
            this.checkForAbort_(e.requestId) ||
              (((r = this.pendingSegment_)[(e = cu(t))] = r[e] || {}),
              (r[e][n] = i),
              this.logger_("timinginfo: " + t + " - " + n + " - " + i),
              this.hasEnoughInfoToAppend_() && this.processCallQueue_());
        }),
        (t.handleCaptions_ = function (e, t) {
          var g,
            b,
            v = this;
          this.earlyAbortWhenNeeded_(e.stats),
            this.checkForAbort_(e.requestId) ||
              (0 !== t.length
                ? this.pendingSegment_.hasAppendedData_
                  ? ((g =
                      null === this.sourceUpdater_.videoTimestampOffset()
                        ? this.sourceUpdater_.audioTimestampOffset()
                        : this.sourceUpdater_.videoTimestampOffset()),
                    (b = {}),
                    t.forEach(function (e) {
                      b[e.stream] = b[e.stream] || {
                        startTime: 1 / 0,
                        captions: [],
                        endTime: 0,
                      };
                      var t = b[e.stream];
                      (t.startTime = Math.min(t.startTime, e.startTime + g)),
                        (t.endTime = Math.max(t.endTime, e.endTime + g)),
                        t.captions.push(e);
                    }),
                    Object.keys(b).forEach(function (e) {
                      var t,
                        n,
                        i,
                        r,
                        a,
                        s,
                        o,
                        l,
                        u,
                        c,
                        d = b[e],
                        h = d.startTime,
                        p = d.endTime,
                        m = d.captions,
                        f = v.inbandTextTracks_;
                      v.logger_(
                        "adding cues from " + h + " -> " + p + " for " + e
                      ),
                        (t = f),
                        (n = v.vhs_.tech_),
                        t[(i = e)] ||
                          (n.trigger({ type: "usage", name: "vhs-608" }),
                          n.trigger({ type: "usage", name: "hls-608" }),
                          /^cc708_/.test((r = i)) &&
                            (r = "SERVICE" + i.split("_")[1]),
                          (o = n.textTracks().getTrackById(r))
                            ? (t[i] = o)
                            : ((s = a = i),
                              (d = !1),
                              (o = ((n.options_.vhs &&
                                n.options_.vhs.captionServices) ||
                                {})[r]) &&
                                ((a = o.label),
                                (s = o.language),
                                (d = o.default)),
                              (t[i] = n.addRemoteTextTrack(
                                {
                                  kind: "captions",
                                  id: r,
                                  default: d,
                                  label: a,
                                  language: s,
                                },
                                !1
                              ).track))),
                        ou(h, p, f[e]),
                        (u = (m = {
                          captionArray: m,
                          inbandTextTracks: f,
                          timestampOffset: g,
                        }).inbandTextTracks),
                        (f = m.captionArray),
                        (c = m.timestampOffset),
                        f &&
                          ((l = window.WebKitDataCue || window.VTTCue),
                          f.forEach(function (e) {
                            var t = e.stream;
                            u[t].addCue(
                              new l(e.startTime + c, e.endTime + c, e.text)
                            );
                          }));
                    }),
                    this.transmuxer_ &&
                      this.transmuxer_.postMessage({
                        action: "clearParsedMp4Captions",
                      }))
                  : this.metadataQueue_.caption.push(
                      this.handleCaptions_.bind(this, e, t)
                    )
                : this.logger_(
                    "SegmentLoader received no captions from a caption event"
                  ));
        }),
        (t.handleId3_ = function (e, t, n) {
          var i, r, a, s;
          this.earlyAbortWhenNeeded_(e.stats),
            this.checkForAbort_(e.requestId) ||
              (this.pendingSegment_.hasAppendedData_
                ? ((i =
                    null === this.sourceUpdater_.videoTimestampOffset()
                      ? this.sourceUpdater_.audioTimestampOffset()
                      : this.sourceUpdater_.videoTimestampOffset()),
                  (r = this.inbandTextTracks_),
                  (a = n),
                  (s = this.vhs_.tech_),
                  r.metadataTrack_ ||
                    ((r.metadataTrack_ = s.addRemoteTextTrack(
                      { kind: "metadata", label: "Timed Metadata" },
                      !1
                    ).track),
                    (r.metadataTrack_.inBandMetadataTrackDispatchType = a)),
                  su({
                    inbandTextTracks: this.inbandTextTracks_,
                    metadataArray: t,
                    timestampOffset: i,
                    videoDuration: this.duration_(),
                  }))
                : this.metadataQueue_.id3.push(
                    this.handleId3_.bind(this, e, t, n)
                  ));
        }),
        (t.processMetadataQueue_ = function () {
          this.metadataQueue_.id3.forEach(function (e) {
            return e();
          }),
            this.metadataQueue_.caption.forEach(function (e) {
              return e();
            }),
            (this.metadataQueue_.id3 = []),
            (this.metadataQueue_.caption = []);
        }),
        (t.processCallQueue_ = function () {
          var e = this.callQueue_;
          (this.callQueue_ = []),
            e.forEach(function (e) {
              return e();
            });
        }),
        (t.processLoadQueue_ = function () {
          var e = this.loadQueue_;
          (this.loadQueue_ = []),
            e.forEach(function (e) {
              return e();
            });
        }),
        (t.hasEnoughInfoToLoad_ = function () {
          if ("audio" !== this.loaderType_) return !0;
          var e = this.pendingSegment_;
          return (
            !!e &&
            (!this.getCurrentMediaInfo_() ||
              !du({
                timelineChangeController: this.timelineChangeController_,
                currentTimeline: this.currentTimeline_,
                segmentTimeline: e.timeline,
                loaderType: this.loaderType_,
                audioDisabled: this.audioDisabled_,
              }))
          );
        }),
        (t.getCurrentMediaInfo_ = function (e) {
          return (
            ((e = void 0 === e ? this.pendingSegment_ : e) && e.trackInfo) ||
            this.currentMediaInfo_
          );
        }),
        (t.getMediaInfo_ = function (e) {
          return (
            void 0 === e && (e = this.pendingSegment_),
            this.getCurrentMediaInfo_(e) || this.startingMediaInfo_
          );
        }),
        (t.hasEnoughInfoToAppend_ = function () {
          if (!this.sourceUpdater_.ready()) return !1;
          if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_)
            return !1;
          var e = this.pendingSegment_,
            t = this.getCurrentMediaInfo_();
          if (!e || !t) return !1;
          var n = t.hasAudio,
            i = t.hasVideo,
            t = t.isMuxed;
          return (
            !(i && !e.videoTimingInfo) &&
            !(n && !this.audioDisabled_ && !t && !e.audioTimingInfo) &&
            !du({
              timelineChangeController: this.timelineChangeController_,
              currentTimeline: this.currentTimeline_,
              segmentTimeline: e.timeline,
              loaderType: this.loaderType_,
              audioDisabled: this.audioDisabled_,
            })
          );
        }),
        (t.handleData_ = function (e, t) {
          if (
            (this.earlyAbortWhenNeeded_(e.stats),
            !this.checkForAbort_(e.requestId))
          )
            if (!this.callQueue_.length && this.hasEnoughInfoToAppend_()) {
              var n,
                i = this.pendingSegment_;
              if (
                (this.setTimeMapping_(i.timeline),
                this.updateMediaSecondsLoaded_(i.part || i.segment),
                "closed" !== this.mediaSource_.readyState)
              ) {
                if (
                  (e.map &&
                    ((e.map = this.initSegmentForMap(e.map, !0)),
                    (i.segment.map = e.map)),
                  e.key && this.segmentKey(e.key, !0),
                  (i.isFmp4 = e.isFmp4),
                  (i.timingInfo = i.timingInfo || {}),
                  i.isFmp4
                    ? (this.trigger("fmp4"),
                      (i.timingInfo.start = i[cu(t.type)].start))
                    : ((n = this.getCurrentMediaInfo_()),
                      (n = "main" === this.loaderType_ && n && n.hasVideo) &&
                        (r = i.videoTimingInfo.start),
                      (i.timingInfo.start = this.trueSegmentStart_({
                        currentStart: i.timingInfo.start,
                        playlist: i.playlist,
                        mediaIndex: i.mediaIndex,
                        currentVideoTimestampOffset:
                          this.sourceUpdater_.videoTimestampOffset(),
                        useVideoTimingInfo: n,
                        firstVideoFrameTimeForData: r,
                        videoTimingInfo: i.videoTimingInfo,
                        audioTimingInfo: i.audioTimingInfo,
                      }))),
                  this.updateAppendInitSegmentStatus(i, t.type),
                  this.updateSourceBufferTimestampOffset_(i),
                  i.isSyncRequest)
                ) {
                  this.updateTimingInfoEnd_(i),
                    this.syncController_.saveSegmentTimingInfo({
                      segmentInfo: i,
                      shouldSaveTimelineMapping: "main" === this.loaderType_,
                    });
                  var r = this.chooseNextRequest_();
                  if (
                    r.mediaIndex !== i.mediaIndex ||
                    r.partIndex !== i.partIndex
                  )
                    return void this.logger_(
                      "sync segment was incorrect, not appending"
                    );
                  this.logger_("sync segment was correct, appending");
                }
                (i.hasAppendedData_ = !0),
                  this.processMetadataQueue_(),
                  this.appendData_(i, t);
              }
            } else this.callQueue_.push(this.handleData_.bind(this, e, t));
        }),
        (t.updateAppendInitSegmentStatus = function (e, t) {
          "main" !== this.loaderType_ ||
            "number" != typeof e.timestampOffset ||
            e.changedTimestampOffset ||
            (this.appendInitSegment_ = { audio: !0, video: !0 }),
            this.playlistOfLastInitSegment_[t] !== e.playlist &&
              (this.appendInitSegment_[t] = !0);
        }),
        (t.getInitSegmentAndUpdateState_ = function (e) {
          var t = e.type,
            n = e.initSegment,
            i = e.map,
            r = e.playlist;
          if (i) {
            e = wl(i);
            if (this.activeInitSegmentId_ === e) return null;
            (n = this.initSegmentForMap(i, !0).bytes),
              (this.activeInitSegmentId_ = e);
          }
          return n && this.appendInitSegment_[t]
            ? ((this.playlistOfLastInitSegment_[t] = r),
              (this.appendInitSegment_[t] = !1),
              (this.activeInitSegmentId_ = null),
              n)
            : null;
        }),
        (t.handleQuotaExceededError_ = function (e, t) {
          var n = this,
            i = e.segmentInfo,
            r = e.type,
            a = e.bytes,
            s = this.sourceUpdater_.audioBuffered(),
            o = this.sourceUpdater_.videoBuffered();
          1 < s.length &&
            this.logger_(
              "On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " +
                qo(s).join(", ")
            ),
            1 < o.length &&
              this.logger_(
                "On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " +
                  qo(o).join(", ")
              );
          var l = s.length ? s.start(0) : 0,
            u = s.length ? s.end(s.length - 1) : 0,
            c = o.length ? o.start(0) : 0,
            e = o.length ? o.end(o.length - 1) : 0;
          if (u - l <= 1 && e - c <= 1)
            return (
              this.logger_(
                "On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. Appended byte length: " +
                  a.byteLength +
                  ", audio buffer: " +
                  qo(s).join(", ") +
                  ", video buffer: " +
                  qo(o).join(", ") +
                  ", "
              ),
              this.error({
                message:
                  "Quota exceeded error with append of a single segment of content",
                excludeUntil: 1 / 0,
              }),
              void this.trigger("error")
            );
          (this.waitingOnRemove_ = !0),
            this.callQueue_.push(
              this.appendToSourceBuffer_.bind(this, {
                segmentInfo: i,
                type: r,
                bytes: a,
              })
            );
          a = this.currentTime_() - 1;
          this.logger_(
            "On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to " + a
          ),
            this.remove(
              0,
              a,
              function () {
                n.logger_("On QUOTA_EXCEEDED_ERR, retrying append in 1s"),
                  (n.waitingOnRemove_ = !1),
                  (n.quotaExceededErrorRetryTimeout_ = window.setTimeout(
                    function () {
                      n.logger_(
                        "On QUOTA_EXCEEDED_ERR, re-processing call queue"
                      ),
                        (n.quotaExceededErrorRetryTimeout_ = null),
                        n.processCallQueue_();
                    },
                    1e3
                  ));
              },
              !0
            );
        }),
        (t.handleAppendError_ = function (e, t) {
          var n = e.segmentInfo,
            i = e.type,
            e = e.bytes;
          t &&
            (22 !== t.code
              ? (this.logger_("Received non QUOTA_EXCEEDED_ERR on append", t),
                this.error(
                  i +
                    " append of " +
                    e.length +
                    "b failed for segment #" +
                    n.mediaIndex +
                    " in playlist " +
                    n.playlist.id
                ),
                this.trigger("appenderror"))
              : this.handleQuotaExceededError_({
                  segmentInfo: n,
                  type: i,
                  bytes: e,
                }));
        }),
        (t.appendToSourceBuffer_ = function (e) {
          var t,
            n,
            i = e.segmentInfo,
            r = e.type,
            a = e.initSegment,
            s = e.data,
            o = e.bytes;
          o ||
            ((e = [s]),
            (s = s.byteLength),
            a && (e.unshift(a), (s += a.byteLength)),
            (n = 0),
            (e = { bytes: s, segments: e }).bytes &&
              ((t = new Uint8Array(e.bytes)),
              e.segments.forEach(function (e) {
                t.set(e, n), (n += e.byteLength);
              })),
            (o = t)),
            this.sourceUpdater_.appendBuffer(
              { segmentInfo: i, type: r, bytes: o },
              this.handleAppendError_.bind(this, {
                segmentInfo: i,
                type: r,
                bytes: o,
              })
            );
        }),
        (t.handleSegmentTimingInfo_ = function (e, t, n) {
          this.pendingSegment_ &&
            t === this.pendingSegment_.requestId &&
            ((t = this.pendingSegment_.segment)[(e = e + "TimingInfo")] ||
              (t[e] = {}),
            (t[e].transmuxerPrependedSeconds = n.prependedContentDuration || 0),
            (t[e].transmuxedPresentationStart = n.start.presentation),
            (t[e].transmuxedDecodeStart = n.start.decode),
            (t[e].transmuxedPresentationEnd = n.end.presentation),
            (t[e].transmuxedDecodeEnd = n.end.decode),
            (t[e].baseMediaDecodeTime = n.baseMediaDecodeTime));
        }),
        (t.appendData_ = function (e, t) {
          var n = t.type,
            i = t.data;
          i &&
            i.byteLength &&
            (("audio" === n && this.audioDisabled_) ||
              ((t = this.getInitSegmentAndUpdateState_({
                type: n,
                initSegment: t.initSegment,
                playlist: e.playlist,
                map: e.isFmp4 ? e.segment.map : null,
              })),
              this.appendToSourceBuffer_({
                segmentInfo: e,
                type: n,
                initSegment: t,
                data: i,
              })));
        }),
        (t.loadSegment_ = function (t) {
          var n = this;
          (this.state = "WAITING"),
            (this.pendingSegment_ = t),
            this.trimBackBuffer_(t),
            "number" == typeof t.timestampOffset &&
              this.transmuxer_ &&
              this.transmuxer_.postMessage({ action: "clearAllMp4Captions" }),
            this.hasEnoughInfoToLoad_()
              ? this.updateTransmuxerAndRequestSegment_(t)
              : this.loadQueue_.push(function () {
                  var e = Q({}, t, { forceTimestampOffset: !0 });
                  Q(t, n.generateSegmentInfo_(e)),
                    (n.isPendingTimestampOffset_ = !1),
                    n.updateTransmuxerAndRequestSegment_(t);
                });
        }),
        (t.updateTransmuxerAndRequestSegment_ = function (i) {
          var r = this;
          this.shouldUpdateTransmuxerTimestampOffset_(i.timestampOffset) &&
            ((this.gopBuffer_.length = 0),
            (i.gopsToAlignWith = []),
            (this.timeMapping_ = 0),
            this.transmuxer_.postMessage({ action: "reset" }),
            this.transmuxer_.postMessage({
              action: "setTimestampOffset",
              timestampOffset: i.timestampOffset,
            }));
          var e = this.createSimplifiedSegmentObj_(i),
            t = this.isEndOfStream_(i.mediaIndex, i.playlist, i.partIndex),
            n = null !== this.mediaIndex,
            a = i.timeline !== this.currentTimeline_ && 0 < i.timeline,
            a = t || (n && a);
          this.logger_("Requesting " + uu(i)),
            e.map &&
              !e.map.bytes &&
              (this.logger_("going to request init segment."),
              (this.appendInitSegment_ = { video: !0, audio: !0 })),
            (i.abortRequests = Ql({
              xhr: this.vhs_.xhr,
              xhrOptions: this.xhrOptions_,
              decryptionWorker: this.decrypter_,
              segment: e,
              abortFn: this.handleAbort_.bind(this, i),
              progressFn: this.handleProgress_.bind(this),
              trackInfoFn: this.handleTrackInfo_.bind(this),
              timingInfoFn: this.handleTimingInfo_.bind(this),
              videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(
                this,
                "video",
                i.requestId
              ),
              audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(
                this,
                "audio",
                i.requestId
              ),
              captionsFn: this.handleCaptions_.bind(this),
              isEndOfTimeline: a,
              endedTimelineFn: function () {
                r.logger_("received endedtimeline callback");
              },
              id3Fn: this.handleId3_.bind(this),
              dataFn: this.handleData_.bind(this),
              doneFn: this.segmentRequestFinished_.bind(this),
              onTransmuxerLog: function (e) {
                var t = e.message,
                  n = e.level,
                  e = e.stream;
                r.logger_(
                  uu(i) +
                    " logged from transmuxer stream " +
                    e +
                    " as a " +
                    n +
                    ": " +
                    t
                );
              },
            }));
        }),
        (t.trimBackBuffer_ = function (e) {
          var t,
            n,
            i,
            r,
            r =
              ((t = this.seekable_()),
              (n = this.currentTime_()),
              (i = this.playlist_.targetDuration || 10),
              (r = n - L.BACK_BUFFER_LENGTH),
              t.length && (r = Math.max(r, t.start(0))),
              Math.min(n - i, r));
          0 < r && this.remove(0, r);
        }),
        (t.createSimplifiedSegmentObj_ = function (e) {
          var t = e.segment,
            n = e.part,
            i = {
              resolvedUri: (n || t).resolvedUri,
              byterange: (n || t).byterange,
              requestId: e.requestId,
              transmuxer: e.transmuxer,
              audioAppendStart: e.audioAppendStart,
              gopsToAlignWith: e.gopsToAlignWith,
              part: e.part,
            },
            n = e.playlist.segments[e.mediaIndex - 1];
          return (
            n &&
              n.timeline === t.timeline &&
              (n.videoTimingInfo
                ? (i.baseStartTime = n.videoTimingInfo.transmuxedDecodeEnd)
                : n.audioTimingInfo &&
                  (i.baseStartTime = n.audioTimingInfo.transmuxedDecodeEnd)),
            t.key &&
              ((e =
                t.key.iv ||
                new Uint32Array([
                  0,
                  0,
                  0,
                  e.mediaIndex + e.playlist.mediaSequence,
                ])),
              (i.key = this.segmentKey(t.key)),
              (i.key.iv = e)),
            t.map && (i.map = this.initSegmentForMap(t.map)),
            i
          );
        }),
        (t.saveTransferStats_ = function (e) {
          (this.mediaRequests += 1),
            e &&
              ((this.mediaBytesTransferred += e.bytesReceived),
              (this.mediaTransferDuration += e.roundTripTime));
        }),
        (t.saveBandwidthRelatedStats_ = function (e, t) {
          (this.pendingSegment_.byteLength = t.bytesReceived),
            e < 1 / 60
              ? this.logger_(
                  "Ignoring segment's bandwidth because its duration of " +
                    e +
                    " is less than the min to record " +
                    1 / 60
                )
              : ((this.bandwidth = t.bandwidth),
                (this.roundTrip = t.roundTripTime));
        }),
        (t.handleTimeout_ = function () {
          (this.mediaRequestsTimedout += 1),
            (this.bandwidth = 1),
            (this.roundTrip = NaN),
            this.trigger("bandwidthupdate");
        }),
        (t.segmentRequestFinished_ = function (e, t, n) {
          if (this.callQueue_.length)
            this.callQueue_.push(
              this.segmentRequestFinished_.bind(this, e, t, n)
            );
          else if (
            (this.saveTransferStats_(t.stats),
            this.pendingSegment_ &&
              t.requestId === this.pendingSegment_.requestId)
          ) {
            if (e)
              return (
                (this.pendingSegment_ = null),
                (this.state = "READY"),
                e.code === Nu
                  ? void 0
                  : (this.pause(),
                    e.code === ju
                      ? void this.handleTimeout_()
                      : ((this.mediaRequestsErrored += 1),
                        this.error(e),
                        void this.trigger("error")))
              );
            e = this.pendingSegment_;
            this.saveBandwidthRelatedStats_(e.duration, t.stats),
              (e.endOfAllRequests = t.endOfAllRequests),
              n.gopInfo &&
                (this.gopBuffer_ = (function (e, t, n) {
                  if (!t.length) return e;
                  if (n) return t.slice();
                  for (
                    var i = t[0].pts, r = 0;
                    r < e.length && !(e[r].pts >= i);
                    r++
                  );
                  return e.slice(0, r).concat(t);
                })(this.gopBuffer_, n.gopInfo, this.safeAppend_)),
              (this.state = "APPENDING"),
              this.trigger("appending"),
              this.waitForAppendsToComplete_(e);
          }
        }),
        (t.setTimeMapping_ = function (e) {
          e = this.syncController_.mappingForTimeline(e);
          null !== e && (this.timeMapping_ = e);
        }),
        (t.updateMediaSecondsLoaded_ = function (e) {
          "number" == typeof e.start && "number" == typeof e.end
            ? (this.mediaSecondsLoaded += e.end - e.start)
            : (this.mediaSecondsLoaded += e.duration);
        }),
        (t.shouldUpdateTransmuxerTimestampOffset_ = function (e) {
          return (
            null !== e &&
            (("main" === this.loaderType_ &&
              e !== this.sourceUpdater_.videoTimestampOffset()) ||
              (!this.audioDisabled_ &&
                e !== this.sourceUpdater_.audioTimestampOffset()))
          );
        }),
        (t.trueSegmentStart_ = function (e) {
          var t = e.currentStart,
            n = e.playlist,
            i = e.mediaIndex,
            r = e.firstVideoFrameTimeForData,
            a = e.currentVideoTimestampOffset,
            s = e.useVideoTimingInfo,
            o = e.videoTimingInfo,
            e = e.audioTimingInfo;
          if ("undefined" != typeof t) return t;
          if (!s) return e.start;
          n = n.segments[i - 1];
          return 0 !== i &&
            n &&
            "undefined" != typeof n.start &&
            n.end === r + a
            ? o.start
            : r;
        }),
        (t.waitForAppendsToComplete_ = function (e) {
          var t = this.getCurrentMediaInfo_(e);
          if (!t)
            return (
              this.error({
                message:
                  "No starting media returned, likely due to an unsupported media format.",
                blacklistDuration: 1 / 0,
              }),
              void this.trigger("error")
            );
          var n = t.hasAudio,
            i = t.hasVideo,
            t = t.isMuxed,
            i = "main" === this.loaderType_ && i,
            t = !this.audioDisabled_ && n && !t;
          if (((e.waitingOnAppends = 0), !e.hasAppendedData_))
            return (
              e.timingInfo ||
                "number" != typeof e.timestampOffset ||
                (this.isPendingTimestampOffset_ = !0),
              (e.timingInfo = { start: 0 }),
              e.waitingOnAppends++,
              this.isPendingTimestampOffset_ ||
                (this.updateSourceBufferTimestampOffset_(e),
                this.processMetadataQueue_()),
              void this.checkAppendsDone_(e)
            );
          i && e.waitingOnAppends++,
            t && e.waitingOnAppends++,
            i &&
              this.sourceUpdater_.videoQueueCallback(
                this.checkAppendsDone_.bind(this, e)
              ),
            t &&
              this.sourceUpdater_.audioQueueCallback(
                this.checkAppendsDone_.bind(this, e)
              );
        }),
        (t.checkAppendsDone_ = function (e) {
          this.checkForAbort_(e.requestId) ||
            (e.waitingOnAppends--,
            0 === e.waitingOnAppends && this.handleAppendsDone_());
        }),
        (t.checkForIllegalMediaSwitch = function (e) {
          var t,
            n,
            e =
              ((t = this.loaderType_),
              (n = this.getCurrentMediaInfo_()),
              (e = e),
              "main" === t && n && e
                ? e.hasAudio || e.hasVideo
                  ? n.hasVideo && !e.hasVideo
                    ? "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest."
                    : !n.hasVideo && e.hasVideo
                    ? "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest."
                    : null
                  : "Neither audio nor video found in segment."
                : null);
          return (
            !!e &&
            (this.error({ message: e, blacklistDuration: 1 / 0 }),
            this.trigger("error"),
            !0)
          );
        }),
        (t.updateSourceBufferTimestampOffset_ = function (e) {
          var t;
          null === e.timestampOffset ||
            "number" != typeof e.timingInfo.start ||
            e.changedTimestampOffset ||
            "main" !== this.loaderType_ ||
            ((t = !1),
            (e.timestampOffset -=
              this.getSegmentStartTimeForTimestampOffsetCalculation_({
                videoTimingInfo: e.segment.videoTimingInfo,
                audioTimingInfo: e.segment.audioTimingInfo,
                timingInfo: e.timingInfo,
              })),
            (e.changedTimestampOffset = !0),
            e.timestampOffset !== this.sourceUpdater_.videoTimestampOffset() &&
              (this.sourceUpdater_.videoTimestampOffset(e.timestampOffset),
              (t = !0)),
            e.timestampOffset !== this.sourceUpdater_.audioTimestampOffset() &&
              (this.sourceUpdater_.audioTimestampOffset(e.timestampOffset),
              (t = !0)),
            t && this.trigger("timestampoffset"));
        }),
        (t.getSegmentStartTimeForTimestampOffsetCalculation_ = function (e) {
          var t = e.videoTimingInfo,
            n = e.audioTimingInfo,
            e = e.timingInfo;
          return this.useDtsForTimestampOffset_
            ? t && "number" == typeof t.transmuxedDecodeStart
              ? t.transmuxedDecodeStart
              : n && "number" == typeof n.transmuxedDecodeStart
              ? n.transmuxedDecodeStart
              : e.start
            : e.start;
        }),
        (t.updateTimingInfoEnd_ = function (e) {
          e.timingInfo = e.timingInfo || {};
          var t = this.getMediaInfo_(),
            t =
              "main" === this.loaderType_ &&
              t &&
              t.hasVideo &&
              e.videoTimingInfo
                ? e.videoTimingInfo
                : e.audioTimingInfo;
          t &&
            (e.timingInfo.end =
              "number" == typeof t.end ? t.end : t.start + e.duration);
        }),
        (t.handleAppendsDone_ = function () {
          if (
            (this.pendingSegment_ && this.trigger("appendsdone"),
            !this.pendingSegment_)
          )
            return (
              (this.state = "READY"),
              void (this.paused() || this.monitorBuffer_())
            );
          var e = this.pendingSegment_;
          this.updateTimingInfoEnd_(e),
            this.shouldSaveSegmentTimingInfo_ &&
              this.syncController_.saveSegmentTimingInfo({
                segmentInfo: e,
                shouldSaveTimelineMapping: "main" === this.loaderType_,
              });
          var t = pu(e, this.sourceType_);
          if (
            (t &&
              ("warn" === t.severity
                ? w.log.warn(t.message)
                : this.logger_(t.message)),
            this.recordThroughput_(e),
            (this.pendingSegment_ = null),
            (this.state = "READY"),
            !e.isSyncRequest ||
              (this.trigger("syncinfoupdate"), e.hasAppendedData_))
          ) {
            this.logger_("Appended " + uu(e)),
              this.addSegmentMetadataCue_(e),
              (this.fetchAtBuffer_ = !0),
              this.currentTimeline_ !== e.timeline &&
                (this.timelineChangeController_.lastTimelineChange({
                  type: this.loaderType_,
                  from: this.currentTimeline_,
                  to: e.timeline,
                }),
                "main" !== this.loaderType_ ||
                  this.audioDisabled_ ||
                  this.timelineChangeController_.lastTimelineChange({
                    type: "audio",
                    from: this.currentTimeline_,
                    to: e.timeline,
                  })),
              (this.currentTimeline_ = e.timeline),
              this.trigger("syncinfoupdate");
            var n = e.segment,
              t = e.part,
              n =
                n.end &&
                this.currentTime_() - n.end > 3 * e.playlist.targetDuration,
              t =
                t &&
                t.end &&
                this.currentTime_() - t.end > 3 * e.playlist.partTargetDuration;
            if (n || t)
              return (
                this.logger_("bad " + (n ? "segment" : "part") + " " + uu(e)),
                void this.resetEverything()
              );
            null !== this.mediaIndex && this.trigger("bandwidthupdate"),
              this.trigger("progress"),
              (this.mediaIndex = e.mediaIndex),
              (this.partIndex = e.partIndex),
              this.isEndOfStream_(e.mediaIndex, e.playlist, e.partIndex) &&
                this.endOfStream(),
              this.trigger("appended"),
              e.hasAppendedData_ && this.mediaAppends++,
              this.paused() || this.monitorBuffer_();
          } else
            this.logger_("Throwing away un-appended sync request " + uu(e));
        }),
        (t.recordThroughput_ = function (e) {
          var t, n;
          e.duration < 1 / 60
            ? this.logger_(
                "Ignoring segment's throughput because its duration of " +
                  e.duration +
                  " is less than the min to record " +
                  1 / 60
              )
            : ((t = this.throughput.rate),
              (n = Date.now() - e.endOfAllRequests + 1),
              (n = Math.floor((e.byteLength / n) * 8 * 1e3)),
              (this.throughput.rate += (n - t) / ++this.throughput.count));
        }),
        (t.addSegmentMetadataCue_ = function (e) {
          var t, n, i, r;
          this.segmentMetadataTrack_ &&
            ((n = (t = e.segment).start),
            (r = t.end),
            lu(n) &&
              lu(r) &&
              (ou(n, r, this.segmentMetadataTrack_),
              (i = window.WebKitDataCue || window.VTTCue),
              (e = {
                custom: t.custom,
                dateTimeObject: t.dateTimeObject,
                dateTimeString: t.dateTimeString,
                bandwidth: e.playlist.attributes.BANDWIDTH,
                resolution: e.playlist.attributes.RESOLUTION,
                codecs: e.playlist.attributes.CODECS,
                byteLength: e.byteLength,
                uri: e.uri,
                timeline: e.timeline,
                playlist: e.playlist.id,
                start: n,
                end: r,
              }),
              ((r = new i(n, r, JSON.stringify(e))).value = e),
              this.segmentMetadataTrack_.addCue(r)));
        }),
        e
      );
    })(w.EventTarget);
  function Ru() {}
  function Bu(e) {
    return "string" != typeof e
      ? e
      : e.replace(/./, function (e) {
          return e.toUpperCase();
        });
  }
  function Uu(e, t) {
    var n = t[e + "Buffer"];
    return (n && n.updating) || t.queuePending[e];
  }
  function Vu(e, t) {
    if (0 !== t.queue.length) {
      var n = 0,
        i = t.queue[n];
      if ("mediaSource" !== i.type) {
        if (
          "mediaSource" !== e &&
          t.ready() &&
          "closed" !== t.mediaSource.readyState &&
          !Uu(e, t)
        ) {
          if (i.type !== e) {
            if (
              null ===
              (n = (function (e, t) {
                for (var n = 0; n < t.length; n++) {
                  var i = t[n];
                  if ("mediaSource" === i.type) return null;
                  if (i.type === e) return n;
                }
                return null;
              })(e, t.queue))
            )
              return;
            i = t.queue[n];
          }
          t.queue.splice(n, 1),
            (t.queuePending[e] = i).action(e, t),
            i.doneFn || ((t.queuePending[e] = null), Vu(e, t));
        }
      } else
        t.updating() ||
          "closed" === t.mediaSource.readyState ||
          (t.queue.shift(),
          i.action(t),
          i.doneFn && i.doneFn(),
          Vu("audio", t),
          Vu("video", t));
    }
  }
  function Fu(e, t) {
    var n = t[e + "Buffer"],
      i = Bu(e);
    n &&
      (n.removeEventListener("updateend", t["on" + i + "UpdateEnd_"]),
      n.removeEventListener("error", t["on" + i + "Error_"]),
      (t.codecs[e] = null),
      (t[e + "Buffer"] = null));
  }
  function Gu(e, t) {
    return e && t && -1 !== Array.prototype.indexOf.call(e.sourceBuffers, t);
  }
  function qu(e) {
    var t = e.type,
      n = e.sourceUpdater,
      i = e.action,
      r = e.doneFn,
      e = e.name;
    n.queue.push({ type: t, action: i, doneFn: r, name: e }), Vu(t, n);
  }
  function zu(n, i) {
    return function (e) {
      var t;
      i.queuePending[n] &&
        ((t = i.queuePending[n].doneFn),
        (i.queuePending[n] = null),
        t && t(i[n + "Error_"])),
        Vu(n, i);
    };
  }
  function Hu(e) {
    return decodeURIComponent(escape(String.fromCharCode.apply(null, e)));
  }
  function Wu(e, t) {
    e.abort(),
      e.pause(),
      t &&
        t.activePlaylistLoader &&
        (t.activePlaylistLoader.pause(), (t.activePlaylistLoader = null));
  }
  function Xu(e, t) {
    (t.activePlaylistLoader = e).load();
  }
  function Yu(e, t) {
    for (var n = 0; n < e.length; n++) {
      if (sl(t, e[n])) return !0;
      if (e[n].playlists && Yu(e[n].playlists, t)) return !0;
    }
    return !1;
  }
  function Ku(a) {
    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function (e) {
      yc[e](e, a);
    });
    var e,
      s = a.mediaTypes,
      t = a.masterPlaylistLoader,
      n = a.tech,
      i = a.vhs,
      r = a.segmentLoaders,
      o = r.AUDIO,
      l = r.main;
    function u() {
      s.AUDIO.onTrackChanged(),
        n.trigger({ type: "usage", name: "vhs-audio-change" }),
        n.trigger({ type: "usage", name: "hls-audio-change" });
    }
    for (e in (["AUDIO", "SUBTITLES"].forEach(function (e) {
      var l, u, o, c, t, n, d, h, i, r;
      (s[e].activeGroup =
        ((l = e),
        (u = a),
        function (t) {
          var e = u.masterPlaylistLoader,
            n = u.mediaTypes[l].groups,
            i = e.media();
          if (!i) return null;
          var r = null;
          i.attributes[l] && (r = n[i.attributes[l]]);
          var a = Object.keys(n);
          if (!r)
            if ("AUDIO" === l && 1 < a.length && ll(u.master))
              for (var s = 0; s < a.length; s++) {
                var o = n[a[s]];
                if (Yu(o, i)) {
                  r = o;
                  break;
                }
              }
            else n.main ? (r = n.main) : 1 === a.length && (r = n[a[0]]);
          return "undefined" == typeof t
            ? r
            : (null !== t &&
                r &&
                r.filter(function (e) {
                  return e.id === t.id;
                })[0]) ||
                null;
        })),
        (s[e].activeTrack = _c[e](e, a)),
        (s[e].onGroupChanged =
          ((o = e),
          (c = a),
          function () {
            var e = c.segmentLoaders,
              t = e[o],
              n = e.main,
              i = c.mediaTypes[o],
              r = i.activeTrack(),
              a = i.getActiveGroup(),
              s = i.activePlaylistLoader,
              e = i.lastGroup_;
            (a && e && a.id === e.id) ||
              ((i.lastGroup_ = a),
              (i.lastTrack_ = r),
              Wu(t, i),
              a &&
                !a.isMasterPlaylist &&
                (a.playlistLoader
                  ? (t.resyncLoader(), Xu(a.playlistLoader, i))
                  : s && n.resetEverything()));
          })),
        (s[e].onGroupChanging =
          ((t = e),
          (n = a),
          function () {
            var e = n.segmentLoaders[t];
            (n.mediaTypes[t].lastGroup_ = null), e.abort(), e.pause();
          })),
        (s[e].onTrackChanged =
          ((d = e),
          (h = a),
          function () {
            var e = h.masterPlaylistLoader,
              t = h.segmentLoaders,
              n = t[d],
              i = t.main,
              r = h.mediaTypes[d],
              a = r.activeTrack(),
              s = r.getActiveGroup(),
              o = r.activePlaylistLoader,
              l = r.lastTrack_;
            if (
              (!l || !a || l.id !== a.id) &&
              ((r.lastGroup_ = s), (r.lastTrack_ = a), Wu(n, r), s)
            ) {
              if (s.isMasterPlaylist) {
                if (!a || !l || a.id === l.id) return;
                var u = h.vhs.masterPlaylistController_,
                  t = u.selectPlaylist();
                return u.media() === t
                  ? void 0
                  : (r.logger_(
                      "track change. Switching master audio from " +
                        l.id +
                        " to " +
                        a.id
                    ),
                    e.pause(),
                    i.resetEverything(),
                    void u.fastQualityChange_(t));
              }
              if ("AUDIO" === d) {
                if (!s.playlistLoader)
                  return i.setAudio(!0), void i.resetEverything();
                n.setAudio(!0), i.setAudio(!1);
              }
              o !== s.playlistLoader &&
                (n.track && n.track(a), n.resetEverything()),
                Xu(s.playlistLoader, r);
            }
          })),
        (s[e].getActiveGroup =
          ((i = e),
          (r = a.mediaTypes),
          function () {
            var e = r[i].activeTrack();
            return e ? r[i].activeGroup(e) : null;
          }));
    }),
    (r = s.AUDIO.activeGroup()) &&
      ((r = (
        r.filter(function (e) {
          return e.default;
        })[0] || r[0]
      ).id),
      (s.AUDIO.tracks[r].enabled = !0),
      s.AUDIO.onGroupChanged(),
      s.AUDIO.onTrackChanged(),
      s.AUDIO.getActiveGroup().playlistLoader
        ? (l.setAudio(!1), o.setAudio(!0))
        : l.setAudio(!0)),
    t.on("mediachange", function () {
      ["AUDIO", "SUBTITLES"].forEach(function (e) {
        return s[e].onGroupChanged();
      });
    }),
    t.on("mediachanging", function () {
      ["AUDIO", "SUBTITLES"].forEach(function (e) {
        return s[e].onGroupChanging();
      });
    }),
    n.audioTracks().addEventListener("change", u),
    n.remoteTextTracks().addEventListener("change", s.SUBTITLES.onTrackChanged),
    i.on("dispose", function () {
      n.audioTracks().removeEventListener("change", u),
        n
          .remoteTextTracks()
          .removeEventListener("change", s.SUBTITLES.onTrackChanged);
    }),
    n.clearTracks("audio"),
    s.AUDIO.tracks))
      n.audioTracks().addTrack(s.AUDIO.tracks[e]);
  }
  function Qu(e, t, n) {
    var i,
      r,
      a,
      s,
      o = e.masterPlaylistController_,
      l =
        o[
          (e.options_.smoothQualityChange ? "smooth" : "fast") +
            "QualityChange_"
        ].bind(o);
    t.attributes &&
      ((i = t.attributes.RESOLUTION),
      (this.width = i && i.width),
      (this.height = i && i.height),
      (this.bandwidth = t.attributes.BANDWIDTH)),
      (this.codecs = eu(o.master(), t)),
      (this.playlist = t),
      (this.id = n),
      (this.enabled =
        ((r = e.playlists),
        (a = t.id),
        (s = l),
        function (e) {
          var t = r.master.playlists[a],
            n = nl(t),
            i = il(t);
          return "undefined" == typeof e
            ? i
            : (e ? delete t.disabled : (t.disabled = !0),
              e === i ||
                n ||
                (s(),
                e
                  ? r.trigger("renditionenabled")
                  : r.trigger("renditiondisabled")),
              e);
        }));
  }
  function Zu(t, e) {
    var n = 0,
      i = 0,
      r = w.mergeOptions(wc, e);
    function a() {
      i && t.currentTime(i);
    }
    function s(e) {
      null != e &&
        ((i = (t.duration() !== 1 / 0 && t.currentTime()) || 0),
        t.one("loadedmetadata", a),
        t.src(e),
        t.trigger({ type: "usage", name: "vhs-error-reload" }),
        t.trigger({ type: "usage", name: "hls-error-reload" }),
        t.play());
    }
    function o() {
      return Date.now() - n < 1e3 * r.errorInterval
        ? (t.trigger({ type: "usage", name: "vhs-error-reload-canceled" }),
          void t.trigger({ type: "usage", name: "hls-error-reload-canceled" }))
        : r.getSource && "function" == typeof r.getSource
        ? ((n = Date.now()), r.getSource.call(t, s))
        : void w.log.error(
            "ERROR: reloadSourceOnError - The option getSource must be a function!"
          );
    }
    function l() {
      t.off("loadedmetadata", a), t.off("error", o), t.off("dispose", l);
    }
    t.ready(function () {
      t.trigger({ type: "usage", name: "vhs-error-reload-initialized" }),
        t.trigger({ type: "usage", name: "hls-error-reload-initialized" });
    }),
      t.on("error", o),
      t.on("dispose", l),
      (t.reloadSourceOnError = function (e) {
        l(), Zu(t, e);
      });
  }
  var Ju,
    $u = ["video", "audio"],
    ec = function (i, r, a) {
      return function (e, t) {
        var n = t[e + "Buffer"];
        if (Gu(t.mediaSource, n)) {
          t.logger_(
            "Appending segment " +
              r.mediaIndex +
              "'s " +
              i.length +
              " bytes to " +
              e +
              "Buffer"
          );
          try {
            n.appendBuffer(i);
          } catch (n) {
            t.logger_(
              "Error with code " +
                n.code +
                " " +
                (22 === n.code ? "(QUOTA_EXCEEDED_ERR) " : "") +
                "when appending segment " +
                r.mediaIndex +
                " to " +
                e +
                "Buffer"
            ),
              (t.queuePending[e] = null),
              a(n);
          }
        }
      };
    },
    tc = function (i, r) {
      return function (e, t) {
        var n = t[e + "Buffer"];
        if (Gu(t.mediaSource, n)) {
          t.logger_("Removing " + i + " to " + r + " from " + e + "Buffer");
          try {
            n.remove(i, r);
          } catch (n) {
            t.logger_(
              "Remove " + i + " to " + r + " from " + e + "Buffer failed"
            );
          }
        }
      };
    },
    nc = function (i) {
      return function (e, t) {
        var n = t[e + "Buffer"];
        Gu(t.mediaSource, n) &&
          (t.logger_("Setting " + e + "timestampOffset to " + i),
          (n.timestampOffset = i));
      };
    },
    ic = function (n) {
      return function (e, t) {
        n();
      };
    },
    rc = function (t) {
      return function (e) {
        if ("open" === e.mediaSource.readyState) {
          e.logger_("Calling mediaSource endOfStream(" + (t || "") + ")");
          try {
            e.mediaSource.endOfStream(t);
          } catch (e) {
            w.log.warn("Failed to call media source endOfStream", e);
          }
        }
      };
    },
    ac = function (t) {
      return function (e) {
        e.logger_("Setting mediaSource duration to " + t);
        try {
          e.mediaSource.duration = t;
        } catch (e) {
          w.log.warn("Failed to set media source duration", e);
        }
      };
    },
    sc = function () {
      return function (e, t) {
        if ("open" === t.mediaSource.readyState) {
          var n = t[e + "Buffer"];
          if (Gu(t.mediaSource, n)) {
            t.logger_("calling abort on " + e + "Buffer");
            try {
              n.abort();
            } catch (t) {
              w.log.warn("Failed to abort on " + e + "Buffer", t);
            }
          }
        }
      };
    },
    oc = function (i, r) {
      return function (e) {
        var t = Bu(i),
          n = Sr(r);
        e.logger_("Adding " + i + "Buffer with codec " + r + " to mediaSource");
        n = e.mediaSource.addSourceBuffer(n);
        n.addEventListener("updateend", e["on" + t + "UpdateEnd_"]),
          n.addEventListener("error", e["on" + t + "Error_"]),
          (e.codecs[i] = r),
          (e[i + "Buffer"] = n);
      };
    },
    lc = function (n) {
      return function (e) {
        var t = e[n + "Buffer"];
        if ((Fu(n, e), Gu(e.mediaSource, t))) {
          e.logger_(
            "Removing " +
              n +
              "Buffer with codec " +
              e.codecs[n] +
              " from mediaSource"
          );
          try {
            e.mediaSource.removeSourceBuffer(t);
          } catch (e) {
            w.log.warn("Failed to removeSourceBuffer " + n + "Buffer", e);
          }
        }
      };
    },
    uc = function (r) {
      return function (e, t) {
        var n = t[e + "Buffer"],
          i = Sr(r);
        Gu(t.mediaSource, n) &&
          t.codecs[e] !== r &&
          (t.logger_(
            "changing " + e + "Buffer codec from " + t.codecs[e] + " to " + r
          ),
          n.changeType(i),
          (t.codecs[e] = r));
      };
    },
    cc = (function (n) {
      function e(e) {
        var t = n.call(this) || this;
        return (
          (t.mediaSource = e),
          (t.sourceopenListener_ = function () {
            return Vu("mediaSource", y(t));
          }),
          t.mediaSource.addEventListener("sourceopen", t.sourceopenListener_),
          (t.logger_ = Bo("SourceUpdater")),
          (t.audioTimestampOffset_ = 0),
          (t.videoTimestampOffset_ = 0),
          (t.queue = []),
          (t.queuePending = { audio: null, video: null }),
          (t.delayedAudioAppendQueue_ = []),
          (t.videoAppendQueued_ = !1),
          (t.codecs = {}),
          (t.onVideoUpdateEnd_ = zu("video", y(t))),
          (t.onAudioUpdateEnd_ = zu("audio", y(t))),
          (t.onVideoError_ = function (e) {
            t.videoError_ = e;
          }),
          (t.onAudioError_ = function (e) {
            t.audioError_ = e;
          }),
          (t.createdSourceBuffers_ = !1),
          (t.initializedEme_ = !1),
          (t.triggeredReady_ = !1),
          t
        );
      }
      b(e, n);
      var t = e.prototype;
      return (
        (t.initializedEme = function () {
          (this.initializedEme_ = !0), this.triggerReady();
        }),
        (t.hasCreatedSourceBuffers = function () {
          return this.createdSourceBuffers_;
        }),
        (t.hasInitializedAnyEme = function () {
          return this.initializedEme_;
        }),
        (t.ready = function () {
          return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
        }),
        (t.createSourceBuffers = function (e) {
          this.hasCreatedSourceBuffers() ||
            (this.addOrChangeSourceBuffers(e),
            (this.createdSourceBuffers_ = !0),
            this.trigger("createdsourcebuffers"),
            this.triggerReady());
        }),
        (t.triggerReady = function () {
          this.ready() &&
            !this.triggeredReady_ &&
            ((this.triggeredReady_ = !0), this.trigger("ready"));
        }),
        (t.addSourceBuffer = function (e, t) {
          qu({
            type: "mediaSource",
            sourceUpdater: this,
            action: oc(e, t),
            name: "addSourceBuffer",
          });
        }),
        (t.abort = function (e) {
          qu({ type: e, sourceUpdater: this, action: sc(e), name: "abort" });
        }),
        (t.removeSourceBuffer = function (e) {
          this.canRemoveSourceBuffer()
            ? qu({
                type: "mediaSource",
                sourceUpdater: this,
                action: lc(e),
                name: "removeSourceBuffer",
              })
            : w.log.error("removeSourceBuffer is not supported!");
        }),
        (t.canRemoveSourceBuffer = function () {
          return (
            !w.browser.IE_VERSION &&
            !w.browser.IS_FIREFOX &&
            window.MediaSource &&
            window.MediaSource.prototype &&
            "function" == typeof window.MediaSource.prototype.removeSourceBuffer
          );
        }),
        (e.canChangeType = function () {
          return (
            window.SourceBuffer &&
            window.SourceBuffer.prototype &&
            "function" == typeof window.SourceBuffer.prototype.changeType
          );
        }),
        (t.canChangeType = function () {
          return this.constructor.canChangeType();
        }),
        (t.changeType = function (e, t) {
          this.canChangeType()
            ? qu({
                type: e,
                sourceUpdater: this,
                action: uc(t),
                name: "changeType",
              })
            : w.log.error("changeType is not supported!");
        }),
        (t.addOrChangeSourceBuffers = function (n) {
          var i = this;
          if (!n || "object" != typeof n || 0 === Object.keys(n).length)
            throw new Error(
              "Cannot addOrChangeSourceBuffers to undefined codecs"
            );
          Object.keys(n).forEach(function (e) {
            var t = n[e];
            if (!i.hasCreatedSourceBuffers()) return i.addSourceBuffer(e, t);
            i.canChangeType() && i.changeType(e, t);
          });
        }),
        (t.appendBuffer = function (e, t) {
          var n = this,
            i = e.segmentInfo,
            r = e.type,
            a = e.bytes;
          if (
            ((this.processedAppend_ = !0),
            "audio" === r && this.videoBuffer && !this.videoAppendQueued_)
          )
            return (
              this.delayedAudioAppendQueue_.push([e, t]),
              void this.logger_(
                "delayed audio append of " + a.length + " until video append"
              )
            );
          qu({
            type: r,
            sourceUpdater: this,
            action: ec(a, i || { mediaIndex: -1 }, t),
            doneFn: t,
            name: "appendBuffer",
          }),
            "video" === r &&
              ((this.videoAppendQueued_ = !0),
              this.delayedAudioAppendQueue_.length &&
                ((r = this.delayedAudioAppendQueue_.slice()),
                this.logger_(
                  "queuing delayed audio " + r.length + " appendBuffers"
                ),
                (this.delayedAudioAppendQueue_.length = 0),
                r.forEach(function (e) {
                  n.appendBuffer.apply(n, e);
                })));
        }),
        (t.audioBuffered = function () {
          return (
            (Gu(this.mediaSource, this.audioBuffer) &&
              this.audioBuffer.buffered) ||
            w.createTimeRange()
          );
        }),
        (t.videoBuffered = function () {
          return (
            (Gu(this.mediaSource, this.videoBuffer) &&
              this.videoBuffer.buffered) ||
            w.createTimeRange()
          );
        }),
        (t.buffered = function () {
          var e = Gu(this.mediaSource, this.videoBuffer)
              ? this.videoBuffer
              : null,
            t = Gu(this.mediaSource, this.audioBuffer)
              ? this.audioBuffer
              : null;
          return t && !e
            ? this.audioBuffered()
            : e && !t
            ? this.videoBuffered()
            : (function (e, t) {
                var n = null,
                  i = null,
                  r = 0,
                  a = [],
                  s = [];
                if (!(e && e.length && t && t.length))
                  return w.createTimeRange();
                for (var o = e.length; o--; )
                  a.push({ time: e.start(o), type: "start" }),
                    a.push({ time: e.end(o), type: "end" });
                for (o = t.length; o--; )
                  a.push({ time: t.start(o), type: "start" }),
                    a.push({ time: t.end(o), type: "end" });
                for (
                  a.sort(function (e, t) {
                    return e.time - t.time;
                  }),
                    o = 0;
                  o < a.length;
                  o++
                )
                  "start" === a[o].type
                    ? 2 === ++r && (n = a[o].time)
                    : "end" === a[o].type && 1 === --r && (i = a[o].time),
                    null !== n &&
                      null !== i &&
                      (s.push([n, i]), (i = n = null));
                return w.createTimeRanges(s);
              })(this.audioBuffered(), this.videoBuffered());
        }),
        (t.setDuration = function (e, t) {
          void 0 === t && (t = Ru),
            qu({
              type: "mediaSource",
              sourceUpdater: this,
              action: ac(e),
              name: "duration",
              doneFn: t,
            });
        }),
        (t.endOfStream = function (e, t) {
          void 0 === t && (t = Ru),
            qu({
              type: "mediaSource",
              sourceUpdater: this,
              action: rc(
                (e =
                  "string" != typeof (e = void 0 === e ? null : e) ? void 0 : e)
              ),
              name: "endOfStream",
              doneFn: t,
            });
        }),
        (t.removeAudio = function (e, t, n) {
          void 0 === n && (n = Ru),
            this.audioBuffered().length && 0 !== this.audioBuffered().end(0)
              ? qu({
                  type: "audio",
                  sourceUpdater: this,
                  action: tc(e, t),
                  doneFn: n,
                  name: "remove",
                })
              : n();
        }),
        (t.removeVideo = function (e, t, n) {
          void 0 === n && (n = Ru),
            this.videoBuffered().length && 0 !== this.videoBuffered().end(0)
              ? qu({
                  type: "video",
                  sourceUpdater: this,
                  action: tc(e, t),
                  doneFn: n,
                  name: "remove",
                })
              : n();
        }),
        (t.updating = function () {
          return !(!Uu("audio", this) && !Uu("video", this));
        }),
        (t.audioTimestampOffset = function (e) {
          return (
            "undefined" != typeof e &&
              this.audioBuffer &&
              this.audioTimestampOffset_ !== e &&
              (qu({
                type: "audio",
                sourceUpdater: this,
                action: nc(e),
                name: "timestampOffset",
              }),
              (this.audioTimestampOffset_ = e)),
            this.audioTimestampOffset_
          );
        }),
        (t.videoTimestampOffset = function (e) {
          return (
            "undefined" != typeof e &&
              this.videoBuffer &&
              this.videoTimestampOffset !== e &&
              (qu({
                type: "video",
                sourceUpdater: this,
                action: nc(e),
                name: "timestampOffset",
              }),
              (this.videoTimestampOffset_ = e)),
            this.videoTimestampOffset_
          );
        }),
        (t.audioQueueCallback = function (e) {
          this.audioBuffer &&
            qu({
              type: "audio",
              sourceUpdater: this,
              action: ic(e),
              name: "callback",
            });
        }),
        (t.videoQueueCallback = function (e) {
          this.videoBuffer &&
            qu({
              type: "video",
              sourceUpdater: this,
              action: ic(e),
              name: "callback",
            });
        }),
        (t.dispose = function () {
          var t = this;
          this.trigger("dispose"),
            $u.forEach(function (e) {
              t.abort(e),
                t.canRemoveSourceBuffer()
                  ? t.removeSourceBuffer(e)
                  : t[e + "QueueCallback"](function () {
                      return Fu(e, t);
                    });
            }),
            (this.videoAppendQueued_ = !1),
            (this.delayedAudioAppendQueue_.length = 0),
            this.sourceopenListener_ &&
              this.mediaSource.removeEventListener(
                "sourceopen",
                this.sourceopenListener_
              ),
            this.off();
        }),
        e
      );
    })(w.EventTarget),
    dc = new Uint8Array(
      "\n\n".split("").map(function (e) {
        return e.charCodeAt(0);
      })
    ),
    hc = (function (n) {
      function e(e, t) {
        return (
          ((t =
            n.call(this, e, (t = void 0 === t ? {} : t)) || this).mediaSource_ =
            null),
          (t.subtitlesTrack_ = null),
          (t.loaderType_ = "subtitle"),
          (t.featuresNativeTextTracks_ = e.featuresNativeTextTracks),
          (t.shouldSaveSegmentTimingInfo_ = !1),
          t
        );
      }
      b(e, n);
      var t = e.prototype;
      return (
        (t.createTransmuxer_ = function () {
          return null;
        }),
        (t.buffered_ = function () {
          if (
            !this.subtitlesTrack_ ||
            !this.subtitlesTrack_.cues ||
            !this.subtitlesTrack_.cues.length
          )
            return w.createTimeRanges();
          var e = this.subtitlesTrack_.cues,
            t = e[0].startTime,
            e = e[e.length - 1].startTime;
          return w.createTimeRanges([[t, e]]);
        }),
        (t.initSegmentForMap = function (e, t) {
          if ((void 0 === t && (t = !1), !e)) return null;
          var n = wl(e),
            i = this.initSegments_[n];
          return (
            t &&
              !i &&
              e.bytes &&
              ((t = dc.byteLength + e.bytes.byteLength),
              (t = new Uint8Array(t)).set(e.bytes),
              t.set(dc, e.bytes.byteLength),
              (this.initSegments_[n] = i =
                {
                  resolvedUri: e.resolvedUri,
                  byterange: e.byterange,
                  bytes: t,
                })),
            i || e
          );
        }),
        (t.couldBeginLoading_ = function () {
          return this.playlist_ && this.subtitlesTrack_ && !this.paused();
        }),
        (t.init_ = function () {
          return (
            (this.state = "READY"),
            this.resetEverything(),
            this.monitorBuffer_()
          );
        }),
        (t.track = function (e) {
          return (
            "undefined" == typeof e ||
              ((this.subtitlesTrack_ = e),
              "INIT" === this.state &&
                this.couldBeginLoading_() &&
                this.init_()),
            this.subtitlesTrack_
          );
        }),
        (t.remove = function (e, t) {
          ou(e, t, this.subtitlesTrack_);
        }),
        (t.fillBuffer_ = function () {
          var e = this,
            t = this.chooseNextRequest_();
          if (t) {
            if (
              null ===
              this.syncController_.timestampOffsetForTimeline(t.timeline)
            )
              return (
                this.syncController_.one("timestampoffset", function () {
                  (e.state = "READY"), e.paused() || e.monitorBuffer_();
                }),
                void (this.state = "WAITING_ON_TIMELINE")
              );
            this.loadSegment_(t);
          }
        }),
        (t.timestampOffsetForSegment_ = function () {
          return null;
        }),
        (t.chooseNextRequest_ = function () {
          return this.skipEmptySegments_(
            n.prototype.chooseNextRequest_.call(this)
          );
        }),
        (t.skipEmptySegments_ = function (e) {
          for (; e && e.segment.empty; ) {
            if (e.mediaIndex + 1 >= e.playlist.segments.length) {
              e = null;
              break;
            }
            e = this.generateSegmentInfo_({
              playlist: e.playlist,
              mediaIndex: e.mediaIndex + 1,
              startOfSegment: e.startOfSegment + e.duration,
              isSyncRequest: e.isSyncRequest,
            });
          }
          return e;
        }),
        (t.stopForError = function (e) {
          this.error(e),
            (this.state = "READY"),
            this.pause(),
            this.trigger("error");
        }),
        (t.segmentRequestFinished_ = function (e, t, n) {
          var i = this;
          if (this.subtitlesTrack_) {
            if ((this.saveTransferStats_(t.stats), !this.pendingSegment_))
              return (
                (this.state = "READY"), void (this.mediaRequestsAborted += 1)
              );
            if (e)
              return (
                e.code === ju && this.handleTimeout_(),
                e.code === Nu
                  ? (this.mediaRequestsAborted += 1)
                  : (this.mediaRequestsErrored += 1),
                void this.stopForError(e)
              );
            var r = this.pendingSegment_;
            this.saveBandwidthRelatedStats_(r.duration, t.stats),
              t.key && this.segmentKey(t.key, !0),
              (this.state = "APPENDING"),
              this.trigger("appending");
            var a = r.segment;
            if (
              (a.map && (a.map.bytes = t.map.bytes),
              (r.bytes = t.bytes),
              "function" != typeof window.WebVTT &&
                this.subtitlesTrack_ &&
                this.subtitlesTrack_.tech_)
            ) {
              var s = function () {
                  i.subtitlesTrack_.tech_.off("vttjsloaded", o),
                    i.stopForError({ message: "Error loading vtt.js" });
                },
                o = function () {
                  i.subtitlesTrack_.tech_.off("vttjserror", s),
                    i.segmentRequestFinished_(e, t, n);
                };
              return (
                (this.state = "WAITING_ON_VTTJS"),
                this.subtitlesTrack_.tech_.one("vttjsloaded", o),
                void this.subtitlesTrack_.tech_.one("vttjserror", s)
              );
            }
            a.requested = !0;
            try {
              this.parseVTTCues_(r);
            } catch (e) {
              return void this.stopForError({ message: e.message });
            }
            if (
              (this.updateTimeMapping_(
                r,
                this.syncController_.timelines[r.timeline],
                this.playlist_
              ),
              r.cues.length
                ? (r.timingInfo = {
                    start: r.cues[0].startTime,
                    end: r.cues[r.cues.length - 1].endTime,
                  })
                : (r.timingInfo = {
                    start: r.startOfSegment,
                    end: r.startOfSegment + r.duration,
                  }),
              r.isSyncRequest)
            )
              return (
                this.trigger("syncinfoupdate"),
                (this.pendingSegment_ = null),
                void (this.state = "READY")
              );
            (r.byteLength = r.bytes.byteLength),
              (this.mediaSecondsLoaded += a.duration),
              r.cues.forEach(function (e) {
                i.subtitlesTrack_.addCue(
                  i.featuresNativeTextTracks_
                    ? new window.VTTCue(e.startTime, e.endTime, e.text)
                    : e
                );
              }),
              (function (t) {
                var e = t.cues;
                if (e)
                  for (var n = 0; n < e.length; n++) {
                    for (var i = [], r = 0, a = 0; a < e.length; a++)
                      e[n].startTime === e[a].startTime &&
                        e[n].endTime === e[a].endTime &&
                        e[n].text === e[a].text &&
                        1 < ++r &&
                        i.push(e[a]);
                    i.length &&
                      i.forEach(function (e) {
                        return t.removeCue(e);
                      });
                  }
              })(this.subtitlesTrack_),
              this.handleAppendsDone_();
          } else this.state = "READY";
        }),
        (t.handleData_ = function () {}),
        (t.updateTimingInfoEnd_ = function () {}),
        (t.parseVTTCues_ = function (t) {
          var e = !1;
          "function" == typeof window.TextDecoder
            ? (n = new window.TextDecoder("utf8"))
            : ((n = window.WebVTT.StringDecoder()), (e = !0));
          var n = new window.WebVTT.Parser(window, window.vttjs, n);
          (t.cues = []),
            (t.timestampmap = { MPEGTS: 0, LOCAL: 0 }),
            (n.oncue = t.cues.push.bind(t.cues)),
            (n.ontimestampmap = function (e) {
              t.timestampmap = e;
            }),
            (n.onparsingerror = function (e) {
              w.log.warn("Error encountered when parsing cues: " + e.message);
            }),
            t.segment.map &&
              ((i = t.segment.map.bytes), e && (i = Hu(i)), n.parse(i));
          var i = t.bytes;
          e && (i = Hu(i)), n.parse(i), n.flush();
        }),
        (t.updateTimeMapping_ = function (e, t, n) {
          var i,
            r,
            a = e.segment;
          t &&
            (e.cues.length
              ? ((r = e.timestampmap),
                (i = r.MPEGTS / fu - r.LOCAL + t.mapping),
                e.cues.forEach(function (e) {
                  (e.startTime += i), (e.endTime += i);
                }),
                n.syncInfo ||
                  ((r = e.cues[0].startTime),
                  (t = e.cues[e.cues.length - 1].startTime),
                  (n.syncInfo = {
                    mediaSequence: n.mediaSequence + e.mediaIndex,
                    time: Math.min(r, t - a.duration),
                  })))
              : (a.empty = !0));
        }),
        e
      );
    })(Du),
    pc = [
      {
        name: "VOD",
        run: function (e, t, n, i, r) {
          if (n === 1 / 0) return null;
          return { time: 0, segmentIndex: 0, partIndex: null };
        },
      },
      {
        name: "ProgramDateTime",
        run: function (e, t, n, i, r) {
          if (!Object.keys(e.timelineToDatetimeMappings).length) return null;
          var a = null,
            s = null,
            o = Xo(t);
          r = r || 0;
          for (var l = 0; l < o.length; l++) {
            var u = o[t.endList || 0 === r ? l : o.length - (l + 1)],
              c = u.segment,
              d = e.timelineToDatetimeMappings[c.timeline];
            if (d && c.dateTimeObject) {
              var h = c.dateTimeObject.getTime() / 1e3 + d;
              if (c.parts && "number" == typeof u.partIndex)
                for (var p = 0; p < u.partIndex; p++) h += c.parts[p].duration;
              d = Math.abs(r - h);
              if (null !== s && (0 === d || s < d)) break;
              (s = d),
                (a = {
                  time: h,
                  segmentIndex: u.segmentIndex,
                  partIndex: u.partIndex,
                });
            }
          }
          return a;
        },
      },
      {
        name: "Segment",
        run: function (e, t, n, i, r) {
          var a = null,
            s = null;
          r = r || 0;
          for (var o = Xo(t), l = 0; l < o.length; l++) {
            var u = o[t.endList || 0 === r ? l : o.length - (l + 1)],
              c = u.segment,
              d = (u.part && u.part.start) || (c && c.start);
            if (c.timeline === i && "undefined" != typeof d) {
              c = Math.abs(r - d);
              if (null !== s && s < c) break;
              (!a || null === s || c <= s) &&
                ((s = c),
                (a = {
                  time: d,
                  segmentIndex: u.segmentIndex,
                  partIndex: u.partIndex,
                }));
            }
          }
          return a;
        },
      },
      {
        name: "Discontinuity",
        run: function (e, t, n, i, r) {
          var a = null;
          if (
            ((r = r || 0),
            t.discontinuityStarts && t.discontinuityStarts.length)
          )
            for (var s = null, o = 0; o < t.discontinuityStarts.length; o++) {
              var l = t.discontinuityStarts[o],
                u = t.discontinuitySequence + o + 1,
                c = e.discontinuities[u];
              if (c) {
                u = Math.abs(r - c.time);
                if (null !== s && s < u) break;
                (!a || null === s || u <= s) &&
                  ((s = u),
                  (a = { time: c.time, segmentIndex: l, partIndex: null }));
              }
            }
          return a;
        },
      },
      {
        name: "Playlist",
        run: function (e, t, n, i, r) {
          return t.syncInfo
            ? {
                time: t.syncInfo.time,
                segmentIndex: t.syncInfo.mediaSequence - t.mediaSequence,
                partIndex: null,
              }
            : null;
        },
      },
    ],
    mc = (function (n) {
      function e(e) {
        var t = n.call(this) || this;
        return (
          (t.timelines = []),
          (t.discontinuities = []),
          (t.timelineToDatetimeMappings = {}),
          (t.logger_ = Bo("SyncController")),
          t
        );
      }
      b(e, n);
      var t = e.prototype;
      return (
        (t.getSyncPoint = function (e, t, n, i) {
          n = this.runStrategies_(e, t, n, i);
          return n.length
            ? this.selectSyncPoint_(n, { key: "time", value: i })
            : null;
        }),
        (t.getExpiredTime = function (e, t) {
          if (!e || !e.segments) return null;
          t = this.runStrategies_(e, t, e.discontinuitySequence, 0);
          if (!t.length) return null;
          t = this.selectSyncPoint_(t, { key: "segmentIndex", value: 0 });
          return (
            0 < t.segmentIndex && (t.time *= -1),
            Math.abs(
              t.time +
                $o({
                  defaultDuration: e.targetDuration,
                  durationList: e.segments,
                  startIndex: t.segmentIndex,
                  endIndex: 0,
                })
            )
          );
        }),
        (t.runStrategies_ = function (e, t, n, i) {
          for (var r = [], a = 0; a < pc.length; a++) {
            var s = pc[a],
              o = s.run(this, e, t, n, i);
            o &&
              ((o.strategy = s.name),
              r.push({ strategy: s.name, syncPoint: o }));
          }
          return r;
        }),
        (t.selectSyncPoint_ = function (e, t) {
          for (
            var n = e[0].syncPoint,
              i = Math.abs(e[0].syncPoint[t.key] - t.value),
              r = e[0].strategy,
              a = 1;
            a < e.length;
            a++
          ) {
            var s = Math.abs(e[a].syncPoint[t.key] - t.value);
            s < i && ((i = s), (n = e[a].syncPoint), (r = e[a].strategy));
          }
          return (
            this.logger_(
              "syncPoint for [" +
                t.key +
                ": " +
                t.value +
                "] chosen with strategy [" +
                r +
                "]: [time:" +
                n.time +
                ", segmentIndex:" +
                n.segmentIndex +
                ("number" == typeof n.partIndex
                  ? ",partIndex:" + n.partIndex
                  : "") +
                "]"
            ),
            n
          );
        }),
        (t.saveExpiredSegmentInfo = function (e, t) {
          var n = t.mediaSequence - e.mediaSequence;
          if (86400 < n)
            w.log.warn(
              "Not saving expired segment info. Media sequence gap " +
                n +
                " is too large."
            );
          else
            for (var i = n - 1; 0 <= i; i--) {
              var r = e.segments[i];
              if (r && "undefined" != typeof r.start) {
                (t.syncInfo = {
                  mediaSequence: e.mediaSequence + i,
                  time: r.start,
                }),
                  this.logger_(
                    "playlist refresh sync: [time:" +
                      t.syncInfo.time +
                      ", mediaSequence: " +
                      t.syncInfo.mediaSequence +
                      "]"
                  ),
                  this.trigger("syncinfoupdate");
                break;
              }
            }
        }),
        (t.setDateTimeMappingForStart = function (e) {
          var t;
          (this.timelineToDatetimeMappings = {}),
            e.segments &&
              e.segments.length &&
              e.segments[0].dateTimeObject &&
              ((e = (t = e.segments[0]).dateTimeObject.getTime() / 1e3),
              (this.timelineToDatetimeMappings[t.timeline] = -e));
        }),
        (t.saveSegmentTimingInfo = function (e) {
          var t = e.segmentInfo,
            n = e.shouldSaveTimelineMapping,
            i = this.calculateSegmentTimeMapping_(t, t.timingInfo, n),
            e = t.segment;
          i &&
            (this.saveDiscontinuitySyncInfo_(t),
            t.playlist.syncInfo ||
              (t.playlist.syncInfo = {
                mediaSequence: t.playlist.mediaSequence + t.mediaIndex,
                time: e.start,
              }));
          t = e.dateTimeObject;
          e.discontinuity &&
            n &&
            t &&
            (this.timelineToDatetimeMappings[e.timeline] = -t.getTime() / 1e3);
        }),
        (t.timestampOffsetForTimeline = function (e) {
          return "undefined" == typeof this.timelines[e]
            ? null
            : this.timelines[e].time;
        }),
        (t.mappingForTimeline = function (e) {
          return "undefined" == typeof this.timelines[e]
            ? null
            : this.timelines[e].mapping;
        }),
        (t.calculateSegmentTimeMapping_ = function (e, t, n) {
          var i,
            r,
            a = e.segment,
            s = e.part,
            o = this.timelines[e.timeline];
          if ("number" == typeof e.timestampOffset)
            (o = {
              time: e.startOfSegment,
              mapping: e.startOfSegment - t.start,
            }),
              n &&
                ((this.timelines[e.timeline] = o),
                this.trigger("timestampoffset"),
                this.logger_(
                  "time mapping for timeline " +
                    e.timeline +
                    ": [time: " +
                    o.time +
                    "] [mapping: " +
                    o.mapping +
                    "]"
                )),
              (i = e.startOfSegment),
              (r = t.end + o.mapping);
          else {
            if (!o) return !1;
            (i = t.start + o.mapping), (r = t.end + o.mapping);
          }
          return (
            s && ((s.start = i), (s.end = r)),
            (!a.start || i < a.start) && (a.start = i),
            (a.end = r),
            !0
          );
        }),
        (t.saveDiscontinuitySyncInfo_ = function (e) {
          var t = e.playlist,
            n = e.segment;
          if (n.discontinuity)
            this.discontinuities[n.timeline] = { time: n.start, accuracy: 0 };
          else if (t.discontinuityStarts && t.discontinuityStarts.length)
            for (var i = 0; i < t.discontinuityStarts.length; i++) {
              var r,
                a = t.discontinuityStarts[i],
                s = t.discontinuitySequence + i + 1,
                o = a - e.mediaIndex,
                l = Math.abs(o);
              (!this.discontinuities[s] ||
                this.discontinuities[s].accuracy > l) &&
                ((r = void 0),
                (r =
                  o < 0
                    ? n.start -
                      $o({
                        defaultDuration: t.targetDuration,
                        durationList: t.segments,
                        startIndex: e.mediaIndex,
                        endIndex: a,
                      })
                    : n.end +
                      $o({
                        defaultDuration: t.targetDuration,
                        durationList: t.segments,
                        startIndex: e.mediaIndex + 1,
                        endIndex: a,
                      })),
                (this.discontinuities[s] = { time: r, accuracy: l }));
            }
        }),
        (t.dispose = function () {
          this.trigger("dispose"), this.off();
        }),
        e
      );
    })(w.EventTarget),
    fc = (function (t) {
      function e() {
        var e = t.call(this) || this;
        return (
          (e.pendingTimelineChanges_ = {}), (e.lastTimelineChanges_ = {}), e
        );
      }
      b(e, t);
      var n = e.prototype;
      return (
        (n.clearPendingTimelineChange = function (e) {
          (this.pendingTimelineChanges_[e] = null),
            this.trigger("pendingtimelinechange");
        }),
        (n.pendingTimelineChange = function (e) {
          var t = e.type,
            n = e.from,
            e = e.to;
          return (
            "number" == typeof n &&
              "number" == typeof e &&
              ((this.pendingTimelineChanges_[t] = { type: t, from: n, to: e }),
              this.trigger("pendingtimelinechange")),
            this.pendingTimelineChanges_[t]
          );
        }),
        (n.lastTimelineChange = function (e) {
          var t = e.type,
            n = e.from,
            e = e.to;
          return (
            "number" == typeof n &&
              "number" == typeof e &&
              ((this.lastTimelineChanges_[t] = { type: t, from: n, to: e }),
              delete this.pendingTimelineChanges_[t],
              this.trigger("timelinechange")),
            this.lastTimelineChanges_[t]
          );
        }),
        (n.dispose = function () {
          this.trigger("dispose"),
            (this.pendingTimelineChanges_ = {}),
            (this.lastTimelineChanges_ = {}),
            this.off();
        }),
        e
      );
    })(w.EventTarget),
    gc = r(
      he(
        s(function () {
          var e =
            "undefined" != typeof globalThis
              ? globalThis
              : "undefined" != typeof window
              ? window
              : "undefined" != typeof global
              ? global
              : "undefined" != typeof self
              ? self
              : {};
          function t(e, t, n) {
            return (
              e(
                (n = {
                  path: t,
                  exports: {},
                  require: function (e, t) {
                    return (function () {
                      throw new Error(
                        "Dynamic requires are not currently supported by @rollup/plugin-commonjs"
                      );
                    })(null == t && n.path);
                  },
                }),
                n.exports
              ),
              n.exports
            );
          }
          var n = t(function (e) {
              function i(e, t) {
                for (var n = 0; n < t.length; n++) {
                  var i = t[n];
                  (i.enumerable = i.enumerable || !1),
                    (i.configurable = !0),
                    "value" in i && (i.writable = !0),
                    Object.defineProperty(e, i.key, i);
                }
              }
              (e.exports = function (e, t, n) {
                return t && i(e.prototype, t), n && i(e, n), e;
              }),
                (e.exports.default = e.exports),
                (e.exports.__esModule = !0);
            }),
            i = t(function (n) {
              function i(e, t) {
                return (
                  (n.exports = i =
                    Object.setPrototypeOf ||
                    function (e, t) {
                      return (e.__proto__ = t), e;
                    }),
                  (n.exports.default = n.exports),
                  (n.exports.__esModule = !0),
                  i(e, t)
                );
              }
              (n.exports = i),
                (n.exports.default = n.exports),
                (n.exports.__esModule = !0);
            }),
            r = t(function (e) {
              (e.exports = function (e, t) {
                (e.prototype = Object.create(t.prototype)),
                  (e.prototype.constructor = e),
                  i(e, t);
              }),
                (e.exports.default = e.exports),
                (e.exports.__esModule = !0);
            }),
            a = (function () {
              function e() {
                this.listeners = {};
              }
              var t = e.prototype;
              return (
                (t.on = function (e, t) {
                  this.listeners[e] || (this.listeners[e] = []),
                    this.listeners[e].push(t);
                }),
                (t.off = function (e, t) {
                  if (!this.listeners[e]) return !1;
                  t = this.listeners[e].indexOf(t);
                  return (
                    (this.listeners[e] = this.listeners[e].slice(0)),
                    this.listeners[e].splice(t, 1),
                    -1 < t
                  );
                }),
                (t.trigger = function (e) {
                  var t = this.listeners[e];
                  if (t)
                    if (2 === arguments.length)
                      for (var n = t.length, i = 0; i < n; ++i)
                        t[i].call(this, arguments[1]);
                    else
                      for (
                        var r = Array.prototype.slice.call(arguments, 1),
                          a = t.length,
                          s = 0;
                        s < a;
                        ++s
                      )
                        t[s].apply(this, r);
                }),
                (t.dispose = function () {
                  this.listeners = {};
                }),
                (t.pipe = function (t) {
                  this.on("data", function (e) {
                    t.push(e);
                  });
                }),
                e
              );
            })();
          var c = null,
            f = (function () {
              function e(e) {
                var t, n, i;
                (c =
                  c ||
                  (function () {
                    for (
                      var e,
                        t,
                        n,
                        i,
                        r,
                        a,
                        s,
                        o = [
                          [[], [], [], [], []],
                          [[], [], [], [], []],
                        ],
                        l = o[0],
                        u = o[1],
                        c = l[4],
                        d = u[4],
                        h = [],
                        p = [],
                        m = 0;
                      m < 256;
                      m++
                    )
                      p[(h[m] = (m << 1) ^ (283 * (m >> 7))) ^ m] = m;
                    for (e = t = 0; !c[e]; e ^= n || 1, t = p[t] || 1)
                      for (
                        s =
                          (16843009 *
                            h[
                              (i =
                                h[
                                  (n =
                                    h[
                                      (d[
                                        (c[e] = r =
                                          ((r =
                                            t ^
                                            (t << 1) ^
                                            (t << 2) ^
                                            (t << 3) ^
                                            (t << 4)) >>
                                            8) ^
                                          (255 & r) ^
                                          99)
                                      ] = e)
                                    ])
                                ])
                            ]) ^
                          (65537 * i) ^
                          (257 * n) ^
                          (16843008 * e),
                          a = (257 * h[r]) ^ (16843008 * r),
                          m = 0;
                        m < 4;
                        m++
                      )
                        (l[m][e] = a = (a << 24) ^ (a >>> 8)),
                          (u[m][r] = s = (s << 24) ^ (s >>> 8));
                    for (m = 0; m < 5; m++)
                      (l[m] = l[m].slice(0)), (u[m] = u[m].slice(0));
                    return o;
                  })()),
                  (this._tables = [
                    [
                      c[0][0].slice(),
                      c[0][1].slice(),
                      c[0][2].slice(),
                      c[0][3].slice(),
                      c[0][4].slice(),
                    ],
                    [
                      c[1][0].slice(),
                      c[1][1].slice(),
                      c[1][2].slice(),
                      c[1][3].slice(),
                      c[1][4].slice(),
                    ],
                  ]);
                var r = this._tables[0][4],
                  a = this._tables[1],
                  s = e.length,
                  o = 1;
                if (4 !== s && 6 !== s && 8 !== s)
                  throw new Error("Invalid aes key size");
                var l = e.slice(0),
                  u = [];
                for (this._key = [l, u], t = s; t < 4 * s + 28; t++)
                  (i = l[t - 1]),
                    (t % s == 0 || (8 === s && t % s == 4)) &&
                      ((i =
                        (r[i >>> 24] << 24) ^
                        (r[(i >> 16) & 255] << 16) ^
                        (r[(i >> 8) & 255] << 8) ^
                        r[255 & i]),
                      t % s == 0 &&
                        ((i = (i << 8) ^ (i >>> 24) ^ (o << 24)),
                        (o = (o << 1) ^ (283 * (o >> 7))))),
                    (l[t] = l[t - s] ^ i);
                for (n = 0; t; n++, t--)
                  (i = l[3 & n ? t : t - 4]),
                    (u[n] =
                      t <= 4 || n < 4
                        ? i
                        : a[0][r[i >>> 24]] ^
                          a[1][r[(i >> 16) & 255]] ^
                          a[2][r[(i >> 8) & 255]] ^
                          a[3][r[255 & i]]);
              }
              return (
                (e.prototype.decrypt = function (e, t, n, i, r, a) {
                  for (
                    var s,
                      o,
                      l,
                      u = this._key[1],
                      c = e ^ u[0],
                      d = i ^ u[1],
                      h = n ^ u[2],
                      p = t ^ u[3],
                      m = u.length / 4 - 2,
                      f = 4,
                      t = this._tables[1],
                      g = t[0],
                      b = t[1],
                      v = t[2],
                      y = t[3],
                      _ = t[4],
                      T = 0;
                    T < m;
                    T++
                  )
                    (s =
                      g[c >>> 24] ^
                      b[(d >> 16) & 255] ^
                      v[(h >> 8) & 255] ^
                      y[255 & p] ^
                      u[f]),
                      (o =
                        g[d >>> 24] ^
                        b[(h >> 16) & 255] ^
                        v[(p >> 8) & 255] ^
                        y[255 & c] ^
                        u[f + 1]),
                      (l =
                        g[h >>> 24] ^
                        b[(p >> 16) & 255] ^
                        v[(c >> 8) & 255] ^
                        y[255 & d] ^
                        u[f + 2]),
                      (p =
                        g[p >>> 24] ^
                        b[(c >> 16) & 255] ^
                        v[(d >> 8) & 255] ^
                        y[255 & h] ^
                        u[f + 3]),
                      (f += 4),
                      (c = s),
                      (d = o),
                      (h = l);
                  for (T = 0; T < 4; T++)
                    (r[(3 & -T) + a] =
                      (_[c >>> 24] << 24) ^
                      (_[(d >> 16) & 255] << 16) ^
                      (_[(h >> 8) & 255] << 8) ^
                      _[255 & p] ^
                      u[f++]),
                      (s = c),
                      (c = d),
                      (d = h),
                      (h = p),
                      (p = s);
                }),
                e
              );
            })(),
            u = (function (t) {
              function e() {
                var e = t.call(this, a) || this;
                return (e.jobs = []), (e.delay = 1), (e.timeout_ = null), e;
              }
              r(e, t);
              var n = e.prototype;
              return (
                (n.processJob_ = function () {
                  this.jobs.shift()(),
                    this.jobs.length
                      ? (this.timeout_ = setTimeout(
                          this.processJob_.bind(this),
                          this.delay
                        ))
                      : (this.timeout_ = null);
                }),
                (n.push = function (e) {
                  this.jobs.push(e),
                    this.timeout_ ||
                      (this.timeout_ = setTimeout(
                        this.processJob_.bind(this),
                        this.delay
                      ));
                }),
                e
              );
            })(a),
            g = function (e) {
              return (
                (e << 24) |
                ((65280 & e) << 8) |
                ((16711680 & e) >> 8) |
                (e >>> 24)
              );
            },
            s = (function () {
              function l(e, t, n, i) {
                var r = l.STEP,
                  a = new Int32Array(e.buffer),
                  s = new Uint8Array(e.byteLength),
                  o = 0;
                for (
                  this.asyncStream_ = new u(),
                    this.asyncStream_.push(
                      this.decryptChunk_(a.subarray(o, o + r), t, n, s)
                    ),
                    o = r;
                  o < a.length;
                  o += r
                )
                  (n = new Uint32Array([
                    g(a[o - 4]),
                    g(a[o - 3]),
                    g(a[o - 2]),
                    g(a[o - 1]),
                  ])),
                    this.asyncStream_.push(
                      this.decryptChunk_(a.subarray(o, o + r), t, n, s)
                    );
                this.asyncStream_.push(function () {
                  var e;
                  i(
                    null,
                    (e = s).subarray(0, e.byteLength - e[e.byteLength - 1])
                  );
                });
              }
              return (
                (l.prototype.decryptChunk_ = function (t, n, i, r) {
                  return function () {
                    var e = (function (e, t, n) {
                      for (
                        var i,
                          r,
                          a,
                          s,
                          o = new Int32Array(
                            e.buffer,
                            e.byteOffset,
                            e.byteLength >> 2
                          ),
                          l = new f(Array.prototype.slice.call(t)),
                          e = new Uint8Array(e.byteLength),
                          u = new Int32Array(e.buffer),
                          c = n[0],
                          d = n[1],
                          h = n[2],
                          p = n[3],
                          m = 0;
                        m < o.length;
                        m += 4
                      )
                        (i = g(o[m])),
                          (r = g(o[m + 1])),
                          (a = g(o[m + 2])),
                          (s = g(o[m + 3])),
                          l.decrypt(i, r, a, s, u, m),
                          (u[m] = g(u[m] ^ c)),
                          (u[m + 1] = g(u[m + 1] ^ d)),
                          (u[m + 2] = g(u[m + 2] ^ h)),
                          (u[m + 3] = g(u[m + 3] ^ p)),
                          (c = i),
                          (d = r),
                          (h = a),
                          (p = s);
                      return e;
                    })(t, n, i);
                    r.set(e, t.byteOffset);
                  };
                }),
                n(l, null, [
                  {
                    key: "STEP",
                    get: function () {
                      return 32e3;
                    },
                  },
                ]),
                l
              );
            })(),
            e =
              "undefined" != typeof window
                ? window
                : "undefined" != typeof e
                ? e
                : "undefined" != typeof self
                ? self
                : {},
            e = e.BigInt || Number;
          e("0x1"),
            e("0x100"),
            e("0x10000"),
            e("0x1000000"),
            e("0x100000000"),
            e("0x10000000000"),
            e("0x1000000000000"),
            e("0x100000000000000"),
            e("0x10000000000000000");
          function o(i) {
            var r = {};
            return (
              Object.keys(i).forEach(function (e) {
                var t,
                  n = i[e];
                (t = n),
                  (
                    "function" === ArrayBuffer.isView
                      ? ArrayBuffer.isView(t)
                      : t && t.buffer instanceof ArrayBuffer
                  )
                    ? (r[e] = {
                        bytes: n.buffer,
                        byteOffset: n.byteOffset,
                        byteLength: n.byteLength,
                      })
                    : (r[e] = n);
              }),
              r
            );
          }
          self.onmessage = function (e) {
            var n = e.data,
              t = new Uint8Array(
                n.encrypted.bytes,
                n.encrypted.byteOffset,
                n.encrypted.byteLength
              ),
              i = new Uint32Array(
                n.key.bytes,
                n.key.byteOffset,
                n.key.byteLength / 4
              ),
              e = new Uint32Array(
                n.iv.bytes,
                n.iv.byteOffset,
                n.iv.byteLength / 4
              );
            new s(t, i, e, function (e, t) {
              self.postMessage(o({ source: n.source, decrypted: t }), [
                t.buffer,
              ]);
            });
          };
        })
      )
    ),
    bc = {
      AUDIO: function (s, o) {
        return function () {
          var e = o.segmentLoaders[s],
            t = o.mediaTypes[s],
            n = o.blacklistCurrentPlaylist;
          Wu(e, t);
          var i = t.activeTrack(),
            e = t.activeGroup(),
            e = (
              e.filter(function (e) {
                return e.default;
              })[0] || e[0]
            ).id,
            r = t.tracks[e];
          if (i !== r) {
            for (var a in (w.log.warn(
              "Problem encountered loading the alternate audio track.Switching back to default."
            ),
            t.tracks))
              t.tracks[a].enabled = t.tracks[a] === r;
            t.onTrackChanged();
          } else
            n({
              message: "Problem encountered loading the default audio track.",
            });
        };
      },
      SUBTITLES: function (n, i) {
        return function () {
          var e = i.segmentLoaders[n],
            t = i.mediaTypes[n];
          w.log.warn(
            "Problem encountered loading the subtitle track.Disabling subtitle track."
          ),
            Wu(e, t);
          e = t.activeTrack();
          e && (e.mode = "disabled"), t.onTrackChanged();
        };
      },
    },
    vc = {
      AUDIO: function (e, t, n) {
        var i, r, a;
        t &&
          ((i = n.tech),
          (r = n.requestOptions),
          (a = n.segmentLoaders[e]),
          t.on("loadedmetadata", function () {
            var e = t.media();
            a.playlist(e, r),
              (!i.paused() || (e.endList && "none" !== i.preload())) &&
                a.load();
          }),
          t.on("loadedplaylist", function () {
            a.playlist(t.media(), r), i.paused() || a.load();
          }),
          t.on("error", bc[e](e, n)));
      },
      SUBTITLES: function (e, t, n) {
        var i = n.tech,
          r = n.requestOptions,
          a = n.segmentLoaders[e],
          s = n.mediaTypes[e];
        t.on("loadedmetadata", function () {
          var e = t.media();
          a.playlist(e, r),
            a.track(s.activeTrack()),
            (!i.paused() || (e.endList && "none" !== i.preload())) && a.load();
        }),
          t.on("loadedplaylist", function () {
            a.playlist(t.media(), r), i.paused() || a.load();
          }),
          t.on("error", bc[e](e, n));
      },
    },
    yc = {
      AUDIO: function (e, t) {
        var n,
          i,
          r = t.vhs,
          a = t.sourceType,
          s = t.segmentLoaders[e],
          o = t.requestOptions,
          l = t.master.mediaGroups,
          u = t.mediaTypes[e],
          c = u.groups,
          d = u.tracks,
          h = u.logger_,
          p = t.masterPlaylistLoader,
          m = ll(p.master);
        for (n in ((l[e] && 0 !== Object.keys(l[e]).length) ||
          ((l[e] = { main: { default: { default: !0 } } }),
          m && (l[e].main.default.playlists = p.master.playlists)),
        l[e]))
          for (var f in (c[n] || (c[n] = []), l[e][n])) {
            var g = l[e][n][f],
              b = void 0,
              b = m
                ? (h(
                    "AUDIO group '" +
                      n +
                      "' label '" +
                      f +
                      "' is a master playlist"
                  ),
                  (g.isMasterPlaylist = !0),
                  null)
                : "vhs-json" === a && g.playlists
                ? new Ou(g.playlists[0], r, o)
                : g.resolvedUri
                ? new Ou(g.resolvedUri, r, o)
                : g.playlists && "dash" === a
                ? new Cu(g.playlists[0], r, o, p)
                : null,
              g = w.mergeOptions({ id: f, playlistLoader: b }, g);
            vc[e](e, g.playlistLoader, t),
              c[n].push(g),
              "undefined" == typeof d[f] &&
                ((g = new w.AudioTrack({
                  id: f,
                  kind:
                    ((i = void 0),
                    (i = (b = g).default ? "main" : "alternative"),
                    (i =
                      b.characteristics &&
                      0 <=
                        b.characteristics.indexOf(
                          "public.accessibility.describes-video"
                        )
                        ? "main-desc"
                        : i)),
                  enabled: !1,
                  language: g.language,
                  default: g.default,
                  label: f,
                })),
                (d[f] = g));
          }
        s.on("error", bc[e](e, t));
      },
      SUBTITLES: function (e, t) {
        var n,
          i = t.tech,
          r = t.vhs,
          a = t.sourceType,
          s = t.segmentLoaders[e],
          o = t.requestOptions,
          l = t.master.mediaGroups,
          u = t.mediaTypes[e],
          c = u.groups,
          d = u.tracks,
          h = t.masterPlaylistLoader;
        for (n in l[e])
          for (var p in (c[n] || (c[n] = []), l[e][n]))
            if (!l[e][n][p].forced) {
              var m = l[e][n][p],
                f = void 0;
              if ("hls" === a) f = new Ou(m.resolvedUri, r, o);
              else if ("dash" === a) {
                if (
                  !m.playlists.filter(function (e) {
                    return e.excludeUntil !== 1 / 0;
                  }).length
                )
                  return;
                f = new Cu(m.playlists[0], r, o, h);
              } else
                "vhs-json" === a &&
                  (f = new Ou(
                    m.playlists ? m.playlists[0] : m.resolvedUri,
                    r,
                    o
                  ));
              (m = w.mergeOptions({ id: p, playlistLoader: f }, m)),
                vc[e](e, m.playlistLoader, t),
                c[n].push(m),
                "undefined" == typeof d[p] &&
                  ((m = i.addRemoteTextTrack(
                    {
                      id: p,
                      kind: "subtitles",
                      default: m.default && m.autoselect,
                      language: m.language,
                      label: p,
                    },
                    !1
                  ).track),
                  (d[p] = m));
            }
        s.on("error", bc[e](e, t));
      },
      "CLOSED-CAPTIONS": function (e, t) {
        var n,
          i = t.tech,
          r = t.master.mediaGroups,
          t = t.mediaTypes[e],
          a = t.groups,
          s = t.tracks;
        for (n in r[e])
          for (var o in (a[n] || (a[n] = []), r[e][n])) {
            var l,
              u,
              c = r[e][n][o];
            /^(?:CC|SERVICE)/.test(c.instreamId) &&
              (void 0 ===
                (u = (l =
                  (i.options_.vhs && i.options_.vhs.captionServices) || {})[
                  (u = {
                    label: o,
                    language: c.language,
                    instreamId: c.instreamId,
                    default: c.default && c.autoselect,
                  }).instreamId
                ]
                  ? w.mergeOptions(u, l[u.instreamId])
                  : u).default && delete u.default,
              a[n].push(w.mergeOptions({ id: o }, c)),
              "undefined" == typeof s[o] &&
                ((u = i.addRemoteTextTrack(
                  {
                    id: u.instreamId,
                    kind: "captions",
                    default: u.default,
                    language: u.language,
                    label: u.label,
                  },
                  !1
                ).track),
                (s[o] = u)));
          }
      },
    },
    _c = {
      AUDIO: function (n, i) {
        return function () {
          var e,
            t = i.mediaTypes[n].tracks;
          for (e in t) if (t[e].enabled) return t[e];
          return null;
        };
      },
      SUBTITLES: function (n, i) {
        return function () {
          var e,
            t = i.mediaTypes[n].tracks;
          for (e in t)
            if ("showing" === t[e].mode || "hidden" === t[e].mode) return t[e];
          return null;
        };
      },
    },
    Tc = [
      "mediaRequests",
      "mediaRequestsAborted",
      "mediaRequestsTimedout",
      "mediaRequestsErrored",
      "mediaTransferDuration",
      "mediaBytesTransferred",
      "mediaAppends",
    ],
    Oc = (function (v) {
      function e(e) {
        var t = v.call(this) || this,
          n = e.src,
          i = e.handleManifestRedirects,
          r = e.withCredentials,
          a = e.tech,
          s = e.bandwidth,
          o = e.externVhs,
          l = e.useCueTags,
          u = e.blacklistDuration,
          c = e.enableLowInitialPlaylist,
          d = e.sourceType,
          h = e.cacheEncryptionKeys,
          p = e.experimentalBufferBasedABR,
          m = e.experimentalLeastPixelDiffSelector,
          f = e.captionServices;
        if (!n)
          throw new Error(
            "A non-empty playlist URL or JSON manifest string is required"
          );
        var g,
          b = e.maxPlaylistRetries;
        (null !== b && "undefined" != typeof b) || (b = 1 / 0),
          (Ju = o),
          (t.experimentalBufferBasedABR = Boolean(p)),
          (t.experimentalLeastPixelDiffSelector = Boolean(m)),
          (t.withCredentials = r),
          (t.tech_ = a),
          (t.vhs_ = a.vhs),
          (t.sourceType_ = d),
          (t.useCueTags_ = l),
          (t.blacklistDuration = u),
          (t.maxPlaylistRetries = b),
          (t.enableLowInitialPlaylist = c),
          t.useCueTags_ &&
            ((t.cueTagsTrack_ = t.tech_.addTextTrack("metadata", "ad-cues")),
            (t.cueTagsTrack_.inBandMetadataTrackDispatchType = "")),
          (t.requestOptions_ = {
            withCredentials: r,
            handleManifestRedirects: i,
            maxPlaylistRetries: b,
            timeout: null,
          }),
          t.on("error", t.pauseLoading),
          (t.mediaTypes_ =
            ((g = {}),
            ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function (e) {
              g[e] = {
                groups: {},
                tracks: {},
                activePlaylistLoader: null,
                activeGroup: Ru,
                activeTrack: Ru,
                getActiveGroup: Ru,
                onGroupChanged: Ru,
                onTrackChanged: Ru,
                lastTrack_: null,
                logger_: Bo("MediaGroups[" + e + "]"),
              };
            }),
            g)),
          (t.mediaSource = new window.MediaSource()),
          (t.handleDurationChange_ = t.handleDurationChange_.bind(y(t))),
          (t.handleSourceOpen_ = t.handleSourceOpen_.bind(y(t))),
          (t.handleSourceEnded_ = t.handleSourceEnded_.bind(y(t))),
          t.mediaSource.addEventListener(
            "durationchange",
            t.handleDurationChange_
          ),
          t.mediaSource.addEventListener("sourceopen", t.handleSourceOpen_),
          t.mediaSource.addEventListener("sourceended", t.handleSourceEnded_),
          (t.seekable_ = w.createTimeRanges()),
          (t.hasPlayed_ = !1),
          (t.syncController_ = new mc(e)),
          (t.segmentMetadataTrack_ = a.addRemoteTextTrack(
            { kind: "metadata", label: "segment-metadata" },
            !1
          ).track),
          (t.decrypter_ = new gc()),
          (t.sourceUpdater_ = new cc(t.mediaSource)),
          (t.inbandTextTracks_ = {}),
          (t.timelineChangeController_ = new fc());
        h = {
          vhs: t.vhs_,
          parse708captions: e.parse708captions,
          useDtsForTimestampOffset: e.useDtsForTimestampOffset,
          captionServices: f,
          mediaSource: t.mediaSource,
          currentTime: t.tech_.currentTime.bind(t.tech_),
          seekable: function () {
            return t.seekable();
          },
          seeking: function () {
            return t.tech_.seeking();
          },
          duration: function () {
            return t.duration();
          },
          hasPlayed: function () {
            return t.hasPlayed_;
          },
          goalBufferLength: function () {
            return t.goalBufferLength();
          },
          bandwidth: s,
          syncController: t.syncController_,
          decrypter: t.decrypter_,
          sourceType: t.sourceType_,
          inbandTextTracks: t.inbandTextTracks_,
          cacheEncryptionKeys: h,
          sourceUpdater: t.sourceUpdater_,
          timelineChangeController: t.timelineChangeController_,
          experimentalExactManifestTimings: e.experimentalExactManifestTimings,
        };
        (t.masterPlaylistLoader_ = new ("dash" === t.sourceType_ ? Cu : Ou)(
          n,
          t.vhs_,
          t.requestOptions_
        )),
          t.setupMasterPlaylistLoaderListeners_(),
          (t.mainSegmentLoader_ = new Du(
            w.mergeOptions(h, {
              segmentMetadataTrack: t.segmentMetadataTrack_,
              loaderType: "main",
            }),
            e
          )),
          (t.audioSegmentLoader_ = new Du(
            w.mergeOptions(h, { loaderType: "audio" }),
            e
          )),
          (t.subtitleSegmentLoader_ = new hc(
            w.mergeOptions(h, {
              loaderType: "vtt",
              featuresNativeTextTracks: t.tech_.featuresNativeTextTracks,
            }),
            e
          )),
          t.setupSegmentLoaderListeners_(),
          t.experimentalBufferBasedABR &&
            (t.masterPlaylistLoader_.one("loadedplaylist", function () {
              return t.startABRTimer_();
            }),
            t.tech_.on("pause", function () {
              return t.stopABRTimer_();
            }),
            t.tech_.on("play", function () {
              return t.startABRTimer_();
            })),
          Tc.forEach(function (e) {
            t[e + "_"] = function (e) {
              return this.audioSegmentLoader_[e] + this.mainSegmentLoader_[e];
            }.bind(y(t), e);
          }),
          (t.logger_ = Bo("MPC")),
          (t.triggeredFmp4Usage = !1),
          "none" === t.tech_.preload()
            ? ((t.loadOnPlay_ = function () {
                (t.loadOnPlay_ = null), t.masterPlaylistLoader_.load();
              }),
              t.tech_.one("play", t.loadOnPlay_))
            : t.masterPlaylistLoader_.load(),
          (t.timeToLoadedData__ = -1),
          (t.mainAppendsToLoadedData__ = -1),
          (t.audioAppendsToLoadedData__ = -1);
        e = "none" === t.tech_.preload() ? "play" : "loadstart";
        return (
          t.tech_.one(e, function () {
            var e = Date.now();
            t.tech_.one("loadeddata", function () {
              (t.timeToLoadedData__ = Date.now() - e),
                (t.mainAppendsToLoadedData__ =
                  t.mainSegmentLoader_.mediaAppends),
                (t.audioAppendsToLoadedData__ =
                  t.audioSegmentLoader_.mediaAppends);
            });
          }),
          t
        );
      }
      b(e, v);
      var t = e.prototype;
      return (
        (t.mainAppendsToLoadedData_ = function () {
          return this.mainAppendsToLoadedData__;
        }),
        (t.audioAppendsToLoadedData_ = function () {
          return this.audioAppendsToLoadedData__;
        }),
        (t.appendsToLoadedData_ = function () {
          var e = this.mainAppendsToLoadedData_(),
            t = this.audioAppendsToLoadedData_();
          return -1 === e || -1 === t ? -1 : e + t;
        }),
        (t.timeToLoadedData_ = function () {
          return this.timeToLoadedData__;
        }),
        (t.checkABR_ = function () {
          var e = this.selectPlaylist();
          e && this.shouldSwitchToMedia_(e) && this.switchMedia_(e, "abr");
        }),
        (t.switchMedia_ = function (e, t, n) {
          var i = this.media(),
            r = i && (i.id || i.uri),
            i = e.id || e.uri;
          r &&
            r !== i &&
            (this.logger_("switch media " + r + " -> " + i + " from " + t),
            this.tech_.trigger({
              type: "usage",
              name: "vhs-rendition-change-" + t,
            })),
            this.masterPlaylistLoader_.media(e, n);
        }),
        (t.startABRTimer_ = function () {
          var e = this;
          this.stopABRTimer_(),
            (this.abrTimer_ = window.setInterval(function () {
              return e.checkABR_();
            }, 250));
        }),
        (t.stopABRTimer_ = function () {
          (this.tech_.scrubbing && this.tech_.scrubbing()) ||
            (window.clearInterval(this.abrTimer_), (this.abrTimer_ = null));
        }),
        (t.getAudioTrackPlaylists_ = function () {
          var e = this.master(),
            t = (e && e.playlists) || [];
          if (!e || !e.mediaGroups || !e.mediaGroups.AUDIO) return t;
          var n,
            i = e.mediaGroups.AUDIO,
            r = Object.keys(i);
          if (Object.keys(this.mediaTypes_.AUDIO.groups).length)
            n = this.mediaTypes_.AUDIO.activeTrack();
          else {
            var a,
              s = i.main || (r.length && i[r[0]]);
            for (a in s)
              if (s[a].default) {
                n = { label: a };
                break;
              }
          }
          if (!n) return t;
          var o,
            l = [];
          for (o in i)
            if (i[o][n.label]) {
              var u = i[o][n.label];
              if (u.playlists && u.playlists.length)
                l.push.apply(l, u.playlists);
              else if (u.uri) l.push(u);
              else if (e.playlists.length)
                for (var c = 0; c < e.playlists.length; c++) {
                  var d = e.playlists[c];
                  d.attributes &&
                    d.attributes.AUDIO &&
                    d.attributes.AUDIO === o &&
                    l.push(d);
                }
            }
          return l.length ? l : t;
        }),
        (t.setupMasterPlaylistLoaderListeners_ = function () {
          var n = this;
          this.masterPlaylistLoader_.on("loadedmetadata", function () {
            var e = n.masterPlaylistLoader_.media(),
              t = 1.5 * e.targetDuration * 1e3;
            al(n.masterPlaylistLoader_.master, n.masterPlaylistLoader_.media())
              ? (n.requestOptions_.timeout = 0)
              : (n.requestOptions_.timeout = t),
              e.endList &&
                "none" !== n.tech_.preload() &&
                (n.mainSegmentLoader_.playlist(e, n.requestOptions_),
                n.mainSegmentLoader_.load()),
              Ku({
                sourceType: n.sourceType_,
                segmentLoaders: {
                  AUDIO: n.audioSegmentLoader_,
                  SUBTITLES: n.subtitleSegmentLoader_,
                  main: n.mainSegmentLoader_,
                },
                tech: n.tech_,
                requestOptions: n.requestOptions_,
                masterPlaylistLoader: n.masterPlaylistLoader_,
                vhs: n.vhs_,
                master: n.master(),
                mediaTypes: n.mediaTypes_,
                blacklistCurrentPlaylist: n.blacklistCurrentPlaylist.bind(n),
              }),
              n.triggerPresenceUsage_(n.master(), e),
              n.setupFirstPlay(),
              !n.mediaTypes_.AUDIO.activePlaylistLoader ||
              n.mediaTypes_.AUDIO.activePlaylistLoader.media()
                ? n.trigger("selectedinitialmedia")
                : n.mediaTypes_.AUDIO.activePlaylistLoader.one(
                    "loadedmetadata",
                    function () {
                      n.trigger("selectedinitialmedia");
                    }
                  );
          }),
            this.masterPlaylistLoader_.on("loadedplaylist", function () {
              n.loadOnPlay_ && n.tech_.off("play", n.loadOnPlay_);
              var e,
                t = n.masterPlaylistLoader_.media();
              if (!t) {
                if (
                  (n.excludeUnsupportedVariants_(),
                  !(e =
                    (e = n.enableLowInitialPlaylist
                      ? n.selectInitialPlaylist()
                      : e) || n.selectPlaylist()) || !n.shouldSwitchToMedia_(e))
                )
                  return;
                if (
                  ((n.initialMedia_ = e),
                  n.switchMedia_(n.initialMedia_, "initial"),
                  !("vhs-json" === n.sourceType_ && n.initialMedia_.segments))
                )
                  return;
                t = n.initialMedia_;
              }
              n.handleUpdatedMediaPlaylist(t);
            }),
            this.masterPlaylistLoader_.on("error", function () {
              n.blacklistCurrentPlaylist(n.masterPlaylistLoader_.error);
            }),
            this.masterPlaylistLoader_.on("mediachanging", function () {
              n.mainSegmentLoader_.abort(), n.mainSegmentLoader_.pause();
            }),
            this.masterPlaylistLoader_.on("mediachange", function () {
              var e = n.masterPlaylistLoader_.media(),
                t = 1.5 * e.targetDuration * 1e3;
              al(
                n.masterPlaylistLoader_.master,
                n.masterPlaylistLoader_.media()
              )
                ? (n.requestOptions_.timeout = 0)
                : (n.requestOptions_.timeout = t),
                n.mainSegmentLoader_.playlist(e, n.requestOptions_),
                n.mainSegmentLoader_.load(),
                n.tech_.trigger({ type: "mediachange", bubbles: !0 });
            }),
            this.masterPlaylistLoader_.on("playlistunchanged", function () {
              var e = n.masterPlaylistLoader_.media();
              "playlist-unchanged" !== e.lastExcludeReason_ &&
                n.stuckAtPlaylistEnd_(e) &&
                (n.blacklistCurrentPlaylist({
                  message: "Playlist no longer updating.",
                  reason: "playlist-unchanged",
                }),
                n.tech_.trigger("playliststuck"));
            }),
            this.masterPlaylistLoader_.on("renditiondisabled", function () {
              n.tech_.trigger({
                type: "usage",
                name: "vhs-rendition-disabled",
              }),
                n.tech_.trigger({
                  type: "usage",
                  name: "hls-rendition-disabled",
                });
            }),
            this.masterPlaylistLoader_.on("renditionenabled", function () {
              n.tech_.trigger({ type: "usage", name: "vhs-rendition-enabled" }),
                n.tech_.trigger({
                  type: "usage",
                  name: "hls-rendition-enabled",
                });
            });
        }),
        (t.handleUpdatedMediaPlaylist = function (e) {
          this.useCueTags_ && this.updateAdCues_(e),
            this.mainSegmentLoader_.playlist(e, this.requestOptions_),
            this.updateDuration(!e.endList),
            this.tech_.paused() ||
              (this.mainSegmentLoader_.load(),
              this.audioSegmentLoader_ && this.audioSegmentLoader_.load());
        }),
        (t.triggerPresenceUsage_ = function (e, t) {
          var n,
            i = e.mediaGroups || {},
            r = !0,
            e = Object.keys(i.AUDIO);
          for (n in i.AUDIO)
            for (var a in i.AUDIO[n]) i.AUDIO[n][a].uri || (r = !1);
          r &&
            (this.tech_.trigger({ type: "usage", name: "vhs-demuxed" }),
            this.tech_.trigger({ type: "usage", name: "hls-demuxed" })),
            Object.keys(i.SUBTITLES).length &&
              (this.tech_.trigger({ type: "usage", name: "vhs-webvtt" }),
              this.tech_.trigger({ type: "usage", name: "hls-webvtt" })),
            Ju.Playlist.isAes(t) &&
              (this.tech_.trigger({ type: "usage", name: "vhs-aes" }),
              this.tech_.trigger({ type: "usage", name: "hls-aes" })),
            e.length &&
              1 < Object.keys(i.AUDIO[e[0]]).length &&
              (this.tech_.trigger({
                type: "usage",
                name: "vhs-alternate-audio",
              }),
              this.tech_.trigger({
                type: "usage",
                name: "hls-alternate-audio",
              })),
            this.useCueTags_ &&
              (this.tech_.trigger({
                type: "usage",
                name: "vhs-playlist-cue-tags",
              }),
              this.tech_.trigger({
                type: "usage",
                name: "hls-playlist-cue-tags",
              }));
        }),
        (t.shouldSwitchToMedia_ = function (e) {
          var t =
              this.masterPlaylistLoader_.media() ||
              this.masterPlaylistLoader_.pendingMedia_,
            n = this.tech_.currentTime(),
            i = this.bufferLowWaterLine(),
            r = this.bufferHighWaterLine();
          return (function (e) {
            var t = e.currentPlaylist,
              n = e.buffered,
              i = e.currentTime,
              r = e.nextPlaylist,
              a = e.bufferLowWaterLine,
              s = e.bufferHighWaterLine,
              o = e.duration,
              l = e.experimentalBufferBasedABR,
              u = e.log;
            if (!r)
              return (
                w.log.warn(
                  "We received no playlist to switch to. Please check your stream."
                ),
                !1
              );
            var c =
              "allowing switch " + ((t && t.id) || "null") + " -> " + r.id;
            if (!t) return u(c + " as current playlist is not set"), !0;
            if (r.id === t.id) return !1;
            e = Boolean(Vo(n, i).length);
            if (!t.endList)
              return e || "number" != typeof t.partTargetDuration
                ? (u(c + " as current playlist is live"), !0)
                : (u(
                    "not " +
                      c +
                      " as current playlist is live llhls, but currentTime isn't in buffered."
                  ),
                  !1);
            (n = Ho(n, i)),
              (i = l
                ? L.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE
                : L.MAX_BUFFER_LOW_WATER_LINE);
            if (o < i)
              return (
                u(
                  c +
                    " as duration < max low water line (" +
                    o +
                    " < " +
                    i +
                    ")"
                ),
                !0
              );
            (i = r.attributes.BANDWIDTH), (r = t.attributes.BANDWIDTH);
            if (i < r && (!l || n < s)) {
              t =
                c +
                " as next bandwidth < current bandwidth (" +
                i +
                " < " +
                r +
                ")";
              return (
                l &&
                  (t +=
                    " and forwardBuffer < bufferHighWaterLine (" +
                    n +
                    " < " +
                    s +
                    ")"),
                u(t),
                !0
              );
            }
            if ((!l || r < i) && a <= n) {
              a =
                c +
                " as forwardBuffer >= bufferLowWaterLine (" +
                n +
                " >= " +
                a +
                ")";
              return (
                l &&
                  (a +=
                    " and next bandwidth > current bandwidth (" +
                    i +
                    " > " +
                    r +
                    ")"),
                u(a),
                !0
              );
            }
            return u("not " + c + " as no switching criteria met"), !1;
          })({
            buffered: this.tech_.buffered(),
            currentTime: n,
            currentPlaylist: t,
            nextPlaylist: e,
            bufferLowWaterLine: i,
            bufferHighWaterLine: r,
            duration: this.duration(),
            experimentalBufferBasedABR: this.experimentalBufferBasedABR,
            log: this.logger_,
          });
        }),
        (t.setupSegmentLoaderListeners_ = function () {
          var t = this;
          this.experimentalBufferBasedABR ||
            (this.mainSegmentLoader_.on("bandwidthupdate", function () {
              var e = t.selectPlaylist();
              t.shouldSwitchToMedia_(e) && t.switchMedia_(e, "bandwidthupdate"),
                t.tech_.trigger("bandwidthupdate");
            }),
            this.mainSegmentLoader_.on("progress", function () {
              t.trigger("progress");
            })),
            this.mainSegmentLoader_.on("error", function () {
              t.blacklistCurrentPlaylist(t.mainSegmentLoader_.error());
            }),
            this.mainSegmentLoader_.on("appenderror", function () {
              (t.error = t.mainSegmentLoader_.error_), t.trigger("error");
            }),
            this.mainSegmentLoader_.on("syncinfoupdate", function () {
              t.onSyncInfoUpdate_();
            }),
            this.mainSegmentLoader_.on("timestampoffset", function () {
              t.tech_.trigger({ type: "usage", name: "vhs-timestamp-offset" }),
                t.tech_.trigger({
                  type: "usage",
                  name: "hls-timestamp-offset",
                });
            }),
            this.audioSegmentLoader_.on("syncinfoupdate", function () {
              t.onSyncInfoUpdate_();
            }),
            this.audioSegmentLoader_.on("appenderror", function () {
              (t.error = t.audioSegmentLoader_.error_), t.trigger("error");
            }),
            this.mainSegmentLoader_.on("ended", function () {
              t.logger_("main segment loader ended"), t.onEndOfStream();
            }),
            this.mainSegmentLoader_.on("earlyabort", function (e) {
              t.experimentalBufferBasedABR ||
                (t.delegateLoaders_("all", ["abort"]),
                t.blacklistCurrentPlaylist(
                  {
                    message:
                      "Aborted early because there isn't enough bandwidth to complete the request without rebuffering.",
                  },
                  120
                ));
            });
          function e() {
            if (!t.sourceUpdater_.hasCreatedSourceBuffers())
              return t.tryToCreateSourceBuffers_();
            var e = t.getCodecsOrExclude_();
            e && t.sourceUpdater_.addOrChangeSourceBuffers(e);
          }
          this.mainSegmentLoader_.on("trackinfo", e),
            this.audioSegmentLoader_.on("trackinfo", e),
            this.mainSegmentLoader_.on("fmp4", function () {
              t.triggeredFmp4Usage ||
                (t.tech_.trigger({ type: "usage", name: "vhs-fmp4" }),
                t.tech_.trigger({ type: "usage", name: "hls-fmp4" }),
                (t.triggeredFmp4Usage = !0));
            }),
            this.audioSegmentLoader_.on("fmp4", function () {
              t.triggeredFmp4Usage ||
                (t.tech_.trigger({ type: "usage", name: "vhs-fmp4" }),
                t.tech_.trigger({ type: "usage", name: "hls-fmp4" }),
                (t.triggeredFmp4Usage = !0));
            }),
            this.audioSegmentLoader_.on("ended", function () {
              t.logger_("audioSegmentLoader ended"), t.onEndOfStream();
            });
        }),
        (t.mediaSecondsLoaded_ = function () {
          return Math.max(
            this.audioSegmentLoader_.mediaSecondsLoaded +
              this.mainSegmentLoader_.mediaSecondsLoaded
          );
        }),
        (t.load = function () {
          this.mainSegmentLoader_.load(),
            this.mediaTypes_.AUDIO.activePlaylistLoader &&
              this.audioSegmentLoader_.load(),
            this.mediaTypes_.SUBTITLES.activePlaylistLoader &&
              this.subtitleSegmentLoader_.load();
        }),
        (t.smoothQualityChange_ = function (e) {
          void 0 === e && (e = this.selectPlaylist()),
            this.fastQualityChange_(e);
        }),
        (t.fastQualityChange_ = function (e) {
          var t = this;
          (e = void 0 === e ? this.selectPlaylist() : e) !==
          this.masterPlaylistLoader_.media()
            ? (this.switchMedia_(e, "fast-quality"),
              this.mainSegmentLoader_.resetEverything(function () {
                w.browser.IE_VERSION || w.browser.IS_EDGE
                  ? t.tech_.setCurrentTime(t.tech_.currentTime() + 0.04)
                  : t.tech_.setCurrentTime(t.tech_.currentTime());
              }))
            : this.logger_(
                "skipping fastQualityChange because new media is same as old"
              );
        }),
        (t.play = function () {
          if (!this.setupFirstPlay()) {
            this.tech_.ended() && this.tech_.setCurrentTime(0),
              this.hasPlayed_ && this.load();
            var e = this.tech_.seekable();
            return this.tech_.duration() === 1 / 0 &&
              this.tech_.currentTime() < e.start(0)
              ? this.tech_.setCurrentTime(e.end(e.length - 1))
              : void 0;
          }
        }),
        (t.setupFirstPlay = function () {
          var e = this,
            t = this.masterPlaylistLoader_.media();
          if (!t || this.tech_.paused() || this.hasPlayed_) return !1;
          if (!t.endList) {
            var n = this.seekable();
            if (!n.length) return !1;
            if (w.browser.IE_VERSION && 0 === this.tech_.readyState())
              return (
                this.tech_.one("loadedmetadata", function () {
                  e.trigger("firstplay"),
                    e.tech_.setCurrentTime(n.end(0)),
                    (e.hasPlayed_ = !0);
                }),
                !1
              );
            this.trigger("firstplay"), this.tech_.setCurrentTime(n.end(0));
          }
          return (this.hasPlayed_ = !0), this.load(), !0;
        }),
        (t.handleSourceOpen_ = function () {
          var e;
          this.tryToCreateSourceBuffers_(),
            !this.tech_.autoplay() ||
              ("undefined" != typeof (e = this.tech_.play()) &&
                "function" == typeof e.then &&
                e.then(null, function (e) {})),
            this.trigger("sourceopen");
        }),
        (t.handleSourceEnded_ = function () {
          var e, t;
          !this.inbandTextTracks_.metadataTrack_ ||
            ((e = this.inbandTextTracks_.metadataTrack_.cues) &&
              e.length &&
              ((t = this.duration()),
              (e[e.length - 1].endTime =
                isNaN(t) || Math.abs(t) === 1 / 0 ? Number.MAX_VALUE : t)));
        }),
        (t.handleDurationChange_ = function () {
          this.tech_.trigger("durationchange");
        }),
        (t.onEndOfStream = function () {
          var e,
            t = this.mainSegmentLoader_.ended_;
          (t = this.mediaTypes_.AUDIO.activePlaylistLoader
            ? (((e = this.mainSegmentLoader_.getCurrentMediaInfo_()) &&
                !e.hasVideo) ||
                t) &&
              this.audioSegmentLoader_.ended_
            : t) && (this.stopABRTimer_(), this.sourceUpdater_.endOfStream());
        }),
        (t.stuckAtPlaylistEnd_ = function (e) {
          if (!this.seekable().length) return !1;
          var t = this.syncController_.getExpiredTime(e, this.duration());
          if (null === t) return !1;
          var n = Ju.Playlist.playlistEnd(e, t),
            e = this.tech_.currentTime(),
            t = this.tech_.buffered();
          if (!t.length) return n - e <= 0.1;
          t = t.end(t.length - 1);
          return t - e <= 0.1 && n - t <= 0.1;
        }),
        (t.blacklistCurrentPlaylist = function (e, t) {
          var n =
            (e = void 0 === e ? {} : e).playlist ||
            this.masterPlaylistLoader_.media();
          if (((t = t || e.blacklistDuration || this.blacklistDuration), !n))
            return (
              (this.error = e),
              void ("open" !== this.mediaSource.readyState
                ? this.trigger("error")
                : this.sourceUpdater_.endOfStream("network"))
            );
          n.playlistErrors_++;
          var i,
            r = this.masterPlaylistLoader_.master.playlists,
            a = r.filter(il),
            s = 1 === a.length && a[0] === n;
          if (1 === r.length && t !== 1 / 0)
            return (
              w.log.warn(
                "Problem encountered with playlist " +
                  n.id +
                  ". Trying again since it is the only playlist."
              ),
              this.tech_.trigger("retryplaylist"),
              this.masterPlaylistLoader_.load(s)
            );
          s &&
            ((i = !1),
            r.forEach(function (e) {
              var t;
              e === n ||
                ("undefined" != typeof (t = e.excludeUntil) &&
                  t !== 1 / 0 &&
                  ((i = !0), delete e.excludeUntil));
            }),
            i &&
              (w.log.warn(
                "Removing other playlists from the exclusion list because the last rendition is about to be excluded."
              ),
              this.tech_.trigger("retryplaylist"))),
            (a =
              n.playlistErrors_ > this.maxPlaylistRetries
                ? 1 / 0
                : Date.now() + 1e3 * t),
            (n.excludeUntil = a),
            e.reason && (n.lastExcludeReason_ = e.reason),
            this.tech_.trigger("blacklistplaylist"),
            this.tech_.trigger({
              type: "usage",
              name: "vhs-rendition-blacklisted",
            }),
            this.tech_.trigger({
              type: "usage",
              name: "hls-rendition-blacklisted",
            });
          r = this.selectPlaylist();
          if (!r)
            return (
              (this.error =
                "Playback cannot continue. No available working or supported playlists."),
              void this.trigger("error")
            );
          (t = e.internal ? this.logger_ : w.log.warn),
            (a = e.message ? " " + e.message : "");
          t(
            (e.internal ? "Internal problem" : "Problem") +
              " encountered with playlist " +
              n.id +
              "." +
              a +
              " Switching to playlist " +
              r.id +
              "."
          ),
            r.attributes.AUDIO !== n.attributes.AUDIO &&
              this.delegateLoaders_("audio", ["abort", "pause"]),
            r.attributes.SUBTITLES !== n.attributes.SUBTITLES &&
              this.delegateLoaders_("subtitle", ["abort", "pause"]),
            this.delegateLoaders_("main", ["abort", "pause"]);
          (a = (r.targetDuration / 2) * 1e3 || 5e3),
            (a =
              "number" == typeof r.lastRequest &&
              Date.now() - r.lastRequest <= a);
          return this.switchMedia_(r, "exclude", s || a);
        }),
        (t.pauseLoading = function () {
          this.delegateLoaders_("all", ["abort", "pause"]),
            this.stopABRTimer_();
        }),
        (t.delegateLoaders_ = function (n, e) {
          var i = this,
            r = [],
            t = "all" === n;
          (!t && "main" !== n) || r.push(this.masterPlaylistLoader_);
          var a = [];
          (!t && "audio" !== n) || a.push("AUDIO"),
            (!t && "subtitle" !== n) ||
              (a.push("CLOSED-CAPTIONS"), a.push("SUBTITLES")),
            a.forEach(function (e) {
              e = i.mediaTypes_[e] && i.mediaTypes_[e].activePlaylistLoader;
              e && r.push(e);
            }),
            ["main", "audio", "subtitle"].forEach(function (e) {
              var t = i[e + "SegmentLoader_"];
              !t || (n !== e && "all" !== n) || r.push(t);
            }),
            r.forEach(function (t) {
              return e.forEach(function (e) {
                "function" == typeof t[e] && t[e]();
              });
            });
        }),
        (t.setCurrentTime = function (e) {
          var t = Vo(this.tech_.buffered(), e);
          return this.masterPlaylistLoader_ &&
            this.masterPlaylistLoader_.media() &&
            this.masterPlaylistLoader_.media().segments
            ? t && t.length
              ? e
              : (this.mainSegmentLoader_.resetEverything(),
                this.mainSegmentLoader_.abort(),
                this.mediaTypes_.AUDIO.activePlaylistLoader &&
                  (this.audioSegmentLoader_.resetEverything(),
                  this.audioSegmentLoader_.abort()),
                this.mediaTypes_.SUBTITLES.activePlaylistLoader &&
                  (this.subtitleSegmentLoader_.resetEverything(),
                  this.subtitleSegmentLoader_.abort()),
                void this.load())
            : 0;
        }),
        (t.duration = function () {
          if (!this.masterPlaylistLoader_) return 0;
          var e = this.masterPlaylistLoader_.media();
          return e
            ? e.endList
              ? this.mediaSource
                ? this.mediaSource.duration
                : Ju.Playlist.duration(e)
              : 1 / 0
            : 0;
        }),
        (t.seekable = function () {
          return this.seekable_;
        }),
        (t.onSyncInfoUpdate_ = function () {
          var e;
          if (this.masterPlaylistLoader_) {
            var t = this.masterPlaylistLoader_.media();
            if (t) {
              var n = this.syncController_.getExpiredTime(t, this.duration());
              if (null !== n) {
                var i,
                  r,
                  a = this.masterPlaylistLoader_.master,
                  s = Ju.Playlist.seekable(
                    t,
                    n,
                    Ju.Playlist.liveEdgeDelay(a, t)
                  );
                if (0 !== s.length) {
                  if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
                    if (
                      ((t =
                        this.mediaTypes_.AUDIO.activePlaylistLoader.media()),
                      null ===
                        (n = this.syncController_.getExpiredTime(
                          t,
                          this.duration()
                        )))
                    )
                      return;
                    if (
                      0 ===
                      (e = Ju.Playlist.seekable(
                        t,
                        n,
                        Ju.Playlist.liveEdgeDelay(a, t)
                      )).length
                    )
                      return;
                  }
                  this.seekable_ &&
                    this.seekable_.length &&
                    ((i = this.seekable_.end(0)),
                    (r = this.seekable_.start(0))),
                    !e || e.start(0) > s.end(0) || s.start(0) > e.end(0)
                      ? (this.seekable_ = s)
                      : (this.seekable_ = w.createTimeRanges([
                          [
                            (e.start(0) > s.start(0) ? e : s).start(0),
                            (e.end(0) < s.end(0) ? e : s).end(0),
                          ],
                        ])),
                    (this.seekable_ &&
                      this.seekable_.length &&
                      this.seekable_.end(0) === i &&
                      this.seekable_.start(0) === r) ||
                      (this.logger_(
                        "seekable updated [" + Go(this.seekable_) + "]"
                      ),
                      this.tech_.trigger("seekablechanged"));
                }
              }
            }
          }
        }),
        (t.updateDuration = function (e) {
          if (
            (this.updateDuration_ &&
              (this.mediaSource.removeEventListener(
                "sourceopen",
                this.updateDuration_
              ),
              (this.updateDuration_ = null)),
            "open" !== this.mediaSource.readyState)
          )
            return (
              (this.updateDuration_ = this.updateDuration.bind(this, e)),
              void this.mediaSource.addEventListener(
                "sourceopen",
                this.updateDuration_
              )
            );
          if (e) {
            var t = this.seekable();
            return t.length
              ? void (
                  (isNaN(this.mediaSource.duration) ||
                    this.mediaSource.duration < t.end(t.length - 1)) &&
                  this.sourceUpdater_.setDuration(t.end(t.length - 1))
                )
              : void 0;
          }
          (e = this.tech_.buffered()),
            (t = Ju.Playlist.duration(this.masterPlaylistLoader_.media()));
          0 < e.length && (t = Math.max(t, e.end(e.length - 1))),
            this.mediaSource.duration !== t &&
              this.sourceUpdater_.setDuration(t);
        }),
        (t.dispose = function () {
          var i = this;
          this.trigger("dispose"),
            this.decrypter_.terminate(),
            this.masterPlaylistLoader_.dispose(),
            this.mainSegmentLoader_.dispose(),
            this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_),
            ["AUDIO", "SUBTITLES"].forEach(function (e) {
              var t,
                n = i.mediaTypes_[e].groups;
              for (t in n)
                n[t].forEach(function (e) {
                  e.playlistLoader && e.playlistLoader.dispose();
                });
            }),
            this.audioSegmentLoader_.dispose(),
            this.subtitleSegmentLoader_.dispose(),
            this.sourceUpdater_.dispose(),
            this.timelineChangeController_.dispose(),
            this.stopABRTimer_(),
            this.updateDuration_ &&
              this.mediaSource.removeEventListener(
                "sourceopen",
                this.updateDuration_
              ),
            this.mediaSource.removeEventListener(
              "durationchange",
              this.handleDurationChange_
            ),
            this.mediaSource.removeEventListener(
              "sourceopen",
              this.handleSourceOpen_
            ),
            this.mediaSource.removeEventListener(
              "sourceended",
              this.handleSourceEnded_
            ),
            this.off();
        }),
        (t.master = function () {
          return this.masterPlaylistLoader_.master;
        }),
        (t.media = function () {
          return this.masterPlaylistLoader_.media() || this.initialMedia_;
        }),
        (t.areMediaTypesKnown_ = function () {
          var e = !!this.mediaTypes_.AUDIO.activePlaylistLoader,
            t = !!this.mainSegmentLoader_.getCurrentMediaInfo_(),
            e = !e || !!this.audioSegmentLoader_.getCurrentMediaInfo_();
          return t && e;
        }),
        (t.getCodecsOrExclude_ = function () {
          var i = this,
            r = {
              main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
              audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {},
            };
          r.video = r.main;
          var e = eu(this.master(), this.media()),
            a = {},
            t = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
          if (
            (r.main.hasVideo &&
              (a.video = e.video || r.main.videoCodec || "avc1.4d400d"),
            r.main.isMuxed &&
              (a.video += "," + (e.audio || r.main.audioCodec || Br)),
            ((r.main.hasAudio && !r.main.isMuxed) || r.audio.hasAudio || t) &&
              ((a.audio =
                e.audio || r.main.audioCodec || r.audio.audioCodec || Br),
              (r.audio.isFmp4 = (
                r.main.hasAudio && !r.main.isMuxed ? r.main : r.audio
              ).isFmp4)),
            a.audio || a.video)
          ) {
            var s,
              n,
              o = {};
            if (
              (["video", "audio"].forEach(function (e) {
                var t, n;
                a.hasOwnProperty(e) &&
                  ((t = r[e].isFmp4), (n = a[e]), !(t ? Ar : wr)(n)) &&
                  ((n = r[e].isFmp4 ? "browser" : "muxer"),
                  (o[n] = o[n] || []),
                  o[n].push(a[e]),
                  "audio" === e && (s = n));
              }),
              t &&
                s &&
                this.media().attributes.AUDIO &&
                ((n = this.media().attributes.AUDIO),
                this.master().playlists.forEach(function (e) {
                  (e.attributes && e.attributes.AUDIO) === n &&
                    e !== i.media() &&
                    (e.excludeUntil = 1 / 0);
                }),
                this.logger_(
                  "excluding audio group " +
                    n +
                    " as " +
                    s +
                    ' does not support codec(s): "' +
                    a.audio +
                    '"'
                )),
              !Object.keys(o).length)
            ) {
              if (
                this.sourceUpdater_.hasCreatedSourceBuffers() &&
                !this.sourceUpdater_.canChangeType()
              ) {
                var l = [];
                if (
                  (["video", "audio"].forEach(function (e) {
                    var t = (Tr(i.sourceUpdater_.codecs[e] || "")[0] || {})
                        .type,
                      n = (Tr(a[e] || "")[0] || {}).type;
                    t &&
                      n &&
                      t.toLowerCase() !== n.toLowerCase() &&
                      l.push(
                        '"' + i.sourceUpdater_.codecs[e] + '" -> "' + a[e] + '"'
                      );
                  }),
                  l.length)
                )
                  return void this.blacklistCurrentPlaylist({
                    playlist: this.media(),
                    message:
                      "Codec switching not supported: " + l.join(", ") + ".",
                    blacklistDuration: 1 / 0,
                    internal: !0,
                  });
              }
              return a;
            }
            t =
              Object.keys(o).reduce(function (e, t) {
                return (
                  e && (e += ", "),
                  (e +=
                    t + ' does not support codec(s): "' + o[t].join(",") + '"')
                );
              }, "") + ".";
            this.blacklistCurrentPlaylist({
              playlist: this.media(),
              internal: !0,
              message: t,
              blacklistDuration: 1 / 0,
            });
          } else
            this.blacklistCurrentPlaylist({
              playlist: this.media(),
              message: "Could not determine codecs for playlist.",
              blacklistDuration: 1 / 0,
            });
        }),
        (t.tryToCreateSourceBuffers_ = function () {
          var e;
          "open" !== this.mediaSource.readyState ||
            this.sourceUpdater_.hasCreatedSourceBuffers() ||
            !this.areMediaTypesKnown_() ||
            ((e = this.getCodecsOrExclude_()) &&
              (this.sourceUpdater_.createSourceBuffers(e),
              (e = [e.video, e.audio].filter(Boolean).join(",")),
              this.excludeIncompatibleVariants_(e)));
        }),
        (t.excludeUnsupportedVariants_ = function () {
          var i = this,
            r = this.master().playlists,
            a = [];
          Object.keys(r).forEach(function (e) {
            var t,
              n = r[e];
            -1 === a.indexOf(n.id) &&
              (a.push(n.id),
              (t = []),
              !(e = eu(i.master, n)).audio ||
                wr(e.audio) ||
                Ar(e.audio) ||
                t.push("audio codec " + e.audio),
              !e.video ||
                wr(e.video) ||
                Ar(e.video) ||
                t.push("video codec " + e.video),
              e.text &&
                "stpp.ttml.im1t" === e.text &&
                t.push("text codec " + e.text),
              t.length &&
                ((n.excludeUntil = 1 / 0),
                i.logger_(
                  "excluding " + n.id + " for unsupported: " + t.join(", ")
                )));
          });
        }),
        (t.excludeIncompatibleVariants_ = function (e) {
          var r = this,
            a = [],
            s = this.master().playlists,
            e = Jl(Tr(e)),
            o = $l(e),
            l = (e.video && Tr(e.video)[0]) || null,
            u = (e.audio && Tr(e.audio)[0]) || null;
          Object.keys(s).forEach(function (e) {
            var t,
              n,
              i = s[e];
            -1 === a.indexOf(i.id) &&
              i.excludeUntil !== 1 / 0 &&
              (a.push(i.id),
              (t = []),
              (n = eu(r.masterPlaylistLoader_.master, i)),
              (e = $l(n)),
              (n.audio || n.video) &&
                (e !== o && t.push('codec count "' + e + '" !== "' + o + '"'),
                r.sourceUpdater_.canChangeType() ||
                  ((e = (n.video && Tr(n.video)[0]) || null),
                  (n = (n.audio && Tr(n.audio)[0]) || null),
                  e &&
                    l &&
                    e.type.toLowerCase() !== l.type.toLowerCase() &&
                    t.push('video codec "' + e.type + '" !== "' + l.type + '"'),
                  n &&
                    u &&
                    n.type.toLowerCase() !== u.type.toLowerCase() &&
                    t.push(
                      'audio codec "' + n.type + '" !== "' + u.type + '"'
                    )),
                t.length &&
                  ((i.excludeUntil = 1 / 0),
                  r.logger_("blacklisting " + i.id + ": " + t.join(" && ")))));
          });
        }),
        (t.updateAdCues_ = function (e) {
          var t = 0,
            n = this.seekable();
          n.length && (t = n.start(0)),
            (function (e, t, n) {
              if ((void 0 === n && (n = 0), e.segments))
                for (var i = n, r = 0; r < e.segments.length; r++) {
                  var a,
                    s,
                    o,
                    l = e.segments[r];
                  if (
                    (o =
                      o ||
                      (function (e, t) {
                        for (var n = e.cues, i = 0; i < n.length; i++) {
                          var r = n[i];
                          if (t >= r.adStartTime && t <= r.adEndTime) return r;
                        }
                        return null;
                      })(t, i + l.duration / 2))
                  ) {
                    if ("cueIn" in l) {
                      (o.endTime = i),
                        (o.adEndTime = i),
                        (i += l.duration),
                        (o = null);
                      continue;
                    }
                    if (i < o.endTime) {
                      i += l.duration;
                      continue;
                    }
                    o.endTime += l.duration;
                  } else
                    "cueOut" in l &&
                      (((o = new window.VTTCue(
                        i,
                        i + l.duration,
                        l.cueOut
                      )).adStartTime = i),
                      (o.adEndTime = i + parseFloat(l.cueOut)),
                      t.addCue(o)),
                      "cueOutCont" in l &&
                        ((a = (s = l.cueOutCont.split("/").map(parseFloat))[0]),
                        (s = s[1]),
                        ((o = new window.VTTCue(
                          i,
                          i + l.duration,
                          ""
                        )).adStartTime = i - a),
                        (o.adEndTime = o.adStartTime + s),
                        t.addCue(o));
                  i += l.duration;
                }
            })(e, this.cueTagsTrack_, t);
        }),
        (t.goalBufferLength = function () {
          var e = this.tech_.currentTime(),
            t = L.GOAL_BUFFER_LENGTH,
            n = L.GOAL_BUFFER_LENGTH_RATE,
            i = Math.max(t, L.MAX_GOAL_BUFFER_LENGTH);
          return Math.min(t + e * n, i);
        }),
        (t.bufferLowWaterLine = function () {
          var e = this.tech_.currentTime(),
            t = L.BUFFER_LOW_WATER_LINE,
            n = L.BUFFER_LOW_WATER_LINE_RATE,
            i = Math.max(t, L.MAX_BUFFER_LOW_WATER_LINE),
            r = Math.max(t, L.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
          return Math.min(t + e * n, this.experimentalBufferBasedABR ? r : i);
        }),
        (t.bufferHighWaterLine = function () {
          return L.BUFFER_HIGH_WATER_LINE;
        }),
        e
      );
    })(w.EventTarget),
    Sc = ["seeking", "seeked", "pause", "playing", "error"],
    Ac = (function () {
      function e(e) {
        var n = this;
        (this.masterPlaylistController_ = e.masterPlaylistController),
          (this.tech_ = e.tech),
          (this.seekable = e.seekable),
          (this.allowSeeksWithinUnsafeLiveWindow =
            e.allowSeeksWithinUnsafeLiveWindow),
          (this.liveRangeSafeTimeDelta = e.liveRangeSafeTimeDelta),
          (this.media = e.media),
          (this.consecutiveUpdates = 0),
          (this.lastRecordedTime = null),
          (this.timer_ = null),
          (this.checkCurrentTimeTimeout_ = null),
          (this.logger_ = Bo("PlaybackWatcher")),
          this.logger_("initialize");
        function t() {
          return n.monitorCurrentTime_();
        }
        function i() {
          return n.monitorCurrentTime_();
        }
        function r() {
          return n.techWaiting_();
        }
        function a() {
          return n.cancelTimer_();
        }
        var s = this.masterPlaylistController_,
          o = ["main", "subtitle", "audio"],
          l = {};
        o.forEach(function (e) {
          (l[e] = {
            reset: function () {
              return n.resetSegmentDownloads_(e);
            },
            updateend: function () {
              return n.checkSegmentDownloads_(e);
            },
          }),
            s[e + "SegmentLoader_"].on("appendsdone", l[e].updateend),
            s[e + "SegmentLoader_"].on("playlistupdate", l[e].reset),
            n.tech_.on(["seeked", "seeking"], l[e].reset);
        });
        function u(t) {
          ["main", "audio"].forEach(function (e) {
            s[e + "SegmentLoader_"][t]("appended", n.seekingAppendCheck_);
          });
        }
        (this.seekingAppendCheck_ = function () {
          n.fixesBadSeeks_() &&
            ((n.consecutiveUpdates = 0),
            (n.lastRecordedTime = n.tech_.currentTime()),
            u("off"));
        }),
          (this.clearSeekingAppendCheck_ = function () {
            return u("off");
          }),
          (this.watchForBadSeeking_ = function () {
            n.clearSeekingAppendCheck_(), u("on");
          }),
          this.tech_.on("seeked", this.clearSeekingAppendCheck_),
          this.tech_.on("seeking", this.watchForBadSeeking_),
          this.tech_.on("waiting", r),
          this.tech_.on(Sc, a),
          this.tech_.on("canplay", i),
          this.tech_.one("play", t),
          (this.dispose = function () {
            n.clearSeekingAppendCheck_(),
              n.logger_("dispose"),
              n.tech_.off("waiting", r),
              n.tech_.off(Sc, a),
              n.tech_.off("canplay", i),
              n.tech_.off("play", t),
              n.tech_.off("seeking", n.watchForBadSeeking_),
              n.tech_.off("seeked", n.clearSeekingAppendCheck_),
              o.forEach(function (e) {
                s[e + "SegmentLoader_"].off("appendsdone", l[e].updateend),
                  s[e + "SegmentLoader_"].off("playlistupdate", l[e].reset),
                  n.tech_.off(["seeked", "seeking"], l[e].reset);
              }),
              n.checkCurrentTimeTimeout_ &&
                window.clearTimeout(n.checkCurrentTimeTimeout_),
              n.cancelTimer_();
          });
      }
      var t = e.prototype;
      return (
        (t.monitorCurrentTime_ = function () {
          this.checkCurrentTime_(),
            this.checkCurrentTimeTimeout_ &&
              window.clearTimeout(this.checkCurrentTimeTimeout_),
            (this.checkCurrentTimeTimeout_ = window.setTimeout(
              this.monitorCurrentTime_.bind(this),
              250
            ));
        }),
        (t.resetSegmentDownloads_ = function (e) {
          var t = this.masterPlaylistController_[e + "SegmentLoader_"];
          0 < this[e + "StalledDownloads_"] &&
            this.logger_(
              "resetting possible stalled download count for " + e + " loader"
            ),
            (this[e + "StalledDownloads_"] = 0),
            (this[e + "Buffered_"] = t.buffered_());
        }),
        (t.checkSegmentDownloads_ = function (e) {
          var t = this.masterPlaylistController_,
            n = t[e + "SegmentLoader_"],
            i = n.buffered_(),
            r = (function (e, t) {
              if (e === t) return !1;
              if ((!e && t) || (!t && e)) return !0;
              if (e.length !== t.length) return !0;
              for (var n = 0; n < e.length; n++)
                if (e.start(n) !== t.start(n) || e.end(n) !== t.end(n))
                  return !0;
              return !1;
            })(this[e + "Buffered_"], i);
          (this[e + "Buffered_"] = i),
            r
              ? this.resetSegmentDownloads_(e)
              : (this[e + "StalledDownloads_"]++,
                this.logger_(
                  "found #" +
                    this[e + "StalledDownloads_"] +
                    " " +
                    e +
                    " appends that did not increase buffer (possible stalled download)",
                  { playlistId: n.playlist_ && n.playlist_.id, buffered: qo(i) }
                ),
                this[e + "StalledDownloads_"] < 10 ||
                  (this.logger_(e + " loader stalled download exclusion"),
                  this.resetSegmentDownloads_(e),
                  this.tech_.trigger({
                    type: "usage",
                    name: "vhs-" + e + "-download-exclusion",
                  }),
                  "subtitle" !== e &&
                    t.blacklistCurrentPlaylist(
                      {
                        message:
                          "Excessive " + e + " segment downloading detected.",
                      },
                      1 / 0
                    )));
        }),
        (t.checkCurrentTime_ = function () {
          if (!this.tech_.paused() && !this.tech_.seeking()) {
            var e = this.tech_.currentTime(),
              t = this.tech_.buffered();
            if (
              this.lastRecordedTime === e &&
              (!t.length || e + 0.1 >= t.end(t.length - 1))
            )
              return this.techWaiting_();
            5 <= this.consecutiveUpdates && e === this.lastRecordedTime
              ? (this.consecutiveUpdates++, this.waiting_())
              : e === this.lastRecordedTime
              ? this.consecutiveUpdates++
              : ((this.consecutiveUpdates = 0), (this.lastRecordedTime = e));
          }
        }),
        (t.cancelTimer_ = function () {
          (this.consecutiveUpdates = 0),
            this.timer_ &&
              (this.logger_("cancelTimer_"), clearTimeout(this.timer_)),
            (this.timer_ = null);
        }),
        (t.fixesBadSeeks_ = function () {
          if (!this.tech_.seeking()) return !1;
          var e,
            t = this.seekable(),
            n = this.tech_.currentTime();
          if (
            (this.afterSeekableWindow_(
              t,
              n,
              this.media(),
              this.allowSeeksWithinUnsafeLiveWindow
            ) && (e = t.end(t.length - 1)),
            "undefined" !=
              typeof (e = this.beforeSeekableWindow_(t, n)
                ? (a = t.start(0)) + (a === t.end(0) ? 0 : 0.1)
                : e))
          )
            return (
              this.logger_(
                "Trying to seek outside of seekable at time " +
                  n +
                  " with seekable range " +
                  Go(t) +
                  ". Seeking to " +
                  e +
                  "."
              ),
              this.tech_.setCurrentTime(e),
              !0
            );
          for (
            var i = this.masterPlaylistController_.sourceUpdater_,
              r = this.tech_.buffered(),
              a = i.audioBuffer ? i.audioBuffered() : null,
              t = i.videoBuffer ? i.videoBuffered() : null,
              i = this.media(),
              s = i.partTargetDuration || 2 * (i.targetDuration - bu),
              o = [a, t],
              l = 0;
            l < o.length;
            l++
          )
            if (o[l]) if (Ho(o[l], n) < s) return !1;
          r = Fo(r, n);
          return (
            0 !== r.length &&
            ((e = r.start(0) + 0.1),
            this.logger_(
              "Buffered region starts (" +
                r.start(0) +
                ")  just beyond seek point (" +
                n +
                "). Seeking to " +
                e +
                "."
            ),
            this.tech_.setCurrentTime(e),
            !0)
          );
        }),
        (t.waiting_ = function () {
          var e, t;
          this.techWaiting_() ||
            ((e = this.tech_.currentTime()),
            (t = this.tech_.buffered()),
            (t = Vo(t, e)).length &&
              e + 3 <= t.end(0) &&
              (this.cancelTimer_(),
              this.tech_.setCurrentTime(e),
              this.logger_(
                "Stopped at " +
                  e +
                  " while inside a buffered region [" +
                  t.start(0) +
                  " -> " +
                  t.end(0) +
                  "]. Attempting to resume playback by seeking to the current time."
              ),
              this.tech_.trigger({
                type: "usage",
                name: "vhs-unknown-waiting",
              }),
              this.tech_.trigger({
                type: "usage",
                name: "hls-unknown-waiting",
              })));
        }),
        (t.techWaiting_ = function () {
          var e = this.seekable(),
            t = this.tech_.currentTime();
          if (this.tech_.seeking() || null !== this.timer_) return !0;
          if (this.beforeSeekableWindow_(e, t)) {
            var n = e.end(e.length - 1);
            return (
              this.logger_(
                "Fell out of live window at time " +
                  t +
                  ". Seeking to live point (seekable end) " +
                  n
              ),
              this.cancelTimer_(),
              this.tech_.setCurrentTime(n),
              this.tech_.trigger({ type: "usage", name: "vhs-live-resync" }),
              this.tech_.trigger({ type: "usage", name: "hls-live-resync" }),
              !0
            );
          }
          (e = this.tech_.vhs.masterPlaylistController_.sourceUpdater_),
            (n = this.tech_.buffered());
          if (
            this.videoUnderflow_({
              audioBuffered: e.audioBuffered(),
              videoBuffered: e.videoBuffered(),
              currentTime: t,
            })
          )
            return (
              this.cancelTimer_(),
              this.tech_.setCurrentTime(t),
              this.tech_.trigger({
                type: "usage",
                name: "vhs-video-underflow",
              }),
              this.tech_.trigger({
                type: "usage",
                name: "hls-video-underflow",
              }),
              !0
            );
          e = Fo(n, t);
          if (0 < e.length) {
            n = e.start(0) - t;
            return (
              this.logger_(
                "Stopped at " +
                  t +
                  ", setting timer for " +
                  n +
                  ", seeking to " +
                  e.start(0)
              ),
              this.cancelTimer_(),
              (this.timer_ = setTimeout(
                this.skipTheGap_.bind(this),
                1e3 * n,
                t
              )),
              !0
            );
          }
          return !1;
        }),
        (t.afterSeekableWindow_ = function (e, t, n, i) {
          if ((void 0 === i && (i = !1), !e.length)) return !1;
          var r = e.end(e.length - 1) + 0.1;
          return (
            (r =
              !n.endList && i
                ? e.end(e.length - 1) + 3 * n.targetDuration
                : r) < t
          );
        }),
        (t.beforeSeekableWindow_ = function (e, t) {
          return !!(
            e.length &&
            0 < e.start(0) &&
            t < e.start(0) - this.liveRangeSafeTimeDelta
          );
        }),
        (t.videoUnderflow_ = function (e) {
          var t,
            n,
            i = e.videoBuffered,
            r = e.audioBuffered,
            a = e.currentTime;
          if (i)
            return (
              i.length && r.length
                ? ((n = Vo(i, a - 3)),
                  (e = Vo(i, a)),
                  (r = Vo(r, a)).length &&
                    !e.length &&
                    n.length &&
                    (t = { start: n.end(0), end: r.end(0) }))
                : Fo(i, a).length || (t = this.gapFromVideoUnderflow_(i, a)),
              !!t &&
                (this.logger_(
                  "Encountered a gap in video from " +
                    t.start +
                    " to " +
                    t.end +
                    ". Seeking to current time " +
                    a
                ),
                !0)
            );
        }),
        (t.skipTheGap_ = function (e) {
          var t = this.tech_.buffered(),
            n = this.tech_.currentTime(),
            t = Fo(t, n);
          this.cancelTimer_(),
            0 !== t.length &&
              n === e &&
              (this.logger_(
                "skipTheGap_:",
                "currentTime:",
                n,
                "scheduled currentTime:",
                e,
                "nextRange start:",
                t.start(0)
              ),
              this.tech_.setCurrentTime(t.start(0) + bu),
              this.tech_.trigger({ type: "usage", name: "vhs-gap-skip" }),
              this.tech_.trigger({ type: "usage", name: "hls-gap-skip" }));
        }),
        (t.gapFromVideoUnderflow_ = function (e, t) {
          for (
            var n = (function (e) {
                if (e.length < 2) return w.createTimeRanges();
                for (var t = [], n = 1; n < e.length; n++) {
                  var i = e.end(n - 1),
                    r = e.start(n);
                  t.push([i, r]);
                }
                return w.createTimeRanges(t);
              })(e),
              i = 0;
            i < n.length;
            i++
          ) {
            var r = n.start(i),
              a = n.end(i);
            if (t - r < 4 && 2 < t - r) return { start: r, end: a };
          }
          return null;
        }),
        e
      );
    })(),
    wc = {
      errorInterval: 30,
      getSource: function (e) {
        return e(
          this.tech({ IWillNotUseThisInPlugins: !0 }).currentSource_ ||
            this.currentSource()
        );
      },
    },
    M = {
      PlaylistLoader: Ou,
      Playlist: yu,
      utils: cn,
      STANDARD_PLAYLIST_SELECTOR: mr,
      INITIAL_PLAYLIST_SELECTOR: function () {
        var t = this,
          e = this.playlists.master.playlists.filter(yu.isEnabled);
        return (
          iu(e, ru),
          e.filter(function (e) {
            return !!eu(t.playlists.master, e).video;
          })[0] || null
        );
      },
      lastBandwidthSelector: mr,
      movingAverageBandwidthSelector: function (t) {
        var n = -1,
          i = -1;
        if (t < 0 || 1 < t)
          throw new Error(
            "Moving average bandwidth decay must be between 0 and 1."
          );
        return function () {
          var e = (this.useDevicePixelRatio && window.devicePixelRatio) || 1;
          return (
            n < 0 && ((n = this.systemBandwidth), (i = this.systemBandwidth)),
            0 < this.systemBandwidth &&
              this.systemBandwidth !== i &&
              ((n = t * this.systemBandwidth + (1 - t) * n),
              (i = this.systemBandwidth)),
            au(
              this.playlists.master,
              n,
              parseInt(nu(this.tech_.el(), "width"), 10) * e,
              parseInt(nu(this.tech_.el(), "height"), 10) * e,
              this.limitRenditionByPlayerDimensions,
              this.masterPlaylistController_
            )
          );
        };
      },
      comparePlaylistBandwidth: ru,
      comparePlaylistResolution: function (e, t) {
        var n, i;
        return (n =
          (n =
            e.attributes.RESOLUTION && e.attributes.RESOLUTION.width
              ? e.attributes.RESOLUTION.width
              : n) || window.Number.MAX_VALUE) ===
          (i =
            (i =
              t.attributes.RESOLUTION && t.attributes.RESOLUTION.width
                ? t.attributes.RESOLUTION.width
                : i) || window.Number.MAX_VALUE) &&
          e.attributes.BANDWIDTH &&
          t.attributes.BANDWIDTH
          ? e.attributes.BANDWIDTH - t.attributes.BANDWIDTH
          : n - i;
      },
      xhr: _l(),
    };
  Object.keys(L).forEach(function (t) {
    Object.defineProperty(M, t, {
      get: function () {
        return (
          w.log.warn(
            "using Vhs." + t + " is UNSAFE be sure you know what you are doing"
          ),
          L[t]
        );
      },
      set: function (e) {
        w.log.warn(
          "using Vhs." + t + " is UNSAFE be sure you know what you are doing"
        ),
          "number" != typeof e || e < 0
            ? w.log.warn(
                "value of Vhs." + t + " must be greater than or equal to 0"
              )
            : (L[t] = e);
      },
    });
  });
  function Cc(e, t) {
    for (var n = t.media(), i = -1, r = 0; r < e.length; r++)
      if (e[r].id === n.id) {
        i = r;
        break;
      }
    (e.selectedIndex_ = i), e.trigger({ selectedIndex: i, type: "change" });
  }
  var Ic = "videojs-vhs";
  M.canPlaySource = function () {
    return w.log.warn(
      "HLS is no longer a tech. Please remove it from your player's techOrder."
    );
  };
  function xc(e) {
    var i = e.player,
      t = e.sourceKeySystems,
      n = e.audioMedia,
      e = e.mainPlaylists;
    if (!i.eme.initializeMediaKeys) return Promise.resolve();
    var r,
      e =
        ((e = e = n ? e.concat([n]) : e),
        (r = Object.keys(t)),
        e.reduce(function (e, i) {
          if (!i.contentProtection) return e;
          var t = r.reduce(function (e, t) {
            var n = i.contentProtection[t];
            return n && n.pssh && (e[t] = { pssh: n.pssh }), e;
          }, {});
          return Object.keys(t).length && e.push(t), e;
        }, [])),
      a = [],
      s = [];
    return (
      e.forEach(function (e) {
        s.push(
          new Promise(function (e, t) {
            i.tech_.one("keysessioncreated", e);
          })
        ),
          a.push(
            new Promise(function (t, n) {
              i.eme.initializeMediaKeys({ keySystems: e }, function (e) {
                e ? n(e) : t();
              });
            })
          );
      }),
      Promise.race([Promise.all(a), Promise.race(s)])
    );
  }
  function Ec(e) {
    var t = e.player;
    return (
      !!(e = (function (e, t, n) {
        if (!e) return e;
        var i = {};
        t &&
          t.attributes &&
          t.attributes.CODECS &&
          (i = Jl(Tr(t.attributes.CODECS))),
          n &&
            n.attributes &&
            n.attributes.CODECS &&
            (i.audio = n.attributes.CODECS);
        var r,
          a = Sr(i.video),
          s = Sr(i.audio),
          o = {};
        for (r in e)
          (o[r] = {}),
            s && (o[r].audioContentType = s),
            a && (o[r].videoContentType = a),
            t.contentProtection &&
              t.contentProtection[r] &&
              t.contentProtection[r].pssh &&
              (o[r].pssh = t.contentProtection[r].pssh),
            "string" == typeof e[r] && (o[r].url = e[r]);
        return w.mergeOptions(e, o);
      })(e.sourceKeySystems, e.media, e.audioMedia)) &&
      (!((t.currentSource().keySystems = e) && !t.eme) ||
        (w.log.warn(
          "DRM encrypted source cannot be decrypted without a DRM plugin"
        ),
        !1))
    );
  }
  function kc() {
    if (!window.localStorage) return null;
    var e = window.localStorage.getItem(Ic);
    if (!e) return null;
    try {
      return JSON.parse(e);
    } catch (e) {
      return null;
    }
  }
  (M.supportsNativeHls = (function () {
    if (!document || !document.createElement) return !1;
    var t = document.createElement("video");
    if (!w.getTech("Html5").isSupported()) return !1;
    return [
      "application/vnd.apple.mpegurl",
      "audio/mpegurl",
      "audio/x-mpegurl",
      "application/x-mpegurl",
      "video/x-mpegurl",
      "video/mpegurl",
      "application/mpegurl",
    ].some(function (e) {
      return /maybe|probably/i.test(t.canPlayType(e));
    });
  })()),
    (M.supportsNativeDash =
      !!(
        document &&
        document.createElement &&
        w.getTech("Html5").isSupported()
      ) &&
      /maybe|probably/i.test(
        document.createElement("video").canPlayType("application/dash+xml")
      )),
    (M.supportsTypeNatively = function (e) {
      return "hls" === e
        ? M.supportsNativeHls
        : "dash" === e && M.supportsNativeDash;
    }),
    (M.isSupported = function () {
      return w.log.warn(
        "HLS is no longer a tech. Please remove it from your player's techOrder."
      );
    });
  var Pc = (function (r) {
      function e(e, t, n) {
        var i = r.call(this, t, w.mergeOptions(n.hls, n.vhs)) || this;
        if (
          (n.hls &&
            Object.keys(n.hls).length &&
            w.log.warn(
              "Using hls options is deprecated. Please rename `hls` to `vhs` in your options object."
            ),
          "number" == typeof n.initialBandwidth &&
            (i.options_.bandwidth = n.initialBandwidth),
          (i.logger_ = Bo("VhsHandler")),
          t.options_ &&
            t.options_.playerId &&
            ((n = w(t.options_.playerId)).hasOwnProperty("hls") ||
              Object.defineProperty(n, "hls", {
                get: function () {
                  return (
                    w.log.warn(
                      "player.hls is deprecated. Use player.tech().vhs instead."
                    ),
                    t.trigger({ type: "usage", name: "hls-player-access" }),
                    y(i)
                  );
                },
                configurable: !0,
              }),
            n.hasOwnProperty("vhs") ||
              Object.defineProperty(n, "vhs", {
                get: function () {
                  return (
                    w.log.warn(
                      "player.vhs is deprecated. Use player.tech().vhs instead."
                    ),
                    t.trigger({ type: "usage", name: "vhs-player-access" }),
                    y(i)
                  );
                },
                configurable: !0,
              }),
            n.hasOwnProperty("dash") ||
              Object.defineProperty(n, "dash", {
                get: function () {
                  return (
                    w.log.warn(
                      "player.dash is deprecated. Use player.tech().vhs instead."
                    ),
                    y(i)
                  );
                },
                configurable: !0,
              }),
            (i.player_ = n)),
          (i.tech_ = t),
          (i.source_ = e),
          (i.stats = {}),
          (i.ignoreNextSeekingEvent_ = !1),
          i.setOptions_(),
          i.options_.overrideNative &&
            t.overrideNativeAudioTracks &&
            t.overrideNativeVideoTracks)
        )
          t.overrideNativeAudioTracks(!0), t.overrideNativeVideoTracks(!0);
        else if (
          i.options_.overrideNative &&
          (t.featuresNativeVideoTracks || t.featuresNativeAudioTracks)
        )
          throw new Error(
            "Overriding native HLS requires emulated tracks. See https://git.io/vMpjB"
          );
        return (
          i.on(
            document,
            [
              "fullscreenchange",
              "webkitfullscreenchange",
              "mozfullscreenchange",
              "MSFullscreenChange",
            ],
            function (e) {
              var t =
                document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.mozFullScreenElement ||
                document.msFullscreenElement;
              t && t.contains(i.tech_.el())
                ? i.masterPlaylistController_.fastQualityChange_()
                : i.masterPlaylistController_.checkABR_();
            }
          ),
          i.on(i.tech_, "seeking", function () {
            this.ignoreNextSeekingEvent_
              ? (this.ignoreNextSeekingEvent_ = !1)
              : this.setCurrentTime(this.tech_.currentTime());
          }),
          i.on(i.tech_, "error", function () {
            this.tech_.error() &&
              this.masterPlaylistController_ &&
              this.masterPlaylistController_.pauseLoading();
          }),
          i.on(i.tech_, "play", i.play),
          i
        );
      }
      b(e, r);
      var t = e.prototype;
      return (
        (t.setOptions_ = function () {
          var e,
            t = this;
          (this.options_.withCredentials = this.options_.withCredentials || !1),
            (this.options_.handleManifestRedirects =
              !1 !== this.options_.handleManifestRedirects),
            (this.options_.limitRenditionByPlayerDimensions =
              !1 !== this.options_.limitRenditionByPlayerDimensions),
            (this.options_.useDevicePixelRatio =
              this.options_.useDevicePixelRatio || !1),
            (this.options_.smoothQualityChange =
              this.options_.smoothQualityChange || !1),
            (this.options_.useBandwidthFromLocalStorage =
              "undefined" != typeof this.source_.useBandwidthFromLocalStorage
                ? this.source_.useBandwidthFromLocalStorage
                : this.options_.useBandwidthFromLocalStorage || !1),
            (this.options_.useNetworkInformationApi =
              this.options_.useNetworkInformationApi || !1),
            (this.options_.useDtsForTimestampOffset =
              this.options_.useDtsForTimestampOffset || !1),
            (this.options_.customTagParsers =
              this.options_.customTagParsers || []),
            (this.options_.customTagMappers =
              this.options_.customTagMappers || []),
            (this.options_.cacheEncryptionKeys =
              this.options_.cacheEncryptionKeys || !1),
            "number" != typeof this.options_.blacklistDuration &&
              (this.options_.blacklistDuration = 300),
            "number" != typeof this.options_.bandwidth &&
              this.options_.useBandwidthFromLocalStorage &&
              ((e = kc()) &&
                e.bandwidth &&
                ((this.options_.bandwidth = e.bandwidth),
                this.tech_.trigger({
                  type: "usage",
                  name: "vhs-bandwidth-from-local-storage",
                }),
                this.tech_.trigger({
                  type: "usage",
                  name: "hls-bandwidth-from-local-storage",
                })),
              e &&
                e.throughput &&
                ((this.options_.throughput = e.throughput),
                this.tech_.trigger({
                  type: "usage",
                  name: "vhs-throughput-from-local-storage",
                }),
                this.tech_.trigger({
                  type: "usage",
                  name: "hls-throughput-from-local-storage",
                }))),
            "number" != typeof this.options_.bandwidth &&
              (this.options_.bandwidth = L.INITIAL_BANDWIDTH),
            (this.options_.enableLowInitialPlaylist =
              this.options_.enableLowInitialPlaylist &&
              this.options_.bandwidth === L.INITIAL_BANDWIDTH),
            [
              "withCredentials",
              "useDevicePixelRatio",
              "limitRenditionByPlayerDimensions",
              "bandwidth",
              "smoothQualityChange",
              "customTagParsers",
              "customTagMappers",
              "handleManifestRedirects",
              "cacheEncryptionKeys",
              "playlistSelector",
              "initialPlaylistSelector",
              "experimentalBufferBasedABR",
              "liveRangeSafeTimeDelta",
              "experimentalLLHLS",
              "useNetworkInformationApi",
              "useDtsForTimestampOffset",
              "experimentalExactManifestTimings",
              "experimentalLeastPixelDiffSelector",
            ].forEach(function (e) {
              "undefined" != typeof t.source_[e] &&
                (t.options_[e] = t.source_[e]);
            }),
            (this.limitRenditionByPlayerDimensions =
              this.options_.limitRenditionByPlayerDimensions),
            (this.useDevicePixelRatio = this.options_.useDevicePixelRatio);
        }),
        (t.src = function (e, t) {
          var i = this;
          e &&
            (this.setOptions_(),
            (this.options_.src =
              0 ===
              (e = this.source_.src)
                .toLowerCase()
                .indexOf("data:application/vnd.videojs.vhs+json,")
                ? JSON.parse(e.substring(e.indexOf(",") + 1))
                : e),
            (this.options_.tech = this.tech_),
            (this.options_.externVhs = M),
            (this.options_.sourceType = Cr(t)),
            (this.options_.seekTo = function (e) {
              i.tech_.setCurrentTime(e);
            }),
            this.options_.smoothQualityChange &&
              w.log.warn(
                "smoothQualityChange is deprecated and will be removed in the next major version"
              ),
            (this.masterPlaylistController_ = new Oc(this.options_)),
            (t = w.mergeOptions(
              { liveRangeSafeTimeDelta: 0.1 },
              this.options_,
              {
                seekable: function () {
                  return i.seekable();
                },
                media: function () {
                  return i.masterPlaylistController_.media();
                },
                masterPlaylistController: this.masterPlaylistController_,
              }
            )),
            (this.playbackWatcher_ = new Ac(t)),
            this.masterPlaylistController_.on("error", function () {
              var e = w.players[i.tech_.options_.playerId],
                t = i.masterPlaylistController_.error;
              "object" != typeof t || t.code
                ? "string" == typeof t && (t = { message: t, code: 3 })
                : (t.code = 3),
                e.error(t);
            }),
            (t = this.options_.experimentalBufferBasedABR
              ? M.movingAverageBandwidthSelector(0.55)
              : M.STANDARD_PLAYLIST_SELECTOR),
            (this.masterPlaylistController_.selectPlaylist = (
              this.selectPlaylist || t
            ).bind(this)),
            (this.masterPlaylistController_.selectInitialPlaylist =
              M.INITIAL_PLAYLIST_SELECTOR.bind(this)),
            (this.playlists =
              this.masterPlaylistController_.masterPlaylistLoader_),
            (this.mediaSource = this.masterPlaylistController_.mediaSource),
            Object.defineProperties(this, {
              selectPlaylist: {
                get: function () {
                  return this.masterPlaylistController_.selectPlaylist;
                },
                set: function (e) {
                  this.masterPlaylistController_.selectPlaylist = e.bind(this);
                },
              },
              throughput: {
                get: function () {
                  return this.masterPlaylistController_.mainSegmentLoader_
                    .throughput.rate;
                },
                set: function (e) {
                  (this.masterPlaylistController_.mainSegmentLoader_.throughput.rate =
                    e),
                    (this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1);
                },
              },
              bandwidth: {
                get: function () {
                  var e =
                      this.masterPlaylistController_.mainSegmentLoader_
                        .bandwidth,
                    t =
                      window.navigator.connection ||
                      window.navigator.mozConnection ||
                      window.navigator.webkitConnection;
                  return (e =
                    this.options_.useNetworkInformationApi && t
                      ? 1e7 <= (t = 1e3 * t.downlink * 1e3) && 1e7 <= e
                        ? Math.max(e, t)
                        : t
                      : e);
                },
                set: function (e) {
                  (this.masterPlaylistController_.mainSegmentLoader_.bandwidth =
                    e),
                    (this.masterPlaylistController_.mainSegmentLoader_.throughput =
                      { rate: 0, count: 0 });
                },
              },
              systemBandwidth: {
                get: function () {
                  var e = 1 / (this.bandwidth || 1),
                    t = 0 < this.throughput ? 1 / this.throughput : 0;
                  return Math.floor(1 / (e + t));
                },
                set: function () {
                  w.log.error('The "systemBandwidth" property is read-only');
                },
              },
            }),
            this.options_.bandwidth &&
              (this.bandwidth = this.options_.bandwidth),
            this.options_.throughput &&
              (this.throughput = this.options_.throughput),
            Object.defineProperties(this.stats, {
              bandwidth: {
                get: function () {
                  return i.bandwidth || 0;
                },
                enumerable: !0,
              },
              mediaRequests: {
                get: function () {
                  return i.masterPlaylistController_.mediaRequests_() || 0;
                },
                enumerable: !0,
              },
              mediaRequestsAborted: {
                get: function () {
                  return (
                    i.masterPlaylistController_.mediaRequestsAborted_() || 0
                  );
                },
                enumerable: !0,
              },
              mediaRequestsTimedout: {
                get: function () {
                  return (
                    i.masterPlaylistController_.mediaRequestsTimedout_() || 0
                  );
                },
                enumerable: !0,
              },
              mediaRequestsErrored: {
                get: function () {
                  return (
                    i.masterPlaylistController_.mediaRequestsErrored_() || 0
                  );
                },
                enumerable: !0,
              },
              mediaTransferDuration: {
                get: function () {
                  return (
                    i.masterPlaylistController_.mediaTransferDuration_() || 0
                  );
                },
                enumerable: !0,
              },
              mediaBytesTransferred: {
                get: function () {
                  return (
                    i.masterPlaylistController_.mediaBytesTransferred_() || 0
                  );
                },
                enumerable: !0,
              },
              mediaSecondsLoaded: {
                get: function () {
                  return i.masterPlaylistController_.mediaSecondsLoaded_() || 0;
                },
                enumerable: !0,
              },
              mediaAppends: {
                get: function () {
                  return i.masterPlaylistController_.mediaAppends_() || 0;
                },
                enumerable: !0,
              },
              mainAppendsToLoadedData: {
                get: function () {
                  return (
                    i.masterPlaylistController_.mainAppendsToLoadedData_() || 0
                  );
                },
                enumerable: !0,
              },
              audioAppendsToLoadedData: {
                get: function () {
                  return (
                    i.masterPlaylistController_.audioAppendsToLoadedData_() || 0
                  );
                },
                enumerable: !0,
              },
              appendsToLoadedData: {
                get: function () {
                  return (
                    i.masterPlaylistController_.appendsToLoadedData_() || 0
                  );
                },
                enumerable: !0,
              },
              timeToLoadedData: {
                get: function () {
                  return i.masterPlaylistController_.timeToLoadedData_() || 0;
                },
                enumerable: !0,
              },
              buffered: {
                get: function () {
                  return qo(i.tech_.buffered());
                },
                enumerable: !0,
              },
              currentTime: {
                get: function () {
                  return i.tech_.currentTime();
                },
                enumerable: !0,
              },
              currentSource: {
                get: function () {
                  return i.tech_.currentSource_;
                },
                enumerable: !0,
              },
              currentTech: {
                get: function () {
                  return i.tech_.name_;
                },
                enumerable: !0,
              },
              duration: {
                get: function () {
                  return i.tech_.duration();
                },
                enumerable: !0,
              },
              master: {
                get: function () {
                  return i.playlists.master;
                },
                enumerable: !0,
              },
              playerDimensions: {
                get: function () {
                  return i.tech_.currentDimensions();
                },
                enumerable: !0,
              },
              seekable: {
                get: function () {
                  return qo(i.tech_.seekable());
                },
                enumerable: !0,
              },
              timestamp: {
                get: function () {
                  return Date.now();
                },
                enumerable: !0,
              },
              videoPlaybackQuality: {
                get: function () {
                  return i.tech_.getVideoPlaybackQuality();
                },
                enumerable: !0,
              },
            }),
            this.tech_.one(
              "canplay",
              this.masterPlaylistController_.setupFirstPlay.bind(
                this.masterPlaylistController_
              )
            ),
            this.tech_.on("bandwidthupdate", function () {
              i.options_.useBandwidthFromLocalStorage &&
                (function (e) {
                  if (!window.localStorage) return;
                  var t = (t = kc()) ? w.mergeOptions(t, e) : e;
                  try {
                    window.localStorage.setItem(Ic, JSON.stringify(t));
                  } catch (e) {
                    return;
                  }
                })({
                  bandwidth: i.bandwidth,
                  throughput: Math.round(i.throughput),
                });
            }),
            this.masterPlaylistController_.on(
              "selectedinitialmedia",
              function () {
                var n;
                (n = i).representations = function () {
                  var e = n.masterPlaylistController_.master(),
                    e = ll(e)
                      ? n.masterPlaylistController_.getAudioTrackPlaylists_()
                      : e.playlists;
                  return e
                    ? e
                        .filter(function (e) {
                          return !nl(e);
                        })
                        .map(function (e, t) {
                          return new Qu(n, e, e.id);
                        })
                    : [];
                };
              }
            ),
            this.masterPlaylistController_.sourceUpdater_.on(
              "createdsourcebuffers",
              function () {
                i.setupEme_();
              }
            ),
            this.on(this.masterPlaylistController_, "progress", function () {
              this.tech_.trigger("progress");
            }),
            this.on(this.masterPlaylistController_, "firstplay", function () {
              this.ignoreNextSeekingEvent_ = !0;
            }),
            this.setupQualityLevels_(),
            this.tech_.el() &&
              ((this.mediaSourceUrl_ = window.URL.createObjectURL(
                this.masterPlaylistController_.mediaSource
              )),
              this.tech_.src(this.mediaSourceUrl_)));
        }),
        (t.createKeySessions_ = function () {
          var t = this,
            e =
              this.masterPlaylistController_.mediaTypes_.AUDIO
                .activePlaylistLoader;
          this.logger_("waiting for EME key session creation"),
            xc({
              player: this.player_,
              sourceKeySystems: this.source_.keySystems,
              audioMedia: e && e.media(),
              mainPlaylists: this.playlists.master.playlists,
            })
              .then(function () {
                t.logger_("created EME key session"),
                  t.masterPlaylistController_.sourceUpdater_.initializedEme();
              })
              .catch(function (e) {
                t.logger_("error while creating EME key session", e),
                  t.player_.error({
                    message: "Failed to initialize media keys for EME",
                    code: 3,
                  });
              });
        }),
        (t.handleWaitingForKey_ = function () {
          this.logger_(
            "waitingforkey fired, attempting to create any new key sessions"
          ),
            this.createKeySessions_();
        }),
        (t.setupEme_ = function () {
          var n = this,
            e =
              this.masterPlaylistController_.mediaTypes_.AUDIO
                .activePlaylistLoader,
            e = Ec({
              player: this.player_,
              sourceKeySystems: this.source_.keySystems,
              media: this.playlists.media(),
              audioMedia: e && e.media(),
            });
          this.player_.tech_.on("keystatuschange", function (e) {
            var t;
            "output-restricted" !== e.status ||
              ((e = n.masterPlaylistController_.master()) &&
                e.playlists &&
                ((t = []),
                e.playlists.forEach(function (e) {
                  e &&
                    e.attributes &&
                    e.attributes.RESOLUTION &&
                    720 <= e.attributes.RESOLUTION.height &&
                    (!e.excludeUntil || e.excludeUntil < 1 / 0) &&
                    ((e.excludeUntil = 1 / 0), t.push(e));
                }),
                t.length &&
                  ((e = w.log).warn.apply(
                    e,
                    [
                      'DRM keystatus changed to "output-restricted." Removing the following HD playlists that will most likely fail to play and clearing the buffer. This may be due to HDCP restrictions on the stream and the capabilities of the current device.',
                    ].concat(t)
                  ),
                  n.masterPlaylistController_.fastQualityChange_())));
          }),
            (this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this)),
            this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_),
            11 !== w.browser.IE_VERSION && e
              ? this.createKeySessions_()
              : this.masterPlaylistController_.sourceUpdater_.initializedEme();
        }),
        (t.setupQualityLevels_ = function () {
          var n = this,
            e = w.players[this.tech_.options_.playerId];
          e &&
            e.qualityLevels &&
            !this.qualityLevels_ &&
            ((this.qualityLevels_ = e.qualityLevels()),
            this.masterPlaylistController_.on(
              "selectedinitialmedia",
              function () {
                var t, e;
                (t = n.qualityLevels_),
                  (e = n).representations().forEach(function (e) {
                    t.addQualityLevel(e);
                  }),
                  Cc(t, e.playlists);
              }
            ),
            this.playlists.on("mediachange", function () {
              Cc(n.qualityLevels_, n.playlists);
            }));
        }),
        (e.version = function () {
          return {
            "@videojs/http-streaming": "2.14.3",
            "mux.js": "6.0.1",
            "mpd-parser": "0.21.1",
            "m3u8-parser": "4.7.1",
            "aes-decrypter": "3.1.3",
          };
        }),
        (t.version = function () {
          return this.constructor.version();
        }),
        (t.canChangeType = function () {
          return cc.canChangeType();
        }),
        (t.play = function () {
          this.masterPlaylistController_.play();
        }),
        (t.setCurrentTime = function (e) {
          this.masterPlaylistController_.setCurrentTime(e);
        }),
        (t.duration = function () {
          return this.masterPlaylistController_.duration();
        }),
        (t.seekable = function () {
          return this.masterPlaylistController_.seekable();
        }),
        (t.dispose = function () {
          this.playbackWatcher_ && this.playbackWatcher_.dispose(),
            this.masterPlaylistController_ &&
              this.masterPlaylistController_.dispose(),
            this.qualityLevels_ && this.qualityLevels_.dispose(),
            this.player_ &&
              (delete this.player_.vhs,
              delete this.player_.dash,
              delete this.player_.hls),
            this.tech_ && this.tech_.vhs && delete this.tech_.vhs,
            this.tech_ && delete this.tech_.hls,
            this.mediaSourceUrl_ &&
              window.URL.revokeObjectURL &&
              (window.URL.revokeObjectURL(this.mediaSourceUrl_),
              (this.mediaSourceUrl_ = null)),
            this.tech_ &&
              this.tech_.off("waitingforkey", this.handleWaitingForKey_),
            r.prototype.dispose.call(this);
        }),
        (t.convertToProgramTime = function (e, t) {
          return xl({
            playlist: this.masterPlaylistController_.media(),
            time: e,
            callback: t,
          });
        }),
        (t.seekToProgramTime = function (e, t, n, i) {
          return (
            void 0 === n && (n = !0),
            void 0 === i && (i = 2),
            El({
              programTime: e,
              playlist: this.masterPlaylistController_.media(),
              retryCount: i,
              pauseAfterSeek: n,
              seekTo: this.options_.seekTo,
              tech: this.options_.tech,
              callback: t,
            })
          );
        }),
        e
      );
    })(w.getComponent("Component")),
    jc = {
      name: "videojs-http-streaming",
      VERSION: "2.14.3",
      canHandleSource: function (e, t) {
        t = w.mergeOptions(w.options, (t = void 0 === t ? {} : t));
        return jc.canPlayType(e.type, t);
      },
      handleSource: function (e, t, n) {
        n = w.mergeOptions(w.options, (n = void 0 === n ? {} : n));
        return (
          (t.vhs = new Pc(e, t, n)),
          w.hasOwnProperty("hls") ||
            Object.defineProperty(t, "hls", {
              get: function () {
                return (
                  w.log.warn(
                    "player.tech().hls is deprecated. Use player.tech().vhs instead."
                  ),
                  t.vhs
                );
              },
              configurable: !0,
            }),
          (t.vhs.xhr = _l()),
          t.vhs.src(e.src, e.type),
          t.vhs
        );
      },
      canPlayType: function (e, t) {
        var n = w.mergeOptions(w.options, (t = void 0 === t ? {} : t)),
          t = n.vhs,
          t = (t = void 0 === t ? {} : t).overrideNative,
          t = void 0 === t ? !w.browser.IS_ANY_SAFARI : t,
          n = n.hls,
          n = (n = void 0 === n ? {} : n).overrideNative,
          n = void 0 !== n && n,
          e = Cr(e);
        return e && (!M.supportsTypeNatively(e) || n || t) ? "maybe" : "";
      },
    };
  return (
    Ar("avc1.4d400d,mp4a.40.2") &&
      w.getTech("Html5").registerSourceHandler(jc, 0),
    (w.VhsHandler = Pc),
    Object.defineProperty(w, "HlsHandler", {
      get: function () {
        return (
          w.log.warn(
            "videojs.HlsHandler is deprecated. Use videojs.VhsHandler instead."
          ),
          Pc
        );
      },
      configurable: !0,
    }),
    (w.VhsSourceHandler = jc),
    Object.defineProperty(w, "HlsSourceHandler", {
      get: function () {
        return (
          w.log.warn(
            "videojs.HlsSourceHandler is deprecated. Use videojs.VhsSourceHandler instead."
          ),
          jc
        );
      },
      configurable: !0,
    }),
    (w.Vhs = M),
    Object.defineProperty(w, "Hls", {
      get: function () {
        return (
          w.log.warn("videojs.Hls is deprecated. Use videojs.Vhs instead."), M
        );
      },
      configurable: !0,
    }),
    w.use || (w.registerComponent("Hls", M), w.registerComponent("Vhs", M)),
    (w.options.vhs = w.options.vhs || {}),
    (w.options.hls = w.options.hls || {}),
    (w.getPlugin && w.getPlugin("reloadSourceOnError")) ||
      (w.registerPlugin || w.plugin)("reloadSourceOnError", function (e) {
        Zu(this, e);
      }),
    w
  );
});
(() => {
  "use strict";
  var e = {};
  const s = {
    ANIM: {
      EASINGS: [
        "linear",
        "absolute",
        "smoothstep",
        "smootherstep",
        "Cubic In",
        "Cubic Out",
        "Cubic In Out",
        "Expo In",
        "Expo Out",
        "Expo In Out",
        "Sin In",
        "Sin Out",
        "Sin In Out",
        "Quart In",
        "Quart Out",
        "Quart In Out",
        "Quint In",
        "Quint Out",
        "Quint In Out",
        "Back In",
        "Back Out",
        "Back In Out",
        "Elastic In",
        "Elastic Out",
        "Bounce In",
        "Bounce Out",
      ],
      EASING_LINEAR: 0,
      EASING_ABSOLUTE: 1,
      EASING_SMOOTHSTEP: 2,
      EASING_SMOOTHERSTEP: 3,
      EASING_CUBICSPLINE: 4,
      EASING_CUBIC_IN: 5,
      EASING_CUBIC_OUT: 6,
      EASING_CUBIC_INOUT: 7,
      EASING_EXPO_IN: 8,
      EASING_EXPO_OUT: 9,
      EASING_EXPO_INOUT: 10,
      EASING_SIN_IN: 11,
      EASING_SIN_OUT: 12,
      EASING_SIN_INOUT: 13,
      EASING_BACK_IN: 14,
      EASING_BACK_OUT: 15,
      EASING_BACK_INOUT: 16,
      EASING_ELASTIC_IN: 17,
      EASING_ELASTIC_OUT: 18,
      EASING_BOUNCE_IN: 19,
      EASING_BOUNCE_OUT: 21,
      EASING_QUART_IN: 22,
      EASING_QUART_OUT: 23,
      EASING_QUART_INOUT: 24,
      EASING_QUINT_IN: 25,
      EASING_QUINT_OUT: 26,
      EASING_QUINT_INOUT: 27,
    },
    OP: {
      OP_PORT_TYPE_VALUE: 0,
      OP_PORT_TYPE_NUMBER: 0,
      OP_PORT_TYPE_FUNCTION: 1,
      OP_PORT_TYPE_TRIGGER: 1,
      OP_PORT_TYPE_OBJECT: 2,
      OP_PORT_TYPE_TEXTURE: 2,
      OP_PORT_TYPE_ARRAY: 3,
      OP_PORT_TYPE_DYNAMIC: 4,
      OP_PORT_TYPE_STRING: 5,
      OP_VERSION_PREFIX: "_v",
    },
    PORT: { PORT_DIR_IN: 0, PORT_DIR_OUT: 1 },
    PACO: {
      PACO_CLEAR: 0,
      PACO_VALUECHANGE: 1,
      PACO_OP_DELETE: 2,
      PACO_UNLINK: 3,
      PACO_LINK: 4,
      PACO_LOAD: 5,
      PACO_OP_CREATE: 6,
      PACO_OP_ENABLE: 7,
      PACO_OP_DISABLE: 8,
      PACO_UIATTRIBS: 9,
      PACO_VARIABLES: 10,
      PACO_TRIGGERS: 11,
      PACO_PORT_SETVARIABLE: 12,
      PACO_PORT_SETANIMATED: 13,
      PACO_PORT_ANIM_UPDATED: 14,
      PACO_DESERIALIZE: 15,
      PACO_OP_RELOAD: 16,
    },
  };
  const t = class {
    constructor(t, e, n, i, r, a) {
      this._valuePort = n;
      this._varNamePort = i;
      this._op = t;
      this._type = e;
      this._typeId = -1;
      this._triggerPort = r;
      this._nextPort = a;
      this._btnCreate = t.inTriggerButton("Create new variable");
      this._btnCreate.setUiAttribs({ hidePort: true });
      this._btnCreate.onTriggered = this._createVar.bind(this);
      this._helper = t.inUiTriggerButtons("", ["Rename"]);
      this._helper.setUiAttribs({ hidePort: true });
      this._helper.onTriggered = (e) => {
        if (e == "Rename") CABLES.CMD.PATCH.renameVariable(t.varName.get());
      };
      this._op.setPortGroup("Variable", [
        this._helper,
        this._varNamePort,
        this._btnCreate,
      ]);
      i.setUiAttribs({ _variableSelect: true });
      this._op.on("uiParamPanel", this._updateVarNamesDropdown.bind(this));
      this._op.patch.addEventListener(
        "variablesChanged",
        this._updateName.bind(this)
      );
      this._op.patch.addEventListener(
        "variableRename",
        this._renameVar.bind(this)
      );
      this._varNamePort.onChange = this._updateName.bind(this);
      this._isTexture = this._valuePort.uiAttribs.objType === "texture";
      this._valuePort.changeAlways = true;
      if (this._triggerPort) {
        this._triggerPort.onTriggered = () => {
          this._setVarValue(true);
        };
      } else {
        this._valuePort.onChange = this._setVarValue.bind(this);
      }
      this._op.init = () => {
        this._updateName();
        if (!this._triggerPort) this._setVarValue();
        this._updateErrorUi();
      };
      if (e == "array") this._typeId = s.OP.OP_PORT_TYPE_ARRAY;
      else if (e == "object") this._typeId = s.OP.OP_PORT_TYPE_OBJECT;
      else if (e == "string") this._typeId = s.OP.OP_PORT_TYPE_STRING;
      else if (e == "texture") this._typeId = s.OP.OP_PORT_TYPE_TEXTURE;
      else this._typeId = s.OP.OP_PORT_TYPE_VALUE;
    }
    _updateErrorUi() {
      if (CABLES.UI) {
        if (!this._varNamePort.get())
          this._op.setUiError("novarname", "no variable selected");
        else {
          if (this._op.hasUiErrors) {
            this._op.setUiError("novarname", null);
          }
        }
      }
    }
    _updateName() {
      const e = this._varNamePort.get();
      this._op.setTitle("var set");
      this._op.setUiAttrib({ extendTitle: "#" + e });
      this._updateErrorUi();
      const t = this._op.patch.getVar(e);
      if (t && !t.type) t.type = this._type;
      if (!this._op.patch.hasVar(e) && e != 0 && !this._triggerPort) {
        this._setVarValue();
      }
      if (!this._op.patch.hasVar(e) && e != 0 && this._triggerPort) {
        if (this._type == "string") this._op.patch.setVarValue(e, "");
        else if (this._type == "number") this._op.patch.setVarValue(e, "");
        else this._op.patch.setVarValue(e, null);
      }
      if (this._op.isCurrentUiOp()) {
        this._updateVarNamesDropdown();
        this._op.refreshParams();
      }
      this._updateDisplay();
      this._op.patch.emitEvent(
        "opVariableNameChanged",
        this._op,
        this._varNamePort.get()
      );
    }
    _createVar() {
      CABLES.CMD.PATCH.createVariable(this._op, this._type, () => {
        this._updateName();
      });
    }
    _updateDisplay() {
      this._valuePort.setUiAttribs({ greyout: !this._varNamePort.get() });
    }
    _updateVarNamesDropdown() {
      if (CABLES.UI && CABLES.UI.loaded && CABLES.UI.loaded) {
        const e = CABLES.UI.uiProfiler.start("[vars] _updateVarNamesDropdown");
        const t = [];
        const n = this._op.patch.getVars();
        for (const i in n) if (n[i].type == this._type && i != "0") t.push(i);
        this._varNamePort.uiAttribs.values = t;
        e.finish();
      }
    }
    _renameVar(e, t) {
      if (e != this._varNamePort.get()) return;
      this._varNamePort.set(t);
      this._updateName();
    }
    _setVarValue(e) {
      const t = this._varNamePort.get();
      if (!t) return;
      const n = this._valuePort.get();
      if (
        this._typeId == s.OP.OP_PORT_TYPE_VALUE ||
        this._typeId == s.OP.OP_PORT_TYPE_STRING
      ) {
        this._op.patch.setVarValue(t, n);
      } else if (this._typeId == s.OP.OP_PORT_TYPE_ARRAY) {
        this._arr = [];
        CABLES.copyArray(n, this._arr);
        this._op.patch.setVarValue(t, this._arr);
      } else {
        if (this._typeId == s.OP.OP_PORT_TYPE_OBJECT) {
          if (this._isTexture)
            this._op.patch.setVarValue(
              t,
              CGL.Texture.getEmptyTexture(this._op.patch.cgl)
            );
          else this._op.patch.setVarValue(t, null);
          if (n && n.tex && n._cgl && !this._isTexture)
            this._op.setUiError(
              "texobj",
              "Dont use object variables for textures, use varSetTexture"
            );
          else this._op.setUiError("texobj", null);
        }
        this._op.patch.setVarValue(t, n);
      }
      if (e && this._nextPort) this._nextPort.trigger();
    }
  };
  const n = class {
    constructor(e, t, n, i) {
      this._op = e;
      this._type = t;
      this._varnamePort = n;
      this._variable = null;
      this._valueOutPort = i;
      this._listenerId = null;
      this._op.on("uiParamPanel", this._updateVarNamesDropdown.bind(this));
      this._op.on("uiErrorChange", this._updateTitle.bind(this));
      this._op.patch.on("variableRename", this._renameVar.bind(this));
      this._op.patch.on("variableDeleted", (e) => {
        if (this._op.isCurrentUiOp()) this._op.refreshParams();
      });
      n.setUiAttribs({ _variableSelect: true });
      n.setUiAttribs({ _variableSelectGet: true });
      this._varnamePort.onChange = this._changeVar.bind(this);
      this._op.patch.addEventListener(
        "variablesChanged",
        this._init.bind(this)
      );
      this._op.onDelete = () => {
        if (this._variable && this._listenerId)
          this._variable.off(this._listenerId);
      };
      this._op.init = () => {
        this._init();
      };
    }
    get variable() {
      return this._variable;
    }
    _changeVar() {
      if (this._variable && this._listenerId) {
        this._variable.off(this._listenerId);
      }
      this._init();
    }
    _renameVar(e, t) {
      if (e != this._varnamePort.get()) return;
      this._varnamePort.set(t);
      this._updateVarNamesDropdown();
      this._updateTitle();
      this._listenerId = this._variable.on(
        "change",
        this._setValueOut.bind(this)
      );
    }
    _updateVarNamesDropdown() {
      if (CABLES.UI && CABLES.UI.loaded) {
        const e = [];
        const t = this._op.patch.getVars();
        for (const n in t) if (t[n].type == this._type && n != "0") e.push(n);
        this._op.varName.uiAttribs.values = e;
      }
    }
    _setValueOut(e) {
      if (this._valueOutPort)
        if (
          this._typeId == s.OP.OP_PORT_TYPE_ARRAY &&
          this._typeId == s.OP.OP_PORT_TYPE_OBJECT
        )
          this._valueOutPort.setRef(e);
        else this._valueOutPort.set(e);
    }
    _updateTitle() {
      if (this._variable) {
        this._op.setUiError("unknownvar", null);
        this._op.setTitle("var get");
        this._op.setUiAttrib({ extendTitle: "#" + this._varnamePort.get() });
        if (this._valueOutPort)
          this._valueOutPort.set(this._variable.getValue());
      } else {
        this._op.setUiError(
          "unknownvar",
          "unknown variable! - there is no setVariable with this name (" +
            this._varnamePort.get() +
            ")"
        );
        this._op.setUiAttrib({ extendTitle: "#invalid" });
        if (this._valueOutPort) this._valueOutPort.set(0);
      }
    }
    _init() {
      this._updateVarNamesDropdown();
      if (this._variable && this._listenerId)
        this._variable.off(this._listenerId);
      this._variable = this._op.patch.getVar(this._op.varName.get());
      if (this._variable)
        this._listenerId = this._variable.on(
          "change",
          this._setValueOut.bind(this)
        );
      this._updateTitle();
      this._op.patch.emitEvent(
        "opVariableNameChanged",
        this._op,
        this._varnamePort.get()
      );
    }
  };
  CABLES.VarSetOpWrapper = t;
  CABLES.VarGetOpWrapper = n;
  ((this.CABLES = this.CABLES || {}).COREMODULES =
    this.CABLES.COREMODULES || {}).Vargetset = e.Cables;
})();
(() => {
  "use strict";
  var e = {};
  class t {
    constructor(e, t, n) {
      this._cgl = e;
      this._name = t;
      this._origShaders = {};
      this._uniforms = [];
      this._structUniforms = [];
      this._definesToggled = {};
      this._defines = {};
      this._mods = [];
      this._textures = [];
      this._boundShader = null;
      this._changedDefines = true;
      this._changedUniforms = true;
      this._modulesChanged = false;
      this.needsTexturePush = false;
      this._lastShader = null;
      this._attributes = [];
      if (n && n.opId) this.opId = n.opId;
      if (this._cgl.glVersion == 1) {
        this._cgl.enableExtension("OES_texture_float");
        this._cgl.enableExtension("OES_texture_float_linear");
        this._cgl.enableExtension("OES_texture_half_float");
        this._cgl.enableExtension("OES_texture_half_float_linear");
      }
    }
    bind(e, t) {
      const n = e || this._cgl.getShader();
      if (!n) return;
      this._boundShader = this._origShaders[n.id];
      let i = false;
      if (this._boundShader && this._lastShader != this._boundShader.shader) {
        if (!this._boundShader.shader.hasModule(this._mods[0].id)) i = true;
      }
      if (
        i ||
        !this._boundShader ||
        n.lastCompile != this._boundShader.lastCompile ||
        this._modulesChanged ||
        n._needsRecompile
      ) {
        if (this._boundShader) this._boundShader.shader.dispose();
        if (n._needsRecompile) n.compile();
        this.needsTexturePush = true;
        this._boundShader = this._origShaders[n.id] = {
          lastCompile: n.lastCompile,
          orig: n,
          shader: n.copy(),
        };
        this._addModulesToShader(this._boundShader.shader);
        this._updateDefinesShader(this._boundShader.shader);
        this._updateUniformsShader(this._boundShader.shader);
      }
      this._boundShader.wireframe = n.wireframe;
      if (this._changedDefines) this._updateDefines();
      if (this._changedUniforms) this._updateUniforms();
      if (t !== false) this._cgl.pushShader(this._boundShader.shader);
      this._boundShader.shader.copyUniformValues(this._boundShader.orig);
      if (this.needsTexturePush) {
        for (let e = 0; e < this._textures.length; e++) {
          const r = this._textures[e][0];
          const a = this._textures[e][1];
          const s = this._textures[e][2];
          if (this._getUniform(r)) {
            const o = this.getPrefixedName(r);
            const l = this._boundShader.shader.getUniform(o);
            if (l) this._boundShader.shader.pushTexture(l, a, s);
          }
        }
        this.needsTexturePush = false;
        this._textures.length = 0;
      }
      this._modulesChanged = false;
      this._boundShader.shader.fromMod = this;
      if (this.onBind) this.onBind(this._boundShader.shader);
      return this._boundShader.shader;
    }
    unbind(e) {
      if (this._boundShader) {
        if (e !== false) this._cgl.popShader();
      }
      this._boundShader = null;
    }
    _addModulesToShader(t) {
      let n;
      if (this._mods.length > 1) n = this._mods[0];
      for (let e = 0; e < this._mods.length; e++) t.addModule(this._mods[e], n);
    }
    _removeModulesFromShader(e) {
      for (const t in this._origShaders)
        this._origShaders[t].shader.removeModule(e);
    }
    addModule(e) {
      this._mods.push(e);
      this._modulesChanged = true;
    }
    removeModule(t) {
      const n = [];
      let i = false;
      for (let e = 0; e < this._mods.length; e++) {
        if (this._mods[e].title == t) {
          i = true;
          this._removeModulesFromShader(this._mods[e]);
          n.push(e);
        }
      }
      for (let e = n.length - 1; e >= 0; e -= 1) this._mods.splice(n[e], 1);
      this._modulesChanged = true;
    }
    _updateUniformsShader(i) {
      for (let e = 0; e < this._uniforms.length; e++) {
        const t = this._uniforms[e];
        const n = this.getPrefixedName(t.name);
        if (!i.hasUniform(n) && !t.structName) {
          let e = null;
          if (t.shaderType === "both") {
            e = i.addUniformBoth(t.type, n, t.v1, t.v2, t.v3, t.v4);
            e.comment = "mod: " + this._name;
          } else if (t.shaderType === "frag") {
            e = i.addUniformFrag(t.type, n, t.v1, t.v2, t.v3, t.v4);
            e.comment = "mod: " + this._name;
          } else if (t.shaderType === "vert") {
            e = i.addUniformVert(t.type, n, t.v1, t.v2, t.v3, t.v4);
            e.comment = "mod: " + this._name;
          }
        }
      }
      for (let n = 0; n < this._structUniforms.length; n += 1) {
        const r = this._structUniforms[n];
        let e = r.uniformName;
        let t = r.structName;
        const a = r.members;
        e = this.getPrefixedName(r.uniformName);
        t = this.getPrefixedName(r.structName);
        if (r.shaderType === "frag") {
          i.addUniformStructFrag(t, e, a);
        }
        if (r.shaderType === "vert") {
          i.addUniformStructVert(t, e, a);
        }
        if (r.shaderType === "both") {
          i.addUniformStructBoth(t, e, a);
        }
      }
    }
    _updateUniforms() {
      for (const e in this._origShaders)
        this._updateUniformsShader(this._origShaders[e].shader);
      this._changedUniforms = false;
    }
    _setUniformValue(e, t, n) {
      const i = e.getUniform(t);
      if (i) i.setValue(n);
    }
    setUniformValue(e, t) {
      const n = this._getUniform(e);
      if (!n) return;
      const i = this.getPrefixedName(e);
      for (const r in this._origShaders) {
        this._setUniformValue(this._origShaders[r].shader, i, t);
      }
    }
    hasUniform(e) {
      return this._getUniform(e);
    }
    _getUniform(t) {
      for (let e = 0; e < this._uniforms.length; e++) {
        if (this._uniforms[e].name == t) return this._uniforms[e];
        if (this._uniforms[e].structName) {
          if (this._uniforms[e].propertyName == t) return this._uniforms[e];
        }
      }
      return false;
    }
    _getStructUniform(t) {
      for (let e = 0; e < this._structUniforms.length; e += 1)
        if (this._structUniforms[e].uniformName === t)
          return this._structUniforms[e];
      return null;
    }
    _isStructUniform(t) {
      for (let e = 0; e < this._uniforms.length; e++) {
        if (this._uniforms[e].name == t) return false;
        if (this._uniforms[e].structName) {
          if (this._uniforms[e].propertyName == t) return true;
        }
      }
      return false;
    }
    addUniform(t, n, i, r, a, s, o, l, u, c) {
      if (!this._getUniform(n)) {
        let e = "both";
        if (c) e = c;
        this._uniforms.push({
          type: t,
          name: n,
          v1: i,
          v2: r,
          v3: a,
          v4: s,
          structUniformName: o,
          structName: l,
          propertyName: u,
          shaderType: e,
        });
        this._changedUniforms = true;
      }
    }
    addUniformFrag(e, t, n, i, r, a) {
      this.addUniform(e, t, n, i, r, a, null, null, null, "frag");
      this._changedUniforms = true;
    }
    addUniformVert(e, t, n, i, r, a) {
      this.addUniform(e, t, n, i, r, a, null, null, null, "vert");
      this._changedUniforms = true;
    }
    addUniformBoth(e, t, n, i, r, a) {
      this.addUniform(e, t, n, i, r, a, null, null, null, "both");
      this._changedUniforms = true;
    }
    addUniformStruct(t, n, i, r) {
      for (let e = 0; e < i.length; e += 1) {
        const a = i[e];
        if (
          (a.type === "2i" || a.type === "i" || a.type === "3i") &&
          r === "both"
        )
          console.error(
            "Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:",
            t,
            " with member:",
            a.name,
            " of type:",
            a.type,
            "."
          );
        if (!this._getUniform(n + "." + a.name)) {
          this.addUniform(
            a.type,
            n + "." + a.name,
            a.v1,
            a.v2,
            a.v3,
            a.v4,
            n,
            t,
            a.name,
            r
          );
        }
      }
      if (!this._getStructUniform(n)) {
        this._structUniforms.push({
          structName: t,
          uniformName: n,
          members: i,
          shaderType: r,
        });
      }
    }
    addUniformStructVert(e, t, n) {
      this.addUniformStruct(e, t, n, "vert");
    }
    addUniformStructFrag(e, t, n) {
      this.addUniformStruct(e, t, n, "frag");
    }
    addUniformStructBoth(e, t, n) {
      this.addUniformStruct(e, t, n, "both");
    }
    addAttribute(t) {
      for (let e = 0; e < this._attributes.length; e++) {
        if (
          this._attributes[e].name == t.name &&
          this._attributes[e].nameFrag == t.nameFrag
        )
          return;
      }
      this._attributes.push(t);
    }
    pushTexture(e, t, n) {
      if (!t) throw new Error("no texture given to texturestack");
      this._textures.push([e, t, n]);
      this.needsTexturePush = true;
    }
    _removeUniformFromShader(e, t) {
      if (t.hasUniform(e)) t.removeUniform(e);
    }
    removeUniform(t) {
      if (this._getUniform(t)) {
        for (let e = this._uniforms.length - 1; e >= 0; e -= 1) {
          const n = t;
          if (this._uniforms[e].name == t && !this._uniforms[e].structName) {
            for (const i in this._origShaders) {
              this._removeUniformFromShader(
                this.getPrefixedName(n),
                this._origShaders[i].shader
              );
            }
            this._uniforms.splice(e, 1);
          }
        }
        this._changedUniforms = true;
      }
    }
    removeUniformStruct(t) {
      if (this._getStructUniform(t)) {
        for (let e = this._structUniforms.length - 1; e >= 0; e -= 1) {
          const n = this._structUniforms[e];
          if (n.uniformName === t) {
            for (const i in this._origShaders) {
              for (let e = 0; e < n.members.length; e += 1) {
                const r = n.members[e];
                this._removeUniformFromShader(
                  this.getPrefixedName(r.name),
                  this._origShaders[i].shader
                );
              }
            }
            this._structUniforms.splice(e, 1);
          }
        }
        this._changedUniforms = true;
      }
    }
    getPrefixedName(e) {
      const t = this._mods[0].group;
      if (t === undefined) {
        return;
      }
      if (e.startsWith("MOD_")) {
        e = e.substr("MOD_".length);
        e = "mod" + t + "_" + e;
      }
      return e;
    }
    _updateDefinesShader(e) {
      for (const t in this._defines) {
        const n = this.getPrefixedName(t);
        if (this._defines[t] !== null && this._defines[t] !== undefined)
          e.define(n, this._defines[t]);
        else e.removeDefine(n);
      }
      for (const t in this._definesToggled) {
        const n = this.getPrefixedName(t);
        e.toggleDefine(n, this._definesToggled[t]);
      }
    }
    _updateDefines() {
      for (const e in this._origShaders)
        this._updateDefinesShader(this._origShaders[e].shader);
      this._changedDefines = false;
    }
    define(e, t) {
      if (t === undefined) t = true;
      this._defines[e] = t;
      this._changedDefines = true;
    }
    removeDefine(e) {
      this._defines[e] = null;
      this._changedDefines = true;
    }
    hasDefine(e) {
      if (this._defines[e] !== null && this._defines[e] !== undefined)
        return true;
      return false;
    }
    toggleDefine(e, t) {
      this._changedDefines = true;
      this._definesToggled[e] = t;
    }
    currentShader() {
      if (!this._boundShader) return null;
      return this._boundShader.shader;
    }
    dispose() {}
  }
  CGL.ShaderModifier = t;
  ((this.CGL = this.CGL || {}).COREMODULES =
    this.CGL.COREMODULES || {}).Shadermodifier = e.Shadermodifier;
})();
(() => {
  "use strict";
  var e = {};
  class t {
    constructor(e) {
      this.cgl = e;
      this.geom = new CGL.Geometry("marker");
      this.geom.setPointVertices([
        -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, -1, 1,
        -1, 1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, 1, 1, 1,
        -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1,
        -1, 1, 1, -1, -1, -1, -1, 1, -1, -1, -1,
      ]);
      this.mesh = new CGL.Mesh(this.cgl, this.geom, this.cgl.gl.LINES);
      this.mesh.setGeom(this.geom);
      this.colorShader = new CGL.UniColorShader(this.cgl);
      this.colorShader.setColor([0, 1, 1, 1]);
      this._vScale = vec3.create();
    }
    render(e, t, n) {
      this.cgl.pushModelMatrix();
      this.cgl.pushShader(this.colorShader.shader);
      this.cgl.pushDepthTest(false);
      if (e == undefined) e = 1;
      if (t == undefined) t = e;
      if (n == undefined) n = e;
      vec3.set(this._vScale, e, t, n);
      mat4.scale(this.cgl.mvMatrix, this.cgl.mvMatrix, this._vScale);
      this.mesh.render(this.cgl.getShader());
      this.cgl.popDepthTest();
      this.cgl.popShader();
      this.cgl.popModelMatrix();
    }
  }
  class n {
    constructor(e) {
      this.cgl = e;
      this.geom = new CGL.Geometry("marker");
      const t = -1;
      const n = 1;
      this.geom.setPointVertices([
        t,
        t,
        0,
        n,
        t,
        0,
        n,
        t,
        0,
        n,
        n,
        0,
        n,
        n,
        0,
        t,
        n,
        0,
        t,
        n,
        0,
        t,
        t,
        0,
      ]);
      this.mesh = new CGL.Mesh(this.cgl, this.geom, this.cgl.gl.LINES);
      this.mesh.setGeom(this.geom);
      this.colorShader = new CGL.UniColorShader(this.cgl);
      this.colorShader.setColor([0, 1, 1, 1]);
      this._vScale = vec3.create();
    }
    render(e, t, n) {
      this.cgl.pushModelMatrix();
      this.cgl.pushShader(this.colorShader.shader);
      this.cgl.pushDepthTest(false);
      vec3.set(this._vScale, e || 1, t || e || 1, n || e || 1);
      mat4.scale(this.cgl.mvMatrix, this.cgl.mvMatrix, this._vScale);
      this.mesh.render(this.cgl.getShader());
      this.cgl.popDepthTest();
      this.cgl.popShader();
      this.cgl.popModelMatrix();
    }
  }
  CGL.WireframeCube = t;
  CGL.WireframeRect = n;
  ((this.CGL = this.CGL || {}).COREMODULES =
    this.CGL.COREMODULES || {}).Wireframes = e.Wireframes;
})();
(() => {
  "use strict";
  var e = {};
  const t = class {
    constructor(n, e) {
      e = e || {};
      this._op = n;
      n.patchId = n.addInPort(
        new CABLES.Port(n, "patchId", CABLES.OP_PORT_TYPE_STRING, {
          display: "readonly",
          hidePort: true,
          hideParam: true,
        })
      );
      n.setUiAttribs({ subPatchOp: { version: 2 } });
      if (n.uiAttribs.parentOfSubpatch) {
        n.patchId.set(n.uiAttribs.parentOfSubpatch);
      } else {
        if (e.subId) n.patchId.set(e.subId);
        else n.patchId.set(CABLES.generateUUID());
      }
      n.patchId.onChange = () => {
        if (e.subId) n.patchId.value = e.subId;
      };
      n.init = () => {
        n.setStorage({ subPatchVer: 2 });
      };
      n.loadDependencies = (e, t) => {
        if (CABLES.UI) {
          gui.serverOps.loadProjectDependencies(e, () => {
            if (t) t();
          });
        } else if (t) t();
      };
      n.on("delete", () => {
        if (n.patch.clearSubPatchCache)
          n.patch.clearSubPatchCache(this.patchId);
        const t = n.patch.ops;
        for (let e = t.length - 1; e >= 0; e--)
          if (
            t[e] &&
            t[e].uiAttribs &&
            t[e].uiAttribs.subPatch == n.patchId.get()
          )
            n.patch.deleteOp(t[e].id);
      });
      this._op.isExposableSubpatchOp = () => {
        return true;
      };
    }
    get patchId() {
      return this._op.patchId.get();
    }
  };
  CABLES.SubPatchOp = t;
  ((this.CABLES = this.CABLES || {}).COREMODULES =
    this.CABLES.COREMODULES || {}).Subpatchop = e.Cables;
})();
